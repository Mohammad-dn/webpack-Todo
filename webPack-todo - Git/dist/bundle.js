/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/@nodelib/fs.scandir/out/adapters/fs.js":
/*!*************************************************************!*\
  !*** ./node_modules/@nodelib/fs.scandir/out/adapters/fs.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.createFileSystemAdapter = exports.FILE_SYSTEM_ADAPTER = void 0;\nconst fs = __webpack_require__(Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'fs'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));\nexports.FILE_SYSTEM_ADAPTER = {\n    lstat: fs.lstat,\n    stat: fs.stat,\n    lstatSync: fs.lstatSync,\n    statSync: fs.statSync,\n    readdir: fs.readdir,\n    readdirSync: fs.readdirSync\n};\nfunction createFileSystemAdapter(fsMethods) {\n    if (fsMethods === undefined) {\n        return exports.FILE_SYSTEM_ADAPTER;\n    }\n    return Object.assign(Object.assign({}, exports.FILE_SYSTEM_ADAPTER), fsMethods);\n}\nexports.createFileSystemAdapter = createFileSystemAdapter;\n\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/@nodelib/fs.scandir/out/adapters/fs.js?");

/***/ }),

/***/ "./node_modules/@nodelib/fs.scandir/out/constants.js":
/*!***********************************************************!*\
  !*** ./node_modules/@nodelib/fs.scandir/out/constants.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.IS_SUPPORT_READDIR_WITH_FILE_TYPES = void 0;\nconst NODE_PROCESS_VERSION_PARTS = process.versions.node.split('.');\nif (NODE_PROCESS_VERSION_PARTS[0] === undefined || NODE_PROCESS_VERSION_PARTS[1] === undefined) {\n    throw new Error(`Unexpected behavior. The 'process.versions.node' variable has invalid value: ${process.versions.node}`);\n}\nconst MAJOR_VERSION = Number.parseInt(NODE_PROCESS_VERSION_PARTS[0], 10);\nconst MINOR_VERSION = Number.parseInt(NODE_PROCESS_VERSION_PARTS[1], 10);\nconst SUPPORTED_MAJOR_VERSION = 10;\nconst SUPPORTED_MINOR_VERSION = 10;\nconst IS_MATCHED_BY_MAJOR = MAJOR_VERSION > SUPPORTED_MAJOR_VERSION;\nconst IS_MATCHED_BY_MAJOR_AND_MINOR = MAJOR_VERSION === SUPPORTED_MAJOR_VERSION && MINOR_VERSION >= SUPPORTED_MINOR_VERSION;\n/**\n * IS `true` for Node.js 10.10 and greater.\n */\nexports.IS_SUPPORT_READDIR_WITH_FILE_TYPES = IS_MATCHED_BY_MAJOR || IS_MATCHED_BY_MAJOR_AND_MINOR;\n\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/@nodelib/fs.scandir/out/constants.js?");

/***/ }),

/***/ "./node_modules/@nodelib/fs.scandir/out/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/@nodelib/fs.scandir/out/index.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Settings = exports.scandirSync = exports.scandir = void 0;\nconst async = __webpack_require__(/*! ./providers/async */ \"./node_modules/@nodelib/fs.scandir/out/providers/async.js\");\nconst sync = __webpack_require__(/*! ./providers/sync */ \"./node_modules/@nodelib/fs.scandir/out/providers/sync.js\");\nconst settings_1 = __webpack_require__(/*! ./settings */ \"./node_modules/@nodelib/fs.scandir/out/settings.js\");\nexports.Settings = settings_1.default;\nfunction scandir(path, optionsOrSettingsOrCallback, callback) {\n    if (typeof optionsOrSettingsOrCallback === 'function') {\n        async.read(path, getSettings(), optionsOrSettingsOrCallback);\n        return;\n    }\n    async.read(path, getSettings(optionsOrSettingsOrCallback), callback);\n}\nexports.scandir = scandir;\nfunction scandirSync(path, optionsOrSettings) {\n    const settings = getSettings(optionsOrSettings);\n    return sync.read(path, settings);\n}\nexports.scandirSync = scandirSync;\nfunction getSettings(settingsOrOptions = {}) {\n    if (settingsOrOptions instanceof settings_1.default) {\n        return settingsOrOptions;\n    }\n    return new settings_1.default(settingsOrOptions);\n}\n\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/@nodelib/fs.scandir/out/index.js?");

/***/ }),

/***/ "./node_modules/@nodelib/fs.scandir/out/providers/async.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@nodelib/fs.scandir/out/providers/async.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.readdir = exports.readdirWithFileTypes = exports.read = void 0;\nconst fsStat = __webpack_require__(/*! @nodelib/fs.stat */ \"./node_modules/@nodelib/fs.stat/out/index.js\");\nconst rpl = __webpack_require__(/*! run-parallel */ \"./node_modules/run-parallel/index.js\");\nconst constants_1 = __webpack_require__(/*! ../constants */ \"./node_modules/@nodelib/fs.scandir/out/constants.js\");\nconst utils = __webpack_require__(/*! ../utils */ \"./node_modules/@nodelib/fs.scandir/out/utils/index.js\");\nconst common = __webpack_require__(/*! ./common */ \"./node_modules/@nodelib/fs.scandir/out/providers/common.js\");\nfunction read(directory, settings, callback) {\n    if (!settings.stats && constants_1.IS_SUPPORT_READDIR_WITH_FILE_TYPES) {\n        readdirWithFileTypes(directory, settings, callback);\n        return;\n    }\n    readdir(directory, settings, callback);\n}\nexports.read = read;\nfunction readdirWithFileTypes(directory, settings, callback) {\n    settings.fs.readdir(directory, { withFileTypes: true }, (readdirError, dirents) => {\n        if (readdirError !== null) {\n            callFailureCallback(callback, readdirError);\n            return;\n        }\n        const entries = dirents.map((dirent) => ({\n            dirent,\n            name: dirent.name,\n            path: common.joinPathSegments(directory, dirent.name, settings.pathSegmentSeparator)\n        }));\n        if (!settings.followSymbolicLinks) {\n            callSuccessCallback(callback, entries);\n            return;\n        }\n        const tasks = entries.map((entry) => makeRplTaskEntry(entry, settings));\n        rpl(tasks, (rplError, rplEntries) => {\n            if (rplError !== null) {\n                callFailureCallback(callback, rplError);\n                return;\n            }\n            callSuccessCallback(callback, rplEntries);\n        });\n    });\n}\nexports.readdirWithFileTypes = readdirWithFileTypes;\nfunction makeRplTaskEntry(entry, settings) {\n    return (done) => {\n        if (!entry.dirent.isSymbolicLink()) {\n            done(null, entry);\n            return;\n        }\n        settings.fs.stat(entry.path, (statError, stats) => {\n            if (statError !== null) {\n                if (settings.throwErrorOnBrokenSymbolicLink) {\n                    done(statError);\n                    return;\n                }\n                done(null, entry);\n                return;\n            }\n            entry.dirent = utils.fs.createDirentFromStats(entry.name, stats);\n            done(null, entry);\n        });\n    };\n}\nfunction readdir(directory, settings, callback) {\n    settings.fs.readdir(directory, (readdirError, names) => {\n        if (readdirError !== null) {\n            callFailureCallback(callback, readdirError);\n            return;\n        }\n        const tasks = names.map((name) => {\n            const path = common.joinPathSegments(directory, name, settings.pathSegmentSeparator);\n            return (done) => {\n                fsStat.stat(path, settings.fsStatSettings, (error, stats) => {\n                    if (error !== null) {\n                        done(error);\n                        return;\n                    }\n                    const entry = {\n                        name,\n                        path,\n                        dirent: utils.fs.createDirentFromStats(name, stats)\n                    };\n                    if (settings.stats) {\n                        entry.stats = stats;\n                    }\n                    done(null, entry);\n                });\n            };\n        });\n        rpl(tasks, (rplError, entries) => {\n            if (rplError !== null) {\n                callFailureCallback(callback, rplError);\n                return;\n            }\n            callSuccessCallback(callback, entries);\n        });\n    });\n}\nexports.readdir = readdir;\nfunction callFailureCallback(callback, error) {\n    callback(error);\n}\nfunction callSuccessCallback(callback, result) {\n    callback(null, result);\n}\n\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/@nodelib/fs.scandir/out/providers/async.js?");

/***/ }),

/***/ "./node_modules/@nodelib/fs.scandir/out/providers/common.js":
/*!******************************************************************!*\
  !*** ./node_modules/@nodelib/fs.scandir/out/providers/common.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.joinPathSegments = void 0;\nfunction joinPathSegments(a, b, separator) {\n    /**\n     * The correct handling of cases when the first segment is a root (`/`, `C:/`) or UNC path (`//?/C:/`).\n     */\n    if (a.endsWith(separator)) {\n        return a + b;\n    }\n    return a + separator + b;\n}\nexports.joinPathSegments = joinPathSegments;\n\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/@nodelib/fs.scandir/out/providers/common.js?");

/***/ }),

/***/ "./node_modules/@nodelib/fs.scandir/out/providers/sync.js":
/*!****************************************************************!*\
  !*** ./node_modules/@nodelib/fs.scandir/out/providers/sync.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.readdir = exports.readdirWithFileTypes = exports.read = void 0;\nconst fsStat = __webpack_require__(/*! @nodelib/fs.stat */ \"./node_modules/@nodelib/fs.stat/out/index.js\");\nconst constants_1 = __webpack_require__(/*! ../constants */ \"./node_modules/@nodelib/fs.scandir/out/constants.js\");\nconst utils = __webpack_require__(/*! ../utils */ \"./node_modules/@nodelib/fs.scandir/out/utils/index.js\");\nconst common = __webpack_require__(/*! ./common */ \"./node_modules/@nodelib/fs.scandir/out/providers/common.js\");\nfunction read(directory, settings) {\n    if (!settings.stats && constants_1.IS_SUPPORT_READDIR_WITH_FILE_TYPES) {\n        return readdirWithFileTypes(directory, settings);\n    }\n    return readdir(directory, settings);\n}\nexports.read = read;\nfunction readdirWithFileTypes(directory, settings) {\n    const dirents = settings.fs.readdirSync(directory, { withFileTypes: true });\n    return dirents.map((dirent) => {\n        const entry = {\n            dirent,\n            name: dirent.name,\n            path: common.joinPathSegments(directory, dirent.name, settings.pathSegmentSeparator)\n        };\n        if (entry.dirent.isSymbolicLink() && settings.followSymbolicLinks) {\n            try {\n                const stats = settings.fs.statSync(entry.path);\n                entry.dirent = utils.fs.createDirentFromStats(entry.name, stats);\n            }\n            catch (error) {\n                if (settings.throwErrorOnBrokenSymbolicLink) {\n                    throw error;\n                }\n            }\n        }\n        return entry;\n    });\n}\nexports.readdirWithFileTypes = readdirWithFileTypes;\nfunction readdir(directory, settings) {\n    const names = settings.fs.readdirSync(directory);\n    return names.map((name) => {\n        const entryPath = common.joinPathSegments(directory, name, settings.pathSegmentSeparator);\n        const stats = fsStat.statSync(entryPath, settings.fsStatSettings);\n        const entry = {\n            name,\n            path: entryPath,\n            dirent: utils.fs.createDirentFromStats(name, stats)\n        };\n        if (settings.stats) {\n            entry.stats = stats;\n        }\n        return entry;\n    });\n}\nexports.readdir = readdir;\n\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/@nodelib/fs.scandir/out/providers/sync.js?");

/***/ }),

/***/ "./node_modules/@nodelib/fs.scandir/out/settings.js":
/*!**********************************************************!*\
  !*** ./node_modules/@nodelib/fs.scandir/out/settings.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst path = __webpack_require__(Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'path'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));\nconst fsStat = __webpack_require__(/*! @nodelib/fs.stat */ \"./node_modules/@nodelib/fs.stat/out/index.js\");\nconst fs = __webpack_require__(/*! ./adapters/fs */ \"./node_modules/@nodelib/fs.scandir/out/adapters/fs.js\");\nclass Settings {\n    constructor(_options = {}) {\n        this._options = _options;\n        this.followSymbolicLinks = this._getValue(this._options.followSymbolicLinks, false);\n        this.fs = fs.createFileSystemAdapter(this._options.fs);\n        this.pathSegmentSeparator = this._getValue(this._options.pathSegmentSeparator, path.sep);\n        this.stats = this._getValue(this._options.stats, false);\n        this.throwErrorOnBrokenSymbolicLink = this._getValue(this._options.throwErrorOnBrokenSymbolicLink, true);\n        this.fsStatSettings = new fsStat.Settings({\n            followSymbolicLink: this.followSymbolicLinks,\n            fs: this.fs,\n            throwErrorOnBrokenSymbolicLink: this.throwErrorOnBrokenSymbolicLink\n        });\n    }\n    _getValue(option, value) {\n        return option !== null && option !== void 0 ? option : value;\n    }\n}\nexports[\"default\"] = Settings;\n\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/@nodelib/fs.scandir/out/settings.js?");

/***/ }),

/***/ "./node_modules/@nodelib/fs.scandir/out/utils/fs.js":
/*!**********************************************************!*\
  !*** ./node_modules/@nodelib/fs.scandir/out/utils/fs.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.createDirentFromStats = void 0;\nclass DirentFromStats {\n    constructor(name, stats) {\n        this.name = name;\n        this.isBlockDevice = stats.isBlockDevice.bind(stats);\n        this.isCharacterDevice = stats.isCharacterDevice.bind(stats);\n        this.isDirectory = stats.isDirectory.bind(stats);\n        this.isFIFO = stats.isFIFO.bind(stats);\n        this.isFile = stats.isFile.bind(stats);\n        this.isSocket = stats.isSocket.bind(stats);\n        this.isSymbolicLink = stats.isSymbolicLink.bind(stats);\n    }\n}\nfunction createDirentFromStats(name, stats) {\n    return new DirentFromStats(name, stats);\n}\nexports.createDirentFromStats = createDirentFromStats;\n\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/@nodelib/fs.scandir/out/utils/fs.js?");

/***/ }),

/***/ "./node_modules/@nodelib/fs.scandir/out/utils/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/@nodelib/fs.scandir/out/utils/index.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.fs = void 0;\nconst fs = __webpack_require__(/*! ./fs */ \"./node_modules/@nodelib/fs.scandir/out/utils/fs.js\");\nexports.fs = fs;\n\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/@nodelib/fs.scandir/out/utils/index.js?");

/***/ }),

/***/ "./node_modules/@nodelib/fs.stat/out/adapters/fs.js":
/*!**********************************************************!*\
  !*** ./node_modules/@nodelib/fs.stat/out/adapters/fs.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.createFileSystemAdapter = exports.FILE_SYSTEM_ADAPTER = void 0;\nconst fs = __webpack_require__(Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'fs'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));\nexports.FILE_SYSTEM_ADAPTER = {\n    lstat: fs.lstat,\n    stat: fs.stat,\n    lstatSync: fs.lstatSync,\n    statSync: fs.statSync\n};\nfunction createFileSystemAdapter(fsMethods) {\n    if (fsMethods === undefined) {\n        return exports.FILE_SYSTEM_ADAPTER;\n    }\n    return Object.assign(Object.assign({}, exports.FILE_SYSTEM_ADAPTER), fsMethods);\n}\nexports.createFileSystemAdapter = createFileSystemAdapter;\n\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/@nodelib/fs.stat/out/adapters/fs.js?");

/***/ }),

/***/ "./node_modules/@nodelib/fs.stat/out/index.js":
/*!****************************************************!*\
  !*** ./node_modules/@nodelib/fs.stat/out/index.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.statSync = exports.stat = exports.Settings = void 0;\nconst async = __webpack_require__(/*! ./providers/async */ \"./node_modules/@nodelib/fs.stat/out/providers/async.js\");\nconst sync = __webpack_require__(/*! ./providers/sync */ \"./node_modules/@nodelib/fs.stat/out/providers/sync.js\");\nconst settings_1 = __webpack_require__(/*! ./settings */ \"./node_modules/@nodelib/fs.stat/out/settings.js\");\nexports.Settings = settings_1.default;\nfunction stat(path, optionsOrSettingsOrCallback, callback) {\n    if (typeof optionsOrSettingsOrCallback === 'function') {\n        async.read(path, getSettings(), optionsOrSettingsOrCallback);\n        return;\n    }\n    async.read(path, getSettings(optionsOrSettingsOrCallback), callback);\n}\nexports.stat = stat;\nfunction statSync(path, optionsOrSettings) {\n    const settings = getSettings(optionsOrSettings);\n    return sync.read(path, settings);\n}\nexports.statSync = statSync;\nfunction getSettings(settingsOrOptions = {}) {\n    if (settingsOrOptions instanceof settings_1.default) {\n        return settingsOrOptions;\n    }\n    return new settings_1.default(settingsOrOptions);\n}\n\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/@nodelib/fs.stat/out/index.js?");

/***/ }),

/***/ "./node_modules/@nodelib/fs.stat/out/providers/async.js":
/*!**************************************************************!*\
  !*** ./node_modules/@nodelib/fs.stat/out/providers/async.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.read = void 0;\nfunction read(path, settings, callback) {\n    settings.fs.lstat(path, (lstatError, lstat) => {\n        if (lstatError !== null) {\n            callFailureCallback(callback, lstatError);\n            return;\n        }\n        if (!lstat.isSymbolicLink() || !settings.followSymbolicLink) {\n            callSuccessCallback(callback, lstat);\n            return;\n        }\n        settings.fs.stat(path, (statError, stat) => {\n            if (statError !== null) {\n                if (settings.throwErrorOnBrokenSymbolicLink) {\n                    callFailureCallback(callback, statError);\n                    return;\n                }\n                callSuccessCallback(callback, lstat);\n                return;\n            }\n            if (settings.markSymbolicLink) {\n                stat.isSymbolicLink = () => true;\n            }\n            callSuccessCallback(callback, stat);\n        });\n    });\n}\nexports.read = read;\nfunction callFailureCallback(callback, error) {\n    callback(error);\n}\nfunction callSuccessCallback(callback, result) {\n    callback(null, result);\n}\n\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/@nodelib/fs.stat/out/providers/async.js?");

/***/ }),

/***/ "./node_modules/@nodelib/fs.stat/out/providers/sync.js":
/*!*************************************************************!*\
  !*** ./node_modules/@nodelib/fs.stat/out/providers/sync.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.read = void 0;\nfunction read(path, settings) {\n    const lstat = settings.fs.lstatSync(path);\n    if (!lstat.isSymbolicLink() || !settings.followSymbolicLink) {\n        return lstat;\n    }\n    try {\n        const stat = settings.fs.statSync(path);\n        if (settings.markSymbolicLink) {\n            stat.isSymbolicLink = () => true;\n        }\n        return stat;\n    }\n    catch (error) {\n        if (!settings.throwErrorOnBrokenSymbolicLink) {\n            return lstat;\n        }\n        throw error;\n    }\n}\nexports.read = read;\n\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/@nodelib/fs.stat/out/providers/sync.js?");

/***/ }),

/***/ "./node_modules/@nodelib/fs.stat/out/settings.js":
/*!*******************************************************!*\
  !*** ./node_modules/@nodelib/fs.stat/out/settings.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst fs = __webpack_require__(/*! ./adapters/fs */ \"./node_modules/@nodelib/fs.stat/out/adapters/fs.js\");\nclass Settings {\n    constructor(_options = {}) {\n        this._options = _options;\n        this.followSymbolicLink = this._getValue(this._options.followSymbolicLink, true);\n        this.fs = fs.createFileSystemAdapter(this._options.fs);\n        this.markSymbolicLink = this._getValue(this._options.markSymbolicLink, false);\n        this.throwErrorOnBrokenSymbolicLink = this._getValue(this._options.throwErrorOnBrokenSymbolicLink, true);\n    }\n    _getValue(option, value) {\n        return option !== null && option !== void 0 ? option : value;\n    }\n}\nexports[\"default\"] = Settings;\n\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/@nodelib/fs.stat/out/settings.js?");

/***/ }),

/***/ "./node_modules/@nodelib/fs.walk/out/index.js":
/*!****************************************************!*\
  !*** ./node_modules/@nodelib/fs.walk/out/index.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Settings = exports.walkStream = exports.walkSync = exports.walk = void 0;\nconst async_1 = __webpack_require__(/*! ./providers/async */ \"./node_modules/@nodelib/fs.walk/out/providers/async.js\");\nconst stream_1 = __webpack_require__(/*! ./providers/stream */ \"./node_modules/@nodelib/fs.walk/out/providers/stream.js\");\nconst sync_1 = __webpack_require__(/*! ./providers/sync */ \"./node_modules/@nodelib/fs.walk/out/providers/sync.js\");\nconst settings_1 = __webpack_require__(/*! ./settings */ \"./node_modules/@nodelib/fs.walk/out/settings.js\");\nexports.Settings = settings_1.default;\nfunction walk(directory, optionsOrSettingsOrCallback, callback) {\n    if (typeof optionsOrSettingsOrCallback === 'function') {\n        new async_1.default(directory, getSettings()).read(optionsOrSettingsOrCallback);\n        return;\n    }\n    new async_1.default(directory, getSettings(optionsOrSettingsOrCallback)).read(callback);\n}\nexports.walk = walk;\nfunction walkSync(directory, optionsOrSettings) {\n    const settings = getSettings(optionsOrSettings);\n    const provider = new sync_1.default(directory, settings);\n    return provider.read();\n}\nexports.walkSync = walkSync;\nfunction walkStream(directory, optionsOrSettings) {\n    const settings = getSettings(optionsOrSettings);\n    const provider = new stream_1.default(directory, settings);\n    return provider.read();\n}\nexports.walkStream = walkStream;\nfunction getSettings(settingsOrOptions = {}) {\n    if (settingsOrOptions instanceof settings_1.default) {\n        return settingsOrOptions;\n    }\n    return new settings_1.default(settingsOrOptions);\n}\n\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/@nodelib/fs.walk/out/index.js?");

/***/ }),

/***/ "./node_modules/@nodelib/fs.walk/out/providers/async.js":
/*!**************************************************************!*\
  !*** ./node_modules/@nodelib/fs.walk/out/providers/async.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst async_1 = __webpack_require__(/*! ../readers/async */ \"./node_modules/@nodelib/fs.walk/out/readers/async.js\");\nclass AsyncProvider {\n    constructor(_root, _settings) {\n        this._root = _root;\n        this._settings = _settings;\n        this._reader = new async_1.default(this._root, this._settings);\n        this._storage = [];\n    }\n    read(callback) {\n        this._reader.onError((error) => {\n            callFailureCallback(callback, error);\n        });\n        this._reader.onEntry((entry) => {\n            this._storage.push(entry);\n        });\n        this._reader.onEnd(() => {\n            callSuccessCallback(callback, this._storage);\n        });\n        this._reader.read();\n    }\n}\nexports[\"default\"] = AsyncProvider;\nfunction callFailureCallback(callback, error) {\n    callback(error);\n}\nfunction callSuccessCallback(callback, entries) {\n    callback(null, entries);\n}\n\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/@nodelib/fs.walk/out/providers/async.js?");

/***/ }),

/***/ "./node_modules/@nodelib/fs.walk/out/providers/stream.js":
/*!***************************************************************!*\
  !*** ./node_modules/@nodelib/fs.walk/out/providers/stream.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst stream_1 = __webpack_require__(Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'stream'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));\nconst async_1 = __webpack_require__(/*! ../readers/async */ \"./node_modules/@nodelib/fs.walk/out/readers/async.js\");\nclass StreamProvider {\n    constructor(_root, _settings) {\n        this._root = _root;\n        this._settings = _settings;\n        this._reader = new async_1.default(this._root, this._settings);\n        this._stream = new stream_1.Readable({\n            objectMode: true,\n            read: () => { },\n            destroy: () => {\n                if (!this._reader.isDestroyed) {\n                    this._reader.destroy();\n                }\n            }\n        });\n    }\n    read() {\n        this._reader.onError((error) => {\n            this._stream.emit('error', error);\n        });\n        this._reader.onEntry((entry) => {\n            this._stream.push(entry);\n        });\n        this._reader.onEnd(() => {\n            this._stream.push(null);\n        });\n        this._reader.read();\n        return this._stream;\n    }\n}\nexports[\"default\"] = StreamProvider;\n\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/@nodelib/fs.walk/out/providers/stream.js?");

/***/ }),

/***/ "./node_modules/@nodelib/fs.walk/out/providers/sync.js":
/*!*************************************************************!*\
  !*** ./node_modules/@nodelib/fs.walk/out/providers/sync.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst sync_1 = __webpack_require__(/*! ../readers/sync */ \"./node_modules/@nodelib/fs.walk/out/readers/sync.js\");\nclass SyncProvider {\n    constructor(_root, _settings) {\n        this._root = _root;\n        this._settings = _settings;\n        this._reader = new sync_1.default(this._root, this._settings);\n    }\n    read() {\n        return this._reader.read();\n    }\n}\nexports[\"default\"] = SyncProvider;\n\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/@nodelib/fs.walk/out/providers/sync.js?");

/***/ }),

/***/ "./node_modules/@nodelib/fs.walk/out/readers/async.js":
/*!************************************************************!*\
  !*** ./node_modules/@nodelib/fs.walk/out/readers/async.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst events_1 = __webpack_require__(/*! events */ \"./node_modules/events/events.js\");\nconst fsScandir = __webpack_require__(/*! @nodelib/fs.scandir */ \"./node_modules/@nodelib/fs.scandir/out/index.js\");\nconst fastq = __webpack_require__(/*! fastq */ \"./node_modules/fastq/queue.js\");\nconst common = __webpack_require__(/*! ./common */ \"./node_modules/@nodelib/fs.walk/out/readers/common.js\");\nconst reader_1 = __webpack_require__(/*! ./reader */ \"./node_modules/@nodelib/fs.walk/out/readers/reader.js\");\nclass AsyncReader extends reader_1.default {\n    constructor(_root, _settings) {\n        super(_root, _settings);\n        this._settings = _settings;\n        this._scandir = fsScandir.scandir;\n        this._emitter = new events_1.EventEmitter();\n        this._queue = fastq(this._worker.bind(this), this._settings.concurrency);\n        this._isFatalError = false;\n        this._isDestroyed = false;\n        this._queue.drain = () => {\n            if (!this._isFatalError) {\n                this._emitter.emit('end');\n            }\n        };\n    }\n    read() {\n        this._isFatalError = false;\n        this._isDestroyed = false;\n        setImmediate(() => {\n            this._pushToQueue(this._root, this._settings.basePath);\n        });\n        return this._emitter;\n    }\n    get isDestroyed() {\n        return this._isDestroyed;\n    }\n    destroy() {\n        if (this._isDestroyed) {\n            throw new Error('The reader is already destroyed');\n        }\n        this._isDestroyed = true;\n        this._queue.killAndDrain();\n    }\n    onEntry(callback) {\n        this._emitter.on('entry', callback);\n    }\n    onError(callback) {\n        this._emitter.once('error', callback);\n    }\n    onEnd(callback) {\n        this._emitter.once('end', callback);\n    }\n    _pushToQueue(directory, base) {\n        const queueItem = { directory, base };\n        this._queue.push(queueItem, (error) => {\n            if (error !== null) {\n                this._handleError(error);\n            }\n        });\n    }\n    _worker(item, done) {\n        this._scandir(item.directory, this._settings.fsScandirSettings, (error, entries) => {\n            if (error !== null) {\n                done(error, undefined);\n                return;\n            }\n            for (const entry of entries) {\n                this._handleEntry(entry, item.base);\n            }\n            done(null, undefined);\n        });\n    }\n    _handleError(error) {\n        if (this._isDestroyed || !common.isFatalError(this._settings, error)) {\n            return;\n        }\n        this._isFatalError = true;\n        this._isDestroyed = true;\n        this._emitter.emit('error', error);\n    }\n    _handleEntry(entry, base) {\n        if (this._isDestroyed || this._isFatalError) {\n            return;\n        }\n        const fullpath = entry.path;\n        if (base !== undefined) {\n            entry.path = common.joinPathSegments(base, entry.name, this._settings.pathSegmentSeparator);\n        }\n        if (common.isAppliedFilter(this._settings.entryFilter, entry)) {\n            this._emitEntry(entry);\n        }\n        if (entry.dirent.isDirectory() && common.isAppliedFilter(this._settings.deepFilter, entry)) {\n            this._pushToQueue(fullpath, base === undefined ? undefined : entry.path);\n        }\n    }\n    _emitEntry(entry) {\n        this._emitter.emit('entry', entry);\n    }\n}\nexports[\"default\"] = AsyncReader;\n\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/@nodelib/fs.walk/out/readers/async.js?");

/***/ }),

/***/ "./node_modules/@nodelib/fs.walk/out/readers/common.js":
/*!*************************************************************!*\
  !*** ./node_modules/@nodelib/fs.walk/out/readers/common.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.joinPathSegments = exports.replacePathSegmentSeparator = exports.isAppliedFilter = exports.isFatalError = void 0;\nfunction isFatalError(settings, error) {\n    if (settings.errorFilter === null) {\n        return true;\n    }\n    return !settings.errorFilter(error);\n}\nexports.isFatalError = isFatalError;\nfunction isAppliedFilter(filter, value) {\n    return filter === null || filter(value);\n}\nexports.isAppliedFilter = isAppliedFilter;\nfunction replacePathSegmentSeparator(filepath, separator) {\n    return filepath.split(/[/\\\\]/).join(separator);\n}\nexports.replacePathSegmentSeparator = replacePathSegmentSeparator;\nfunction joinPathSegments(a, b, separator) {\n    if (a === '') {\n        return b;\n    }\n    /**\n     * The correct handling of cases when the first segment is a root (`/`, `C:/`) or UNC path (`//?/C:/`).\n     */\n    if (a.endsWith(separator)) {\n        return a + b;\n    }\n    return a + separator + b;\n}\nexports.joinPathSegments = joinPathSegments;\n\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/@nodelib/fs.walk/out/readers/common.js?");

/***/ }),

/***/ "./node_modules/@nodelib/fs.walk/out/readers/reader.js":
/*!*************************************************************!*\
  !*** ./node_modules/@nodelib/fs.walk/out/readers/reader.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst common = __webpack_require__(/*! ./common */ \"./node_modules/@nodelib/fs.walk/out/readers/common.js\");\nclass Reader {\n    constructor(_root, _settings) {\n        this._root = _root;\n        this._settings = _settings;\n        this._root = common.replacePathSegmentSeparator(_root, _settings.pathSegmentSeparator);\n    }\n}\nexports[\"default\"] = Reader;\n\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/@nodelib/fs.walk/out/readers/reader.js?");

/***/ }),

/***/ "./node_modules/@nodelib/fs.walk/out/readers/sync.js":
/*!***********************************************************!*\
  !*** ./node_modules/@nodelib/fs.walk/out/readers/sync.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst fsScandir = __webpack_require__(/*! @nodelib/fs.scandir */ \"./node_modules/@nodelib/fs.scandir/out/index.js\");\nconst common = __webpack_require__(/*! ./common */ \"./node_modules/@nodelib/fs.walk/out/readers/common.js\");\nconst reader_1 = __webpack_require__(/*! ./reader */ \"./node_modules/@nodelib/fs.walk/out/readers/reader.js\");\nclass SyncReader extends reader_1.default {\n    constructor() {\n        super(...arguments);\n        this._scandir = fsScandir.scandirSync;\n        this._storage = [];\n        this._queue = new Set();\n    }\n    read() {\n        this._pushToQueue(this._root, this._settings.basePath);\n        this._handleQueue();\n        return this._storage;\n    }\n    _pushToQueue(directory, base) {\n        this._queue.add({ directory, base });\n    }\n    _handleQueue() {\n        for (const item of this._queue.values()) {\n            this._handleDirectory(item.directory, item.base);\n        }\n    }\n    _handleDirectory(directory, base) {\n        try {\n            const entries = this._scandir(directory, this._settings.fsScandirSettings);\n            for (const entry of entries) {\n                this._handleEntry(entry, base);\n            }\n        }\n        catch (error) {\n            this._handleError(error);\n        }\n    }\n    _handleError(error) {\n        if (!common.isFatalError(this._settings, error)) {\n            return;\n        }\n        throw error;\n    }\n    _handleEntry(entry, base) {\n        const fullpath = entry.path;\n        if (base !== undefined) {\n            entry.path = common.joinPathSegments(base, entry.name, this._settings.pathSegmentSeparator);\n        }\n        if (common.isAppliedFilter(this._settings.entryFilter, entry)) {\n            this._pushToStorage(entry);\n        }\n        if (entry.dirent.isDirectory() && common.isAppliedFilter(this._settings.deepFilter, entry)) {\n            this._pushToQueue(fullpath, base === undefined ? undefined : entry.path);\n        }\n    }\n    _pushToStorage(entry) {\n        this._storage.push(entry);\n    }\n}\nexports[\"default\"] = SyncReader;\n\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/@nodelib/fs.walk/out/readers/sync.js?");

/***/ }),

/***/ "./node_modules/@nodelib/fs.walk/out/settings.js":
/*!*******************************************************!*\
  !*** ./node_modules/@nodelib/fs.walk/out/settings.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst path = __webpack_require__(Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'path'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));\nconst fsScandir = __webpack_require__(/*! @nodelib/fs.scandir */ \"./node_modules/@nodelib/fs.scandir/out/index.js\");\nclass Settings {\n    constructor(_options = {}) {\n        this._options = _options;\n        this.basePath = this._getValue(this._options.basePath, undefined);\n        this.concurrency = this._getValue(this._options.concurrency, Number.POSITIVE_INFINITY);\n        this.deepFilter = this._getValue(this._options.deepFilter, null);\n        this.entryFilter = this._getValue(this._options.entryFilter, null);\n        this.errorFilter = this._getValue(this._options.errorFilter, null);\n        this.pathSegmentSeparator = this._getValue(this._options.pathSegmentSeparator, path.sep);\n        this.fsScandirSettings = new fsScandir.Settings({\n            followSymbolicLinks: this._options.followSymbolicLinks,\n            fs: this._options.fs,\n            pathSegmentSeparator: this._options.pathSegmentSeparator,\n            stats: this._options.stats,\n            throwErrorOnBrokenSymbolicLink: this._options.throwErrorOnBrokenSymbolicLink\n        });\n    }\n    _getValue(option, value) {\n        return option !== null && option !== void 0 ? option : value;\n    }\n}\nexports[\"default\"] = Settings;\n\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/@nodelib/fs.walk/out/settings.js?");

/***/ }),

/***/ "./node_modules/acorn-node/index.js":
/*!******************************************!*\
  !*** ./node_modules/acorn-node/index.js ***!
  \******************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("var acorn = __webpack_require__(/*! acorn */ \"./node_modules/acorn/dist/acorn.mjs\")\nvar xtend = __webpack_require__(/*! xtend */ \"./node_modules/xtend/immutable.js\")\n\nvar CJSParser = acorn.Parser\n  .extend(__webpack_require__(/*! ./lib/bigint */ \"./node_modules/acorn-node/lib/bigint/index.js\"))\n  .extend(__webpack_require__(/*! ./lib/class-fields */ \"./node_modules/acorn-node/lib/class-fields/index.js\"))\n  .extend(__webpack_require__(/*! ./lib/static-class-features */ \"./node_modules/acorn-node/lib/static-class-features/index.js\"))\n  .extend(__webpack_require__(/*! ./lib/numeric-separator */ \"./node_modules/acorn-node/lib/numeric-separator/index.js\"))\n  .extend((__webpack_require__(/*! ./lib/dynamic-import */ \"./node_modules/acorn-node/lib/dynamic-import/index.js\")[\"default\"]))\nvar ESModulesParser = CJSParser\n  .extend(__webpack_require__(/*! ./lib/export-ns-from */ \"./node_modules/acorn-node/lib/export-ns-from/index.js\"))\n  .extend(__webpack_require__(/*! ./lib/import-meta */ \"./node_modules/acorn-node/lib/import-meta/index.js\"))\n\nfunction mapOptions (opts) {\n  if (!opts) opts = {}\n  return xtend({\n    ecmaVersion: 2020,\n    allowHashBang: true,\n    allowReturnOutsideFunction: true\n  }, opts)\n}\n\nfunction getParser (opts) {\n  if (!opts) opts = {}\n  return opts.sourceType === 'module' ? ESModulesParser : CJSParser\n}\n\nmodule.exports = exports = xtend(acorn, {\n  parse: function parse (src, opts) {\n    return getParser(opts).parse(src, mapOptions(opts))\n  },\n  parseExpressionAt: function parseExpressionAt (src, offset, opts) {\n    return getParser(opts).parseExpressionAt(src, offset, mapOptions(opts))\n  },\n  tokenizer: function tokenizer (src, opts) {\n    return getParser(opts).tokenizer(src, mapOptions(opts))\n  }\n})\n\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/acorn-node/index.js?");

/***/ }),

/***/ "./node_modules/acorn-node/lib/bigint/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/acorn-node/lib/bigint/index.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/* Generated by `npm run build`, do not edit! */\n\n\n\nvar acorn = __webpack_require__(/*! acorn */ \"./node_modules/acorn/dist/acorn.mjs\")\nvar tt = acorn.tokTypes\nvar isIdentifierStart = acorn.isIdentifierStart\n\nmodule.exports = function(Parser) {\n  return /*@__PURE__*/(function (Parser) {\n    function anonymous () {\n      Parser.apply(this, arguments);\n    }\n\n    if ( Parser ) anonymous.__proto__ = Parser;\n    anonymous.prototype = Object.create( Parser && Parser.prototype );\n    anonymous.prototype.constructor = anonymous;\n\n    anonymous.prototype.parseLiteral = function parseLiteral (value) {\n      var node = Parser.prototype.parseLiteral.call(this, value)\n      if (node.raw.charCodeAt(node.raw.length - 1) == 110) { node.bigint = this.getNumberInput(node.start, node.end) }\n      return node\n    };\n\n    anonymous.prototype.readRadixNumber = function readRadixNumber (radix) {\n      var start = this.pos\n      this.pos += 2 // 0x\n      var val = this.readInt(radix)\n      if (val === null) { this.raise(this.start + 2, (\"Expected number in radix \" + radix)) }\n      if (this.input.charCodeAt(this.pos) == 110) {\n        var str = this.getNumberInput(start, this.pos)\n        val = typeof BigInt !== \"undefined\" ? BigInt(str) : null\n        ++this.pos\n      } else if (isIdentifierStart(this.fullCharCodeAtPos())) { this.raise(this.pos, \"Identifier directly after number\") }\n      return this.finishToken(tt.num, val)\n    };\n\n    anonymous.prototype.readNumber = function readNumber (startsWithDot) {\n      var start = this.pos\n\n      // Not an int\n      if (startsWithDot) { return Parser.prototype.readNumber.call(this, startsWithDot) }\n\n      // Legacy octal\n      if (this.input.charCodeAt(start) === 48 && this.input.charCodeAt(start + 1) !== 110) {\n        return Parser.prototype.readNumber.call(this, startsWithDot)\n      }\n\n      if (this.readInt(10) === null) { this.raise(start, \"Invalid number\") }\n\n      // Not a BigInt, reset and parse again\n      if (this.input.charCodeAt(this.pos) != 110) {\n        this.pos = start\n        return Parser.prototype.readNumber.call(this, startsWithDot)\n      }\n\n      var str = this.getNumberInput(start, this.pos)\n      var val = typeof BigInt !== \"undefined\" ? BigInt(str) : null\n      ++this.pos\n      return this.finishToken(tt.num, val)\n    };\n\n    // This is basically a hook for acorn-numeric-separator\n    anonymous.prototype.getNumberInput = function getNumberInput (start, end) {\n      if (Parser.prototype.getNumberInput) { return Parser.prototype.getNumberInput.call(this, start, end) }\n      return this.input.slice(start, end)\n    };\n\n    return anonymous;\n  }(Parser))\n}\n\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/acorn-node/lib/bigint/index.js?");

/***/ }),

/***/ "./node_modules/acorn-node/lib/class-fields/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/acorn-node/lib/class-fields/index.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/* Generated by `npm run build`, do not edit! */\n\n\n\nvar acorn = __webpack_require__(/*! acorn */ \"./node_modules/acorn/dist/acorn.mjs\")\nvar tt = acorn.tokTypes\nvar privateClassElements = __webpack_require__(/*! ../private-class-elements */ \"./node_modules/acorn-node/lib/private-class-elements/index.js\")\n\nfunction maybeParseFieldValue(field) {\n  if (this.eat(tt.eq)) {\n    var oldInFieldValue = this._inFieldValue\n    this._inFieldValue = true\n    field.value = this.parseExpression()\n    this._inFieldValue = oldInFieldValue\n  } else { field.value = null }\n}\n\nmodule.exports = function(Parser) {\n  Parser = privateClassElements(Parser)\n  return /*@__PURE__*/(function (Parser) {\n    function anonymous () {\n      Parser.apply(this, arguments);\n    }\n\n    if ( Parser ) anonymous.__proto__ = Parser;\n    anonymous.prototype = Object.create( Parser && Parser.prototype );\n    anonymous.prototype.constructor = anonymous;\n\n    anonymous.prototype.parseClassElement = function parseClassElement (_constructorAllowsSuper) {\n      if (this.options.ecmaVersion >= 8 && (this.type == tt.name || this.type == this.privateNameToken || this.type == tt.bracketL || this.type == tt.string)) {\n        var branch = this._branch()\n        if (branch.type == tt.bracketL) {\n          var count = 0\n          do {\n            if (branch.eat(tt.bracketL)) { ++count }\n            else if (branch.eat(tt.bracketR)) { --count }\n            else { branch.next() }\n          } while (count > 0)\n        } else { branch.next() }\n        if (branch.type == tt.eq || branch.canInsertSemicolon() || branch.type == tt.semi) {\n          var node = this.startNode()\n          if (this.type == this.privateNameToken) {\n            this.parsePrivateClassElementName(node)\n          } else {\n            this.parsePropertyName(node)\n          }\n          if ((node.key.type === \"Identifier\" && node.key.name === \"constructor\") ||\n              (node.key.type === \"Literal\" && node.key.value === \"constructor\")) {\n            this.raise(node.key.start, \"Classes may not have a field called constructor\")\n          }\n          maybeParseFieldValue.call(this, node)\n          this.finishNode(node, \"FieldDefinition\")\n          this.semicolon()\n          return node\n        }\n      }\n\n      return Parser.prototype.parseClassElement.apply(this, arguments)\n    };\n\n    // Prohibit arguments in class field initializers\n    anonymous.prototype.parseIdent = function parseIdent (liberal, isBinding) {\n      var ident = Parser.prototype.parseIdent.call(this, liberal, isBinding)\n      if (this._inFieldValue && ident.name == \"arguments\") { this.raise(ident.start, \"A class field initializer may not contain arguments\") }\n      return ident\n    };\n\n    return anonymous;\n  }(Parser))\n}\n\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/acorn-node/lib/class-fields/index.js?");

/***/ }),

/***/ "./node_modules/acorn-node/lib/dynamic-import/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/acorn-node/lib/dynamic-import/index.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("/* Generated by `npm run build`, do not edit! */\n\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.DynamicImportKey = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) { descriptor.writable = true; } Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) { defineProperties(Constructor.prototype, protoProps); } if (staticProps) { defineProperties(Constructor, staticProps); } return Constructor; }; }();\n\nvar _get = function () {\n  function get(object, property, receiver) { if (object === null) { object = Function.prototype; } var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } }\n\n  return get;\n}();\n\nexports[\"default\"] = dynamicImport;\n\nvar _acorn = __webpack_require__(/*! acorn */ \"./node_modules/acorn/dist/acorn.mjs\");\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) { Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } } /* eslint-disable no-underscore-dangle */\n\n\nvar DynamicImportKey = exports.DynamicImportKey = 'Import';\n\n// NOTE: This allows `yield import()` to parse correctly.\n_acorn.tokTypes._import.startsExpr = true;\n\nfunction parseDynamicImport() {\n  var node = this.startNode();\n  this.next();\n  if (this.type !== _acorn.tokTypes.parenL) {\n    this.unexpected();\n  }\n  return this.finishNode(node, DynamicImportKey);\n}\n\nfunction parenAfter() {\n  return (/^(\\s|\\/\\/.*|\\/\\*[^]*?\\*\\/)*\\(/.test(this.input.slice(this.pos))\n  );\n}\n\nfunction dynamicImport(Parser) {\n  return function (_Parser) {\n    _inherits(_class, _Parser);\n\n    function _class() {\n      _classCallCheck(this, _class);\n\n      return _possibleConstructorReturn(this, (_class.__proto__ || Object.getPrototypeOf(_class)).apply(this, arguments));\n    }\n\n    _createClass(_class, [{\n      key: 'parseStatement',\n      value: function () {\n        function parseStatement(context, topLevel, exports) {\n          if (this.type === _acorn.tokTypes._import && parenAfter.call(this)) {\n            return this.parseExpressionStatement(this.startNode(), this.parseExpression());\n          }\n          return _get(_class.prototype.__proto__ || Object.getPrototypeOf(_class.prototype), 'parseStatement', this).call(this, context, topLevel, exports);\n        }\n\n        return parseStatement;\n      }()\n    }, {\n      key: 'parseExprAtom',\n      value: function () {\n        function parseExprAtom(refDestructuringErrors) {\n          if (this.type === _acorn.tokTypes._import) {\n            return parseDynamicImport.call(this);\n          }\n          return _get(_class.prototype.__proto__ || Object.getPrototypeOf(_class.prototype), 'parseExprAtom', this).call(this, refDestructuringErrors);\n        }\n\n        return parseExprAtom;\n      }()\n    }]);\n\n    return _class;\n  }(Parser);\n}\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/acorn-node/lib/dynamic-import/index.js?");

/***/ }),

/***/ "./node_modules/acorn-node/lib/export-ns-from/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/acorn-node/lib/export-ns-from/index.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/* Generated by `npm run build`, do not edit! */\n\n\n\nvar skipWhiteSpace = /(?:\\s|\\/\\/.*|\\/\\*[^]*?\\*\\/)*/g\n\nvar tt = (__webpack_require__(/*! acorn */ \"./node_modules/acorn/dist/acorn.mjs\").tokTypes)\n\nmodule.exports = function(Parser) {\n  return /*@__PURE__*/(function (Parser) {\n    function anonymous () {\n      Parser.apply(this, arguments);\n    }\n\n    if ( Parser ) anonymous.__proto__ = Parser;\n    anonymous.prototype = Object.create( Parser && Parser.prototype );\n    anonymous.prototype.constructor = anonymous;\n\n    anonymous.prototype.parseExport = function parseExport (node, exports) {\n      skipWhiteSpace.lastIndex = this.pos\n      var skip = skipWhiteSpace.exec(this.input)\n      var next = this.input.charAt(this.pos + skip[0].length)\n      if (next !== \"*\") { return Parser.prototype.parseExport.call(this, node, exports) }\n\n      this.next()\n      var specifier = this.startNode()\n      this.expect(tt.star)\n      if (this.eatContextual(\"as\")) {\n        node.declaration = null\n        specifier.exported = this.parseIdent(true)\n        this.checkExport(exports, specifier.exported.name, this.lastTokStart)\n        node.specifiers = [this.finishNode(specifier, \"ExportNamespaceSpecifier\")]\n      }\n      this.expectContextual(\"from\")\n      if (this.type !== tt.string) { this.unexpected() }\n      node.source = this.parseExprAtom()\n      this.semicolon()\n      return this.finishNode(node, node.specifiers ? \"ExportNamedDeclaration\" : \"ExportAllDeclaration\")\n    };\n\n    return anonymous;\n  }(Parser))\n}\n\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/acorn-node/lib/export-ns-from/index.js?");

/***/ }),

/***/ "./node_modules/acorn-node/lib/import-meta/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/acorn-node/lib/import-meta/index.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/* Generated by `npm run build`, do not edit! */\n\n\n\nvar tt = (__webpack_require__(/*! acorn */ \"./node_modules/acorn/dist/acorn.mjs\").tokTypes)\n\nvar skipWhiteSpace = /(?:\\s|\\/\\/.*|\\/\\*[^]*?\\*\\/)*/g\n\nvar nextTokenIsDot = function (parser) {\n  skipWhiteSpace.lastIndex = parser.pos\n  var skip = skipWhiteSpace.exec(parser.input)\n  var next = parser.pos + skip[0].length\n  return parser.input.slice(next, next + 1) === \".\"\n}\n\nmodule.exports = function(Parser) {\n  return /*@__PURE__*/(function (Parser) {\n    function anonymous () {\n      Parser.apply(this, arguments);\n    }\n\n    if ( Parser ) anonymous.__proto__ = Parser;\n    anonymous.prototype = Object.create( Parser && Parser.prototype );\n    anonymous.prototype.constructor = anonymous;\n\n    anonymous.prototype.parseExprAtom = function parseExprAtom (refDestructuringErrors) {\n      if (this.type !== tt._import || !nextTokenIsDot(this)) { return Parser.prototype.parseExprAtom.call(this, refDestructuringErrors) }\n\n      if (!this.options.allowImportExportEverywhere && !this.inModule) {\n        this.raise(this.start, \"'import' and 'export' may appear only with 'sourceType: module'\")\n      }\n\n      var node = this.startNode()\n      node.meta = this.parseIdent(true)\n      this.expect(tt.dot)\n      node.property = this.parseIdent(true)\n      if (node.property.name !== \"meta\") {\n        this.raiseRecoverable(node.property.start, \"The only valid meta property for import is import.meta\")\n      }\n      return this.finishNode(node, \"MetaProperty\")\n    };\n\n    anonymous.prototype.parseStatement = function parseStatement (context, topLevel, exports) {\n      if (this.type !== tt._import || !nextTokenIsDot(this)) {\n        return Parser.prototype.parseStatement.call(this, context, topLevel, exports)\n      }\n\n      var node = this.startNode()\n      var expr = this.parseExpression()\n      return this.parseExpressionStatement(node, expr)\n    };\n\n    return anonymous;\n  }(Parser))\n}\n\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/acorn-node/lib/import-meta/index.js?");

/***/ }),

/***/ "./node_modules/acorn-node/lib/numeric-separator/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/acorn-node/lib/numeric-separator/index.js ***!
  \****************************************************************/
/***/ ((module) => {

"use strict";
eval("/* Generated by `npm run build`, do not edit! */\n\n\n\nmodule.exports = function(Parser) {\n  return /*@__PURE__*/(function (Parser) {\n    function anonymous () {\n      Parser.apply(this, arguments);\n    }\n\n    if ( Parser ) anonymous.__proto__ = Parser;\n    anonymous.prototype = Object.create( Parser && Parser.prototype );\n    anonymous.prototype.constructor = anonymous;\n\n    anonymous.prototype.readInt = function readInt (radix, len) {\n      // Hack: len is only != null for unicode escape sequences,\n      // where numeric separators are not allowed\n      if (len != null) { return Parser.prototype.readInt.call(this, radix, len) }\n\n      var start = this.pos, total = 0, acceptUnderscore = false\n      for (;;) {\n        var code = this.input.charCodeAt(this.pos), val = (void 0)\n        if (code >= 97) { val = code - 97 + 10 } // a\n        else if (code == 95) {\n          if (!acceptUnderscore) { this.raise(this.pos, \"Invalid numeric separator\") }\n          ++this.pos\n          acceptUnderscore = false\n          continue\n        } else if (code >= 65) { val = code - 65 + 10 } // A\n        else if (code >= 48 && code <= 57) { val = code - 48 } // 0-9\n        else { val = Infinity }\n        if (val >= radix) { break }\n        ++this.pos\n        total = total * radix + val\n        acceptUnderscore = true\n      }\n      if (this.pos === start) { return null }\n      if (!acceptUnderscore) { this.raise(this.pos - 1, \"Invalid numeric separator\") }\n\n      return total\n    };\n\n    anonymous.prototype.readNumber = function readNumber (startsWithDot) {\n      var token = Parser.prototype.readNumber.call(this, startsWithDot)\n      var octal = this.end - this.start >= 2 && this.input.charCodeAt(this.start) === 48\n      var stripped = this.getNumberInput(this.start, this.end)\n      if (stripped.length < this.end - this.start) {\n        if (octal) { this.raise(this.start, \"Invalid number\") }\n        this.value = parseFloat(stripped)\n      }\n      return token\n    };\n\n    // This is used by acorn-bigint\n    anonymous.prototype.getNumberInput = function getNumberInput (start, end) {\n      return this.input.slice(start, end).replace(/_/g, \"\")\n    };\n\n    return anonymous;\n  }(Parser))\n}\n\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/acorn-node/lib/numeric-separator/index.js?");

/***/ }),

/***/ "./node_modules/acorn-node/lib/private-class-elements/index.js":
/*!*********************************************************************!*\
  !*** ./node_modules/acorn-node/lib/private-class-elements/index.js ***!
  \*********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/* Generated by `npm run build`, do not edit! */\n\n\n\nvar acorn = __webpack_require__(/*! acorn */ \"./node_modules/acorn/dist/acorn.mjs\")\nif (false) {}\nvar tt = acorn.tokTypes\nvar TokenType = acorn.TokenType\n\nmodule.exports = function(Parser) {\n  // Only load this plugin once.\n  if (Parser.prototype.parsePrivateName) {\n    return Parser\n  }\n\n  // Make sure `Parser` comes from the same acorn as our `tt`,\n  // otherwise the comparisons fail.\n  var cur = Parser\n  while (cur && cur !== acorn.Parser) {\n    cur = cur.__proto__\n  }\n  if (cur !== acorn.Parser) {\n    throw new Error(\"acorn-private-class-elements does not support mixing different acorn copies\")\n  }\n\n  Parser = /*@__PURE__*/(function (Parser) {\n    function Parser_ () {\n      Parser.apply(this, arguments);\n    }\n\n    if ( Parser ) Parser_.__proto__ = Parser;\n    Parser_.prototype = Object.create( Parser && Parser.prototype );\n    Parser_.prototype.constructor = Parser_;\n\n    Parser_.prototype._branch = function _branch () {\n      this.__branch = this.__branch || new Parser({ecmaVersion: this.options.ecmaVersion}, this.input)\n      this.__branch.end = this.end\n      this.__branch.pos = this.pos\n      this.__branch.type = this.type\n      this.__branch.value = this.value\n      this.__branch.containsEsc = this.containsEsc\n      return this.__branch\n    };\n\n    Parser_.prototype.parsePrivateClassElementName = function parsePrivateClassElementName (element) {\n      element.computed = false\n      element.key = this.parsePrivateName()\n      if (element.key.name == \"constructor\") { this.raise(element.key.start, \"Classes may not have a private element named constructor\") }\n      var accept = {get: \"set\", set: \"get\"}[element.kind]\n      var privateBoundNames = this._privateBoundNamesStack[this._privateBoundNamesStack.length - 1]\n      if (Object.prototype.hasOwnProperty.call(privateBoundNames, element.key.name) && privateBoundNames[element.key.name] !== accept) {\n        this.raise(element.start, \"Duplicate private element\")\n      }\n      privateBoundNames[element.key.name] = element.kind || true\n      delete this._unresolvedPrivateNamesStack[this._unresolvedPrivateNamesStack.length - 1][element.key.name]\n      return element.key\n    };\n\n    Parser_.prototype.parsePrivateName = function parsePrivateName () {\n      var node = this.startNode()\n      node.name = this.value\n      this.next()\n      this.finishNode(node, \"PrivateName\")\n      if (this.options.allowReserved == \"never\") { this.checkUnreserved(node) }\n      return node\n    };\n\n    // Parse # token\n    Parser_.prototype.getTokenFromCode = function getTokenFromCode (code) {\n      if (code === 35) {\n        ++this.pos\n        var word = this.readWord1()\n        return this.finishToken(this.privateNameToken, word)\n      }\n      return Parser.prototype.getTokenFromCode.call(this, code)\n    };\n\n    // Manage stacks and check for undeclared private names\n    Parser_.prototype.parseClass = function parseClass (node, isStatement) {\n      this._privateBoundNamesStack = this._privateBoundNamesStack || []\n      var privateBoundNames = Object.create(this._privateBoundNamesStack[this._privateBoundNamesStack.length - 1] || null)\n      this._privateBoundNamesStack.push(privateBoundNames)\n      this._unresolvedPrivateNamesStack = this._unresolvedPrivateNamesStack || []\n      var unresolvedPrivateNames = Object.create(null)\n      this._unresolvedPrivateNamesStack.push(unresolvedPrivateNames)\n      var _return = Parser.prototype.parseClass.call(this, node, isStatement)\n      this._privateBoundNamesStack.pop()\n      this._unresolvedPrivateNamesStack.pop()\n      if (!this._unresolvedPrivateNamesStack.length) {\n        var names = Object.keys(unresolvedPrivateNames)\n        if (names.length) {\n          names.sort(function (n1, n2) { return unresolvedPrivateNames[n1] - unresolvedPrivateNames[n2]; })\n          this.raise(unresolvedPrivateNames[names[0]], \"Usage of undeclared private name\")\n        }\n      } else { Object.assign(this._unresolvedPrivateNamesStack[this._unresolvedPrivateNamesStack.length - 1], unresolvedPrivateNames) }\n      return _return\n    };\n\n    // Parse private element access\n    Parser_.prototype.parseSubscript = function parseSubscript (base, startPos, startLoc, noCalls, maybeAsyncArrow) {\n      if (!this.eat(tt.dot)) {\n        return Parser.prototype.parseSubscript.call(this, base, startPos, startLoc, noCalls, maybeAsyncArrow)\n      }\n      var node = this.startNodeAt(startPos, startLoc)\n      node.object = base\n      node.computed = false\n      if (this.type == this.privateNameToken) {\n        node.property = this.parsePrivateName()\n        if (!this._privateBoundNamesStack.length || !this._privateBoundNamesStack[this._privateBoundNamesStack.length - 1][node.property.name]) {\n          this._unresolvedPrivateNamesStack[this._unresolvedPrivateNamesStack.length - 1][node.property.name] = node.property.start\n        }\n      } else {\n        node.property = this.parseIdent(true)\n      }\n      return this.finishNode(node, \"MemberExpression\")\n    };\n\n    // Prohibit delete of private class elements\n    Parser_.prototype.parseMaybeUnary = function parseMaybeUnary (refDestructuringErrors, sawUnary) {\n      var _return = Parser.prototype.parseMaybeUnary.call(this, refDestructuringErrors, sawUnary)\n      if (_return.operator == \"delete\") {\n        if (_return.argument.type == \"MemberExpression\" && _return.argument.property.type == \"PrivateName\") {\n          this.raise(_return.start, \"Private elements may not be deleted\")\n        }\n      }\n      return _return\n    };\n\n    return Parser_;\n  }(Parser))\n  Parser.prototype.privateNameToken = new TokenType(\"privateName\")\n  return Parser\n}\n\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/acorn-node/lib/private-class-elements/index.js?");

/***/ }),

/***/ "./node_modules/acorn-node/lib/static-class-features/index.js":
/*!********************************************************************!*\
  !*** ./node_modules/acorn-node/lib/static-class-features/index.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/* Generated by `npm run build`, do not edit! */\n\n\n\nvar skipWhiteSpace = /(?:\\s|\\/\\/.*|\\/\\*[^]*?\\*\\/)*/g\n\nvar acorn = __webpack_require__(/*! acorn */ \"./node_modules/acorn/dist/acorn.mjs\")\nvar tt = acorn.tokTypes\n\nfunction maybeParseFieldValue(field) {\n  if (this.eat(tt.eq)) {\n    var oldInFieldValue = this._inStaticFieldValue\n    this._inStaticFieldValue = true\n    field.value = this.parseExpression()\n    this._inStaticFieldValue = oldInFieldValue\n  } else { field.value = null }\n}\n\nvar privateClassElements = __webpack_require__(/*! ../private-class-elements */ \"./node_modules/acorn-node/lib/private-class-elements/index.js\")\n\nmodule.exports = function(Parser) {\n  var ExtendedParser = privateClassElements(Parser)\n\n  return /*@__PURE__*/(function (ExtendedParser) {\n    function anonymous () {\n      ExtendedParser.apply(this, arguments);\n    }\n\n    if ( ExtendedParser ) anonymous.__proto__ = ExtendedParser;\n    anonymous.prototype = Object.create( ExtendedParser && ExtendedParser.prototype );\n    anonymous.prototype.constructor = anonymous;\n\n    anonymous.prototype.parseClassElement = function parseClassElement (_constructorAllowsSuper) {\n      var this$1 = this;\n\n      if (this.eat(tt.semi)) { return null }\n\n      var node = this.startNode()\n\n      var tryContextual = function (k, noLineBreak) {\n        if (typeof noLineBreak == \"undefined\") { noLineBreak = false }\n        var start = this$1.start, startLoc = this$1.startLoc\n        if (!this$1.eatContextual(k)) { return false }\n        if (this$1.type !== tt.parenL && (!noLineBreak || !this$1.canInsertSemicolon())) { return true }\n        if (node.key) { this$1.unexpected() }\n        node.computed = false\n        node.key = this$1.startNodeAt(start, startLoc)\n        node.key.name = k\n        this$1.finishNode(node.key, \"Identifier\")\n        return false\n      }\n\n      node.static = tryContextual(\"static\")\n      if (!node.static) { return ExtendedParser.prototype.parseClassElement.apply(this, arguments) }\n\n      var isGenerator = this.eat(tt.star)\n      var isAsync = false\n      if (!isGenerator) {\n        // Special-case for `async`, since `parseClassMember` currently looks\n        // for `(` to determine whether `async` is a method name\n        if (this.options.ecmaVersion >= 8 && this.isContextual(\"async\")) {\n          skipWhiteSpace.lastIndex = this.pos\n          var skip = skipWhiteSpace.exec(this.input)\n          var next = this.input.charAt(this.pos + skip[0].length)\n          if (next === \";\" || next === \"=\") {\n            node.key = this.parseIdent(true)\n            node.computed = false\n            maybeParseFieldValue.call(this, node)\n            this.finishNode(node, \"FieldDefinition\")\n            this.semicolon()\n            return node\n          } else if (this.options.ecmaVersion >= 8 && tryContextual(\"async\", true)) {\n            isAsync = true\n            isGenerator = this.options.ecmaVersion >= 9 && this.eat(tt.star)\n          }\n        } else if (tryContextual(\"get\")) {\n          node.kind = \"get\"\n        } else if (tryContextual(\"set\")) {\n          node.kind = \"set\"\n        }\n      }\n      if (this.type === this.privateNameToken) {\n        this.parsePrivateClassElementName(node)\n        if (this.type !== tt.parenL) {\n          if (node.key.name === \"prototype\") {\n            this.raise(node.key.start, \"Classes may not have a private static property named prototype\")\n          }\n          maybeParseFieldValue.call(this, node)\n          this.finishNode(node, \"FieldDefinition\")\n          this.semicolon()\n          return node\n        }\n      } else if (!node.key) {\n        this.parsePropertyName(node)\n        if ((node.key.name || node.key.value) === \"prototype\" && !node.computed) {\n          this.raise(node.key.start, \"Classes may not have a static property named prototype\")\n        }\n      }\n      if (!node.kind) { node.kind = \"method\" }\n      this.parseClassMethod(node, isGenerator, isAsync)\n      if (!node.kind && (node.key.name || node.key.value) === \"constructor\" && !node.computed) {\n        this.raise(node.key.start, \"Classes may not have a static field named constructor\")\n      }\n      if (node.kind === \"get\" && node.value.params.length !== 0) {\n        this.raiseRecoverable(node.value.start, \"getter should have no params\")\n      }\n      if (node.kind === \"set\" && node.value.params.length !== 1) {\n        this.raiseRecoverable(node.value.start, \"setter should have exactly one param\")\n      }\n      if (node.kind === \"set\" && node.value.params[0].type === \"RestElement\") {\n        this.raiseRecoverable(node.value.params[0].start, \"Setter cannot use rest params\")\n      }\n\n      return node\n\n    };\n\n    // Parse public static fields\n    anonymous.prototype.parseClassMethod = function parseClassMethod (method, isGenerator, isAsync, _allowsDirectSuper) {\n      if (isGenerator || isAsync || method.kind != \"method\" || !method.static || this.options.ecmaVersion < 8 || this.type == tt.parenL) {\n        return ExtendedParser.prototype.parseClassMethod.apply(this, arguments)\n      }\n      maybeParseFieldValue.call(this, method)\n      delete method.kind\n      method = this.finishNode(method, \"FieldDefinition\")\n      this.semicolon()\n      return method\n    };\n\n    // Prohibit arguments in class field initializers\n    anonymous.prototype.parseIdent = function parseIdent (liberal, isBinding) {\n      var ident = ExtendedParser.prototype.parseIdent.call(this, liberal, isBinding)\n      if (this._inStaticFieldValue && ident.name == \"arguments\") { this.raise(ident.start, \"A static class field initializer may not contain arguments\") }\n      return ident\n    };\n\n    return anonymous;\n  }(ExtendedParser))\n}\n\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/acorn-node/lib/static-class-features/index.js?");

/***/ }),

/***/ "./node_modules/acorn-node/walk.js":
/*!*****************************************!*\
  !*** ./node_modules/acorn-node/walk.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("var xtend = __webpack_require__(/*! xtend */ \"./node_modules/xtend/immutable.js\")\nvar walk = __webpack_require__(/*! acorn-walk */ \"./node_modules/acorn-walk/dist/walk.mjs\")\n\nvar base = xtend(walk.base)\nbase.Import = function () {}\n\nfunction simple (node, visitors, baseVisitor, state, override) {\n  return walk.simple(node, visitors, baseVisitor || base, state, override)\n}\n\nfunction ancestor (node, visitors, baseVisitor, state) {\n  return walk.ancestor(node, visitors, baseVisitor || base, state)\n}\n\nfunction recursive (node, state, funcs, baseVisitor, override) {\n  return walk.recursive(node, state, funcs, baseVisitor || base, override)\n}\n\nfunction full (node, callback, baseVisitor, state, override) {\n  return walk.full(node, callback, baseVisitor || base, state, override)\n}\n\nfunction fullAncestor (node, callback, baseVisitor, state) {\n  return walk.fullAncestor(node, callback, baseVisitor || base, state)\n}\n\nfunction findNodeAt (node, start, end, test, baseVisitor, state) {\n  return walk.findNodeAt(node, start, end, test, baseVisitor || base, state)\n}\n\nfunction findNodeAround (node, pos, test, baseVisitor, state) {\n  return walk.findNodeAround(node, pos, test, baseVisitor || base, state)\n}\n\nfunction findNodeAfter (node, pos, test, baseVisitor, state) {\n  return walk.findNodeAfter(node, pos, test, baseVisitor || base, state)\n}\n\nfunction findNodeBefore (node, pos, test, baseVisitor, state) {\n  return walk.findNodeBefore(node, pos, test, baseVisitor || base, state)\n}\n\nfunction make (funcs, baseVisitor) {\n  return walk.make(funcs, baseVisitor || base)\n}\n\nexports.simple = simple\nexports.ancestor = ancestor\nexports.recursive = recursive\nexports.full = full\nexports.fullAncestor = fullAncestor\nexports.findNodeAt = findNodeAt\nexports.findNodeAround = findNodeAround\nexports.findNodeAfter = findNodeAfter\nexports.findNodeBefore = findNodeBefore\nexports.make = make\nexports.base = base\n\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/acorn-node/walk.js?");

/***/ }),

/***/ "./node_modules/braces/index.js":
/*!**************************************!*\
  !*** ./node_modules/braces/index.js ***!
  \**************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst stringify = __webpack_require__(/*! ./lib/stringify */ \"./node_modules/braces/lib/stringify.js\");\nconst compile = __webpack_require__(/*! ./lib/compile */ \"./node_modules/braces/lib/compile.js\");\nconst expand = __webpack_require__(/*! ./lib/expand */ \"./node_modules/braces/lib/expand.js\");\nconst parse = __webpack_require__(/*! ./lib/parse */ \"./node_modules/braces/lib/parse.js\");\n\n/**\n * Expand the given pattern or create a regex-compatible string.\n *\n * ```js\n * const braces = require('braces');\n * console.log(braces('{a,b,c}', { compile: true })); //=> ['(a|b|c)']\n * console.log(braces('{a,b,c}')); //=> ['a', 'b', 'c']\n * ```\n * @param {String} `str`\n * @param {Object} `options`\n * @return {String}\n * @api public\n */\n\nconst braces = (input, options = {}) => {\n  let output = [];\n\n  if (Array.isArray(input)) {\n    for (let pattern of input) {\n      let result = braces.create(pattern, options);\n      if (Array.isArray(result)) {\n        output.push(...result);\n      } else {\n        output.push(result);\n      }\n    }\n  } else {\n    output = [].concat(braces.create(input, options));\n  }\n\n  if (options && options.expand === true && options.nodupes === true) {\n    output = [...new Set(output)];\n  }\n  return output;\n};\n\n/**\n * Parse the given `str` with the given `options`.\n *\n * ```js\n * // braces.parse(pattern, [, options]);\n * const ast = braces.parse('a/{b,c}/d');\n * console.log(ast);\n * ```\n * @param {String} pattern Brace pattern to parse\n * @param {Object} options\n * @return {Object} Returns an AST\n * @api public\n */\n\nbraces.parse = (input, options = {}) => parse(input, options);\n\n/**\n * Creates a braces string from an AST, or an AST node.\n *\n * ```js\n * const braces = require('braces');\n * let ast = braces.parse('foo/{a,b}/bar');\n * console.log(stringify(ast.nodes[2])); //=> '{a,b}'\n * ```\n * @param {String} `input` Brace pattern or AST.\n * @param {Object} `options`\n * @return {Array} Returns an array of expanded values.\n * @api public\n */\n\nbraces.stringify = (input, options = {}) => {\n  if (typeof input === 'string') {\n    return stringify(braces.parse(input, options), options);\n  }\n  return stringify(input, options);\n};\n\n/**\n * Compiles a brace pattern into a regex-compatible, optimized string.\n * This method is called by the main [braces](#braces) function by default.\n *\n * ```js\n * const braces = require('braces');\n * console.log(braces.compile('a/{b,c}/d'));\n * //=> ['a/(b|c)/d']\n * ```\n * @param {String} `input` Brace pattern or AST.\n * @param {Object} `options`\n * @return {Array} Returns an array of expanded values.\n * @api public\n */\n\nbraces.compile = (input, options = {}) => {\n  if (typeof input === 'string') {\n    input = braces.parse(input, options);\n  }\n  return compile(input, options);\n};\n\n/**\n * Expands a brace pattern into an array. This method is called by the\n * main [braces](#braces) function when `options.expand` is true. Before\n * using this method it's recommended that you read the [performance notes](#performance))\n * and advantages of using [.compile](#compile) instead.\n *\n * ```js\n * const braces = require('braces');\n * console.log(braces.expand('a/{b,c}/d'));\n * //=> ['a/b/d', 'a/c/d'];\n * ```\n * @param {String} `pattern` Brace pattern\n * @param {Object} `options`\n * @return {Array} Returns an array of expanded values.\n * @api public\n */\n\nbraces.expand = (input, options = {}) => {\n  if (typeof input === 'string') {\n    input = braces.parse(input, options);\n  }\n\n  let result = expand(input, options);\n\n  // filter out empty strings if specified\n  if (options.noempty === true) {\n    result = result.filter(Boolean);\n  }\n\n  // filter out duplicates if specified\n  if (options.nodupes === true) {\n    result = [...new Set(result)];\n  }\n\n  return result;\n};\n\n/**\n * Processes a brace pattern and returns either an expanded array\n * (if `options.expand` is true), a highly optimized regex-compatible string.\n * This method is called by the main [braces](#braces) function.\n *\n * ```js\n * const braces = require('braces');\n * console.log(braces.create('user-{200..300}/project-{a,b,c}-{1..10}'))\n * //=> 'user-(20[0-9]|2[1-9][0-9]|300)/project-(a|b|c)-([1-9]|10)'\n * ```\n * @param {String} `pattern` Brace pattern\n * @param {Object} `options`\n * @return {Array} Returns an array of expanded values.\n * @api public\n */\n\nbraces.create = (input, options = {}) => {\n  if (input === '' || input.length < 3) {\n    return [input];\n  }\n\n return options.expand !== true\n    ? braces.compile(input, options)\n    : braces.expand(input, options);\n};\n\n/**\n * Expose \"braces\"\n */\n\nmodule.exports = braces;\n\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/braces/index.js?");

/***/ }),

/***/ "./node_modules/braces/lib/compile.js":
/*!********************************************!*\
  !*** ./node_modules/braces/lib/compile.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst fill = __webpack_require__(/*! fill-range */ \"./node_modules/fill-range/index.js\");\nconst utils = __webpack_require__(/*! ./utils */ \"./node_modules/braces/lib/utils.js\");\n\nconst compile = (ast, options = {}) => {\n  let walk = (node, parent = {}) => {\n    let invalidBlock = utils.isInvalidBrace(parent);\n    let invalidNode = node.invalid === true && options.escapeInvalid === true;\n    let invalid = invalidBlock === true || invalidNode === true;\n    let prefix = options.escapeInvalid === true ? '\\\\' : '';\n    let output = '';\n\n    if (node.isOpen === true) {\n      return prefix + node.value;\n    }\n    if (node.isClose === true) {\n      return prefix + node.value;\n    }\n\n    if (node.type === 'open') {\n      return invalid ? (prefix + node.value) : '(';\n    }\n\n    if (node.type === 'close') {\n      return invalid ? (prefix + node.value) : ')';\n    }\n\n    if (node.type === 'comma') {\n      return node.prev.type === 'comma' ? '' : (invalid ? node.value : '|');\n    }\n\n    if (node.value) {\n      return node.value;\n    }\n\n    if (node.nodes && node.ranges > 0) {\n      let args = utils.reduce(node.nodes);\n      let range = fill(...args, { ...options, wrap: false, toRegex: true });\n\n      if (range.length !== 0) {\n        return args.length > 1 && range.length > 1 ? `(${range})` : range;\n      }\n    }\n\n    if (node.nodes) {\n      for (let child of node.nodes) {\n        output += walk(child, node);\n      }\n    }\n    return output;\n  };\n\n  return walk(ast);\n};\n\nmodule.exports = compile;\n\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/braces/lib/compile.js?");

/***/ }),

/***/ "./node_modules/braces/lib/constants.js":
/*!**********************************************!*\
  !*** ./node_modules/braces/lib/constants.js ***!
  \**********************************************/
/***/ ((module) => {

"use strict";
eval("\n\nmodule.exports = {\n  MAX_LENGTH: 1024 * 64,\n\n  // Digits\n  CHAR_0: '0', /* 0 */\n  CHAR_9: '9', /* 9 */\n\n  // Alphabet chars.\n  CHAR_UPPERCASE_A: 'A', /* A */\n  CHAR_LOWERCASE_A: 'a', /* a */\n  CHAR_UPPERCASE_Z: 'Z', /* Z */\n  CHAR_LOWERCASE_Z: 'z', /* z */\n\n  CHAR_LEFT_PARENTHESES: '(', /* ( */\n  CHAR_RIGHT_PARENTHESES: ')', /* ) */\n\n  CHAR_ASTERISK: '*', /* * */\n\n  // Non-alphabetic chars.\n  CHAR_AMPERSAND: '&', /* & */\n  CHAR_AT: '@', /* @ */\n  CHAR_BACKSLASH: '\\\\', /* \\ */\n  CHAR_BACKTICK: '`', /* ` */\n  CHAR_CARRIAGE_RETURN: '\\r', /* \\r */\n  CHAR_CIRCUMFLEX_ACCENT: '^', /* ^ */\n  CHAR_COLON: ':', /* : */\n  CHAR_COMMA: ',', /* , */\n  CHAR_DOLLAR: '$', /* . */\n  CHAR_DOT: '.', /* . */\n  CHAR_DOUBLE_QUOTE: '\"', /* \" */\n  CHAR_EQUAL: '=', /* = */\n  CHAR_EXCLAMATION_MARK: '!', /* ! */\n  CHAR_FORM_FEED: '\\f', /* \\f */\n  CHAR_FORWARD_SLASH: '/', /* / */\n  CHAR_HASH: '#', /* # */\n  CHAR_HYPHEN_MINUS: '-', /* - */\n  CHAR_LEFT_ANGLE_BRACKET: '<', /* < */\n  CHAR_LEFT_CURLY_BRACE: '{', /* { */\n  CHAR_LEFT_SQUARE_BRACKET: '[', /* [ */\n  CHAR_LINE_FEED: '\\n', /* \\n */\n  CHAR_NO_BREAK_SPACE: '\\u00A0', /* \\u00A0 */\n  CHAR_PERCENT: '%', /* % */\n  CHAR_PLUS: '+', /* + */\n  CHAR_QUESTION_MARK: '?', /* ? */\n  CHAR_RIGHT_ANGLE_BRACKET: '>', /* > */\n  CHAR_RIGHT_CURLY_BRACE: '}', /* } */\n  CHAR_RIGHT_SQUARE_BRACKET: ']', /* ] */\n  CHAR_SEMICOLON: ';', /* ; */\n  CHAR_SINGLE_QUOTE: '\\'', /* ' */\n  CHAR_SPACE: ' ', /*   */\n  CHAR_TAB: '\\t', /* \\t */\n  CHAR_UNDERSCORE: '_', /* _ */\n  CHAR_VERTICAL_LINE: '|', /* | */\n  CHAR_ZERO_WIDTH_NOBREAK_SPACE: '\\uFEFF' /* \\uFEFF */\n};\n\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/braces/lib/constants.js?");

/***/ }),

/***/ "./node_modules/braces/lib/expand.js":
/*!*******************************************!*\
  !*** ./node_modules/braces/lib/expand.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst fill = __webpack_require__(/*! fill-range */ \"./node_modules/fill-range/index.js\");\nconst stringify = __webpack_require__(/*! ./stringify */ \"./node_modules/braces/lib/stringify.js\");\nconst utils = __webpack_require__(/*! ./utils */ \"./node_modules/braces/lib/utils.js\");\n\nconst append = (queue = '', stash = '', enclose = false) => {\n  let result = [];\n\n  queue = [].concat(queue);\n  stash = [].concat(stash);\n\n  if (!stash.length) return queue;\n  if (!queue.length) {\n    return enclose ? utils.flatten(stash).map(ele => `{${ele}}`) : stash;\n  }\n\n  for (let item of queue) {\n    if (Array.isArray(item)) {\n      for (let value of item) {\n        result.push(append(value, stash, enclose));\n      }\n    } else {\n      for (let ele of stash) {\n        if (enclose === true && typeof ele === 'string') ele = `{${ele}}`;\n        result.push(Array.isArray(ele) ? append(item, ele, enclose) : (item + ele));\n      }\n    }\n  }\n  return utils.flatten(result);\n};\n\nconst expand = (ast, options = {}) => {\n  let rangeLimit = options.rangeLimit === void 0 ? 1000 : options.rangeLimit;\n\n  let walk = (node, parent = {}) => {\n    node.queue = [];\n\n    let p = parent;\n    let q = parent.queue;\n\n    while (p.type !== 'brace' && p.type !== 'root' && p.parent) {\n      p = p.parent;\n      q = p.queue;\n    }\n\n    if (node.invalid || node.dollar) {\n      q.push(append(q.pop(), stringify(node, options)));\n      return;\n    }\n\n    if (node.type === 'brace' && node.invalid !== true && node.nodes.length === 2) {\n      q.push(append(q.pop(), ['{}']));\n      return;\n    }\n\n    if (node.nodes && node.ranges > 0) {\n      let args = utils.reduce(node.nodes);\n\n      if (utils.exceedsLimit(...args, options.step, rangeLimit)) {\n        throw new RangeError('expanded array length exceeds range limit. Use options.rangeLimit to increase or disable the limit.');\n      }\n\n      let range = fill(...args, options);\n      if (range.length === 0) {\n        range = stringify(node, options);\n      }\n\n      q.push(append(q.pop(), range));\n      node.nodes = [];\n      return;\n    }\n\n    let enclose = utils.encloseBrace(node);\n    let queue = node.queue;\n    let block = node;\n\n    while (block.type !== 'brace' && block.type !== 'root' && block.parent) {\n      block = block.parent;\n      queue = block.queue;\n    }\n\n    for (let i = 0; i < node.nodes.length; i++) {\n      let child = node.nodes[i];\n\n      if (child.type === 'comma' && node.type === 'brace') {\n        if (i === 1) queue.push('');\n        queue.push('');\n        continue;\n      }\n\n      if (child.type === 'close') {\n        q.push(append(q.pop(), queue, enclose));\n        continue;\n      }\n\n      if (child.value && child.type !== 'open') {\n        queue.push(append(queue.pop(), child.value));\n        continue;\n      }\n\n      if (child.nodes) {\n        walk(child, node);\n      }\n    }\n\n    return queue;\n  };\n\n  return utils.flatten(walk(ast));\n};\n\nmodule.exports = expand;\n\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/braces/lib/expand.js?");

/***/ }),

/***/ "./node_modules/braces/lib/parse.js":
/*!******************************************!*\
  !*** ./node_modules/braces/lib/parse.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst stringify = __webpack_require__(/*! ./stringify */ \"./node_modules/braces/lib/stringify.js\");\n\n/**\n * Constants\n */\n\nconst {\n  MAX_LENGTH,\n  CHAR_BACKSLASH, /* \\ */\n  CHAR_BACKTICK, /* ` */\n  CHAR_COMMA, /* , */\n  CHAR_DOT, /* . */\n  CHAR_LEFT_PARENTHESES, /* ( */\n  CHAR_RIGHT_PARENTHESES, /* ) */\n  CHAR_LEFT_CURLY_BRACE, /* { */\n  CHAR_RIGHT_CURLY_BRACE, /* } */\n  CHAR_LEFT_SQUARE_BRACKET, /* [ */\n  CHAR_RIGHT_SQUARE_BRACKET, /* ] */\n  CHAR_DOUBLE_QUOTE, /* \" */\n  CHAR_SINGLE_QUOTE, /* ' */\n  CHAR_NO_BREAK_SPACE,\n  CHAR_ZERO_WIDTH_NOBREAK_SPACE\n} = __webpack_require__(/*! ./constants */ \"./node_modules/braces/lib/constants.js\");\n\n/**\n * parse\n */\n\nconst parse = (input, options = {}) => {\n  if (typeof input !== 'string') {\n    throw new TypeError('Expected a string');\n  }\n\n  let opts = options || {};\n  let max = typeof opts.maxLength === 'number' ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;\n  if (input.length > max) {\n    throw new SyntaxError(`Input length (${input.length}), exceeds max characters (${max})`);\n  }\n\n  let ast = { type: 'root', input, nodes: [] };\n  let stack = [ast];\n  let block = ast;\n  let prev = ast;\n  let brackets = 0;\n  let length = input.length;\n  let index = 0;\n  let depth = 0;\n  let value;\n  let memo = {};\n\n  /**\n   * Helpers\n   */\n\n  const advance = () => input[index++];\n  const push = node => {\n    if (node.type === 'text' && prev.type === 'dot') {\n      prev.type = 'text';\n    }\n\n    if (prev && prev.type === 'text' && node.type === 'text') {\n      prev.value += node.value;\n      return;\n    }\n\n    block.nodes.push(node);\n    node.parent = block;\n    node.prev = prev;\n    prev = node;\n    return node;\n  };\n\n  push({ type: 'bos' });\n\n  while (index < length) {\n    block = stack[stack.length - 1];\n    value = advance();\n\n    /**\n     * Invalid chars\n     */\n\n    if (value === CHAR_ZERO_WIDTH_NOBREAK_SPACE || value === CHAR_NO_BREAK_SPACE) {\n      continue;\n    }\n\n    /**\n     * Escaped chars\n     */\n\n    if (value === CHAR_BACKSLASH) {\n      push({ type: 'text', value: (options.keepEscaping ? value : '') + advance() });\n      continue;\n    }\n\n    /**\n     * Right square bracket (literal): ']'\n     */\n\n    if (value === CHAR_RIGHT_SQUARE_BRACKET) {\n      push({ type: 'text', value: '\\\\' + value });\n      continue;\n    }\n\n    /**\n     * Left square bracket: '['\n     */\n\n    if (value === CHAR_LEFT_SQUARE_BRACKET) {\n      brackets++;\n\n      let closed = true;\n      let next;\n\n      while (index < length && (next = advance())) {\n        value += next;\n\n        if (next === CHAR_LEFT_SQUARE_BRACKET) {\n          brackets++;\n          continue;\n        }\n\n        if (next === CHAR_BACKSLASH) {\n          value += advance();\n          continue;\n        }\n\n        if (next === CHAR_RIGHT_SQUARE_BRACKET) {\n          brackets--;\n\n          if (brackets === 0) {\n            break;\n          }\n        }\n      }\n\n      push({ type: 'text', value });\n      continue;\n    }\n\n    /**\n     * Parentheses\n     */\n\n    if (value === CHAR_LEFT_PARENTHESES) {\n      block = push({ type: 'paren', nodes: [] });\n      stack.push(block);\n      push({ type: 'text', value });\n      continue;\n    }\n\n    if (value === CHAR_RIGHT_PARENTHESES) {\n      if (block.type !== 'paren') {\n        push({ type: 'text', value });\n        continue;\n      }\n      block = stack.pop();\n      push({ type: 'text', value });\n      block = stack[stack.length - 1];\n      continue;\n    }\n\n    /**\n     * Quotes: '|\"|`\n     */\n\n    if (value === CHAR_DOUBLE_QUOTE || value === CHAR_SINGLE_QUOTE || value === CHAR_BACKTICK) {\n      let open = value;\n      let next;\n\n      if (options.keepQuotes !== true) {\n        value = '';\n      }\n\n      while (index < length && (next = advance())) {\n        if (next === CHAR_BACKSLASH) {\n          value += next + advance();\n          continue;\n        }\n\n        if (next === open) {\n          if (options.keepQuotes === true) value += next;\n          break;\n        }\n\n        value += next;\n      }\n\n      push({ type: 'text', value });\n      continue;\n    }\n\n    /**\n     * Left curly brace: '{'\n     */\n\n    if (value === CHAR_LEFT_CURLY_BRACE) {\n      depth++;\n\n      let dollar = prev.value && prev.value.slice(-1) === '$' || block.dollar === true;\n      let brace = {\n        type: 'brace',\n        open: true,\n        close: false,\n        dollar,\n        depth,\n        commas: 0,\n        ranges: 0,\n        nodes: []\n      };\n\n      block = push(brace);\n      stack.push(block);\n      push({ type: 'open', value });\n      continue;\n    }\n\n    /**\n     * Right curly brace: '}'\n     */\n\n    if (value === CHAR_RIGHT_CURLY_BRACE) {\n      if (block.type !== 'brace') {\n        push({ type: 'text', value });\n        continue;\n      }\n\n      let type = 'close';\n      block = stack.pop();\n      block.close = true;\n\n      push({ type, value });\n      depth--;\n\n      block = stack[stack.length - 1];\n      continue;\n    }\n\n    /**\n     * Comma: ','\n     */\n\n    if (value === CHAR_COMMA && depth > 0) {\n      if (block.ranges > 0) {\n        block.ranges = 0;\n        let open = block.nodes.shift();\n        block.nodes = [open, { type: 'text', value: stringify(block) }];\n      }\n\n      push({ type: 'comma', value });\n      block.commas++;\n      continue;\n    }\n\n    /**\n     * Dot: '.'\n     */\n\n    if (value === CHAR_DOT && depth > 0 && block.commas === 0) {\n      let siblings = block.nodes;\n\n      if (depth === 0 || siblings.length === 0) {\n        push({ type: 'text', value });\n        continue;\n      }\n\n      if (prev.type === 'dot') {\n        block.range = [];\n        prev.value += value;\n        prev.type = 'range';\n\n        if (block.nodes.length !== 3 && block.nodes.length !== 5) {\n          block.invalid = true;\n          block.ranges = 0;\n          prev.type = 'text';\n          continue;\n        }\n\n        block.ranges++;\n        block.args = [];\n        continue;\n      }\n\n      if (prev.type === 'range') {\n        siblings.pop();\n\n        let before = siblings[siblings.length - 1];\n        before.value += prev.value + value;\n        prev = before;\n        block.ranges--;\n        continue;\n      }\n\n      push({ type: 'dot', value });\n      continue;\n    }\n\n    /**\n     * Text\n     */\n\n    push({ type: 'text', value });\n  }\n\n  // Mark imbalanced braces and brackets as invalid\n  do {\n    block = stack.pop();\n\n    if (block.type !== 'root') {\n      block.nodes.forEach(node => {\n        if (!node.nodes) {\n          if (node.type === 'open') node.isOpen = true;\n          if (node.type === 'close') node.isClose = true;\n          if (!node.nodes) node.type = 'text';\n          node.invalid = true;\n        }\n      });\n\n      // get the location of the block on parent.nodes (block's siblings)\n      let parent = stack[stack.length - 1];\n      let index = parent.nodes.indexOf(block);\n      // replace the (invalid) block with it's nodes\n      parent.nodes.splice(index, 1, ...block.nodes);\n    }\n  } while (stack.length > 0);\n\n  push({ type: 'eos' });\n  return ast;\n};\n\nmodule.exports = parse;\n\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/braces/lib/parse.js?");

/***/ }),

/***/ "./node_modules/braces/lib/stringify.js":
/*!**********************************************!*\
  !*** ./node_modules/braces/lib/stringify.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst utils = __webpack_require__(/*! ./utils */ \"./node_modules/braces/lib/utils.js\");\n\nmodule.exports = (ast, options = {}) => {\n  let stringify = (node, parent = {}) => {\n    let invalidBlock = options.escapeInvalid && utils.isInvalidBrace(parent);\n    let invalidNode = node.invalid === true && options.escapeInvalid === true;\n    let output = '';\n\n    if (node.value) {\n      if ((invalidBlock || invalidNode) && utils.isOpenOrClose(node)) {\n        return '\\\\' + node.value;\n      }\n      return node.value;\n    }\n\n    if (node.value) {\n      return node.value;\n    }\n\n    if (node.nodes) {\n      for (let child of node.nodes) {\n        output += stringify(child);\n      }\n    }\n    return output;\n  };\n\n  return stringify(ast);\n};\n\n\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/braces/lib/stringify.js?");

/***/ }),

/***/ "./node_modules/braces/lib/utils.js":
/*!******************************************!*\
  !*** ./node_modules/braces/lib/utils.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\nexports.isInteger = num => {\n  if (typeof num === 'number') {\n    return Number.isInteger(num);\n  }\n  if (typeof num === 'string' && num.trim() !== '') {\n    return Number.isInteger(Number(num));\n  }\n  return false;\n};\n\n/**\n * Find a node of the given type\n */\n\nexports.find = (node, type) => node.nodes.find(node => node.type === type);\n\n/**\n * Find a node of the given type\n */\n\nexports.exceedsLimit = (min, max, step = 1, limit) => {\n  if (limit === false) return false;\n  if (!exports.isInteger(min) || !exports.isInteger(max)) return false;\n  return ((Number(max) - Number(min)) / Number(step)) >= limit;\n};\n\n/**\n * Escape the given node with '\\\\' before node.value\n */\n\nexports.escapeNode = (block, n = 0, type) => {\n  let node = block.nodes[n];\n  if (!node) return;\n\n  if ((type && node.type === type) || node.type === 'open' || node.type === 'close') {\n    if (node.escaped !== true) {\n      node.value = '\\\\' + node.value;\n      node.escaped = true;\n    }\n  }\n};\n\n/**\n * Returns true if the given brace node should be enclosed in literal braces\n */\n\nexports.encloseBrace = node => {\n  if (node.type !== 'brace') return false;\n  if ((node.commas >> 0 + node.ranges >> 0) === 0) {\n    node.invalid = true;\n    return true;\n  }\n  return false;\n};\n\n/**\n * Returns true if a brace node is invalid.\n */\n\nexports.isInvalidBrace = block => {\n  if (block.type !== 'brace') return false;\n  if (block.invalid === true || block.dollar) return true;\n  if ((block.commas >> 0 + block.ranges >> 0) === 0) {\n    block.invalid = true;\n    return true;\n  }\n  if (block.open !== true || block.close !== true) {\n    block.invalid = true;\n    return true;\n  }\n  return false;\n};\n\n/**\n * Returns true if a node is an open or close node\n */\n\nexports.isOpenOrClose = node => {\n  if (node.type === 'open' || node.type === 'close') {\n    return true;\n  }\n  return node.open === true || node.close === true;\n};\n\n/**\n * Reduce an array of text nodes.\n */\n\nexports.reduce = nodes => nodes.reduce((acc, node) => {\n  if (node.type === 'text') acc.push(node.value);\n  if (node.type === 'range') node.type = 'text';\n  return acc;\n}, []);\n\n/**\n * Flatten an array\n */\n\nexports.flatten = (...args) => {\n  const result = [];\n  const flat = arr => {\n    for (let i = 0; i < arr.length; i++) {\n      let ele = arr[i];\n      Array.isArray(ele) ? flat(ele, result) : ele !== void 0 && result.push(ele);\n    }\n    return result;\n  };\n  flat(args);\n  return result;\n};\n\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/braces/lib/utils.js?");

/***/ }),

/***/ "./node_modules/camelcase-css/index-es5.js":
/*!*************************************************!*\
  !*** ./node_modules/camelcase-css/index-es5.js ***!
  \*************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nvar pattern = /-(\\w|$)/g;\n\nvar callback = function callback(dashChar, char) {\n\treturn char.toUpperCase();\n};\n\nvar camelCaseCSS = function camelCaseCSS(property) {\n\tproperty = property.toLowerCase();\n\n\t// NOTE :: IE8's \"styleFloat\" is intentionally not supported\n\tif (property === \"float\") {\n\t\treturn \"cssFloat\";\n\t}\n\t// Microsoft vendor-prefixes are uniquely cased\n\telse if (property.charCodeAt(0) === 45&& property.charCodeAt(1) === 109&& property.charCodeAt(2) === 115&& property.charCodeAt(3) === 45) {\n\t\t\treturn property.substr(1).replace(pattern, callback);\n\t\t} else {\n\t\t\treturn property.replace(pattern, callback);\n\t\t}\n};\n\nmodule.exports = camelCaseCSS;\n\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/camelcase-css/index-es5.js?");

/***/ }),

/***/ "./node_modules/color-name/index.js":
/*!******************************************!*\
  !*** ./node_modules/color-name/index.js ***!
  \******************************************/
/***/ ((module) => {

"use strict";
eval("\r\n\r\nmodule.exports = {\r\n\t\"aliceblue\": [240, 248, 255],\r\n\t\"antiquewhite\": [250, 235, 215],\r\n\t\"aqua\": [0, 255, 255],\r\n\t\"aquamarine\": [127, 255, 212],\r\n\t\"azure\": [240, 255, 255],\r\n\t\"beige\": [245, 245, 220],\r\n\t\"bisque\": [255, 228, 196],\r\n\t\"black\": [0, 0, 0],\r\n\t\"blanchedalmond\": [255, 235, 205],\r\n\t\"blue\": [0, 0, 255],\r\n\t\"blueviolet\": [138, 43, 226],\r\n\t\"brown\": [165, 42, 42],\r\n\t\"burlywood\": [222, 184, 135],\r\n\t\"cadetblue\": [95, 158, 160],\r\n\t\"chartreuse\": [127, 255, 0],\r\n\t\"chocolate\": [210, 105, 30],\r\n\t\"coral\": [255, 127, 80],\r\n\t\"cornflowerblue\": [100, 149, 237],\r\n\t\"cornsilk\": [255, 248, 220],\r\n\t\"crimson\": [220, 20, 60],\r\n\t\"cyan\": [0, 255, 255],\r\n\t\"darkblue\": [0, 0, 139],\r\n\t\"darkcyan\": [0, 139, 139],\r\n\t\"darkgoldenrod\": [184, 134, 11],\r\n\t\"darkgray\": [169, 169, 169],\r\n\t\"darkgreen\": [0, 100, 0],\r\n\t\"darkgrey\": [169, 169, 169],\r\n\t\"darkkhaki\": [189, 183, 107],\r\n\t\"darkmagenta\": [139, 0, 139],\r\n\t\"darkolivegreen\": [85, 107, 47],\r\n\t\"darkorange\": [255, 140, 0],\r\n\t\"darkorchid\": [153, 50, 204],\r\n\t\"darkred\": [139, 0, 0],\r\n\t\"darksalmon\": [233, 150, 122],\r\n\t\"darkseagreen\": [143, 188, 143],\r\n\t\"darkslateblue\": [72, 61, 139],\r\n\t\"darkslategray\": [47, 79, 79],\r\n\t\"darkslategrey\": [47, 79, 79],\r\n\t\"darkturquoise\": [0, 206, 209],\r\n\t\"darkviolet\": [148, 0, 211],\r\n\t\"deeppink\": [255, 20, 147],\r\n\t\"deepskyblue\": [0, 191, 255],\r\n\t\"dimgray\": [105, 105, 105],\r\n\t\"dimgrey\": [105, 105, 105],\r\n\t\"dodgerblue\": [30, 144, 255],\r\n\t\"firebrick\": [178, 34, 34],\r\n\t\"floralwhite\": [255, 250, 240],\r\n\t\"forestgreen\": [34, 139, 34],\r\n\t\"fuchsia\": [255, 0, 255],\r\n\t\"gainsboro\": [220, 220, 220],\r\n\t\"ghostwhite\": [248, 248, 255],\r\n\t\"gold\": [255, 215, 0],\r\n\t\"goldenrod\": [218, 165, 32],\r\n\t\"gray\": [128, 128, 128],\r\n\t\"green\": [0, 128, 0],\r\n\t\"greenyellow\": [173, 255, 47],\r\n\t\"grey\": [128, 128, 128],\r\n\t\"honeydew\": [240, 255, 240],\r\n\t\"hotpink\": [255, 105, 180],\r\n\t\"indianred\": [205, 92, 92],\r\n\t\"indigo\": [75, 0, 130],\r\n\t\"ivory\": [255, 255, 240],\r\n\t\"khaki\": [240, 230, 140],\r\n\t\"lavender\": [230, 230, 250],\r\n\t\"lavenderblush\": [255, 240, 245],\r\n\t\"lawngreen\": [124, 252, 0],\r\n\t\"lemonchiffon\": [255, 250, 205],\r\n\t\"lightblue\": [173, 216, 230],\r\n\t\"lightcoral\": [240, 128, 128],\r\n\t\"lightcyan\": [224, 255, 255],\r\n\t\"lightgoldenrodyellow\": [250, 250, 210],\r\n\t\"lightgray\": [211, 211, 211],\r\n\t\"lightgreen\": [144, 238, 144],\r\n\t\"lightgrey\": [211, 211, 211],\r\n\t\"lightpink\": [255, 182, 193],\r\n\t\"lightsalmon\": [255, 160, 122],\r\n\t\"lightseagreen\": [32, 178, 170],\r\n\t\"lightskyblue\": [135, 206, 250],\r\n\t\"lightslategray\": [119, 136, 153],\r\n\t\"lightslategrey\": [119, 136, 153],\r\n\t\"lightsteelblue\": [176, 196, 222],\r\n\t\"lightyellow\": [255, 255, 224],\r\n\t\"lime\": [0, 255, 0],\r\n\t\"limegreen\": [50, 205, 50],\r\n\t\"linen\": [250, 240, 230],\r\n\t\"magenta\": [255, 0, 255],\r\n\t\"maroon\": [128, 0, 0],\r\n\t\"mediumaquamarine\": [102, 205, 170],\r\n\t\"mediumblue\": [0, 0, 205],\r\n\t\"mediumorchid\": [186, 85, 211],\r\n\t\"mediumpurple\": [147, 112, 219],\r\n\t\"mediumseagreen\": [60, 179, 113],\r\n\t\"mediumslateblue\": [123, 104, 238],\r\n\t\"mediumspringgreen\": [0, 250, 154],\r\n\t\"mediumturquoise\": [72, 209, 204],\r\n\t\"mediumvioletred\": [199, 21, 133],\r\n\t\"midnightblue\": [25, 25, 112],\r\n\t\"mintcream\": [245, 255, 250],\r\n\t\"mistyrose\": [255, 228, 225],\r\n\t\"moccasin\": [255, 228, 181],\r\n\t\"navajowhite\": [255, 222, 173],\r\n\t\"navy\": [0, 0, 128],\r\n\t\"oldlace\": [253, 245, 230],\r\n\t\"olive\": [128, 128, 0],\r\n\t\"olivedrab\": [107, 142, 35],\r\n\t\"orange\": [255, 165, 0],\r\n\t\"orangered\": [255, 69, 0],\r\n\t\"orchid\": [218, 112, 214],\r\n\t\"palegoldenrod\": [238, 232, 170],\r\n\t\"palegreen\": [152, 251, 152],\r\n\t\"paleturquoise\": [175, 238, 238],\r\n\t\"palevioletred\": [219, 112, 147],\r\n\t\"papayawhip\": [255, 239, 213],\r\n\t\"peachpuff\": [255, 218, 185],\r\n\t\"peru\": [205, 133, 63],\r\n\t\"pink\": [255, 192, 203],\r\n\t\"plum\": [221, 160, 221],\r\n\t\"powderblue\": [176, 224, 230],\r\n\t\"purple\": [128, 0, 128],\r\n\t\"rebeccapurple\": [102, 51, 153],\r\n\t\"red\": [255, 0, 0],\r\n\t\"rosybrown\": [188, 143, 143],\r\n\t\"royalblue\": [65, 105, 225],\r\n\t\"saddlebrown\": [139, 69, 19],\r\n\t\"salmon\": [250, 128, 114],\r\n\t\"sandybrown\": [244, 164, 96],\r\n\t\"seagreen\": [46, 139, 87],\r\n\t\"seashell\": [255, 245, 238],\r\n\t\"sienna\": [160, 82, 45],\r\n\t\"silver\": [192, 192, 192],\r\n\t\"skyblue\": [135, 206, 235],\r\n\t\"slateblue\": [106, 90, 205],\r\n\t\"slategray\": [112, 128, 144],\r\n\t\"slategrey\": [112, 128, 144],\r\n\t\"snow\": [255, 250, 250],\r\n\t\"springgreen\": [0, 255, 127],\r\n\t\"steelblue\": [70, 130, 180],\r\n\t\"tan\": [210, 180, 140],\r\n\t\"teal\": [0, 128, 128],\r\n\t\"thistle\": [216, 191, 216],\r\n\t\"tomato\": [255, 99, 71],\r\n\t\"turquoise\": [64, 224, 208],\r\n\t\"violet\": [238, 130, 238],\r\n\t\"wheat\": [245, 222, 179],\r\n\t\"white\": [255, 255, 255],\r\n\t\"whitesmoke\": [245, 245, 245],\r\n\t\"yellow\": [255, 255, 0],\r\n\t\"yellowgreen\": [154, 205, 50]\r\n};\r\n\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/color-name/index.js?");

/***/ }),

/***/ "./node_modules/cssesc/cssesc.js":
/*!***************************************!*\
  !*** ./node_modules/cssesc/cssesc.js ***!
  \***************************************/
/***/ ((module) => {

"use strict";
eval("/*! https://mths.be/cssesc v3.0.0 by @mathias */\n\n\nvar object = {};\nvar hasOwnProperty = object.hasOwnProperty;\nvar merge = function merge(options, defaults) {\n\tif (!options) {\n\t\treturn defaults;\n\t}\n\tvar result = {};\n\tfor (var key in defaults) {\n\t\t// `if (defaults.hasOwnProperty(key) { … }` is not needed here, since\n\t\t// only recognized option names are used.\n\t\tresult[key] = hasOwnProperty.call(options, key) ? options[key] : defaults[key];\n\t}\n\treturn result;\n};\n\nvar regexAnySingleEscape = /[ -,\\.\\/:-@\\[-\\^`\\{-~]/;\nvar regexSingleEscape = /[ -,\\.\\/:-@\\[\\]\\^`\\{-~]/;\nvar regexAlwaysEscape = /['\"\\\\]/;\nvar regexExcessiveSpaces = /(^|\\\\+)?(\\\\[A-F0-9]{1,6})\\x20(?![a-fA-F0-9\\x20])/g;\n\n// https://mathiasbynens.be/notes/css-escapes#css\nvar cssesc = function cssesc(string, options) {\n\toptions = merge(options, cssesc.options);\n\tif (options.quotes != 'single' && options.quotes != 'double') {\n\t\toptions.quotes = 'single';\n\t}\n\tvar quote = options.quotes == 'double' ? '\"' : '\\'';\n\tvar isIdentifier = options.isIdentifier;\n\n\tvar firstChar = string.charAt(0);\n\tvar output = '';\n\tvar counter = 0;\n\tvar length = string.length;\n\twhile (counter < length) {\n\t\tvar character = string.charAt(counter++);\n\t\tvar codePoint = character.charCodeAt();\n\t\tvar value = void 0;\n\t\t// If it’s not a printable ASCII character…\n\t\tif (codePoint < 0x20 || codePoint > 0x7E) {\n\t\t\tif (codePoint >= 0xD800 && codePoint <= 0xDBFF && counter < length) {\n\t\t\t\t// It’s a high surrogate, and there is a next character.\n\t\t\t\tvar extra = string.charCodeAt(counter++);\n\t\t\t\tif ((extra & 0xFC00) == 0xDC00) {\n\t\t\t\t\t// next character is low surrogate\n\t\t\t\t\tcodePoint = ((codePoint & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000;\n\t\t\t\t} else {\n\t\t\t\t\t// It’s an unmatched surrogate; only append this code unit, in case\n\t\t\t\t\t// the next code unit is the high surrogate of a surrogate pair.\n\t\t\t\t\tcounter--;\n\t\t\t\t}\n\t\t\t}\n\t\t\tvalue = '\\\\' + codePoint.toString(16).toUpperCase() + ' ';\n\t\t} else {\n\t\t\tif (options.escapeEverything) {\n\t\t\t\tif (regexAnySingleEscape.test(character)) {\n\t\t\t\t\tvalue = '\\\\' + character;\n\t\t\t\t} else {\n\t\t\t\t\tvalue = '\\\\' + codePoint.toString(16).toUpperCase() + ' ';\n\t\t\t\t}\n\t\t\t} else if (/[\\t\\n\\f\\r\\x0B]/.test(character)) {\n\t\t\t\tvalue = '\\\\' + codePoint.toString(16).toUpperCase() + ' ';\n\t\t\t} else if (character == '\\\\' || !isIdentifier && (character == '\"' && quote == character || character == '\\'' && quote == character) || isIdentifier && regexSingleEscape.test(character)) {\n\t\t\t\tvalue = '\\\\' + character;\n\t\t\t} else {\n\t\t\t\tvalue = character;\n\t\t\t}\n\t\t}\n\t\toutput += value;\n\t}\n\n\tif (isIdentifier) {\n\t\tif (/^-[-\\d]/.test(output)) {\n\t\t\toutput = '\\\\-' + output.slice(1);\n\t\t} else if (/\\d/.test(firstChar)) {\n\t\t\toutput = '\\\\3' + firstChar + ' ' + output.slice(1);\n\t\t}\n\t}\n\n\t// Remove spaces after `\\HEX` escapes that are not followed by a hex digit,\n\t// since they’re redundant. Note that this is only possible if the escape\n\t// sequence isn’t preceded by an odd number of backslashes.\n\toutput = output.replace(regexExcessiveSpaces, function ($0, $1, $2) {\n\t\tif ($1 && $1.length % 2) {\n\t\t\t// It’s not safe to remove the space, so don’t.\n\t\t\treturn $0;\n\t\t}\n\t\t// Strip the space.\n\t\treturn ($1 || '') + $2;\n\t});\n\n\tif (!isIdentifier && options.wrap) {\n\t\treturn quote + output + quote;\n\t}\n\treturn output;\n};\n\n// Expose default options (so they can be overridden globally).\ncssesc.options = {\n\t'escapeEverything': false,\n\t'isIdentifier': false,\n\t'quotes': 'single',\n\t'wrap': false\n};\n\ncssesc.version = '3.0.0';\n\nmodule.exports = cssesc;\n\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/cssesc/cssesc.js?");

/***/ }),

/***/ "./node_modules/defined/index.js":
/*!***************************************!*\
  !*** ./node_modules/defined/index.js ***!
  \***************************************/
/***/ ((module) => {

"use strict";
eval("\n\nmodule.exports = function defined() {\n\tfor (var i = 0; i < arguments.length; i++) {\n\t\tif (typeof arguments[i] !== 'undefined') {\n\t\t\treturn arguments[i];\n\t\t}\n\t}\n};\n\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/defined/index.js?");

/***/ }),

/***/ "./node_modules/detective/index.js":
/*!*****************************************!*\
  !*** ./node_modules/detective/index.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var acorn = __webpack_require__(/*! acorn-node */ \"./node_modules/acorn-node/index.js\");\nvar walk = __webpack_require__(/*! acorn-node/walk */ \"./node_modules/acorn-node/walk.js\");\nvar defined = __webpack_require__(/*! defined */ \"./node_modules/defined/index.js\");\n\nvar requireRe = /\\brequire\\b/;\n\nfunction parse (src, opts) {\n    if (!opts) opts = {};\n    var acornOpts = {\n        ranges: defined(opts.ranges, opts.range),\n        locations: defined(opts.locations, opts.loc),\n        allowReserved: defined(opts.allowReserved, true),\n        allowImportExportEverywhere: defined(opts.allowImportExportEverywhere, false)\n    };\n\n    // Use acorn-node's defaults for the rest.\n    if (opts.ecmaVersion != null) acornOpts.ecmaVersion = opts.ecmaVersion;\n    if (opts.sourceType != null) acornOpts.sourceType = opts.sourceType;\n    if (opts.allowHashBang != null) acornOpts.allowHashBang = opts.allowHashBang;\n    if (opts.allowReturnOutsideFunction != null) acornOpts.allowReturnOutsideFunction = opts.allowReturnOutsideFunction;\n\n    return acorn.parse(src, acornOpts);\n}\n\nvar exports = module.exports = function (src, opts) {\n    return exports.find(src, opts).strings;\n};\n\nexports.find = function (src, opts) {\n    if (!opts) opts = {};\n    \n    var word = opts.word === undefined ? 'require' : opts.word;\n    if (typeof src !== 'string') src = String(src);\n    \n    var isRequire = opts.isRequire || function (node) {\n        return node.callee.type === 'Identifier'\n            && node.callee.name === word\n        ;\n    };\n    \n    var modules = { strings : [], expressions : [] };\n    if (opts.nodes) modules.nodes = [];\n    \n    var wordRe = word === 'require' ? requireRe : RegExp('\\\\b' + word + '\\\\b');\n    if (!wordRe.test(src)) return modules;\n    \n    var ast = parse(src, opts.parse);\n    \n    function visit(node, st, c) {\n        var hasRequire = wordRe.test(src.slice(node.start, node.end));\n        if (!hasRequire) return;\n        walk.base[node.type](node, st, c);\n        if (node.type !== 'CallExpression') return;\n        if (isRequire(node)) {\n            if (node.arguments.length) {\n                var arg = node.arguments[0];\n                if (arg.type === 'Literal') {\n                    modules.strings.push(arg.value);\n                }\n                else if (arg.type === 'TemplateLiteral'\n                        && arg.quasis.length === 1\n                        && arg.expressions.length === 0) {\n\n                    modules.strings.push(arg.quasis[0].value.raw);\n                }\n                else {\n                    modules.expressions.push(src.slice(arg.start, arg.end));\n                }\n            }\n            if (opts.nodes) modules.nodes.push(node);\n        }\n    }\n    \n    walk.recursive(ast, null, {\n        Statement: visit,\n        Expression: visit\n    });\n    \n    return modules;\n};\n\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/detective/index.js?");

/***/ }),

/***/ "./node_modules/didyoumean/didYouMean-1.2.1.js":
/*!*****************************************************!*\
  !*** ./node_modules/didyoumean/didYouMean-1.2.1.js ***!
  \*****************************************************/
/***/ ((module) => {

eval("/*\n\ndidYouMean.js - A simple JavaScript matching engine\n===================================================\n\n[Available on GitHub](https://github.com/dcporter/didyoumean.js).\n\nA super-simple, highly optimized JS library for matching human-quality input to a list of potential\nmatches. You can use it to suggest a misspelled command-line utility option to a user, or to offer\nlinks to nearby valid URLs on your 404 page. (The examples below are taken from a personal project,\nmy [HTML5 business card](http://dcporter.aws.af.cm/me), which uses didYouMean.js to suggest correct\nURLs from misspelled ones, such as [dcporter.aws.af.cm/me/instagarm](http://dcporter.aws.af.cm/me/instagarm).)\nUses the [Levenshtein distance algorithm](https://en.wikipedia.org/wiki/Levenshtein_distance).\n\ndidYouMean.js works in the browser as well as in node.js. To install it for use in node:\n\n```\nnpm install didyoumean\n```\n\n\nExamples\n--------\n\nMatching against a list of strings:\n```\nvar input = 'insargrm'\nvar list = ['facebook', 'twitter', 'instagram', 'linkedin'];\nconsole.log(didYouMean(input, list));\n> 'instagram'\n// The method matches 'insargrm' to 'instagram'.\n\ninput = 'google plus';\nconsole.log(didYouMean(input, list));\n> null\n// The method was unable to find 'google plus' in the list of options.\n```\n\nMatching against a list of objects:\n```\nvar input = 'insargrm';\nvar list = [ { id: 'facebook' }, { id: 'twitter' }, { id: 'instagram' }, { id: 'linkedin' } ];\nvar key = 'id';\nconsole.log(didYouMean(input, list, key));\n> 'instagram'\n// The method returns the matching value.\n\ndidYouMean.returnWinningObject = true;\nconsole.log(didYouMean(input, list, key));\n> { id: 'instagram' }\n// The method returns the matching object.\n```\n\n\ndidYouMean(str, list, [key])\n----------------------------\n\n- str: The string input to match.\n- list: An array of strings or objects to match against.\n- key (OPTIONAL): If your list array contains objects, you must specify the key which contains the string\n  to match against.\n\nReturns: the closest matching string, or null if no strings exceed the threshold.\n\n\nOptions\n-------\n\nOptions are set on the didYouMean function object. You may change them at any time.\n\n### threshold\n\n  By default, the method will only return strings whose edit distance is less than 40% (0.4x) of their length.\n  For example, if a ten-letter string is five edits away from its nearest match, the method will return null.\n\n  You can control this by setting the \"threshold\" value on the didYouMean function. For example, to set the\n  edit distance threshold to 50% of the input string's length:\n\n  ```\n  didYouMean.threshold = 0.5;\n  ```\n\n  To return the nearest match no matter the threshold, set this value to null.\n\n### thresholdAbsolute\n\n  This option behaves the same as threshold, but instead takes an integer number of edit steps. For example,\n  if thresholdAbsolute is set to 20 (the default), then the method will only return strings whose edit distance\n  is less than 20. Both options apply.\n\n### caseSensitive\n\n  By default, the method will perform case-insensitive comparisons. If you wish to force case sensitivity, set\n  the \"caseSensitive\" value to true:\n\n  ```\n  didYouMean.caseSensitive = true;\n  ```\n\n### nullResultValue\n\n  By default, the method will return null if there is no sufficiently close match. You can change this value here.\n\n### returnWinningObject\n\n  By default, the method will return the winning string value (if any). If your list contains objects rather\n  than strings, you may set returnWinningObject to true.\n  \n  ```\n  didYouMean.returnWinningObject = true;\n  ```\n  \n  This option has no effect on lists of strings.\n\n### returnFirstMatch\n  \n  By default, the method will search all values and return the closest match. If you're simply looking for a \"good-\n  enough\" match, you can set your thresholds appropriately and set returnFirstMatch to true to substantially speed\n  things up.\n\n\nLicense\n-------\n\ndidYouMean copyright (c) 2013-2014 Dave Porter.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License\n[here](http://www.apache.org/licenses/LICENSE-2.0).\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n\n*/\n(function() {\n  \"use strict\";\n\n  // The didYouMean method.\n  function didYouMean(str, list, key) {\n    if (!str) return null;\n\n    // If we're running a case-insensitive search, smallify str.\n    if (!didYouMean.caseSensitive) { str = str.toLowerCase(); }\n\n    // Calculate the initial value (the threshold) if present.\n    var thresholdRelative = didYouMean.threshold === null ? null : didYouMean.threshold * str.length,\n        thresholdAbsolute = didYouMean.thresholdAbsolute,\n        winningVal;\n    if (thresholdRelative !== null && thresholdAbsolute !== null) winningVal = Math.min(thresholdRelative, thresholdAbsolute);\n    else if (thresholdRelative !== null) winningVal = thresholdRelative;\n    else if (thresholdAbsolute !== null) winningVal = thresholdAbsolute;\n    else winningVal = null;\n\n    // Get the edit distance to each option. If the closest one is less than 40% (by default) of str's length,\n    // then return it.\n    var winner, candidate, testCandidate, val,\n        i, len = list.length;\n    for (i = 0; i < len; i++) {\n      // Get item.\n      candidate = list[i];\n      // If there's a key, get the candidate value out of the object.\n      if (key) { candidate = candidate[key]; }\n      // Gatekeep.\n      if (!candidate) { continue; }\n      // If we're running a case-insensitive search, smallify the candidate.\n      if (!didYouMean.caseSensitive) { testCandidate = candidate.toLowerCase(); }\n      else { testCandidate = candidate; }\n      // Get and compare edit distance.\n      val = getEditDistance(str, testCandidate, winningVal);\n      // If this value is smaller than our current winning value, OR if we have no winning val yet (i.e. the\n      // threshold option is set to null, meaning the caller wants a match back no matter how bad it is), then\n      // this is our new winner.\n      if (winningVal === null || val < winningVal) {\n        winningVal = val;\n        // Set the winner to either the value or its object, depending on the returnWinningObject option.\n        if (key && didYouMean.returnWinningObject) winner = list[i];\n        else winner = candidate;\n        // If we're returning the first match, return it now.\n        if (didYouMean.returnFirstMatch) return winner;\n      }\n    }\n\n    // If we have a winner, return it.\n    return winner || didYouMean.nullResultValue;\n  }\n\n  // Set default options.\n  didYouMean.threshold = 0.4;\n  didYouMean.thresholdAbsolute = 20;\n  didYouMean.caseSensitive = false;\n  didYouMean.nullResultValue = null;\n  didYouMean.returnWinningObject = null;\n  didYouMean.returnFirstMatch = false;\n\n  // Expose.\n  // In node...\n  if ( true && module.exports) {\n    module.exports = didYouMean;\n  }\n  // Otherwise...\n  else {\n    window.didYouMean = didYouMean;\n  }\n\n  var MAX_INT = Math.pow(2,32) - 1; // We could probably go higher than this, but for practical reasons let's not.\n  function getEditDistance(a, b, max) {\n    // Handle null or undefined max.\n    max = max || max === 0 ? max : MAX_INT;\n\n    var lena = a.length;\n    var lenb = b.length;\n\n    // Fast path - no A or B.\n    if (lena === 0) return Math.min(max + 1, lenb);\n    if (lenb === 0) return Math.min(max + 1, lena);\n\n    // Fast path - length diff larger than max.\n    if (Math.abs(lena - lenb) > max) return max + 1;\n\n    // Slow path.\n    var matrix = [],\n        i, j, colMin, minJ, maxJ;\n\n    // Set up the first row ([0, 1, 2, 3, etc]).\n    for (i = 0; i <= lenb; i++) { matrix[i] = [i]; }\n\n    // Set up the first column (same).\n    for (j = 0; j <= lena; j++) { matrix[0][j] = j; }\n\n    // Loop over the rest of the columns.\n    for (i = 1; i <= lenb; i++) {\n      colMin = MAX_INT;\n      minJ = 1;\n      if (i > max) minJ = i - max;\n      maxJ = lenb + 1;\n      if (maxJ > max + i) maxJ = max + i;\n      // Loop over the rest of the rows.\n      for (j = 1; j <= lena; j++) {\n        // If j is out of bounds, just put a large value in the slot.\n        if (j < minJ || j > maxJ) {\n          matrix[i][j] = max + 1;\n        }\n\n        // Otherwise do the normal Levenshtein thing.\n        else {\n          // If the characters are the same, there's no change in edit distance.\n          if (b.charAt(i - 1) === a.charAt(j - 1)) {\n            matrix[i][j] = matrix[i - 1][j - 1];\n          }\n          // Otherwise, see if we're substituting, inserting or deleting.\n          else {\n            matrix[i][j] = Math.min(matrix[i - 1][j - 1] + 1, // Substitute\n                                    Math.min(matrix[i][j - 1] + 1, // Insert\n                                    matrix[i - 1][j] + 1)); // Delete\n          }\n        }\n\n        // Either way, update colMin.\n        if (matrix[i][j] < colMin) colMin = matrix[i][j];\n      }\n\n      // If this column's minimum is greater than the allowed maximum, there's no point\n      // in going on with life.\n      if (colMin > max) return max + 1;\n    }\n    // If we made it this far without running into the max, then return the final matrix value.\n    return matrix[lenb][lena];\n  }\n\n})();\n\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/didyoumean/didYouMean-1.2.1.js?");

/***/ }),

/***/ "./node_modules/dlv/dist/dlv.umd.js":
/*!******************************************!*\
  !*** ./node_modules/dlv/dist/dlv.umd.js ***!
  \******************************************/
/***/ (function(module) {

eval("!function(t,n){ true?module.exports=function(t,n,e,i,o){for(n=n.split?n.split(\".\"):n,i=0;i<n.length;i++)t=t?t[n[i]]:o;return t===o?e:t}:0}(this);\n//# sourceMappingURL=dlv.umd.js.map\n\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/dlv/dist/dlv.umd.js?");

/***/ }),

/***/ "./node_modules/events/events.js":
/*!***************************************!*\
  !*** ./node_modules/events/events.js ***!
  \***************************************/
/***/ ((module) => {

"use strict";
eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\nvar R = typeof Reflect === 'object' ? Reflect : null\nvar ReflectApply = R && typeof R.apply === 'function'\n  ? R.apply\n  : function ReflectApply(target, receiver, args) {\n    return Function.prototype.apply.call(target, receiver, args);\n  }\n\nvar ReflectOwnKeys\nif (R && typeof R.ownKeys === 'function') {\n  ReflectOwnKeys = R.ownKeys\n} else if (Object.getOwnPropertySymbols) {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target)\n      .concat(Object.getOwnPropertySymbols(target));\n  };\n} else {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target);\n  };\n}\n\nfunction ProcessEmitWarning(warning) {\n  if (console && console.warn) console.warn(warning);\n}\n\nvar NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {\n  return value !== value;\n}\n\nfunction EventEmitter() {\n  EventEmitter.init.call(this);\n}\nmodule.exports = EventEmitter;\nmodule.exports.once = once;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._eventsCount = 0;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nvar defaultMaxListeners = 10;\n\nfunction checkListener(listener) {\n  if (typeof listener !== 'function') {\n    throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n  }\n}\n\nObject.defineProperty(EventEmitter, 'defaultMaxListeners', {\n  enumerable: true,\n  get: function() {\n    return defaultMaxListeners;\n  },\n  set: function(arg) {\n    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {\n      throw new RangeError('The value of \"defaultMaxListeners\" is out of range. It must be a non-negative number. Received ' + arg + '.');\n    }\n    defaultMaxListeners = arg;\n  }\n});\n\nEventEmitter.init = function() {\n\n  if (this._events === undefined ||\n      this._events === Object.getPrototypeOf(this)._events) {\n    this._events = Object.create(null);\n    this._eventsCount = 0;\n  }\n\n  this._maxListeners = this._maxListeners || undefined;\n};\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {\n    throw new RangeError('The value of \"n\" is out of range. It must be a non-negative number. Received ' + n + '.');\n  }\n  this._maxListeners = n;\n  return this;\n};\n\nfunction _getMaxListeners(that) {\n  if (that._maxListeners === undefined)\n    return EventEmitter.defaultMaxListeners;\n  return that._maxListeners;\n}\n\nEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n  return _getMaxListeners(this);\n};\n\nEventEmitter.prototype.emit = function emit(type) {\n  var args = [];\n  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);\n  var doError = (type === 'error');\n\n  var events = this._events;\n  if (events !== undefined)\n    doError = (doError && events.error === undefined);\n  else if (!doError)\n    return false;\n\n  // If there is no 'error' event listener then throw.\n  if (doError) {\n    var er;\n    if (args.length > 0)\n      er = args[0];\n    if (er instanceof Error) {\n      // Note: The comments on the `throw` lines are intentional, they show\n      // up in Node's output if this results in an unhandled exception.\n      throw er; // Unhandled 'error' event\n    }\n    // At least give some kind of context to the user\n    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));\n    err.context = er;\n    throw err; // Unhandled 'error' event\n  }\n\n  var handler = events[type];\n\n  if (handler === undefined)\n    return false;\n\n  if (typeof handler === 'function') {\n    ReflectApply(handler, this, args);\n  } else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      ReflectApply(listeners[i], this, args);\n  }\n\n  return true;\n};\n\nfunction _addListener(target, type, listener, prepend) {\n  var m;\n  var events;\n  var existing;\n\n  checkListener(listener);\n\n  events = target._events;\n  if (events === undefined) {\n    events = target._events = Object.create(null);\n    target._eventsCount = 0;\n  } else {\n    // To avoid recursion in the case that type === \"newListener\"! Before\n    // adding it to the listeners, first emit \"newListener\".\n    if (events.newListener !== undefined) {\n      target.emit('newListener', type,\n                  listener.listener ? listener.listener : listener);\n\n      // Re-assign `events` because a newListener handler could have caused the\n      // this._events to be assigned to a new object\n      events = target._events;\n    }\n    existing = events[type];\n  }\n\n  if (existing === undefined) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    existing = events[type] = listener;\n    ++target._eventsCount;\n  } else {\n    if (typeof existing === 'function') {\n      // Adding the second element, need to change to array.\n      existing = events[type] =\n        prepend ? [listener, existing] : [existing, listener];\n      // If we've already got an array, just append.\n    } else if (prepend) {\n      existing.unshift(listener);\n    } else {\n      existing.push(listener);\n    }\n\n    // Check for listener leak\n    m = _getMaxListeners(target);\n    if (m > 0 && existing.length > m && !existing.warned) {\n      existing.warned = true;\n      // No error code for this since it is a Warning\n      // eslint-disable-next-line no-restricted-syntax\n      var w = new Error('Possible EventEmitter memory leak detected. ' +\n                          existing.length + ' ' + String(type) + ' listeners ' +\n                          'added. Use emitter.setMaxListeners() to ' +\n                          'increase limit');\n      w.name = 'MaxListenersExceededWarning';\n      w.emitter = target;\n      w.type = type;\n      w.count = existing.length;\n      ProcessEmitWarning(w);\n    }\n  }\n\n  return target;\n}\n\nEventEmitter.prototype.addListener = function addListener(type, listener) {\n  return _addListener(this, type, listener, false);\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.prependListener =\n    function prependListener(type, listener) {\n      return _addListener(this, type, listener, true);\n    };\n\nfunction onceWrapper() {\n  if (!this.fired) {\n    this.target.removeListener(this.type, this.wrapFn);\n    this.fired = true;\n    if (arguments.length === 0)\n      return this.listener.call(this.target);\n    return this.listener.apply(this.target, arguments);\n  }\n}\n\nfunction _onceWrap(target, type, listener) {\n  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };\n  var wrapped = onceWrapper.bind(state);\n  wrapped.listener = listener;\n  state.wrapFn = wrapped;\n  return wrapped;\n}\n\nEventEmitter.prototype.once = function once(type, listener) {\n  checkListener(listener);\n  this.on(type, _onceWrap(this, type, listener));\n  return this;\n};\n\nEventEmitter.prototype.prependOnceListener =\n    function prependOnceListener(type, listener) {\n      checkListener(listener);\n      this.prependListener(type, _onceWrap(this, type, listener));\n      return this;\n    };\n\n// Emits a 'removeListener' event if and only if the listener was removed.\nEventEmitter.prototype.removeListener =\n    function removeListener(type, listener) {\n      var list, events, position, i, originalListener;\n\n      checkListener(listener);\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      list = events[type];\n      if (list === undefined)\n        return this;\n\n      if (list === listener || list.listener === listener) {\n        if (--this._eventsCount === 0)\n          this._events = Object.create(null);\n        else {\n          delete events[type];\n          if (events.removeListener)\n            this.emit('removeListener', type, list.listener || listener);\n        }\n      } else if (typeof list !== 'function') {\n        position = -1;\n\n        for (i = list.length - 1; i >= 0; i--) {\n          if (list[i] === listener || list[i].listener === listener) {\n            originalListener = list[i].listener;\n            position = i;\n            break;\n          }\n        }\n\n        if (position < 0)\n          return this;\n\n        if (position === 0)\n          list.shift();\n        else {\n          spliceOne(list, position);\n        }\n\n        if (list.length === 1)\n          events[type] = list[0];\n\n        if (events.removeListener !== undefined)\n          this.emit('removeListener', type, originalListener || listener);\n      }\n\n      return this;\n    };\n\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n\nEventEmitter.prototype.removeAllListeners =\n    function removeAllListeners(type) {\n      var listeners, events, i;\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      // not listening for removeListener, no need to emit\n      if (events.removeListener === undefined) {\n        if (arguments.length === 0) {\n          this._events = Object.create(null);\n          this._eventsCount = 0;\n        } else if (events[type] !== undefined) {\n          if (--this._eventsCount === 0)\n            this._events = Object.create(null);\n          else\n            delete events[type];\n        }\n        return this;\n      }\n\n      // emit removeListener for all listeners on all events\n      if (arguments.length === 0) {\n        var keys = Object.keys(events);\n        var key;\n        for (i = 0; i < keys.length; ++i) {\n          key = keys[i];\n          if (key === 'removeListener') continue;\n          this.removeAllListeners(key);\n        }\n        this.removeAllListeners('removeListener');\n        this._events = Object.create(null);\n        this._eventsCount = 0;\n        return this;\n      }\n\n      listeners = events[type];\n\n      if (typeof listeners === 'function') {\n        this.removeListener(type, listeners);\n      } else if (listeners !== undefined) {\n        // LIFO order\n        for (i = listeners.length - 1; i >= 0; i--) {\n          this.removeListener(type, listeners[i]);\n        }\n      }\n\n      return this;\n    };\n\nfunction _listeners(target, type, unwrap) {\n  var events = target._events;\n\n  if (events === undefined)\n    return [];\n\n  var evlistener = events[type];\n  if (evlistener === undefined)\n    return [];\n\n  if (typeof evlistener === 'function')\n    return unwrap ? [evlistener.listener || evlistener] : [evlistener];\n\n  return unwrap ?\n    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);\n}\n\nEventEmitter.prototype.listeners = function listeners(type) {\n  return _listeners(this, type, true);\n};\n\nEventEmitter.prototype.rawListeners = function rawListeners(type) {\n  return _listeners(this, type, false);\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  if (typeof emitter.listenerCount === 'function') {\n    return emitter.listenerCount(type);\n  } else {\n    return listenerCount.call(emitter, type);\n  }\n};\n\nEventEmitter.prototype.listenerCount = listenerCount;\nfunction listenerCount(type) {\n  var events = this._events;\n\n  if (events !== undefined) {\n    var evlistener = events[type];\n\n    if (typeof evlistener === 'function') {\n      return 1;\n    } else if (evlistener !== undefined) {\n      return evlistener.length;\n    }\n  }\n\n  return 0;\n}\n\nEventEmitter.prototype.eventNames = function eventNames() {\n  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];\n};\n\nfunction arrayClone(arr, n) {\n  var copy = new Array(n);\n  for (var i = 0; i < n; ++i)\n    copy[i] = arr[i];\n  return copy;\n}\n\nfunction spliceOne(list, index) {\n  for (; index + 1 < list.length; index++)\n    list[index] = list[index + 1];\n  list.pop();\n}\n\nfunction unwrapListeners(arr) {\n  var ret = new Array(arr.length);\n  for (var i = 0; i < ret.length; ++i) {\n    ret[i] = arr[i].listener || arr[i];\n  }\n  return ret;\n}\n\nfunction once(emitter, name) {\n  return new Promise(function (resolve, reject) {\n    function errorListener(err) {\n      emitter.removeListener(name, resolver);\n      reject(err);\n    }\n\n    function resolver() {\n      if (typeof emitter.removeListener === 'function') {\n        emitter.removeListener('error', errorListener);\n      }\n      resolve([].slice.call(arguments));\n    };\n\n    eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });\n    if (name !== 'error') {\n      addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });\n    }\n  });\n}\n\nfunction addErrorHandlerIfEventEmitter(emitter, handler, flags) {\n  if (typeof emitter.on === 'function') {\n    eventTargetAgnosticAddListener(emitter, 'error', handler, flags);\n  }\n}\n\nfunction eventTargetAgnosticAddListener(emitter, name, listener, flags) {\n  if (typeof emitter.on === 'function') {\n    if (flags.once) {\n      emitter.once(name, listener);\n    } else {\n      emitter.on(name, listener);\n    }\n  } else if (typeof emitter.addEventListener === 'function') {\n    // EventTarget does not have `error` event semantics like Node\n    // EventEmitters, we do not listen for `error` events here.\n    emitter.addEventListener(name, function wrapListener(arg) {\n      // IE does not have builtin `{ once: true }` support so we\n      // have to do it manually.\n      if (flags.once) {\n        emitter.removeEventListener(name, wrapListener);\n      }\n      listener(arg);\n    });\n  } else {\n    throw new TypeError('The \"emitter\" argument must be of type EventEmitter. Received type ' + typeof emitter);\n  }\n}\n\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/events/events.js?");

/***/ }),

/***/ "./node_modules/fast-glob/node_modules/glob-parent/index.js":
/*!******************************************************************!*\
  !*** ./node_modules/fast-glob/node_modules/glob-parent/index.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar isGlob = __webpack_require__(/*! is-glob */ \"./node_modules/is-glob/index.js\");\nvar pathPosixDirname = Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'path'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }());\nvar isWin32 = Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'os'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }())() === 'win32';\n\nvar slash = '/';\nvar backslash = /\\\\/g;\nvar enclosure = /[\\{\\[].*[\\}\\]]$/;\nvar globby = /(^|[^\\\\])([\\{\\[]|\\([^\\)]+$)/;\nvar escaped = /\\\\([\\!\\*\\?\\|\\[\\]\\(\\)\\{\\}])/g;\n\n/**\n * @param {string} str\n * @param {Object} opts\n * @param {boolean} [opts.flipBackslashes=true]\n * @returns {string}\n */\nmodule.exports = function globParent(str, opts) {\n  var options = Object.assign({ flipBackslashes: true }, opts);\n\n  // flip windows path separators\n  if (options.flipBackslashes && isWin32 && str.indexOf(slash) < 0) {\n    str = str.replace(backslash, slash);\n  }\n\n  // special case for strings ending in enclosure containing path separator\n  if (enclosure.test(str)) {\n    str += slash;\n  }\n\n  // preserves full path in case of trailing path separator\n  str += 'a';\n\n  // remove path parts that are globby\n  do {\n    str = pathPosixDirname(str);\n  } while (isGlob(str) || globby.test(str));\n\n  // remove escape chars and return result\n  return str.replace(escaped, '$1');\n};\n\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/fast-glob/node_modules/glob-parent/index.js?");

/***/ }),

/***/ "./node_modules/fast-glob/out/index.js":
/*!*********************************************!*\
  !*** ./node_modules/fast-glob/out/index.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\r\nconst taskManager = __webpack_require__(/*! ./managers/tasks */ \"./node_modules/fast-glob/out/managers/tasks.js\");\r\nconst patternManager = __webpack_require__(/*! ./managers/patterns */ \"./node_modules/fast-glob/out/managers/patterns.js\");\r\nconst async_1 = __webpack_require__(/*! ./providers/async */ \"./node_modules/fast-glob/out/providers/async.js\");\r\nconst stream_1 = __webpack_require__(/*! ./providers/stream */ \"./node_modules/fast-glob/out/providers/stream.js\");\r\nconst sync_1 = __webpack_require__(/*! ./providers/sync */ \"./node_modules/fast-glob/out/providers/sync.js\");\r\nconst settings_1 = __webpack_require__(/*! ./settings */ \"./node_modules/fast-glob/out/settings.js\");\r\nconst utils = __webpack_require__(/*! ./utils */ \"./node_modules/fast-glob/out/utils/index.js\");\r\nasync function FastGlob(source, options) {\r\n    assertPatternsInput(source);\r\n    const works = getWorks(source, async_1.default, options);\r\n    const result = await Promise.all(works);\r\n    return utils.array.flatten(result);\r\n}\r\n// https://github.com/typescript-eslint/typescript-eslint/issues/60\r\n// eslint-disable-next-line no-redeclare\r\n(function (FastGlob) {\r\n    function sync(source, options) {\r\n        assertPatternsInput(source);\r\n        const works = getWorks(source, sync_1.default, options);\r\n        return utils.array.flatten(works);\r\n    }\r\n    FastGlob.sync = sync;\r\n    function stream(source, options) {\r\n        assertPatternsInput(source);\r\n        const works = getWorks(source, stream_1.default, options);\r\n        /**\r\n         * The stream returned by the provider cannot work with an asynchronous iterator.\r\n         * To support asynchronous iterators, regardless of the number of tasks, we always multiplex streams.\r\n         * This affects performance (+25%). I don't see best solution right now.\r\n         */\r\n        return utils.stream.merge(works);\r\n    }\r\n    FastGlob.stream = stream;\r\n    function generateTasks(source, options) {\r\n        assertPatternsInput(source);\r\n        const patterns = patternManager.transform([].concat(source));\r\n        const settings = new settings_1.default(options);\r\n        return taskManager.generate(patterns, settings);\r\n    }\r\n    FastGlob.generateTasks = generateTasks;\r\n    function isDynamicPattern(source, options) {\r\n        assertPatternsInput(source);\r\n        const settings = new settings_1.default(options);\r\n        return utils.pattern.isDynamicPattern(source, settings);\r\n    }\r\n    FastGlob.isDynamicPattern = isDynamicPattern;\r\n    function escapePath(source) {\r\n        assertPatternsInput(source);\r\n        return utils.path.escape(source);\r\n    }\r\n    FastGlob.escapePath = escapePath;\r\n})(FastGlob || (FastGlob = {}));\r\nfunction getWorks(source, _Provider, options) {\r\n    const patterns = patternManager.transform([].concat(source));\r\n    const settings = new settings_1.default(options);\r\n    const tasks = taskManager.generate(patterns, settings);\r\n    const provider = new _Provider(settings);\r\n    return tasks.map(provider.read, provider);\r\n}\r\nfunction assertPatternsInput(input) {\r\n    const source = [].concat(input);\r\n    const isValidSource = source.every((item) => utils.string.isString(item) && !utils.string.isEmpty(item));\r\n    if (!isValidSource) {\r\n        throw new TypeError('Patterns must be a string (non empty) or an array of strings');\r\n    }\r\n}\r\nmodule.exports = FastGlob;\r\n\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/fast-glob/out/index.js?");

/***/ }),

/***/ "./node_modules/fast-glob/out/managers/patterns.js":
/*!*********************************************************!*\
  !*** ./node_modules/fast-glob/out/managers/patterns.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.removeDuplicateSlashes = exports.transform = void 0;\r\n/**\r\n * Matches a sequence of two or more consecutive slashes, excluding the first two slashes at the beginning of the string.\r\n * The latter is due to the presence of the device path at the beginning of the UNC path.\r\n * @todo rewrite to negative lookbehind with the next major release.\r\n */\r\nconst DOUBLE_SLASH_RE = /(?!^)\\/{2,}/g;\r\nfunction transform(patterns) {\r\n    return patterns.map((pattern) => removeDuplicateSlashes(pattern));\r\n}\r\nexports.transform = transform;\r\n/**\r\n * This package only works with forward slashes as a path separator.\r\n * Because of this, we cannot use the standard `path.normalize` method, because on Windows platform it will use of backslashes.\r\n */\r\nfunction removeDuplicateSlashes(pattern) {\r\n    return pattern.replace(DOUBLE_SLASH_RE, '/');\r\n}\r\nexports.removeDuplicateSlashes = removeDuplicateSlashes;\r\n\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/fast-glob/out/managers/patterns.js?");

/***/ }),

/***/ "./node_modules/fast-glob/out/managers/tasks.js":
/*!******************************************************!*\
  !*** ./node_modules/fast-glob/out/managers/tasks.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.convertPatternGroupToTask = exports.convertPatternGroupsToTasks = exports.groupPatternsByBaseDirectory = exports.getNegativePatternsAsPositive = exports.getPositivePatterns = exports.convertPatternsToTasks = exports.generate = void 0;\r\nconst utils = __webpack_require__(/*! ../utils */ \"./node_modules/fast-glob/out/utils/index.js\");\r\nfunction generate(patterns, settings) {\r\n    const positivePatterns = getPositivePatterns(patterns);\r\n    const negativePatterns = getNegativePatternsAsPositive(patterns, settings.ignore);\r\n    const staticPatterns = positivePatterns.filter((pattern) => utils.pattern.isStaticPattern(pattern, settings));\r\n    const dynamicPatterns = positivePatterns.filter((pattern) => utils.pattern.isDynamicPattern(pattern, settings));\r\n    const staticTasks = convertPatternsToTasks(staticPatterns, negativePatterns, /* dynamic */ false);\r\n    const dynamicTasks = convertPatternsToTasks(dynamicPatterns, negativePatterns, /* dynamic */ true);\r\n    return staticTasks.concat(dynamicTasks);\r\n}\r\nexports.generate = generate;\r\n/**\r\n * Returns tasks grouped by basic pattern directories.\r\n *\r\n * Patterns that can be found inside (`./`) and outside (`../`) the current directory are handled separately.\r\n * This is necessary because directory traversal starts at the base directory and goes deeper.\r\n */\r\nfunction convertPatternsToTasks(positive, negative, dynamic) {\r\n    const tasks = [];\r\n    const patternsOutsideCurrentDirectory = utils.pattern.getPatternsOutsideCurrentDirectory(positive);\r\n    const patternsInsideCurrentDirectory = utils.pattern.getPatternsInsideCurrentDirectory(positive);\r\n    const outsideCurrentDirectoryGroup = groupPatternsByBaseDirectory(patternsOutsideCurrentDirectory);\r\n    const insideCurrentDirectoryGroup = groupPatternsByBaseDirectory(patternsInsideCurrentDirectory);\r\n    tasks.push(...convertPatternGroupsToTasks(outsideCurrentDirectoryGroup, negative, dynamic));\r\n    /*\r\n     * For the sake of reducing future accesses to the file system, we merge all tasks within the current directory\r\n     * into a global task, if at least one pattern refers to the root (`.`). In this case, the global task covers the rest.\r\n     */\r\n    if ('.' in insideCurrentDirectoryGroup) {\r\n        tasks.push(convertPatternGroupToTask('.', patternsInsideCurrentDirectory, negative, dynamic));\r\n    }\r\n    else {\r\n        tasks.push(...convertPatternGroupsToTasks(insideCurrentDirectoryGroup, negative, dynamic));\r\n    }\r\n    return tasks;\r\n}\r\nexports.convertPatternsToTasks = convertPatternsToTasks;\r\nfunction getPositivePatterns(patterns) {\r\n    return utils.pattern.getPositivePatterns(patterns);\r\n}\r\nexports.getPositivePatterns = getPositivePatterns;\r\nfunction getNegativePatternsAsPositive(patterns, ignore) {\r\n    const negative = utils.pattern.getNegativePatterns(patterns).concat(ignore);\r\n    const positive = negative.map(utils.pattern.convertToPositivePattern);\r\n    return positive;\r\n}\r\nexports.getNegativePatternsAsPositive = getNegativePatternsAsPositive;\r\nfunction groupPatternsByBaseDirectory(patterns) {\r\n    const group = {};\r\n    return patterns.reduce((collection, pattern) => {\r\n        const base = utils.pattern.getBaseDirectory(pattern);\r\n        if (base in collection) {\r\n            collection[base].push(pattern);\r\n        }\r\n        else {\r\n            collection[base] = [pattern];\r\n        }\r\n        return collection;\r\n    }, group);\r\n}\r\nexports.groupPatternsByBaseDirectory = groupPatternsByBaseDirectory;\r\nfunction convertPatternGroupsToTasks(positive, negative, dynamic) {\r\n    return Object.keys(positive).map((base) => {\r\n        return convertPatternGroupToTask(base, positive[base], negative, dynamic);\r\n    });\r\n}\r\nexports.convertPatternGroupsToTasks = convertPatternGroupsToTasks;\r\nfunction convertPatternGroupToTask(base, positive, negative, dynamic) {\r\n    return {\r\n        dynamic,\r\n        positive,\r\n        negative,\r\n        base,\r\n        patterns: [].concat(positive, negative.map(utils.pattern.convertToNegativePattern))\r\n    };\r\n}\r\nexports.convertPatternGroupToTask = convertPatternGroupToTask;\r\n\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/fast-glob/out/managers/tasks.js?");

/***/ }),

/***/ "./node_modules/fast-glob/out/providers/async.js":
/*!*******************************************************!*\
  !*** ./node_modules/fast-glob/out/providers/async.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nconst async_1 = __webpack_require__(/*! ../readers/async */ \"./node_modules/fast-glob/out/readers/async.js\");\r\nconst provider_1 = __webpack_require__(/*! ./provider */ \"./node_modules/fast-glob/out/providers/provider.js\");\r\nclass ProviderAsync extends provider_1.default {\r\n    constructor() {\r\n        super(...arguments);\r\n        this._reader = new async_1.default(this._settings);\r\n    }\r\n    async read(task) {\r\n        const root = this._getRootDirectory(task);\r\n        const options = this._getReaderOptions(task);\r\n        const entries = await this.api(root, task, options);\r\n        return entries.map((entry) => options.transform(entry));\r\n    }\r\n    api(root, task, options) {\r\n        if (task.dynamic) {\r\n            return this._reader.dynamic(root, options);\r\n        }\r\n        return this._reader.static(task.patterns, options);\r\n    }\r\n}\r\nexports[\"default\"] = ProviderAsync;\r\n\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/fast-glob/out/providers/async.js?");

/***/ }),

/***/ "./node_modules/fast-glob/out/providers/filters/deep.js":
/*!**************************************************************!*\
  !*** ./node_modules/fast-glob/out/providers/filters/deep.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nconst utils = __webpack_require__(/*! ../../utils */ \"./node_modules/fast-glob/out/utils/index.js\");\r\nconst partial_1 = __webpack_require__(/*! ../matchers/partial */ \"./node_modules/fast-glob/out/providers/matchers/partial.js\");\r\nclass DeepFilter {\r\n    constructor(_settings, _micromatchOptions) {\r\n        this._settings = _settings;\r\n        this._micromatchOptions = _micromatchOptions;\r\n    }\r\n    getFilter(basePath, positive, negative) {\r\n        const matcher = this._getMatcher(positive);\r\n        const negativeRe = this._getNegativePatternsRe(negative);\r\n        return (entry) => this._filter(basePath, entry, matcher, negativeRe);\r\n    }\r\n    _getMatcher(patterns) {\r\n        return new partial_1.default(patterns, this._settings, this._micromatchOptions);\r\n    }\r\n    _getNegativePatternsRe(patterns) {\r\n        const affectDepthOfReadingPatterns = patterns.filter(utils.pattern.isAffectDepthOfReadingPattern);\r\n        return utils.pattern.convertPatternsToRe(affectDepthOfReadingPatterns, this._micromatchOptions);\r\n    }\r\n    _filter(basePath, entry, matcher, negativeRe) {\r\n        if (this._isSkippedByDeep(basePath, entry.path)) {\r\n            return false;\r\n        }\r\n        if (this._isSkippedSymbolicLink(entry)) {\r\n            return false;\r\n        }\r\n        const filepath = utils.path.removeLeadingDotSegment(entry.path);\r\n        if (this._isSkippedByPositivePatterns(filepath, matcher)) {\r\n            return false;\r\n        }\r\n        return this._isSkippedByNegativePatterns(filepath, negativeRe);\r\n    }\r\n    _isSkippedByDeep(basePath, entryPath) {\r\n        /**\r\n         * Avoid unnecessary depth calculations when it doesn't matter.\r\n         */\r\n        if (this._settings.deep === Infinity) {\r\n            return false;\r\n        }\r\n        return this._getEntryLevel(basePath, entryPath) >= this._settings.deep;\r\n    }\r\n    _getEntryLevel(basePath, entryPath) {\r\n        const entryPathDepth = entryPath.split('/').length;\r\n        if (basePath === '') {\r\n            return entryPathDepth;\r\n        }\r\n        const basePathDepth = basePath.split('/').length;\r\n        return entryPathDepth - basePathDepth;\r\n    }\r\n    _isSkippedSymbolicLink(entry) {\r\n        return !this._settings.followSymbolicLinks && entry.dirent.isSymbolicLink();\r\n    }\r\n    _isSkippedByPositivePatterns(entryPath, matcher) {\r\n        return !this._settings.baseNameMatch && !matcher.match(entryPath);\r\n    }\r\n    _isSkippedByNegativePatterns(entryPath, patternsRe) {\r\n        return !utils.pattern.matchAny(entryPath, patternsRe);\r\n    }\r\n}\r\nexports[\"default\"] = DeepFilter;\r\n\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/fast-glob/out/providers/filters/deep.js?");

/***/ }),

/***/ "./node_modules/fast-glob/out/providers/filters/entry.js":
/*!***************************************************************!*\
  !*** ./node_modules/fast-glob/out/providers/filters/entry.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nconst utils = __webpack_require__(/*! ../../utils */ \"./node_modules/fast-glob/out/utils/index.js\");\r\nclass EntryFilter {\r\n    constructor(_settings, _micromatchOptions) {\r\n        this._settings = _settings;\r\n        this._micromatchOptions = _micromatchOptions;\r\n        this.index = new Map();\r\n    }\r\n    getFilter(positive, negative) {\r\n        const positiveRe = utils.pattern.convertPatternsToRe(positive, this._micromatchOptions);\r\n        const negativeRe = utils.pattern.convertPatternsToRe(negative, this._micromatchOptions);\r\n        return (entry) => this._filter(entry, positiveRe, negativeRe);\r\n    }\r\n    _filter(entry, positiveRe, negativeRe) {\r\n        if (this._settings.unique && this._isDuplicateEntry(entry)) {\r\n            return false;\r\n        }\r\n        if (this._onlyFileFilter(entry) || this._onlyDirectoryFilter(entry)) {\r\n            return false;\r\n        }\r\n        if (this._isSkippedByAbsoluteNegativePatterns(entry.path, negativeRe)) {\r\n            return false;\r\n        }\r\n        const filepath = this._settings.baseNameMatch ? entry.name : entry.path;\r\n        const isDirectory = entry.dirent.isDirectory();\r\n        const isMatched = this._isMatchToPatterns(filepath, positiveRe, isDirectory) && !this._isMatchToPatterns(entry.path, negativeRe, isDirectory);\r\n        if (this._settings.unique && isMatched) {\r\n            this._createIndexRecord(entry);\r\n        }\r\n        return isMatched;\r\n    }\r\n    _isDuplicateEntry(entry) {\r\n        return this.index.has(entry.path);\r\n    }\r\n    _createIndexRecord(entry) {\r\n        this.index.set(entry.path, undefined);\r\n    }\r\n    _onlyFileFilter(entry) {\r\n        return this._settings.onlyFiles && !entry.dirent.isFile();\r\n    }\r\n    _onlyDirectoryFilter(entry) {\r\n        return this._settings.onlyDirectories && !entry.dirent.isDirectory();\r\n    }\r\n    _isSkippedByAbsoluteNegativePatterns(entryPath, patternsRe) {\r\n        if (!this._settings.absolute) {\r\n            return false;\r\n        }\r\n        const fullpath = utils.path.makeAbsolute(this._settings.cwd, entryPath);\r\n        return utils.pattern.matchAny(fullpath, patternsRe);\r\n    }\r\n    _isMatchToPatterns(entryPath, patternsRe, isDirectory) {\r\n        const filepath = utils.path.removeLeadingDotSegment(entryPath);\r\n        // Trying to match files and directories by patterns.\r\n        const isMatched = utils.pattern.matchAny(filepath, patternsRe);\r\n        // A pattern with a trailling slash can be used for directory matching.\r\n        // To apply such pattern, we need to add a tralling slash to the path.\r\n        if (!isMatched && isDirectory) {\r\n            return utils.pattern.matchAny(filepath + '/', patternsRe);\r\n        }\r\n        return isMatched;\r\n    }\r\n}\r\nexports[\"default\"] = EntryFilter;\r\n\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/fast-glob/out/providers/filters/entry.js?");

/***/ }),

/***/ "./node_modules/fast-glob/out/providers/filters/error.js":
/*!***************************************************************!*\
  !*** ./node_modules/fast-glob/out/providers/filters/error.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nconst utils = __webpack_require__(/*! ../../utils */ \"./node_modules/fast-glob/out/utils/index.js\");\r\nclass ErrorFilter {\r\n    constructor(_settings) {\r\n        this._settings = _settings;\r\n    }\r\n    getFilter() {\r\n        return (error) => this._isNonFatalError(error);\r\n    }\r\n    _isNonFatalError(error) {\r\n        return utils.errno.isEnoentCodeError(error) || this._settings.suppressErrors;\r\n    }\r\n}\r\nexports[\"default\"] = ErrorFilter;\r\n\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/fast-glob/out/providers/filters/error.js?");

/***/ }),

/***/ "./node_modules/fast-glob/out/providers/matchers/matcher.js":
/*!******************************************************************!*\
  !*** ./node_modules/fast-glob/out/providers/matchers/matcher.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nconst utils = __webpack_require__(/*! ../../utils */ \"./node_modules/fast-glob/out/utils/index.js\");\r\nclass Matcher {\r\n    constructor(_patterns, _settings, _micromatchOptions) {\r\n        this._patterns = _patterns;\r\n        this._settings = _settings;\r\n        this._micromatchOptions = _micromatchOptions;\r\n        this._storage = [];\r\n        this._fillStorage();\r\n    }\r\n    _fillStorage() {\r\n        /**\r\n         * The original pattern may include `{,*,**,a/*}`, which will lead to problems with matching (unresolved level).\r\n         * So, before expand patterns with brace expansion into separated patterns.\r\n         */\r\n        const patterns = utils.pattern.expandPatternsWithBraceExpansion(this._patterns);\r\n        for (const pattern of patterns) {\r\n            const segments = this._getPatternSegments(pattern);\r\n            const sections = this._splitSegmentsIntoSections(segments);\r\n            this._storage.push({\r\n                complete: sections.length <= 1,\r\n                pattern,\r\n                segments,\r\n                sections\r\n            });\r\n        }\r\n    }\r\n    _getPatternSegments(pattern) {\r\n        const parts = utils.pattern.getPatternParts(pattern, this._micromatchOptions);\r\n        return parts.map((part) => {\r\n            const dynamic = utils.pattern.isDynamicPattern(part, this._settings);\r\n            if (!dynamic) {\r\n                return {\r\n                    dynamic: false,\r\n                    pattern: part\r\n                };\r\n            }\r\n            return {\r\n                dynamic: true,\r\n                pattern: part,\r\n                patternRe: utils.pattern.makeRe(part, this._micromatchOptions)\r\n            };\r\n        });\r\n    }\r\n    _splitSegmentsIntoSections(segments) {\r\n        return utils.array.splitWhen(segments, (segment) => segment.dynamic && utils.pattern.hasGlobStar(segment.pattern));\r\n    }\r\n}\r\nexports[\"default\"] = Matcher;\r\n\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/fast-glob/out/providers/matchers/matcher.js?");

/***/ }),

/***/ "./node_modules/fast-glob/out/providers/matchers/partial.js":
/*!******************************************************************!*\
  !*** ./node_modules/fast-glob/out/providers/matchers/partial.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nconst matcher_1 = __webpack_require__(/*! ./matcher */ \"./node_modules/fast-glob/out/providers/matchers/matcher.js\");\r\nclass PartialMatcher extends matcher_1.default {\r\n    match(filepath) {\r\n        const parts = filepath.split('/');\r\n        const levels = parts.length;\r\n        const patterns = this._storage.filter((info) => !info.complete || info.segments.length > levels);\r\n        for (const pattern of patterns) {\r\n            const section = pattern.sections[0];\r\n            /**\r\n             * In this case, the pattern has a globstar and we must read all directories unconditionally,\r\n             * but only if the level has reached the end of the first group.\r\n             *\r\n             * fixtures/{a,b}/**\r\n             *  ^ true/false  ^ always true\r\n            */\r\n            if (!pattern.complete && levels > section.length) {\r\n                return true;\r\n            }\r\n            const match = parts.every((part, index) => {\r\n                const segment = pattern.segments[index];\r\n                if (segment.dynamic && segment.patternRe.test(part)) {\r\n                    return true;\r\n                }\r\n                if (!segment.dynamic && segment.pattern === part) {\r\n                    return true;\r\n                }\r\n                return false;\r\n            });\r\n            if (match) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n}\r\nexports[\"default\"] = PartialMatcher;\r\n\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/fast-glob/out/providers/matchers/partial.js?");

/***/ }),

/***/ "./node_modules/fast-glob/out/providers/provider.js":
/*!**********************************************************!*\
  !*** ./node_modules/fast-glob/out/providers/provider.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nconst path = __webpack_require__(Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'path'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));\r\nconst deep_1 = __webpack_require__(/*! ./filters/deep */ \"./node_modules/fast-glob/out/providers/filters/deep.js\");\r\nconst entry_1 = __webpack_require__(/*! ./filters/entry */ \"./node_modules/fast-glob/out/providers/filters/entry.js\");\r\nconst error_1 = __webpack_require__(/*! ./filters/error */ \"./node_modules/fast-glob/out/providers/filters/error.js\");\r\nconst entry_2 = __webpack_require__(/*! ./transformers/entry */ \"./node_modules/fast-glob/out/providers/transformers/entry.js\");\r\nclass Provider {\r\n    constructor(_settings) {\r\n        this._settings = _settings;\r\n        this.errorFilter = new error_1.default(this._settings);\r\n        this.entryFilter = new entry_1.default(this._settings, this._getMicromatchOptions());\r\n        this.deepFilter = new deep_1.default(this._settings, this._getMicromatchOptions());\r\n        this.entryTransformer = new entry_2.default(this._settings);\r\n    }\r\n    _getRootDirectory(task) {\r\n        return path.resolve(this._settings.cwd, task.base);\r\n    }\r\n    _getReaderOptions(task) {\r\n        const basePath = task.base === '.' ? '' : task.base;\r\n        return {\r\n            basePath,\r\n            pathSegmentSeparator: '/',\r\n            concurrency: this._settings.concurrency,\r\n            deepFilter: this.deepFilter.getFilter(basePath, task.positive, task.negative),\r\n            entryFilter: this.entryFilter.getFilter(task.positive, task.negative),\r\n            errorFilter: this.errorFilter.getFilter(),\r\n            followSymbolicLinks: this._settings.followSymbolicLinks,\r\n            fs: this._settings.fs,\r\n            stats: this._settings.stats,\r\n            throwErrorOnBrokenSymbolicLink: this._settings.throwErrorOnBrokenSymbolicLink,\r\n            transform: this.entryTransformer.getTransformer()\r\n        };\r\n    }\r\n    _getMicromatchOptions() {\r\n        return {\r\n            dot: this._settings.dot,\r\n            matchBase: this._settings.baseNameMatch,\r\n            nobrace: !this._settings.braceExpansion,\r\n            nocase: !this._settings.caseSensitiveMatch,\r\n            noext: !this._settings.extglob,\r\n            noglobstar: !this._settings.globstar,\r\n            posix: true,\r\n            strictSlashes: false\r\n        };\r\n    }\r\n}\r\nexports[\"default\"] = Provider;\r\n\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/fast-glob/out/providers/provider.js?");

/***/ }),

/***/ "./node_modules/fast-glob/out/providers/stream.js":
/*!********************************************************!*\
  !*** ./node_modules/fast-glob/out/providers/stream.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nconst stream_1 = __webpack_require__(Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'stream'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));\r\nconst stream_2 = __webpack_require__(/*! ../readers/stream */ \"./node_modules/fast-glob/out/readers/stream.js\");\r\nconst provider_1 = __webpack_require__(/*! ./provider */ \"./node_modules/fast-glob/out/providers/provider.js\");\r\nclass ProviderStream extends provider_1.default {\r\n    constructor() {\r\n        super(...arguments);\r\n        this._reader = new stream_2.default(this._settings);\r\n    }\r\n    read(task) {\r\n        const root = this._getRootDirectory(task);\r\n        const options = this._getReaderOptions(task);\r\n        const source = this.api(root, task, options);\r\n        const destination = new stream_1.Readable({ objectMode: true, read: () => { } });\r\n        source\r\n            .once('error', (error) => destination.emit('error', error))\r\n            .on('data', (entry) => destination.emit('data', options.transform(entry)))\r\n            .once('end', () => destination.emit('end'));\r\n        destination\r\n            .once('close', () => source.destroy());\r\n        return destination;\r\n    }\r\n    api(root, task, options) {\r\n        if (task.dynamic) {\r\n            return this._reader.dynamic(root, options);\r\n        }\r\n        return this._reader.static(task.patterns, options);\r\n    }\r\n}\r\nexports[\"default\"] = ProviderStream;\r\n\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/fast-glob/out/providers/stream.js?");

/***/ }),

/***/ "./node_modules/fast-glob/out/providers/sync.js":
/*!******************************************************!*\
  !*** ./node_modules/fast-glob/out/providers/sync.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nconst sync_1 = __webpack_require__(/*! ../readers/sync */ \"./node_modules/fast-glob/out/readers/sync.js\");\r\nconst provider_1 = __webpack_require__(/*! ./provider */ \"./node_modules/fast-glob/out/providers/provider.js\");\r\nclass ProviderSync extends provider_1.default {\r\n    constructor() {\r\n        super(...arguments);\r\n        this._reader = new sync_1.default(this._settings);\r\n    }\r\n    read(task) {\r\n        const root = this._getRootDirectory(task);\r\n        const options = this._getReaderOptions(task);\r\n        const entries = this.api(root, task, options);\r\n        return entries.map(options.transform);\r\n    }\r\n    api(root, task, options) {\r\n        if (task.dynamic) {\r\n            return this._reader.dynamic(root, options);\r\n        }\r\n        return this._reader.static(task.patterns, options);\r\n    }\r\n}\r\nexports[\"default\"] = ProviderSync;\r\n\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/fast-glob/out/providers/sync.js?");

/***/ }),

/***/ "./node_modules/fast-glob/out/providers/transformers/entry.js":
/*!********************************************************************!*\
  !*** ./node_modules/fast-glob/out/providers/transformers/entry.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nconst utils = __webpack_require__(/*! ../../utils */ \"./node_modules/fast-glob/out/utils/index.js\");\r\nclass EntryTransformer {\r\n    constructor(_settings) {\r\n        this._settings = _settings;\r\n    }\r\n    getTransformer() {\r\n        return (entry) => this._transform(entry);\r\n    }\r\n    _transform(entry) {\r\n        let filepath = entry.path;\r\n        if (this._settings.absolute) {\r\n            filepath = utils.path.makeAbsolute(this._settings.cwd, filepath);\r\n            filepath = utils.path.unixify(filepath);\r\n        }\r\n        if (this._settings.markDirectories && entry.dirent.isDirectory()) {\r\n            filepath += '/';\r\n        }\r\n        if (!this._settings.objectMode) {\r\n            return filepath;\r\n        }\r\n        return Object.assign(Object.assign({}, entry), { path: filepath });\r\n    }\r\n}\r\nexports[\"default\"] = EntryTransformer;\r\n\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/fast-glob/out/providers/transformers/entry.js?");

/***/ }),

/***/ "./node_modules/fast-glob/out/readers/async.js":
/*!*****************************************************!*\
  !*** ./node_modules/fast-glob/out/readers/async.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nconst fsWalk = __webpack_require__(/*! @nodelib/fs.walk */ \"./node_modules/@nodelib/fs.walk/out/index.js\");\r\nconst reader_1 = __webpack_require__(/*! ./reader */ \"./node_modules/fast-glob/out/readers/reader.js\");\r\nconst stream_1 = __webpack_require__(/*! ./stream */ \"./node_modules/fast-glob/out/readers/stream.js\");\r\nclass ReaderAsync extends reader_1.default {\r\n    constructor() {\r\n        super(...arguments);\r\n        this._walkAsync = fsWalk.walk;\r\n        this._readerStream = new stream_1.default(this._settings);\r\n    }\r\n    dynamic(root, options) {\r\n        return new Promise((resolve, reject) => {\r\n            this._walkAsync(root, options, (error, entries) => {\r\n                if (error === null) {\r\n                    resolve(entries);\r\n                }\r\n                else {\r\n                    reject(error);\r\n                }\r\n            });\r\n        });\r\n    }\r\n    async static(patterns, options) {\r\n        const entries = [];\r\n        const stream = this._readerStream.static(patterns, options);\r\n        // After #235, replace it with an asynchronous iterator.\r\n        return new Promise((resolve, reject) => {\r\n            stream.once('error', reject);\r\n            stream.on('data', (entry) => entries.push(entry));\r\n            stream.once('end', () => resolve(entries));\r\n        });\r\n    }\r\n}\r\nexports[\"default\"] = ReaderAsync;\r\n\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/fast-glob/out/readers/async.js?");

/***/ }),

/***/ "./node_modules/fast-glob/out/readers/reader.js":
/*!******************************************************!*\
  !*** ./node_modules/fast-glob/out/readers/reader.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nconst path = __webpack_require__(Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'path'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));\r\nconst fsStat = __webpack_require__(/*! @nodelib/fs.stat */ \"./node_modules/@nodelib/fs.stat/out/index.js\");\r\nconst utils = __webpack_require__(/*! ../utils */ \"./node_modules/fast-glob/out/utils/index.js\");\r\nclass Reader {\r\n    constructor(_settings) {\r\n        this._settings = _settings;\r\n        this._fsStatSettings = new fsStat.Settings({\r\n            followSymbolicLink: this._settings.followSymbolicLinks,\r\n            fs: this._settings.fs,\r\n            throwErrorOnBrokenSymbolicLink: this._settings.followSymbolicLinks\r\n        });\r\n    }\r\n    _getFullEntryPath(filepath) {\r\n        return path.resolve(this._settings.cwd, filepath);\r\n    }\r\n    _makeEntry(stats, pattern) {\r\n        const entry = {\r\n            name: pattern,\r\n            path: pattern,\r\n            dirent: utils.fs.createDirentFromStats(pattern, stats)\r\n        };\r\n        if (this._settings.stats) {\r\n            entry.stats = stats;\r\n        }\r\n        return entry;\r\n    }\r\n    _isFatalError(error) {\r\n        return !utils.errno.isEnoentCodeError(error) && !this._settings.suppressErrors;\r\n    }\r\n}\r\nexports[\"default\"] = Reader;\r\n\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/fast-glob/out/readers/reader.js?");

/***/ }),

/***/ "./node_modules/fast-glob/out/readers/stream.js":
/*!******************************************************!*\
  !*** ./node_modules/fast-glob/out/readers/stream.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nconst stream_1 = __webpack_require__(Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'stream'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));\r\nconst fsStat = __webpack_require__(/*! @nodelib/fs.stat */ \"./node_modules/@nodelib/fs.stat/out/index.js\");\r\nconst fsWalk = __webpack_require__(/*! @nodelib/fs.walk */ \"./node_modules/@nodelib/fs.walk/out/index.js\");\r\nconst reader_1 = __webpack_require__(/*! ./reader */ \"./node_modules/fast-glob/out/readers/reader.js\");\r\nclass ReaderStream extends reader_1.default {\r\n    constructor() {\r\n        super(...arguments);\r\n        this._walkStream = fsWalk.walkStream;\r\n        this._stat = fsStat.stat;\r\n    }\r\n    dynamic(root, options) {\r\n        return this._walkStream(root, options);\r\n    }\r\n    static(patterns, options) {\r\n        const filepaths = patterns.map(this._getFullEntryPath, this);\r\n        const stream = new stream_1.PassThrough({ objectMode: true });\r\n        stream._write = (index, _enc, done) => {\r\n            return this._getEntry(filepaths[index], patterns[index], options)\r\n                .then((entry) => {\r\n                if (entry !== null && options.entryFilter(entry)) {\r\n                    stream.push(entry);\r\n                }\r\n                if (index === filepaths.length - 1) {\r\n                    stream.end();\r\n                }\r\n                done();\r\n            })\r\n                .catch(done);\r\n        };\r\n        for (let i = 0; i < filepaths.length; i++) {\r\n            stream.write(i);\r\n        }\r\n        return stream;\r\n    }\r\n    _getEntry(filepath, pattern, options) {\r\n        return this._getStat(filepath)\r\n            .then((stats) => this._makeEntry(stats, pattern))\r\n            .catch((error) => {\r\n            if (options.errorFilter(error)) {\r\n                return null;\r\n            }\r\n            throw error;\r\n        });\r\n    }\r\n    _getStat(filepath) {\r\n        return new Promise((resolve, reject) => {\r\n            this._stat(filepath, this._fsStatSettings, (error, stats) => {\r\n                return error === null ? resolve(stats) : reject(error);\r\n            });\r\n        });\r\n    }\r\n}\r\nexports[\"default\"] = ReaderStream;\r\n\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/fast-glob/out/readers/stream.js?");

/***/ }),

/***/ "./node_modules/fast-glob/out/readers/sync.js":
/*!****************************************************!*\
  !*** ./node_modules/fast-glob/out/readers/sync.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nconst fsStat = __webpack_require__(/*! @nodelib/fs.stat */ \"./node_modules/@nodelib/fs.stat/out/index.js\");\r\nconst fsWalk = __webpack_require__(/*! @nodelib/fs.walk */ \"./node_modules/@nodelib/fs.walk/out/index.js\");\r\nconst reader_1 = __webpack_require__(/*! ./reader */ \"./node_modules/fast-glob/out/readers/reader.js\");\r\nclass ReaderSync extends reader_1.default {\r\n    constructor() {\r\n        super(...arguments);\r\n        this._walkSync = fsWalk.walkSync;\r\n        this._statSync = fsStat.statSync;\r\n    }\r\n    dynamic(root, options) {\r\n        return this._walkSync(root, options);\r\n    }\r\n    static(patterns, options) {\r\n        const entries = [];\r\n        for (const pattern of patterns) {\r\n            const filepath = this._getFullEntryPath(pattern);\r\n            const entry = this._getEntry(filepath, pattern, options);\r\n            if (entry === null || !options.entryFilter(entry)) {\r\n                continue;\r\n            }\r\n            entries.push(entry);\r\n        }\r\n        return entries;\r\n    }\r\n    _getEntry(filepath, pattern, options) {\r\n        try {\r\n            const stats = this._getStat(filepath);\r\n            return this._makeEntry(stats, pattern);\r\n        }\r\n        catch (error) {\r\n            if (options.errorFilter(error)) {\r\n                return null;\r\n            }\r\n            throw error;\r\n        }\r\n    }\r\n    _getStat(filepath) {\r\n        return this._statSync(filepath, this._fsStatSettings);\r\n    }\r\n}\r\nexports[\"default\"] = ReaderSync;\r\n\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/fast-glob/out/readers/sync.js?");

/***/ }),

/***/ "./node_modules/fast-glob/out/settings.js":
/*!************************************************!*\
  !*** ./node_modules/fast-glob/out/settings.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.DEFAULT_FILE_SYSTEM_ADAPTER = void 0;\r\nconst fs = __webpack_require__(Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'fs'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));\r\nconst os = __webpack_require__(Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'os'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));\r\n/**\r\n * The `os.cpus` method can return zero. We expect the number of cores to be greater than zero.\r\n * https://github.com/nodejs/node/blob/7faeddf23a98c53896f8b574a6e66589e8fb1eb8/lib/os.js#L106-L107\r\n */\r\nconst CPU_COUNT = Math.max(os.cpus().length, 1);\r\nexports.DEFAULT_FILE_SYSTEM_ADAPTER = {\r\n    lstat: fs.lstat,\r\n    lstatSync: fs.lstatSync,\r\n    stat: fs.stat,\r\n    statSync: fs.statSync,\r\n    readdir: fs.readdir,\r\n    readdirSync: fs.readdirSync\r\n};\r\nclass Settings {\r\n    constructor(_options = {}) {\r\n        this._options = _options;\r\n        this.absolute = this._getValue(this._options.absolute, false);\r\n        this.baseNameMatch = this._getValue(this._options.baseNameMatch, false);\r\n        this.braceExpansion = this._getValue(this._options.braceExpansion, true);\r\n        this.caseSensitiveMatch = this._getValue(this._options.caseSensitiveMatch, true);\r\n        this.concurrency = this._getValue(this._options.concurrency, CPU_COUNT);\r\n        this.cwd = this._getValue(this._options.cwd, process.cwd());\r\n        this.deep = this._getValue(this._options.deep, Infinity);\r\n        this.dot = this._getValue(this._options.dot, false);\r\n        this.extglob = this._getValue(this._options.extglob, true);\r\n        this.followSymbolicLinks = this._getValue(this._options.followSymbolicLinks, true);\r\n        this.fs = this._getFileSystemMethods(this._options.fs);\r\n        this.globstar = this._getValue(this._options.globstar, true);\r\n        this.ignore = this._getValue(this._options.ignore, []);\r\n        this.markDirectories = this._getValue(this._options.markDirectories, false);\r\n        this.objectMode = this._getValue(this._options.objectMode, false);\r\n        this.onlyDirectories = this._getValue(this._options.onlyDirectories, false);\r\n        this.onlyFiles = this._getValue(this._options.onlyFiles, true);\r\n        this.stats = this._getValue(this._options.stats, false);\r\n        this.suppressErrors = this._getValue(this._options.suppressErrors, false);\r\n        this.throwErrorOnBrokenSymbolicLink = this._getValue(this._options.throwErrorOnBrokenSymbolicLink, false);\r\n        this.unique = this._getValue(this._options.unique, true);\r\n        if (this.onlyDirectories) {\r\n            this.onlyFiles = false;\r\n        }\r\n        if (this.stats) {\r\n            this.objectMode = true;\r\n        }\r\n    }\r\n    _getValue(option, value) {\r\n        return option === undefined ? value : option;\r\n    }\r\n    _getFileSystemMethods(methods = {}) {\r\n        return Object.assign(Object.assign({}, exports.DEFAULT_FILE_SYSTEM_ADAPTER), methods);\r\n    }\r\n}\r\nexports[\"default\"] = Settings;\r\n\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/fast-glob/out/settings.js?");

/***/ }),

/***/ "./node_modules/fast-glob/out/utils/array.js":
/*!***************************************************!*\
  !*** ./node_modules/fast-glob/out/utils/array.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.splitWhen = exports.flatten = void 0;\r\nfunction flatten(items) {\r\n    return items.reduce((collection, item) => [].concat(collection, item), []);\r\n}\r\nexports.flatten = flatten;\r\nfunction splitWhen(items, predicate) {\r\n    const result = [[]];\r\n    let groupIndex = 0;\r\n    for (const item of items) {\r\n        if (predicate(item)) {\r\n            groupIndex++;\r\n            result[groupIndex] = [];\r\n        }\r\n        else {\r\n            result[groupIndex].push(item);\r\n        }\r\n    }\r\n    return result;\r\n}\r\nexports.splitWhen = splitWhen;\r\n\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/fast-glob/out/utils/array.js?");

/***/ }),

/***/ "./node_modules/fast-glob/out/utils/errno.js":
/*!***************************************************!*\
  !*** ./node_modules/fast-glob/out/utils/errno.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.isEnoentCodeError = void 0;\r\nfunction isEnoentCodeError(error) {\r\n    return error.code === 'ENOENT';\r\n}\r\nexports.isEnoentCodeError = isEnoentCodeError;\r\n\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/fast-glob/out/utils/errno.js?");

/***/ }),

/***/ "./node_modules/fast-glob/out/utils/fs.js":
/*!************************************************!*\
  !*** ./node_modules/fast-glob/out/utils/fs.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.createDirentFromStats = void 0;\r\nclass DirentFromStats {\r\n    constructor(name, stats) {\r\n        this.name = name;\r\n        this.isBlockDevice = stats.isBlockDevice.bind(stats);\r\n        this.isCharacterDevice = stats.isCharacterDevice.bind(stats);\r\n        this.isDirectory = stats.isDirectory.bind(stats);\r\n        this.isFIFO = stats.isFIFO.bind(stats);\r\n        this.isFile = stats.isFile.bind(stats);\r\n        this.isSocket = stats.isSocket.bind(stats);\r\n        this.isSymbolicLink = stats.isSymbolicLink.bind(stats);\r\n    }\r\n}\r\nfunction createDirentFromStats(name, stats) {\r\n    return new DirentFromStats(name, stats);\r\n}\r\nexports.createDirentFromStats = createDirentFromStats;\r\n\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/fast-glob/out/utils/fs.js?");

/***/ }),

/***/ "./node_modules/fast-glob/out/utils/index.js":
/*!***************************************************!*\
  !*** ./node_modules/fast-glob/out/utils/index.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.string = exports.stream = exports.pattern = exports.path = exports.fs = exports.errno = exports.array = void 0;\r\nconst array = __webpack_require__(/*! ./array */ \"./node_modules/fast-glob/out/utils/array.js\");\r\nexports.array = array;\r\nconst errno = __webpack_require__(/*! ./errno */ \"./node_modules/fast-glob/out/utils/errno.js\");\r\nexports.errno = errno;\r\nconst fs = __webpack_require__(/*! ./fs */ \"./node_modules/fast-glob/out/utils/fs.js\");\r\nexports.fs = fs;\r\nconst path = __webpack_require__(/*! ./path */ \"./node_modules/fast-glob/out/utils/path.js\");\r\nexports.path = path;\r\nconst pattern = __webpack_require__(/*! ./pattern */ \"./node_modules/fast-glob/out/utils/pattern.js\");\r\nexports.pattern = pattern;\r\nconst stream = __webpack_require__(/*! ./stream */ \"./node_modules/fast-glob/out/utils/stream.js\");\r\nexports.stream = stream;\r\nconst string = __webpack_require__(/*! ./string */ \"./node_modules/fast-glob/out/utils/string.js\");\r\nexports.string = string;\r\n\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/fast-glob/out/utils/index.js?");

/***/ }),

/***/ "./node_modules/fast-glob/out/utils/path.js":
/*!**************************************************!*\
  !*** ./node_modules/fast-glob/out/utils/path.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.removeLeadingDotSegment = exports.escape = exports.makeAbsolute = exports.unixify = void 0;\r\nconst path = __webpack_require__(Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'path'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));\r\nconst LEADING_DOT_SEGMENT_CHARACTERS_COUNT = 2; // ./ or .\\\\\r\nconst UNESCAPED_GLOB_SYMBOLS_RE = /(\\\\?)([()*?[\\]{|}]|^!|[!+@](?=\\())/g;\r\n/**\r\n * Designed to work only with simple paths: `dir\\\\file`.\r\n */\r\nfunction unixify(filepath) {\r\n    return filepath.replace(/\\\\/g, '/');\r\n}\r\nexports.unixify = unixify;\r\nfunction makeAbsolute(cwd, filepath) {\r\n    return path.resolve(cwd, filepath);\r\n}\r\nexports.makeAbsolute = makeAbsolute;\r\nfunction escape(pattern) {\r\n    return pattern.replace(UNESCAPED_GLOB_SYMBOLS_RE, '\\\\$2');\r\n}\r\nexports.escape = escape;\r\nfunction removeLeadingDotSegment(entry) {\r\n    // We do not use `startsWith` because this is 10x slower than current implementation for some cases.\r\n    // eslint-disable-next-line @typescript-eslint/prefer-string-starts-ends-with\r\n    if (entry.charAt(0) === '.') {\r\n        const secondCharactery = entry.charAt(1);\r\n        if (secondCharactery === '/' || secondCharactery === '\\\\') {\r\n            return entry.slice(LEADING_DOT_SEGMENT_CHARACTERS_COUNT);\r\n        }\r\n    }\r\n    return entry;\r\n}\r\nexports.removeLeadingDotSegment = removeLeadingDotSegment;\r\n\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/fast-glob/out/utils/path.js?");

/***/ }),

/***/ "./node_modules/fast-glob/out/utils/pattern.js":
/*!*****************************************************!*\
  !*** ./node_modules/fast-glob/out/utils/pattern.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.matchAny = exports.convertPatternsToRe = exports.makeRe = exports.getPatternParts = exports.expandBraceExpansion = exports.expandPatternsWithBraceExpansion = exports.isAffectDepthOfReadingPattern = exports.endsWithSlashGlobStar = exports.hasGlobStar = exports.getBaseDirectory = exports.isPatternRelatedToParentDirectory = exports.getPatternsOutsideCurrentDirectory = exports.getPatternsInsideCurrentDirectory = exports.getPositivePatterns = exports.getNegativePatterns = exports.isPositivePattern = exports.isNegativePattern = exports.convertToNegativePattern = exports.convertToPositivePattern = exports.isDynamicPattern = exports.isStaticPattern = void 0;\r\nconst path = __webpack_require__(Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'path'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));\r\nconst globParent = __webpack_require__(/*! glob-parent */ \"./node_modules/fast-glob/node_modules/glob-parent/index.js\");\r\nconst micromatch = __webpack_require__(/*! micromatch */ \"./node_modules/micromatch/index.js\");\r\nconst GLOBSTAR = '**';\r\nconst ESCAPE_SYMBOL = '\\\\';\r\nconst COMMON_GLOB_SYMBOLS_RE = /[*?]|^!/;\r\nconst REGEX_CHARACTER_CLASS_SYMBOLS_RE = /\\[[^[]*]/;\r\nconst REGEX_GROUP_SYMBOLS_RE = /(?:^|[^!*+?@])\\([^(]*\\|[^|]*\\)/;\r\nconst GLOB_EXTENSION_SYMBOLS_RE = /[!*+?@]\\([^(]*\\)/;\r\nconst BRACE_EXPANSION_SEPARATORS_RE = /,|\\.\\./;\r\nfunction isStaticPattern(pattern, options = {}) {\r\n    return !isDynamicPattern(pattern, options);\r\n}\r\nexports.isStaticPattern = isStaticPattern;\r\nfunction isDynamicPattern(pattern, options = {}) {\r\n    /**\r\n     * A special case with an empty string is necessary for matching patterns that start with a forward slash.\r\n     * An empty string cannot be a dynamic pattern.\r\n     * For example, the pattern `/lib/*` will be spread into parts: '', 'lib', '*'.\r\n     */\r\n    if (pattern === '') {\r\n        return false;\r\n    }\r\n    /**\r\n     * When the `caseSensitiveMatch` option is disabled, all patterns must be marked as dynamic, because we cannot check\r\n     * filepath directly (without read directory).\r\n     */\r\n    if (options.caseSensitiveMatch === false || pattern.includes(ESCAPE_SYMBOL)) {\r\n        return true;\r\n    }\r\n    if (COMMON_GLOB_SYMBOLS_RE.test(pattern) || REGEX_CHARACTER_CLASS_SYMBOLS_RE.test(pattern) || REGEX_GROUP_SYMBOLS_RE.test(pattern)) {\r\n        return true;\r\n    }\r\n    if (options.extglob !== false && GLOB_EXTENSION_SYMBOLS_RE.test(pattern)) {\r\n        return true;\r\n    }\r\n    if (options.braceExpansion !== false && hasBraceExpansion(pattern)) {\r\n        return true;\r\n    }\r\n    return false;\r\n}\r\nexports.isDynamicPattern = isDynamicPattern;\r\nfunction hasBraceExpansion(pattern) {\r\n    const openingBraceIndex = pattern.indexOf('{');\r\n    if (openingBraceIndex === -1) {\r\n        return false;\r\n    }\r\n    const closingBraceIndex = pattern.indexOf('}', openingBraceIndex + 1);\r\n    if (closingBraceIndex === -1) {\r\n        return false;\r\n    }\r\n    const braceContent = pattern.slice(openingBraceIndex, closingBraceIndex);\r\n    return BRACE_EXPANSION_SEPARATORS_RE.test(braceContent);\r\n}\r\nfunction convertToPositivePattern(pattern) {\r\n    return isNegativePattern(pattern) ? pattern.slice(1) : pattern;\r\n}\r\nexports.convertToPositivePattern = convertToPositivePattern;\r\nfunction convertToNegativePattern(pattern) {\r\n    return '!' + pattern;\r\n}\r\nexports.convertToNegativePattern = convertToNegativePattern;\r\nfunction isNegativePattern(pattern) {\r\n    return pattern.startsWith('!') && pattern[1] !== '(';\r\n}\r\nexports.isNegativePattern = isNegativePattern;\r\nfunction isPositivePattern(pattern) {\r\n    return !isNegativePattern(pattern);\r\n}\r\nexports.isPositivePattern = isPositivePattern;\r\nfunction getNegativePatterns(patterns) {\r\n    return patterns.filter(isNegativePattern);\r\n}\r\nexports.getNegativePatterns = getNegativePatterns;\r\nfunction getPositivePatterns(patterns) {\r\n    return patterns.filter(isPositivePattern);\r\n}\r\nexports.getPositivePatterns = getPositivePatterns;\r\n/**\r\n * Returns patterns that can be applied inside the current directory.\r\n *\r\n * @example\r\n * // ['./*', '*', 'a/*']\r\n * getPatternsInsideCurrentDirectory(['./*', '*', 'a/*', '../*', './../*'])\r\n */\r\nfunction getPatternsInsideCurrentDirectory(patterns) {\r\n    return patterns.filter((pattern) => !isPatternRelatedToParentDirectory(pattern));\r\n}\r\nexports.getPatternsInsideCurrentDirectory = getPatternsInsideCurrentDirectory;\r\n/**\r\n * Returns patterns to be expanded relative to (outside) the current directory.\r\n *\r\n * @example\r\n * // ['../*', './../*']\r\n * getPatternsInsideCurrentDirectory(['./*', '*', 'a/*', '../*', './../*'])\r\n */\r\nfunction getPatternsOutsideCurrentDirectory(patterns) {\r\n    return patterns.filter(isPatternRelatedToParentDirectory);\r\n}\r\nexports.getPatternsOutsideCurrentDirectory = getPatternsOutsideCurrentDirectory;\r\nfunction isPatternRelatedToParentDirectory(pattern) {\r\n    return pattern.startsWith('..') || pattern.startsWith('./..');\r\n}\r\nexports.isPatternRelatedToParentDirectory = isPatternRelatedToParentDirectory;\r\nfunction getBaseDirectory(pattern) {\r\n    return globParent(pattern, { flipBackslashes: false });\r\n}\r\nexports.getBaseDirectory = getBaseDirectory;\r\nfunction hasGlobStar(pattern) {\r\n    return pattern.includes(GLOBSTAR);\r\n}\r\nexports.hasGlobStar = hasGlobStar;\r\nfunction endsWithSlashGlobStar(pattern) {\r\n    return pattern.endsWith('/' + GLOBSTAR);\r\n}\r\nexports.endsWithSlashGlobStar = endsWithSlashGlobStar;\r\nfunction isAffectDepthOfReadingPattern(pattern) {\r\n    const basename = path.basename(pattern);\r\n    return endsWithSlashGlobStar(pattern) || isStaticPattern(basename);\r\n}\r\nexports.isAffectDepthOfReadingPattern = isAffectDepthOfReadingPattern;\r\nfunction expandPatternsWithBraceExpansion(patterns) {\r\n    return patterns.reduce((collection, pattern) => {\r\n        return collection.concat(expandBraceExpansion(pattern));\r\n    }, []);\r\n}\r\nexports.expandPatternsWithBraceExpansion = expandPatternsWithBraceExpansion;\r\nfunction expandBraceExpansion(pattern) {\r\n    return micromatch.braces(pattern, {\r\n        expand: true,\r\n        nodupes: true\r\n    });\r\n}\r\nexports.expandBraceExpansion = expandBraceExpansion;\r\nfunction getPatternParts(pattern, options) {\r\n    let { parts } = micromatch.scan(pattern, Object.assign(Object.assign({}, options), { parts: true }));\r\n    /**\r\n     * The scan method returns an empty array in some cases.\r\n     * See micromatch/picomatch#58 for more details.\r\n     */\r\n    if (parts.length === 0) {\r\n        parts = [pattern];\r\n    }\r\n    /**\r\n     * The scan method does not return an empty part for the pattern with a forward slash.\r\n     * This is another part of micromatch/picomatch#58.\r\n     */\r\n    if (parts[0].startsWith('/')) {\r\n        parts[0] = parts[0].slice(1);\r\n        parts.unshift('');\r\n    }\r\n    return parts;\r\n}\r\nexports.getPatternParts = getPatternParts;\r\nfunction makeRe(pattern, options) {\r\n    return micromatch.makeRe(pattern, options);\r\n}\r\nexports.makeRe = makeRe;\r\nfunction convertPatternsToRe(patterns, options) {\r\n    return patterns.map((pattern) => makeRe(pattern, options));\r\n}\r\nexports.convertPatternsToRe = convertPatternsToRe;\r\nfunction matchAny(entry, patternsRe) {\r\n    return patternsRe.some((patternRe) => patternRe.test(entry));\r\n}\r\nexports.matchAny = matchAny;\r\n\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/fast-glob/out/utils/pattern.js?");

/***/ }),

/***/ "./node_modules/fast-glob/out/utils/stream.js":
/*!****************************************************!*\
  !*** ./node_modules/fast-glob/out/utils/stream.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.merge = void 0;\r\nconst merge2 = __webpack_require__(/*! merge2 */ \"./node_modules/merge2/index.js\");\r\nfunction merge(streams) {\r\n    const mergedStream = merge2(streams);\r\n    streams.forEach((stream) => {\r\n        stream.once('error', (error) => mergedStream.emit('error', error));\r\n    });\r\n    mergedStream.once('close', () => propagateCloseEventToSources(streams));\r\n    mergedStream.once('end', () => propagateCloseEventToSources(streams));\r\n    return mergedStream;\r\n}\r\nexports.merge = merge;\r\nfunction propagateCloseEventToSources(streams) {\r\n    streams.forEach((stream) => stream.emit('close'));\r\n}\r\n\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/fast-glob/out/utils/stream.js?");

/***/ }),

/***/ "./node_modules/fast-glob/out/utils/string.js":
/*!****************************************************!*\
  !*** ./node_modules/fast-glob/out/utils/string.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.isEmpty = exports.isString = void 0;\r\nfunction isString(input) {\r\n    return typeof input === 'string';\r\n}\r\nexports.isString = isString;\r\nfunction isEmpty(input) {\r\n    return input === '';\r\n}\r\nexports.isEmpty = isEmpty;\r\n\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/fast-glob/out/utils/string.js?");

/***/ }),

/***/ "./node_modules/fastq/queue.js":
/*!*************************************!*\
  !*** ./node_modules/fastq/queue.js ***!
  \*************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n/* eslint-disable no-var */\n\nvar reusify = __webpack_require__(/*! reusify */ \"./node_modules/reusify/reusify.js\")\n\nfunction fastqueue (context, worker, concurrency) {\n  if (typeof context === 'function') {\n    concurrency = worker\n    worker = context\n    context = null\n  }\n\n  if (concurrency < 1) {\n    throw new Error('fastqueue concurrency must be greater than 1')\n  }\n\n  var cache = reusify(Task)\n  var queueHead = null\n  var queueTail = null\n  var _running = 0\n  var errorHandler = null\n\n  var self = {\n    push: push,\n    drain: noop,\n    saturated: noop,\n    pause: pause,\n    paused: false,\n    concurrency: concurrency,\n    running: running,\n    resume: resume,\n    idle: idle,\n    length: length,\n    getQueue: getQueue,\n    unshift: unshift,\n    empty: noop,\n    kill: kill,\n    killAndDrain: killAndDrain,\n    error: error\n  }\n\n  return self\n\n  function running () {\n    return _running\n  }\n\n  function pause () {\n    self.paused = true\n  }\n\n  function length () {\n    var current = queueHead\n    var counter = 0\n\n    while (current) {\n      current = current.next\n      counter++\n    }\n\n    return counter\n  }\n\n  function getQueue () {\n    var current = queueHead\n    var tasks = []\n\n    while (current) {\n      tasks.push(current.value)\n      current = current.next\n    }\n\n    return tasks\n  }\n\n  function resume () {\n    if (!self.paused) return\n    self.paused = false\n    for (var i = 0; i < self.concurrency; i++) {\n      _running++\n      release()\n    }\n  }\n\n  function idle () {\n    return _running === 0 && self.length() === 0\n  }\n\n  function push (value, done) {\n    var current = cache.get()\n\n    current.context = context\n    current.release = release\n    current.value = value\n    current.callback = done || noop\n    current.errorHandler = errorHandler\n\n    if (_running === self.concurrency || self.paused) {\n      if (queueTail) {\n        queueTail.next = current\n        queueTail = current\n      } else {\n        queueHead = current\n        queueTail = current\n        self.saturated()\n      }\n    } else {\n      _running++\n      worker.call(context, current.value, current.worked)\n    }\n  }\n\n  function unshift (value, done) {\n    var current = cache.get()\n\n    current.context = context\n    current.release = release\n    current.value = value\n    current.callback = done || noop\n\n    if (_running === self.concurrency || self.paused) {\n      if (queueHead) {\n        current.next = queueHead\n        queueHead = current\n      } else {\n        queueHead = current\n        queueTail = current\n        self.saturated()\n      }\n    } else {\n      _running++\n      worker.call(context, current.value, current.worked)\n    }\n  }\n\n  function release (holder) {\n    if (holder) {\n      cache.release(holder)\n    }\n    var next = queueHead\n    if (next) {\n      if (!self.paused) {\n        if (queueTail === queueHead) {\n          queueTail = null\n        }\n        queueHead = next.next\n        next.next = null\n        worker.call(context, next.value, next.worked)\n        if (queueTail === null) {\n          self.empty()\n        }\n      } else {\n        _running--\n      }\n    } else if (--_running === 0) {\n      self.drain()\n    }\n  }\n\n  function kill () {\n    queueHead = null\n    queueTail = null\n    self.drain = noop\n  }\n\n  function killAndDrain () {\n    queueHead = null\n    queueTail = null\n    self.drain()\n    self.drain = noop\n  }\n\n  function error (handler) {\n    errorHandler = handler\n  }\n}\n\nfunction noop () {}\n\nfunction Task () {\n  this.value = null\n  this.callback = noop\n  this.next = null\n  this.release = noop\n  this.context = null\n  this.errorHandler = null\n\n  var self = this\n\n  this.worked = function worked (err, result) {\n    var callback = self.callback\n    var errorHandler = self.errorHandler\n    var val = self.value\n    self.value = null\n    self.callback = noop\n    if (self.errorHandler) {\n      errorHandler(err, val)\n    }\n    callback.call(self.context, err, result)\n    self.release(self)\n  }\n}\n\nfunction queueAsPromised (context, worker, concurrency) {\n  if (typeof context === 'function') {\n    concurrency = worker\n    worker = context\n    context = null\n  }\n\n  function asyncWrapper (arg, cb) {\n    worker.call(this, arg)\n      .then(function (res) {\n        cb(null, res)\n      }, cb)\n  }\n\n  var queue = fastqueue(context, asyncWrapper, concurrency)\n\n  var pushCb = queue.push\n  var unshiftCb = queue.unshift\n\n  queue.push = push\n  queue.unshift = unshift\n  queue.drained = drained\n\n  return queue\n\n  function push (value) {\n    var p = new Promise(function (resolve, reject) {\n      pushCb(value, function (err, result) {\n        if (err) {\n          reject(err)\n          return\n        }\n        resolve(result)\n      })\n    })\n\n    // Let's fork the promise chain to\n    // make the error bubble up to the user but\n    // not lead to a unhandledRejection\n    p.catch(noop)\n\n    return p\n  }\n\n  function unshift (value) {\n    var p = new Promise(function (resolve, reject) {\n      unshiftCb(value, function (err, result) {\n        if (err) {\n          reject(err)\n          return\n        }\n        resolve(result)\n      })\n    })\n\n    // Let's fork the promise chain to\n    // make the error bubble up to the user but\n    // not lead to a unhandledRejection\n    p.catch(noop)\n\n    return p\n  }\n\n  function drained () {\n    var previousDrain = queue.drain\n\n    var p = new Promise(function (resolve) {\n      queue.drain = function () {\n        previousDrain()\n        resolve()\n      }\n    })\n\n    return p\n  }\n}\n\nmodule.exports = fastqueue\nmodule.exports.promise = queueAsPromised\n\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/fastq/queue.js?");

/***/ }),

/***/ "./node_modules/fill-range/index.js":
/*!******************************************!*\
  !*** ./node_modules/fill-range/index.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*!\n * fill-range <https://github.com/jonschlinkert/fill-range>\n *\n * Copyright (c) 2014-present, Jon Schlinkert.\n * Licensed under the MIT License.\n */\n\n\n\nconst util = __webpack_require__(Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'util'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));\nconst toRegexRange = __webpack_require__(/*! to-regex-range */ \"./node_modules/to-regex-range/index.js\");\n\nconst isObject = val => val !== null && typeof val === 'object' && !Array.isArray(val);\n\nconst transform = toNumber => {\n  return value => toNumber === true ? Number(value) : String(value);\n};\n\nconst isValidValue = value => {\n  return typeof value === 'number' || (typeof value === 'string' && value !== '');\n};\n\nconst isNumber = num => Number.isInteger(+num);\n\nconst zeros = input => {\n  let value = `${input}`;\n  let index = -1;\n  if (value[0] === '-') value = value.slice(1);\n  if (value === '0') return false;\n  while (value[++index] === '0');\n  return index > 0;\n};\n\nconst stringify = (start, end, options) => {\n  if (typeof start === 'string' || typeof end === 'string') {\n    return true;\n  }\n  return options.stringify === true;\n};\n\nconst pad = (input, maxLength, toNumber) => {\n  if (maxLength > 0) {\n    let dash = input[0] === '-' ? '-' : '';\n    if (dash) input = input.slice(1);\n    input = (dash + input.padStart(dash ? maxLength - 1 : maxLength, '0'));\n  }\n  if (toNumber === false) {\n    return String(input);\n  }\n  return input;\n};\n\nconst toMaxLen = (input, maxLength) => {\n  let negative = input[0] === '-' ? '-' : '';\n  if (negative) {\n    input = input.slice(1);\n    maxLength--;\n  }\n  while (input.length < maxLength) input = '0' + input;\n  return negative ? ('-' + input) : input;\n};\n\nconst toSequence = (parts, options) => {\n  parts.negatives.sort((a, b) => a < b ? -1 : a > b ? 1 : 0);\n  parts.positives.sort((a, b) => a < b ? -1 : a > b ? 1 : 0);\n\n  let prefix = options.capture ? '' : '?:';\n  let positives = '';\n  let negatives = '';\n  let result;\n\n  if (parts.positives.length) {\n    positives = parts.positives.join('|');\n  }\n\n  if (parts.negatives.length) {\n    negatives = `-(${prefix}${parts.negatives.join('|')})`;\n  }\n\n  if (positives && negatives) {\n    result = `${positives}|${negatives}`;\n  } else {\n    result = positives || negatives;\n  }\n\n  if (options.wrap) {\n    return `(${prefix}${result})`;\n  }\n\n  return result;\n};\n\nconst toRange = (a, b, isNumbers, options) => {\n  if (isNumbers) {\n    return toRegexRange(a, b, { wrap: false, ...options });\n  }\n\n  let start = String.fromCharCode(a);\n  if (a === b) return start;\n\n  let stop = String.fromCharCode(b);\n  return `[${start}-${stop}]`;\n};\n\nconst toRegex = (start, end, options) => {\n  if (Array.isArray(start)) {\n    let wrap = options.wrap === true;\n    let prefix = options.capture ? '' : '?:';\n    return wrap ? `(${prefix}${start.join('|')})` : start.join('|');\n  }\n  return toRegexRange(start, end, options);\n};\n\nconst rangeError = (...args) => {\n  return new RangeError('Invalid range arguments: ' + util.inspect(...args));\n};\n\nconst invalidRange = (start, end, options) => {\n  if (options.strictRanges === true) throw rangeError([start, end]);\n  return [];\n};\n\nconst invalidStep = (step, options) => {\n  if (options.strictRanges === true) {\n    throw new TypeError(`Expected step \"${step}\" to be a number`);\n  }\n  return [];\n};\n\nconst fillNumbers = (start, end, step = 1, options = {}) => {\n  let a = Number(start);\n  let b = Number(end);\n\n  if (!Number.isInteger(a) || !Number.isInteger(b)) {\n    if (options.strictRanges === true) throw rangeError([start, end]);\n    return [];\n  }\n\n  // fix negative zero\n  if (a === 0) a = 0;\n  if (b === 0) b = 0;\n\n  let descending = a > b;\n  let startString = String(start);\n  let endString = String(end);\n  let stepString = String(step);\n  step = Math.max(Math.abs(step), 1);\n\n  let padded = zeros(startString) || zeros(endString) || zeros(stepString);\n  let maxLen = padded ? Math.max(startString.length, endString.length, stepString.length) : 0;\n  let toNumber = padded === false && stringify(start, end, options) === false;\n  let format = options.transform || transform(toNumber);\n\n  if (options.toRegex && step === 1) {\n    return toRange(toMaxLen(start, maxLen), toMaxLen(end, maxLen), true, options);\n  }\n\n  let parts = { negatives: [], positives: [] };\n  let push = num => parts[num < 0 ? 'negatives' : 'positives'].push(Math.abs(num));\n  let range = [];\n  let index = 0;\n\n  while (descending ? a >= b : a <= b) {\n    if (options.toRegex === true && step > 1) {\n      push(a);\n    } else {\n      range.push(pad(format(a, index), maxLen, toNumber));\n    }\n    a = descending ? a - step : a + step;\n    index++;\n  }\n\n  if (options.toRegex === true) {\n    return step > 1\n      ? toSequence(parts, options)\n      : toRegex(range, null, { wrap: false, ...options });\n  }\n\n  return range;\n};\n\nconst fillLetters = (start, end, step = 1, options = {}) => {\n  if ((!isNumber(start) && start.length > 1) || (!isNumber(end) && end.length > 1)) {\n    return invalidRange(start, end, options);\n  }\n\n\n  let format = options.transform || (val => String.fromCharCode(val));\n  let a = `${start}`.charCodeAt(0);\n  let b = `${end}`.charCodeAt(0);\n\n  let descending = a > b;\n  let min = Math.min(a, b);\n  let max = Math.max(a, b);\n\n  if (options.toRegex && step === 1) {\n    return toRange(min, max, false, options);\n  }\n\n  let range = [];\n  let index = 0;\n\n  while (descending ? a >= b : a <= b) {\n    range.push(format(a, index));\n    a = descending ? a - step : a + step;\n    index++;\n  }\n\n  if (options.toRegex === true) {\n    return toRegex(range, null, { wrap: false, options });\n  }\n\n  return range;\n};\n\nconst fill = (start, end, step, options = {}) => {\n  if (end == null && isValidValue(start)) {\n    return [start];\n  }\n\n  if (!isValidValue(start) || !isValidValue(end)) {\n    return invalidRange(start, end, options);\n  }\n\n  if (typeof step === 'function') {\n    return fill(start, end, 1, { transform: step });\n  }\n\n  if (isObject(step)) {\n    return fill(start, end, 0, step);\n  }\n\n  let opts = { ...options };\n  if (opts.capture === true) opts.wrap = true;\n  step = step || opts.step || 1;\n\n  if (!isNumber(step)) {\n    if (step != null && !isObject(step)) return invalidStep(step, opts);\n    return fill(start, end, 1, step);\n  }\n\n  if (isNumber(start) && isNumber(end)) {\n    return fillNumbers(start, end, step, opts);\n  }\n\n  return fillLetters(start, end, Math.max(Math.abs(step), 1), opts);\n};\n\nmodule.exports = fill;\n\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/fill-range/index.js?");

/***/ }),

/***/ "./node_modules/function-bind/implementation.js":
/*!******************************************************!*\
  !*** ./node_modules/function-bind/implementation.js ***!
  \******************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/* eslint no-invalid-this: 1 */\n\nvar ERROR_MESSAGE = 'Function.prototype.bind called on incompatible ';\nvar slice = Array.prototype.slice;\nvar toStr = Object.prototype.toString;\nvar funcType = '[object Function]';\n\nmodule.exports = function bind(that) {\n    var target = this;\n    if (typeof target !== 'function' || toStr.call(target) !== funcType) {\n        throw new TypeError(ERROR_MESSAGE + target);\n    }\n    var args = slice.call(arguments, 1);\n\n    var bound;\n    var binder = function () {\n        if (this instanceof bound) {\n            var result = target.apply(\n                this,\n                args.concat(slice.call(arguments))\n            );\n            if (Object(result) === result) {\n                return result;\n            }\n            return this;\n        } else {\n            return target.apply(\n                that,\n                args.concat(slice.call(arguments))\n            );\n        }\n    };\n\n    var boundLength = Math.max(0, target.length - args.length);\n    var boundArgs = [];\n    for (var i = 0; i < boundLength; i++) {\n        boundArgs.push('$' + i);\n    }\n\n    bound = Function('binder', 'return function (' + boundArgs.join(',') + '){ return binder.apply(this,arguments); }')(binder);\n\n    if (target.prototype) {\n        var Empty = function Empty() {};\n        Empty.prototype = target.prototype;\n        bound.prototype = new Empty();\n        Empty.prototype = null;\n    }\n\n    return bound;\n};\n\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/function-bind/implementation.js?");

/***/ }),

/***/ "./node_modules/function-bind/index.js":
/*!*********************************************!*\
  !*** ./node_modules/function-bind/index.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar implementation = __webpack_require__(/*! ./implementation */ \"./node_modules/function-bind/implementation.js\");\n\nmodule.exports = Function.prototype.bind || implementation;\n\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/function-bind/index.js?");

/***/ }),

/***/ "./node_modules/glob-parent/index.js":
/*!*******************************************!*\
  !*** ./node_modules/glob-parent/index.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar isGlob = __webpack_require__(/*! is-glob */ \"./node_modules/is-glob/index.js\");\nvar pathPosixDirname = Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'path'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }());\nvar isWin32 = Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'os'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }())() === 'win32';\n\nvar slash = '/';\nvar backslash = /\\\\/g;\nvar escaped = /\\\\([!*?|[\\](){}])/g;\n\n/**\n * @param {string} str\n * @param {Object} opts\n * @param {boolean} [opts.flipBackslashes=true]\n */\nmodule.exports = function globParent(str, opts) {\n  var options = Object.assign({ flipBackslashes: true }, opts);\n\n  // flip windows path separators\n  if (options.flipBackslashes && isWin32 && str.indexOf(slash) < 0) {\n    str = str.replace(backslash, slash);\n  }\n\n  // special case for strings ending in enclosure containing path separator\n  if (isEnclosure(str)) {\n    str += slash;\n  }\n\n  // preserves full path in case of trailing path separator\n  str += 'a';\n\n  // remove path parts that are globby\n  do {\n    str = pathPosixDirname(str);\n  } while (isGlobby(str));\n\n  // remove escape chars and return result\n  return str.replace(escaped, '$1');\n};\n\nfunction isEnclosure(str) {\n  var lastChar = str.slice(-1);\n\n  var enclosureStart;\n  switch (lastChar) {\n    case '}':\n      enclosureStart = '{';\n      break;\n    case ']':\n      enclosureStart = '[';\n      break;\n    default:\n      return false;\n  }\n\n  var foundIndex = str.indexOf(enclosureStart);\n  if (foundIndex < 0) {\n    return false;\n  }\n\n  return str.slice(foundIndex + 1, -1).includes(slash);\n}\n\nfunction isGlobby(str) {\n  if (/\\([^()]+$/.test(str)) {\n    return true;\n  }\n  if (str[0] === '{' || str[0] === '[') {\n    return true;\n  }\n  if (/[^\\\\][{[]/.test(str)) {\n    return true;\n  }\n  return isGlob(str);\n}\n\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/glob-parent/index.js?");

/***/ }),

/***/ "./node_modules/has/src/index.js":
/*!***************************************!*\
  !*** ./node_modules/has/src/index.js ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar bind = __webpack_require__(/*! function-bind */ \"./node_modules/function-bind/index.js\");\n\nmodule.exports = bind.call(Function.call, Object.prototype.hasOwnProperty);\n\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/has/src/index.js?");

/***/ }),

/***/ "./node_modules/is-core-module/index.js":
/*!**********************************************!*\
  !*** ./node_modules/is-core-module/index.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar has = __webpack_require__(/*! has */ \"./node_modules/has/src/index.js\");\n\nfunction specifierIncluded(current, specifier) {\n\tvar nodeParts = current.split('.');\n\tvar parts = specifier.split(' ');\n\tvar op = parts.length > 1 ? parts[0] : '=';\n\tvar versionParts = (parts.length > 1 ? parts[1] : parts[0]).split('.');\n\n\tfor (var i = 0; i < 3; ++i) {\n\t\tvar cur = parseInt(nodeParts[i] || 0, 10);\n\t\tvar ver = parseInt(versionParts[i] || 0, 10);\n\t\tif (cur === ver) {\n\t\t\tcontinue; // eslint-disable-line no-restricted-syntax, no-continue\n\t\t}\n\t\tif (op === '<') {\n\t\t\treturn cur < ver;\n\t\t}\n\t\tif (op === '>=') {\n\t\t\treturn cur >= ver;\n\t\t}\n\t\treturn false;\n\t}\n\treturn op === '>=';\n}\n\nfunction matchesRange(current, range) {\n\tvar specifiers = range.split(/ ?&& ?/);\n\tif (specifiers.length === 0) {\n\t\treturn false;\n\t}\n\tfor (var i = 0; i < specifiers.length; ++i) {\n\t\tif (!specifierIncluded(current, specifiers[i])) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\nfunction versionIncluded(nodeVersion, specifierValue) {\n\tif (typeof specifierValue === 'boolean') {\n\t\treturn specifierValue;\n\t}\n\n\tvar current = typeof nodeVersion === 'undefined'\n\t\t? process.versions && process.versions.node\n\t\t: nodeVersion;\n\n\tif (typeof current !== 'string') {\n\t\tthrow new TypeError(typeof nodeVersion === 'undefined' ? 'Unable to determine current node version' : 'If provided, a valid node version is required');\n\t}\n\n\tif (specifierValue && typeof specifierValue === 'object') {\n\t\tfor (var i = 0; i < specifierValue.length; ++i) {\n\t\t\tif (matchesRange(current, specifierValue[i])) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\treturn matchesRange(current, specifierValue);\n}\n\nvar data = __webpack_require__(/*! ./core.json */ \"./node_modules/is-core-module/core.json\");\n\nmodule.exports = function isCore(x, nodeVersion) {\n\treturn has(data, x) && versionIncluded(nodeVersion, data[x]);\n};\n\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/is-core-module/index.js?");

/***/ }),

/***/ "./node_modules/is-extglob/index.js":
/*!******************************************!*\
  !*** ./node_modules/is-extglob/index.js ***!
  \******************************************/
/***/ ((module) => {

eval("/*!\n * is-extglob <https://github.com/jonschlinkert/is-extglob>\n *\n * Copyright (c) 2014-2016, Jon Schlinkert.\n * Licensed under the MIT License.\n */\n\nmodule.exports = function isExtglob(str) {\n  if (typeof str !== 'string' || str === '') {\n    return false;\n  }\n\n  var match;\n  while ((match = /(\\\\).|([@?!+*]\\(.*\\))/g.exec(str))) {\n    if (match[2]) return true;\n    str = str.slice(match.index + match[0].length);\n  }\n\n  return false;\n};\n\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/is-extglob/index.js?");

/***/ }),

/***/ "./node_modules/is-glob/index.js":
/*!***************************************!*\
  !*** ./node_modules/is-glob/index.js ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*!\n * is-glob <https://github.com/jonschlinkert/is-glob>\n *\n * Copyright (c) 2014-2017, Jon Schlinkert.\n * Released under the MIT License.\n */\n\nvar isExtglob = __webpack_require__(/*! is-extglob */ \"./node_modules/is-extglob/index.js\");\nvar chars = { '{': '}', '(': ')', '[': ']'};\nvar strictCheck = function(str) {\n  if (str[0] === '!') {\n    return true;\n  }\n  var index = 0;\n  var pipeIndex = -2;\n  var closeSquareIndex = -2;\n  var closeCurlyIndex = -2;\n  var closeParenIndex = -2;\n  var backSlashIndex = -2;\n  while (index < str.length) {\n    if (str[index] === '*') {\n      return true;\n    }\n\n    if (str[index + 1] === '?' && /[\\].+)]/.test(str[index])) {\n      return true;\n    }\n\n    if (closeSquareIndex !== -1 && str[index] === '[' && str[index + 1] !== ']') {\n      if (closeSquareIndex < index) {\n        closeSquareIndex = str.indexOf(']', index);\n      }\n      if (closeSquareIndex > index) {\n        if (backSlashIndex === -1 || backSlashIndex > closeSquareIndex) {\n          return true;\n        }\n        backSlashIndex = str.indexOf('\\\\', index);\n        if (backSlashIndex === -1 || backSlashIndex > closeSquareIndex) {\n          return true;\n        }\n      }\n    }\n\n    if (closeCurlyIndex !== -1 && str[index] === '{' && str[index + 1] !== '}') {\n      closeCurlyIndex = str.indexOf('}', index);\n      if (closeCurlyIndex > index) {\n        backSlashIndex = str.indexOf('\\\\', index);\n        if (backSlashIndex === -1 || backSlashIndex > closeCurlyIndex) {\n          return true;\n        }\n      }\n    }\n\n    if (closeParenIndex !== -1 && str[index] === '(' && str[index + 1] === '?' && /[:!=]/.test(str[index + 2]) && str[index + 3] !== ')') {\n      closeParenIndex = str.indexOf(')', index);\n      if (closeParenIndex > index) {\n        backSlashIndex = str.indexOf('\\\\', index);\n        if (backSlashIndex === -1 || backSlashIndex > closeParenIndex) {\n          return true;\n        }\n      }\n    }\n\n    if (pipeIndex !== -1 && str[index] === '(' && str[index + 1] !== '|') {\n      if (pipeIndex < index) {\n        pipeIndex = str.indexOf('|', index);\n      }\n      if (pipeIndex !== -1 && str[pipeIndex + 1] !== ')') {\n        closeParenIndex = str.indexOf(')', pipeIndex);\n        if (closeParenIndex > pipeIndex) {\n          backSlashIndex = str.indexOf('\\\\', pipeIndex);\n          if (backSlashIndex === -1 || backSlashIndex > closeParenIndex) {\n            return true;\n          }\n        }\n      }\n    }\n\n    if (str[index] === '\\\\') {\n      var open = str[index + 1];\n      index += 2;\n      var close = chars[open];\n\n      if (close) {\n        var n = str.indexOf(close, index);\n        if (n !== -1) {\n          index = n + 1;\n        }\n      }\n\n      if (str[index] === '!') {\n        return true;\n      }\n    } else {\n      index++;\n    }\n  }\n  return false;\n};\n\nvar relaxedCheck = function(str) {\n  if (str[0] === '!') {\n    return true;\n  }\n  var index = 0;\n  while (index < str.length) {\n    if (/[*?{}()[\\]]/.test(str[index])) {\n      return true;\n    }\n\n    if (str[index] === '\\\\') {\n      var open = str[index + 1];\n      index += 2;\n      var close = chars[open];\n\n      if (close) {\n        var n = str.indexOf(close, index);\n        if (n !== -1) {\n          index = n + 1;\n        }\n      }\n\n      if (str[index] === '!') {\n        return true;\n      }\n    } else {\n      index++;\n    }\n  }\n  return false;\n};\n\nmodule.exports = function isGlob(str, options) {\n  if (typeof str !== 'string' || str === '') {\n    return false;\n  }\n\n  if (isExtglob(str)) {\n    return true;\n  }\n\n  var check = strictCheck;\n\n  // optionally relax check\n  if (options && options.strict === false) {\n    check = relaxedCheck;\n  }\n\n  return check(str);\n};\n\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/is-glob/index.js?");

/***/ }),

/***/ "./node_modules/is-number/index.js":
/*!*****************************************!*\
  !*** ./node_modules/is-number/index.js ***!
  \*****************************************/
/***/ ((module) => {

"use strict";
eval("/*!\n * is-number <https://github.com/jonschlinkert/is-number>\n *\n * Copyright (c) 2014-present, Jon Schlinkert.\n * Released under the MIT License.\n */\n\n\n\nmodule.exports = function(num) {\n  if (typeof num === 'number') {\n    return num - num === 0;\n  }\n  if (typeof num === 'string' && num.trim() !== '') {\n    return Number.isFinite ? Number.isFinite(+num) : isFinite(+num);\n  }\n  return false;\n};\n\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/is-number/index.js?");

/***/ }),

/***/ "./node_modules/merge2/index.js":
/*!**************************************!*\
  !*** ./node_modules/merge2/index.js ***!
  \**************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n/*\n * merge2\n * https://github.com/teambition/merge2\n *\n * Copyright (c) 2014-2020 Teambition\n * Licensed under the MIT license.\n */\nconst Stream = __webpack_require__(Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'stream'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()))\nconst PassThrough = Stream.PassThrough\nconst slice = Array.prototype.slice\n\nmodule.exports = merge2\n\nfunction merge2 () {\n  const streamsQueue = []\n  const args = slice.call(arguments)\n  let merging = false\n  let options = args[args.length - 1]\n\n  if (options && !Array.isArray(options) && options.pipe == null) {\n    args.pop()\n  } else {\n    options = {}\n  }\n\n  const doEnd = options.end !== false\n  const doPipeError = options.pipeError === true\n  if (options.objectMode == null) {\n    options.objectMode = true\n  }\n  if (options.highWaterMark == null) {\n    options.highWaterMark = 64 * 1024\n  }\n  const mergedStream = PassThrough(options)\n\n  function addStream () {\n    for (let i = 0, len = arguments.length; i < len; i++) {\n      streamsQueue.push(pauseStreams(arguments[i], options))\n    }\n    mergeStream()\n    return this\n  }\n\n  function mergeStream () {\n    if (merging) {\n      return\n    }\n    merging = true\n\n    let streams = streamsQueue.shift()\n    if (!streams) {\n      process.nextTick(endStream)\n      return\n    }\n    if (!Array.isArray(streams)) {\n      streams = [streams]\n    }\n\n    let pipesCount = streams.length + 1\n\n    function next () {\n      if (--pipesCount > 0) {\n        return\n      }\n      merging = false\n      mergeStream()\n    }\n\n    function pipe (stream) {\n      function onend () {\n        stream.removeListener('merge2UnpipeEnd', onend)\n        stream.removeListener('end', onend)\n        if (doPipeError) {\n          stream.removeListener('error', onerror)\n        }\n        next()\n      }\n      function onerror (err) {\n        mergedStream.emit('error', err)\n      }\n      // skip ended stream\n      if (stream._readableState.endEmitted) {\n        return next()\n      }\n\n      stream.on('merge2UnpipeEnd', onend)\n      stream.on('end', onend)\n\n      if (doPipeError) {\n        stream.on('error', onerror)\n      }\n\n      stream.pipe(mergedStream, { end: false })\n      // compatible for old stream\n      stream.resume()\n    }\n\n    for (let i = 0; i < streams.length; i++) {\n      pipe(streams[i])\n    }\n\n    next()\n  }\n\n  function endStream () {\n    merging = false\n    // emit 'queueDrain' when all streams merged.\n    mergedStream.emit('queueDrain')\n    if (doEnd) {\n      mergedStream.end()\n    }\n  }\n\n  mergedStream.setMaxListeners(0)\n  mergedStream.add = addStream\n  mergedStream.on('unpipe', function (stream) {\n    stream.emit('merge2UnpipeEnd')\n  })\n\n  if (args.length) {\n    addStream.apply(null, args)\n  }\n  return mergedStream\n}\n\n// check and pause streams for pipe.\nfunction pauseStreams (streams, options) {\n  if (!Array.isArray(streams)) {\n    // Backwards-compat with old-style streams\n    if (!streams._readableState && streams.pipe) {\n      streams = streams.pipe(PassThrough(options))\n    }\n    if (!streams._readableState || !streams.pause || !streams.pipe) {\n      throw new Error('Only readable stream can be merged.')\n    }\n    streams.pause()\n  } else {\n    for (let i = 0, len = streams.length; i < len; i++) {\n      streams[i] = pauseStreams(streams[i], options)\n    }\n  }\n  return streams\n}\n\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/merge2/index.js?");

/***/ }),

/***/ "./node_modules/micromatch/index.js":
/*!******************************************!*\
  !*** ./node_modules/micromatch/index.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst util = __webpack_require__(Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'util'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));\nconst braces = __webpack_require__(/*! braces */ \"./node_modules/braces/index.js\");\nconst picomatch = __webpack_require__(/*! picomatch */ \"./node_modules/picomatch/index.js\");\nconst utils = __webpack_require__(/*! picomatch/lib/utils */ \"./node_modules/picomatch/lib/utils.js\");\nconst isEmptyString = val => val === '' || val === './';\n\n/**\n * Returns an array of strings that match one or more glob patterns.\n *\n * ```js\n * const mm = require('micromatch');\n * // mm(list, patterns[, options]);\n *\n * console.log(mm(['a.js', 'a.txt'], ['*.js']));\n * //=> [ 'a.js' ]\n * ```\n * @param {String|Array<string>} `list` List of strings to match.\n * @param {String|Array<string>} `patterns` One or more glob patterns to use for matching.\n * @param {Object} `options` See available [options](#options)\n * @return {Array} Returns an array of matches\n * @summary false\n * @api public\n */\n\nconst micromatch = (list, patterns, options) => {\n  patterns = [].concat(patterns);\n  list = [].concat(list);\n\n  let omit = new Set();\n  let keep = new Set();\n  let items = new Set();\n  let negatives = 0;\n\n  let onResult = state => {\n    items.add(state.output);\n    if (options && options.onResult) {\n      options.onResult(state);\n    }\n  };\n\n  for (let i = 0; i < patterns.length; i++) {\n    let isMatch = picomatch(String(patterns[i]), { ...options, onResult }, true);\n    let negated = isMatch.state.negated || isMatch.state.negatedExtglob;\n    if (negated) negatives++;\n\n    for (let item of list) {\n      let matched = isMatch(item, true);\n\n      let match = negated ? !matched.isMatch : matched.isMatch;\n      if (!match) continue;\n\n      if (negated) {\n        omit.add(matched.output);\n      } else {\n        omit.delete(matched.output);\n        keep.add(matched.output);\n      }\n    }\n  }\n\n  let result = negatives === patterns.length ? [...items] : [...keep];\n  let matches = result.filter(item => !omit.has(item));\n\n  if (options && matches.length === 0) {\n    if (options.failglob === true) {\n      throw new Error(`No matches found for \"${patterns.join(', ')}\"`);\n    }\n\n    if (options.nonull === true || options.nullglob === true) {\n      return options.unescape ? patterns.map(p => p.replace(/\\\\/g, '')) : patterns;\n    }\n  }\n\n  return matches;\n};\n\n/**\n * Backwards compatibility\n */\n\nmicromatch.match = micromatch;\n\n/**\n * Returns a matcher function from the given glob `pattern` and `options`.\n * The returned function takes a string to match as its only argument and returns\n * true if the string is a match.\n *\n * ```js\n * const mm = require('micromatch');\n * // mm.matcher(pattern[, options]);\n *\n * const isMatch = mm.matcher('*.!(*a)');\n * console.log(isMatch('a.a')); //=> false\n * console.log(isMatch('a.b')); //=> true\n * ```\n * @param {String} `pattern` Glob pattern\n * @param {Object} `options`\n * @return {Function} Returns a matcher function.\n * @api public\n */\n\nmicromatch.matcher = (pattern, options) => picomatch(pattern, options);\n\n/**\n * Returns true if **any** of the given glob `patterns` match the specified `string`.\n *\n * ```js\n * const mm = require('micromatch');\n * // mm.isMatch(string, patterns[, options]);\n *\n * console.log(mm.isMatch('a.a', ['b.*', '*.a'])); //=> true\n * console.log(mm.isMatch('a.a', 'b.*')); //=> false\n * ```\n * @param {String} `str` The string to test.\n * @param {String|Array} `patterns` One or more glob patterns to use for matching.\n * @param {Object} `[options]` See available [options](#options).\n * @return {Boolean} Returns true if any patterns match `str`\n * @api public\n */\n\nmicromatch.isMatch = (str, patterns, options) => picomatch(patterns, options)(str);\n\n/**\n * Backwards compatibility\n */\n\nmicromatch.any = micromatch.isMatch;\n\n/**\n * Returns a list of strings that _**do not match any**_ of the given `patterns`.\n *\n * ```js\n * const mm = require('micromatch');\n * // mm.not(list, patterns[, options]);\n *\n * console.log(mm.not(['a.a', 'b.b', 'c.c'], '*.a'));\n * //=> ['b.b', 'c.c']\n * ```\n * @param {Array} `list` Array of strings to match.\n * @param {String|Array} `patterns` One or more glob pattern to use for matching.\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Array} Returns an array of strings that **do not match** the given patterns.\n * @api public\n */\n\nmicromatch.not = (list, patterns, options = {}) => {\n  patterns = [].concat(patterns).map(String);\n  let result = new Set();\n  let items = [];\n\n  let onResult = state => {\n    if (options.onResult) options.onResult(state);\n    items.push(state.output);\n  };\n\n  let matches = new Set(micromatch(list, patterns, { ...options, onResult }));\n\n  for (let item of items) {\n    if (!matches.has(item)) {\n      result.add(item);\n    }\n  }\n  return [...result];\n};\n\n/**\n * Returns true if the given `string` contains the given pattern. Similar\n * to [.isMatch](#isMatch) but the pattern can match any part of the string.\n *\n * ```js\n * var mm = require('micromatch');\n * // mm.contains(string, pattern[, options]);\n *\n * console.log(mm.contains('aa/bb/cc', '*b'));\n * //=> true\n * console.log(mm.contains('aa/bb/cc', '*d'));\n * //=> false\n * ```\n * @param {String} `str` The string to match.\n * @param {String|Array} `patterns` Glob pattern to use for matching.\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Boolean} Returns true if any of the patterns matches any part of `str`.\n * @api public\n */\n\nmicromatch.contains = (str, pattern, options) => {\n  if (typeof str !== 'string') {\n    throw new TypeError(`Expected a string: \"${util.inspect(str)}\"`);\n  }\n\n  if (Array.isArray(pattern)) {\n    return pattern.some(p => micromatch.contains(str, p, options));\n  }\n\n  if (typeof pattern === 'string') {\n    if (isEmptyString(str) || isEmptyString(pattern)) {\n      return false;\n    }\n\n    if (str.includes(pattern) || (str.startsWith('./') && str.slice(2).includes(pattern))) {\n      return true;\n    }\n  }\n\n  return micromatch.isMatch(str, pattern, { ...options, contains: true });\n};\n\n/**\n * Filter the keys of the given object with the given `glob` pattern\n * and `options`. Does not attempt to match nested keys. If you need this feature,\n * use [glob-object][] instead.\n *\n * ```js\n * const mm = require('micromatch');\n * // mm.matchKeys(object, patterns[, options]);\n *\n * const obj = { aa: 'a', ab: 'b', ac: 'c' };\n * console.log(mm.matchKeys(obj, '*b'));\n * //=> { ab: 'b' }\n * ```\n * @param {Object} `object` The object with keys to filter.\n * @param {String|Array} `patterns` One or more glob patterns to use for matching.\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Object} Returns an object with only keys that match the given patterns.\n * @api public\n */\n\nmicromatch.matchKeys = (obj, patterns, options) => {\n  if (!utils.isObject(obj)) {\n    throw new TypeError('Expected the first argument to be an object');\n  }\n  let keys = micromatch(Object.keys(obj), patterns, options);\n  let res = {};\n  for (let key of keys) res[key] = obj[key];\n  return res;\n};\n\n/**\n * Returns true if some of the strings in the given `list` match any of the given glob `patterns`.\n *\n * ```js\n * const mm = require('micromatch');\n * // mm.some(list, patterns[, options]);\n *\n * console.log(mm.some(['foo.js', 'bar.js'], ['*.js', '!foo.js']));\n * // true\n * console.log(mm.some(['foo.js'], ['*.js', '!foo.js']));\n * // false\n * ```\n * @param {String|Array} `list` The string or array of strings to test. Returns as soon as the first match is found.\n * @param {String|Array} `patterns` One or more glob patterns to use for matching.\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Boolean} Returns true if any `patterns` matches any of the strings in `list`\n * @api public\n */\n\nmicromatch.some = (list, patterns, options) => {\n  let items = [].concat(list);\n\n  for (let pattern of [].concat(patterns)) {\n    let isMatch = picomatch(String(pattern), options);\n    if (items.some(item => isMatch(item))) {\n      return true;\n    }\n  }\n  return false;\n};\n\n/**\n * Returns true if every string in the given `list` matches\n * any of the given glob `patterns`.\n *\n * ```js\n * const mm = require('micromatch');\n * // mm.every(list, patterns[, options]);\n *\n * console.log(mm.every('foo.js', ['foo.js']));\n * // true\n * console.log(mm.every(['foo.js', 'bar.js'], ['*.js']));\n * // true\n * console.log(mm.every(['foo.js', 'bar.js'], ['*.js', '!foo.js']));\n * // false\n * console.log(mm.every(['foo.js'], ['*.js', '!foo.js']));\n * // false\n * ```\n * @param {String|Array} `list` The string or array of strings to test.\n * @param {String|Array} `patterns` One or more glob patterns to use for matching.\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Boolean} Returns true if all `patterns` matches all of the strings in `list`\n * @api public\n */\n\nmicromatch.every = (list, patterns, options) => {\n  let items = [].concat(list);\n\n  for (let pattern of [].concat(patterns)) {\n    let isMatch = picomatch(String(pattern), options);\n    if (!items.every(item => isMatch(item))) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/**\n * Returns true if **all** of the given `patterns` match\n * the specified string.\n *\n * ```js\n * const mm = require('micromatch');\n * // mm.all(string, patterns[, options]);\n *\n * console.log(mm.all('foo.js', ['foo.js']));\n * // true\n *\n * console.log(mm.all('foo.js', ['*.js', '!foo.js']));\n * // false\n *\n * console.log(mm.all('foo.js', ['*.js', 'foo.js']));\n * // true\n *\n * console.log(mm.all('foo.js', ['*.js', 'f*', '*o*', '*o.js']));\n * // true\n * ```\n * @param {String|Array} `str` The string to test.\n * @param {String|Array} `patterns` One or more glob patterns to use for matching.\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Boolean} Returns true if any patterns match `str`\n * @api public\n */\n\nmicromatch.all = (str, patterns, options) => {\n  if (typeof str !== 'string') {\n    throw new TypeError(`Expected a string: \"${util.inspect(str)}\"`);\n  }\n\n  return [].concat(patterns).every(p => picomatch(p, options)(str));\n};\n\n/**\n * Returns an array of matches captured by `pattern` in `string, or `null` if the pattern did not match.\n *\n * ```js\n * const mm = require('micromatch');\n * // mm.capture(pattern, string[, options]);\n *\n * console.log(mm.capture('test/*.js', 'test/foo.js'));\n * //=> ['foo']\n * console.log(mm.capture('test/*.js', 'foo/bar.css'));\n * //=> null\n * ```\n * @param {String} `glob` Glob pattern to use for matching.\n * @param {String} `input` String to match\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Array|null} Returns an array of captures if the input matches the glob pattern, otherwise `null`.\n * @api public\n */\n\nmicromatch.capture = (glob, input, options) => {\n  let posix = utils.isWindows(options);\n  let regex = picomatch.makeRe(String(glob), { ...options, capture: true });\n  let match = regex.exec(posix ? utils.toPosixSlashes(input) : input);\n\n  if (match) {\n    return match.slice(1).map(v => v === void 0 ? '' : v);\n  }\n};\n\n/**\n * Create a regular expression from the given glob `pattern`.\n *\n * ```js\n * const mm = require('micromatch');\n * // mm.makeRe(pattern[, options]);\n *\n * console.log(mm.makeRe('*.js'));\n * //=> /^(?:(\\.[\\\\\\/])?(?!\\.)(?=.)[^\\/]*?\\.js)$/\n * ```\n * @param {String} `pattern` A glob pattern to convert to regex.\n * @param {Object} `options`\n * @return {RegExp} Returns a regex created from the given pattern.\n * @api public\n */\n\nmicromatch.makeRe = (...args) => picomatch.makeRe(...args);\n\n/**\n * Scan a glob pattern to separate the pattern into segments. Used\n * by the [split](#split) method.\n *\n * ```js\n * const mm = require('micromatch');\n * const state = mm.scan(pattern[, options]);\n * ```\n * @param {String} `pattern`\n * @param {Object} `options`\n * @return {Object} Returns an object with\n * @api public\n */\n\nmicromatch.scan = (...args) => picomatch.scan(...args);\n\n/**\n * Parse a glob pattern to create the source string for a regular\n * expression.\n *\n * ```js\n * const mm = require('micromatch');\n * const state = mm.parse(pattern[, options]);\n * ```\n * @param {String} `glob`\n * @param {Object} `options`\n * @return {Object} Returns an object with useful properties and output to be used as regex source string.\n * @api public\n */\n\nmicromatch.parse = (patterns, options) => {\n  let res = [];\n  for (let pattern of [].concat(patterns || [])) {\n    for (let str of braces(String(pattern), options)) {\n      res.push(picomatch.parse(str, options));\n    }\n  }\n  return res;\n};\n\n/**\n * Process the given brace `pattern`.\n *\n * ```js\n * const { braces } = require('micromatch');\n * console.log(braces('foo/{a,b,c}/bar'));\n * //=> [ 'foo/(a|b|c)/bar' ]\n *\n * console.log(braces('foo/{a,b,c}/bar', { expand: true }));\n * //=> [ 'foo/a/bar', 'foo/b/bar', 'foo/c/bar' ]\n * ```\n * @param {String} `pattern` String with brace pattern to process.\n * @param {Object} `options` Any [options](#options) to change how expansion is performed. See the [braces][] library for all available options.\n * @return {Array}\n * @api public\n */\n\nmicromatch.braces = (pattern, options) => {\n  if (typeof pattern !== 'string') throw new TypeError('Expected a string');\n  if ((options && options.nobrace === true) || !/\\{.*\\}/.test(pattern)) {\n    return [pattern];\n  }\n  return braces(pattern, options);\n};\n\n/**\n * Expand braces\n */\n\nmicromatch.braceExpand = (pattern, options) => {\n  if (typeof pattern !== 'string') throw new TypeError('Expected a string');\n  return micromatch.braces(pattern, { ...options, expand: true });\n};\n\n/**\n * Expose micromatch\n */\n\nmodule.exports = micromatch;\n\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/micromatch/index.js?");

/***/ }),

/***/ "./node_modules/normalize-path/index.js":
/*!**********************************************!*\
  !*** ./node_modules/normalize-path/index.js ***!
  \**********************************************/
/***/ ((module) => {

eval("/*!\n * normalize-path <https://github.com/jonschlinkert/normalize-path>\n *\n * Copyright (c) 2014-2018, Jon Schlinkert.\n * Released under the MIT License.\n */\n\nmodule.exports = function(path, stripTrailing) {\n  if (typeof path !== 'string') {\n    throw new TypeError('expected path to be a string');\n  }\n\n  if (path === '\\\\' || path === '/') return '/';\n\n  var len = path.length;\n  if (len <= 1) return path;\n\n  // ensure that win32 namespaces has two leading slashes, so that the path is\n  // handled properly by the win32 version of path.parse() after being normalized\n  // https://msdn.microsoft.com/library/windows/desktop/aa365247(v=vs.85).aspx#namespaces\n  var prefix = '';\n  if (len > 4 && path[3] === '\\\\') {\n    var ch = path[2];\n    if ((ch === '?' || ch === '.') && path.slice(0, 2) === '\\\\\\\\') {\n      path = path.slice(2);\n      prefix = '//';\n    }\n  }\n\n  var segs = path.split(/[/\\\\]+/);\n  if (stripTrailing !== false && segs[segs.length - 1] === '') {\n    segs.pop();\n  }\n  return prefix + segs.join('/');\n};\n\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/normalize-path/index.js?");

/***/ }),

/***/ "./node_modules/object-hash/dist/object_hash.js":
/*!******************************************************!*\
  !*** ./node_modules/object-hash/dist/object_hash.js ***!
  \******************************************************/
/***/ ((module) => {

eval("!function(e){var t; true?module.exports=e():0}(function(){return function r(o,i,u){function s(n,e){if(!i[n]){if(!o[n]){var t=undefined;if(!e&&t)return require(n,!0);if(a)return a(n,!0);throw new Error(\"Cannot find module '\"+n+\"'\")}e=i[n]={exports:{}};o[n][0].call(e.exports,function(e){var t=o[n][1][e];return s(t||e)},e,e.exports,r,o,i,u)}return i[n].exports}for(var a=undefined,e=0;e<u.length;e++)s(u[e]);return s}({1:[function(w,b,m){!function(e,n,s,c,d,h,p,g,y){\"use strict\";var r=w(\"crypto\");function t(e,t){t=u(e,t);var n;return void 0===(n=\"passthrough\"!==t.algorithm?r.createHash(t.algorithm):new l).write&&(n.write=n.update,n.end=n.update),f(t,n).dispatch(e),n.update||n.end(\"\"),n.digest?n.digest(\"buffer\"===t.encoding?void 0:t.encoding):(e=n.read(),\"buffer\"!==t.encoding?e.toString(t.encoding):e)}(m=b.exports=t).sha1=function(e){return t(e)},m.keys=function(e){return t(e,{excludeValues:!0,algorithm:\"sha1\",encoding:\"hex\"})},m.MD5=function(e){return t(e,{algorithm:\"md5\",encoding:\"hex\"})},m.keysMD5=function(e){return t(e,{algorithm:\"md5\",encoding:\"hex\",excludeValues:!0})};var o=r.getHashes?r.getHashes().slice():[\"sha1\",\"md5\"],i=(o.push(\"passthrough\"),[\"buffer\",\"hex\",\"binary\",\"base64\"]);function u(e,t){var n={};if(n.algorithm=(t=t||{}).algorithm||\"sha1\",n.encoding=t.encoding||\"hex\",n.excludeValues=!!t.excludeValues,n.algorithm=n.algorithm.toLowerCase(),n.encoding=n.encoding.toLowerCase(),n.ignoreUnknown=!0===t.ignoreUnknown,n.respectType=!1!==t.respectType,n.respectFunctionNames=!1!==t.respectFunctionNames,n.respectFunctionProperties=!1!==t.respectFunctionProperties,n.unorderedArrays=!0===t.unorderedArrays,n.unorderedSets=!1!==t.unorderedSets,n.unorderedObjects=!1!==t.unorderedObjects,n.replacer=t.replacer||void 0,n.excludeKeys=t.excludeKeys||void 0,void 0===e)throw new Error(\"Object argument required.\");for(var r=0;r<o.length;++r)o[r].toLowerCase()===n.algorithm.toLowerCase()&&(n.algorithm=o[r]);if(-1===o.indexOf(n.algorithm))throw new Error('Algorithm \"'+n.algorithm+'\"  not supported. supported values: '+o.join(\", \"));if(-1===i.indexOf(n.encoding)&&\"passthrough\"!==n.algorithm)throw new Error('Encoding \"'+n.encoding+'\"  not supported. supported values: '+i.join(\", \"));return n}function a(e){if(\"function\"==typeof e)return null!=/^function\\s+\\w*\\s*\\(\\s*\\)\\s*{\\s+\\[native code\\]\\s+}$/i.exec(Function.prototype.toString.call(e))}function f(o,t,i){i=i||[];function u(e){return t.update?t.update(e,\"utf8\"):t.write(e,\"utf8\")}return{dispatch:function(e){return this[\"_\"+(null===(e=o.replacer?o.replacer(e):e)?\"null\":typeof e)](e)},_object:function(t){var n,e=Object.prototype.toString.call(t),r=/\\[object (.*)\\]/i.exec(e);r=(r=r?r[1]:\"unknown:[\"+e+\"]\").toLowerCase();if(0<=(e=i.indexOf(t)))return this.dispatch(\"[CIRCULAR:\"+e+\"]\");if(i.push(t),void 0!==s&&s.isBuffer&&s.isBuffer(t))return u(\"buffer:\"),u(t);if(\"object\"===r||\"function\"===r||\"asyncfunction\"===r)return e=Object.keys(t),o.unorderedObjects&&(e=e.sort()),!1===o.respectType||a(t)||e.splice(0,0,\"prototype\",\"__proto__\",\"constructor\"),o.excludeKeys&&(e=e.filter(function(e){return!o.excludeKeys(e)})),u(\"object:\"+e.length+\":\"),n=this,e.forEach(function(e){n.dispatch(e),u(\":\"),o.excludeValues||n.dispatch(t[e]),u(\",\")});if(!this[\"_\"+r]){if(o.ignoreUnknown)return u(\"[\"+r+\"]\");throw new Error('Unknown object type \"'+r+'\"')}this[\"_\"+r](t)},_array:function(e,t){t=void 0!==t?t:!1!==o.unorderedArrays;var n=this;if(u(\"array:\"+e.length+\":\"),!t||e.length<=1)return e.forEach(function(e){return n.dispatch(e)});var r=[],t=e.map(function(e){var t=new l,n=i.slice();return f(o,t,n).dispatch(e),r=r.concat(n.slice(i.length)),t.read().toString()});return i=i.concat(r),t.sort(),this._array(t,!1)},_date:function(e){return u(\"date:\"+e.toJSON())},_symbol:function(e){return u(\"symbol:\"+e.toString())},_error:function(e){return u(\"error:\"+e.toString())},_boolean:function(e){return u(\"bool:\"+e.toString())},_string:function(e){u(\"string:\"+e.length+\":\"),u(e.toString())},_function:function(e){u(\"fn:\"),a(e)?this.dispatch(\"[native]\"):this.dispatch(e.toString()),!1!==o.respectFunctionNames&&this.dispatch(\"function-name:\"+String(e.name)),o.respectFunctionProperties&&this._object(e)},_number:function(e){return u(\"number:\"+e.toString())},_xml:function(e){return u(\"xml:\"+e.toString())},_null:function(){return u(\"Null\")},_undefined:function(){return u(\"Undefined\")},_regexp:function(e){return u(\"regex:\"+e.toString())},_uint8array:function(e){return u(\"uint8array:\"),this.dispatch(Array.prototype.slice.call(e))},_uint8clampedarray:function(e){return u(\"uint8clampedarray:\"),this.dispatch(Array.prototype.slice.call(e))},_int8array:function(e){return u(\"int8array:\"),this.dispatch(Array.prototype.slice.call(e))},_uint16array:function(e){return u(\"uint16array:\"),this.dispatch(Array.prototype.slice.call(e))},_int16array:function(e){return u(\"int16array:\"),this.dispatch(Array.prototype.slice.call(e))},_uint32array:function(e){return u(\"uint32array:\"),this.dispatch(Array.prototype.slice.call(e))},_int32array:function(e){return u(\"int32array:\"),this.dispatch(Array.prototype.slice.call(e))},_float32array:function(e){return u(\"float32array:\"),this.dispatch(Array.prototype.slice.call(e))},_float64array:function(e){return u(\"float64array:\"),this.dispatch(Array.prototype.slice.call(e))},_arraybuffer:function(e){return u(\"arraybuffer:\"),this.dispatch(new Uint8Array(e))},_url:function(e){return u(\"url:\"+e.toString())},_map:function(e){u(\"map:\");e=Array.from(e);return this._array(e,!1!==o.unorderedSets)},_set:function(e){u(\"set:\");e=Array.from(e);return this._array(e,!1!==o.unorderedSets)},_file:function(e){return u(\"file:\"),this.dispatch([e.name,e.size,e.type,e.lastModfied])},_blob:function(){if(o.ignoreUnknown)return u(\"[blob]\");throw Error('Hashing Blob objects is currently not supported\\n(see https://github.com/puleos/object-hash/issues/26)\\nUse \"options.replacer\" or \"options.ignoreUnknown\"\\n')},_domwindow:function(){return u(\"domwindow\")},_bigint:function(e){return u(\"bigint:\"+e.toString())},_process:function(){return u(\"process\")},_timer:function(){return u(\"timer\")},_pipe:function(){return u(\"pipe\")},_tcp:function(){return u(\"tcp\")},_udp:function(){return u(\"udp\")},_tty:function(){return u(\"tty\")},_statwatcher:function(){return u(\"statwatcher\")},_securecontext:function(){return u(\"securecontext\")},_connection:function(){return u(\"connection\")},_zlib:function(){return u(\"zlib\")},_context:function(){return u(\"context\")},_nodescript:function(){return u(\"nodescript\")},_httpparser:function(){return u(\"httpparser\")},_dataview:function(){return u(\"dataview\")},_signal:function(){return u(\"signal\")},_fsevent:function(){return u(\"fsevent\")},_tlswrap:function(){return u(\"tlswrap\")}}}function l(){return{buf:\"\",write:function(e){this.buf+=e},end:function(e){this.buf+=e},read:function(){return this.buf}}}m.writeToStream=function(e,t,n){return void 0===n&&(n=t,t={}),f(t=u(e,t),n).dispatch(e)}}.call(this,w(\"lYpoI2\"),\"undefined\"!=typeof self?self:\"undefined\"!=typeof window?window:{},w(\"buffer\").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],\"/fake_9a5aa49d.js\",\"/\")},{buffer:3,crypto:5,lYpoI2:11}],2:[function(e,t,f){!function(e,t,n,r,o,i,u,s,a){!function(e){\"use strict\";var a=\"undefined\"!=typeof Uint8Array?Uint8Array:Array,t=\"+\".charCodeAt(0),n=\"/\".charCodeAt(0),r=\"0\".charCodeAt(0),o=\"a\".charCodeAt(0),i=\"A\".charCodeAt(0),u=\"-\".charCodeAt(0),s=\"_\".charCodeAt(0);function f(e){e=e.charCodeAt(0);return e===t||e===u?62:e===n||e===s?63:e<r?-1:e<r+10?e-r+26+26:e<i+26?e-i:e<o+26?e-o+26:void 0}e.toByteArray=function(e){var t,n;if(0<e.length%4)throw new Error(\"Invalid string. Length must be a multiple of 4\");var r=e.length,r=\"=\"===e.charAt(r-2)?2:\"=\"===e.charAt(r-1)?1:0,o=new a(3*e.length/4-r),i=0<r?e.length-4:e.length,u=0;function s(e){o[u++]=e}for(t=0;t<i;t+=4,0)s((16711680&(n=f(e.charAt(t))<<18|f(e.charAt(t+1))<<12|f(e.charAt(t+2))<<6|f(e.charAt(t+3))))>>16),s((65280&n)>>8),s(255&n);return 2==r?s(255&(n=f(e.charAt(t))<<2|f(e.charAt(t+1))>>4)):1==r&&(s((n=f(e.charAt(t))<<10|f(e.charAt(t+1))<<4|f(e.charAt(t+2))>>2)>>8&255),s(255&n)),o},e.fromByteArray=function(e){var t,n,r,o,i=e.length%3,u=\"\";function s(e){return\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\".charAt(e)}for(t=0,r=e.length-i;t<r;t+=3)n=(e[t]<<16)+(e[t+1]<<8)+e[t+2],u+=s((o=n)>>18&63)+s(o>>12&63)+s(o>>6&63)+s(63&o);switch(i){case 1:u=(u+=s((n=e[e.length-1])>>2))+s(n<<4&63)+\"==\";break;case 2:u=(u=(u+=s((n=(e[e.length-2]<<8)+e[e.length-1])>>10))+s(n>>4&63))+s(n<<2&63)+\"=\"}return u}}(void 0===f?this.base64js={}:f)}.call(this,e(\"lYpoI2\"),\"undefined\"!=typeof self?self:\"undefined\"!=typeof window?window:{},e(\"buffer\").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],\"/node_modules/gulp-browserify/node_modules/base64-js/lib/b64.js\",\"/node_modules/gulp-browserify/node_modules/base64-js/lib\")},{buffer:3,lYpoI2:11}],3:[function(O,e,H){!function(e,n,f,r,h,p,g,y,w){var a=O(\"base64-js\"),i=O(\"ieee754\");function f(e,t,n){if(!(this instanceof f))return new f(e,t,n);var r,o,i,u,s=typeof e;if(\"base64\"===t&&\"string\"==s)for(e=(u=e).trim?u.trim():u.replace(/^\\s+|\\s+$/g,\"\");e.length%4!=0;)e+=\"=\";if(\"number\"==s)r=j(e);else if(\"string\"==s)r=f.byteLength(e,t);else{if(\"object\"!=s)throw new Error(\"First argument needs to be a number, array or string.\");r=j(e.length)}if(f._useTypedArrays?o=f._augment(new Uint8Array(r)):((o=this).length=r,o._isBuffer=!0),f._useTypedArrays&&\"number\"==typeof e.byteLength)o._set(e);else if(C(u=e)||f.isBuffer(u)||u&&\"object\"==typeof u&&\"number\"==typeof u.length)for(i=0;i<r;i++)f.isBuffer(e)?o[i]=e.readUInt8(i):o[i]=e[i];else if(\"string\"==s)o.write(e,0,t);else if(\"number\"==s&&!f._useTypedArrays&&!n)for(i=0;i<r;i++)o[i]=0;return o}function b(e,t,n,r){return f._charsWritten=c(function(e){for(var t=[],n=0;n<e.length;n++)t.push(255&e.charCodeAt(n));return t}(t),e,n,r)}function m(e,t,n,r){return f._charsWritten=c(function(e){for(var t,n,r=[],o=0;o<e.length;o++)n=e.charCodeAt(o),t=n>>8,n=n%256,r.push(n),r.push(t);return r}(t),e,n,r)}function v(e,t,n){var r=\"\";n=Math.min(e.length,n);for(var o=t;o<n;o++)r+=String.fromCharCode(e[o]);return r}function o(e,t,n,r){r||(d(\"boolean\"==typeof n,\"missing or invalid endian\"),d(null!=t,\"missing offset\"),d(t+1<e.length,\"Trying to read beyond buffer length\"));var o,r=e.length;if(!(r<=t))return n?(o=e[t],t+1<r&&(o|=e[t+1]<<8)):(o=e[t]<<8,t+1<r&&(o|=e[t+1])),o}function u(e,t,n,r){r||(d(\"boolean\"==typeof n,\"missing or invalid endian\"),d(null!=t,\"missing offset\"),d(t+3<e.length,\"Trying to read beyond buffer length\"));var o,r=e.length;if(!(r<=t))return n?(t+2<r&&(o=e[t+2]<<16),t+1<r&&(o|=e[t+1]<<8),o|=e[t],t+3<r&&(o+=e[t+3]<<24>>>0)):(t+1<r&&(o=e[t+1]<<16),t+2<r&&(o|=e[t+2]<<8),t+3<r&&(o|=e[t+3]),o+=e[t]<<24>>>0),o}function _(e,t,n,r){if(r||(d(\"boolean\"==typeof n,\"missing or invalid endian\"),d(null!=t,\"missing offset\"),d(t+1<e.length,\"Trying to read beyond buffer length\")),!(e.length<=t))return r=o(e,t,n,!0),32768&r?-1*(65535-r+1):r}function E(e,t,n,r){if(r||(d(\"boolean\"==typeof n,\"missing or invalid endian\"),d(null!=t,\"missing offset\"),d(t+3<e.length,\"Trying to read beyond buffer length\")),!(e.length<=t))return r=u(e,t,n,!0),2147483648&r?-1*(4294967295-r+1):r}function I(e,t,n,r){return r||(d(\"boolean\"==typeof n,\"missing or invalid endian\"),d(t+3<e.length,\"Trying to read beyond buffer length\")),i.read(e,t,n,23,4)}function A(e,t,n,r){return r||(d(\"boolean\"==typeof n,\"missing or invalid endian\"),d(t+7<e.length,\"Trying to read beyond buffer length\")),i.read(e,t,n,52,8)}function s(e,t,n,r,o){o||(d(null!=t,\"missing value\"),d(\"boolean\"==typeof r,\"missing or invalid endian\"),d(null!=n,\"missing offset\"),d(n+1<e.length,\"trying to write beyond buffer length\"),Y(t,65535));o=e.length;if(!(o<=n))for(var i=0,u=Math.min(o-n,2);i<u;i++)e[n+i]=(t&255<<8*(r?i:1-i))>>>8*(r?i:1-i)}function l(e,t,n,r,o){o||(d(null!=t,\"missing value\"),d(\"boolean\"==typeof r,\"missing or invalid endian\"),d(null!=n,\"missing offset\"),d(n+3<e.length,\"trying to write beyond buffer length\"),Y(t,4294967295));o=e.length;if(!(o<=n))for(var i=0,u=Math.min(o-n,4);i<u;i++)e[n+i]=t>>>8*(r?i:3-i)&255}function B(e,t,n,r,o){o||(d(null!=t,\"missing value\"),d(\"boolean\"==typeof r,\"missing or invalid endian\"),d(null!=n,\"missing offset\"),d(n+1<e.length,\"Trying to write beyond buffer length\"),F(t,32767,-32768)),e.length<=n||s(e,0<=t?t:65535+t+1,n,r,o)}function L(e,t,n,r,o){o||(d(null!=t,\"missing value\"),d(\"boolean\"==typeof r,\"missing or invalid endian\"),d(null!=n,\"missing offset\"),d(n+3<e.length,\"Trying to write beyond buffer length\"),F(t,2147483647,-2147483648)),e.length<=n||l(e,0<=t?t:4294967295+t+1,n,r,o)}function U(e,t,n,r,o){o||(d(null!=t,\"missing value\"),d(\"boolean\"==typeof r,\"missing or invalid endian\"),d(null!=n,\"missing offset\"),d(n+3<e.length,\"Trying to write beyond buffer length\"),D(t,34028234663852886e22,-34028234663852886e22)),e.length<=n||i.write(e,t,n,r,23,4)}function x(e,t,n,r,o){o||(d(null!=t,\"missing value\"),d(\"boolean\"==typeof r,\"missing or invalid endian\"),d(null!=n,\"missing offset\"),d(n+7<e.length,\"Trying to write beyond buffer length\"),D(t,17976931348623157e292,-17976931348623157e292)),e.length<=n||i.write(e,t,n,r,52,8)}H.Buffer=f,H.SlowBuffer=f,H.INSPECT_MAX_BYTES=50,f.poolSize=8192,f._useTypedArrays=function(){try{var e=new ArrayBuffer(0),t=new Uint8Array(e);return t.foo=function(){return 42},42===t.foo()&&\"function\"==typeof t.subarray}catch(e){return!1}}(),f.isEncoding=function(e){switch(String(e).toLowerCase()){case\"hex\":case\"utf8\":case\"utf-8\":case\"ascii\":case\"binary\":case\"base64\":case\"raw\":case\"ucs2\":case\"ucs-2\":case\"utf16le\":case\"utf-16le\":return!0;default:return!1}},f.isBuffer=function(e){return!(null==e||!e._isBuffer)},f.byteLength=function(e,t){var n;switch(e+=\"\",t||\"utf8\"){case\"hex\":n=e.length/2;break;case\"utf8\":case\"utf-8\":n=T(e).length;break;case\"ascii\":case\"binary\":case\"raw\":n=e.length;break;case\"base64\":n=M(e).length;break;case\"ucs2\":case\"ucs-2\":case\"utf16le\":case\"utf-16le\":n=2*e.length;break;default:throw new Error(\"Unknown encoding\")}return n},f.concat=function(e,t){if(d(C(e),\"Usage: Buffer.concat(list, [totalLength])\\nlist should be an Array.\"),0===e.length)return new f(0);if(1===e.length)return e[0];if(\"number\"!=typeof t)for(o=t=0;o<e.length;o++)t+=e[o].length;for(var n=new f(t),r=0,o=0;o<e.length;o++){var i=e[o];i.copy(n,r),r+=i.length}return n},f.prototype.write=function(e,t,n,r){isFinite(t)?isFinite(n)||(r=n,n=void 0):(a=r,r=t,t=n,n=a),t=Number(t)||0;var o,i,u,s,a=this.length-t;switch((!n||a<(n=Number(n)))&&(n=a),r=String(r||\"utf8\").toLowerCase()){case\"hex\":o=function(e,t,n,r){n=Number(n)||0;var o=e.length-n;(!r||o<(r=Number(r)))&&(r=o),d((o=t.length)%2==0,\"Invalid hex string\"),o/2<r&&(r=o/2);for(var i=0;i<r;i++){var u=parseInt(t.substr(2*i,2),16);d(!isNaN(u),\"Invalid hex string\"),e[n+i]=u}return f._charsWritten=2*i,i}(this,e,t,n);break;case\"utf8\":case\"utf-8\":i=this,u=t,s=n,o=f._charsWritten=c(T(e),i,u,s);break;case\"ascii\":case\"binary\":o=b(this,e,t,n);break;case\"base64\":i=this,u=t,s=n,o=f._charsWritten=c(M(e),i,u,s);break;case\"ucs2\":case\"ucs-2\":case\"utf16le\":case\"utf-16le\":o=m(this,e,t,n);break;default:throw new Error(\"Unknown encoding\")}return o},f.prototype.toString=function(e,t,n){var r,o,i,u,s=this;if(e=String(e||\"utf8\").toLowerCase(),t=Number(t)||0,(n=void 0!==n?Number(n):s.length)===t)return\"\";switch(e){case\"hex\":r=function(e,t,n){var r=e.length;(!t||t<0)&&(t=0);(!n||n<0||r<n)&&(n=r);for(var o=\"\",i=t;i<n;i++)o+=k(e[i]);return o}(s,t,n);break;case\"utf8\":case\"utf-8\":r=function(e,t,n){var r=\"\",o=\"\";n=Math.min(e.length,n);for(var i=t;i<n;i++)e[i]<=127?(r+=N(o)+String.fromCharCode(e[i]),o=\"\"):o+=\"%\"+e[i].toString(16);return r+N(o)}(s,t,n);break;case\"ascii\":case\"binary\":r=v(s,t,n);break;case\"base64\":o=s,u=n,r=0===(i=t)&&u===o.length?a.fromByteArray(o):a.fromByteArray(o.slice(i,u));break;case\"ucs2\":case\"ucs-2\":case\"utf16le\":case\"utf-16le\":r=function(e,t,n){for(var r=e.slice(t,n),o=\"\",i=0;i<r.length;i+=2)o+=String.fromCharCode(r[i]+256*r[i+1]);return o}(s,t,n);break;default:throw new Error(\"Unknown encoding\")}return r},f.prototype.toJSON=function(){return{type:\"Buffer\",data:Array.prototype.slice.call(this._arr||this,0)}},f.prototype.copy=function(e,t,n,r){if(t=t||0,(r=r||0===r?r:this.length)!==(n=n||0)&&0!==e.length&&0!==this.length){d(n<=r,\"sourceEnd < sourceStart\"),d(0<=t&&t<e.length,\"targetStart out of bounds\"),d(0<=n&&n<this.length,\"sourceStart out of bounds\"),d(0<=r&&r<=this.length,\"sourceEnd out of bounds\"),r>this.length&&(r=this.length);var o=(r=e.length-t<r-n?e.length-t+n:r)-n;if(o<100||!f._useTypedArrays)for(var i=0;i<o;i++)e[i+t]=this[i+n];else e._set(this.subarray(n,n+o),t)}},f.prototype.slice=function(e,t){var n=this.length;if(e=S(e,n,0),t=S(t,n,n),f._useTypedArrays)return f._augment(this.subarray(e,t));for(var r=t-e,o=new f(r,void 0,!0),i=0;i<r;i++)o[i]=this[i+e];return o},f.prototype.get=function(e){return console.log(\".get() is deprecated. Access using array indexes instead.\"),this.readUInt8(e)},f.prototype.set=function(e,t){return console.log(\".set() is deprecated. Access using array indexes instead.\"),this.writeUInt8(e,t)},f.prototype.readUInt8=function(e,t){if(t||(d(null!=e,\"missing offset\"),d(e<this.length,\"Trying to read beyond buffer length\")),!(e>=this.length))return this[e]},f.prototype.readUInt16LE=function(e,t){return o(this,e,!0,t)},f.prototype.readUInt16BE=function(e,t){return o(this,e,!1,t)},f.prototype.readUInt32LE=function(e,t){return u(this,e,!0,t)},f.prototype.readUInt32BE=function(e,t){return u(this,e,!1,t)},f.prototype.readInt8=function(e,t){if(t||(d(null!=e,\"missing offset\"),d(e<this.length,\"Trying to read beyond buffer length\")),!(e>=this.length))return 128&this[e]?-1*(255-this[e]+1):this[e]},f.prototype.readInt16LE=function(e,t){return _(this,e,!0,t)},f.prototype.readInt16BE=function(e,t){return _(this,e,!1,t)},f.prototype.readInt32LE=function(e,t){return E(this,e,!0,t)},f.prototype.readInt32BE=function(e,t){return E(this,e,!1,t)},f.prototype.readFloatLE=function(e,t){return I(this,e,!0,t)},f.prototype.readFloatBE=function(e,t){return I(this,e,!1,t)},f.prototype.readDoubleLE=function(e,t){return A(this,e,!0,t)},f.prototype.readDoubleBE=function(e,t){return A(this,e,!1,t)},f.prototype.writeUInt8=function(e,t,n){n||(d(null!=e,\"missing value\"),d(null!=t,\"missing offset\"),d(t<this.length,\"trying to write beyond buffer length\"),Y(e,255)),t>=this.length||(this[t]=e)},f.prototype.writeUInt16LE=function(e,t,n){s(this,e,t,!0,n)},f.prototype.writeUInt16BE=function(e,t,n){s(this,e,t,!1,n)},f.prototype.writeUInt32LE=function(e,t,n){l(this,e,t,!0,n)},f.prototype.writeUInt32BE=function(e,t,n){l(this,e,t,!1,n)},f.prototype.writeInt8=function(e,t,n){n||(d(null!=e,\"missing value\"),d(null!=t,\"missing offset\"),d(t<this.length,\"Trying to write beyond buffer length\"),F(e,127,-128)),t>=this.length||(0<=e?this.writeUInt8(e,t,n):this.writeUInt8(255+e+1,t,n))},f.prototype.writeInt16LE=function(e,t,n){B(this,e,t,!0,n)},f.prototype.writeInt16BE=function(e,t,n){B(this,e,t,!1,n)},f.prototype.writeInt32LE=function(e,t,n){L(this,e,t,!0,n)},f.prototype.writeInt32BE=function(e,t,n){L(this,e,t,!1,n)},f.prototype.writeFloatLE=function(e,t,n){U(this,e,t,!0,n)},f.prototype.writeFloatBE=function(e,t,n){U(this,e,t,!1,n)},f.prototype.writeDoubleLE=function(e,t,n){x(this,e,t,!0,n)},f.prototype.writeDoubleBE=function(e,t,n){x(this,e,t,!1,n)},f.prototype.fill=function(e,t,n){if(t=t||0,n=n||this.length,d(\"number\"==typeof(e=\"string\"==typeof(e=e||0)?e.charCodeAt(0):e)&&!isNaN(e),\"value is not a number\"),d(t<=n,\"end < start\"),n!==t&&0!==this.length){d(0<=t&&t<this.length,\"start out of bounds\"),d(0<=n&&n<=this.length,\"end out of bounds\");for(var r=t;r<n;r++)this[r]=e}},f.prototype.inspect=function(){for(var e=[],t=this.length,n=0;n<t;n++)if(e[n]=k(this[n]),n===H.INSPECT_MAX_BYTES){e[n+1]=\"...\";break}return\"<Buffer \"+e.join(\" \")+\">\"},f.prototype.toArrayBuffer=function(){if(\"undefined\"==typeof Uint8Array)throw new Error(\"Buffer.toArrayBuffer not supported in this browser\");if(f._useTypedArrays)return new f(this).buffer;for(var e=new Uint8Array(this.length),t=0,n=e.length;t<n;t+=1)e[t]=this[t];return e.buffer};var t=f.prototype;function S(e,t,n){return\"number\"!=typeof e?n:t<=(e=~~e)?t:0<=e||0<=(e+=t)?e:0}function j(e){return(e=~~Math.ceil(+e))<0?0:e}function C(e){return(Array.isArray||function(e){return\"[object Array]\"===Object.prototype.toString.call(e)})(e)}function k(e){return e<16?\"0\"+e.toString(16):e.toString(16)}function T(e){for(var t=[],n=0;n<e.length;n++){var r=e.charCodeAt(n);if(r<=127)t.push(e.charCodeAt(n));else for(var o=n,i=(55296<=r&&r<=57343&&n++,encodeURIComponent(e.slice(o,n+1)).substr(1).split(\"%\")),u=0;u<i.length;u++)t.push(parseInt(i[u],16))}return t}function M(e){return a.toByteArray(e)}function c(e,t,n,r){for(var o=0;o<r&&!(o+n>=t.length||o>=e.length);o++)t[o+n]=e[o];return o}function N(e){try{return decodeURIComponent(e)}catch(e){return String.fromCharCode(65533)}}function Y(e,t){d(\"number\"==typeof e,\"cannot write a non-number as a number\"),d(0<=e,\"specified a negative value for writing an unsigned value\"),d(e<=t,\"value is larger than maximum value for type\"),d(Math.floor(e)===e,\"value has a fractional component\")}function F(e,t,n){d(\"number\"==typeof e,\"cannot write a non-number as a number\"),d(e<=t,\"value larger than maximum allowed value\"),d(n<=e,\"value smaller than minimum allowed value\"),d(Math.floor(e)===e,\"value has a fractional component\")}function D(e,t,n){d(\"number\"==typeof e,\"cannot write a non-number as a number\"),d(e<=t,\"value larger than maximum allowed value\"),d(n<=e,\"value smaller than minimum allowed value\")}function d(e,t){if(!e)throw new Error(t||\"Failed assertion\")}f._augment=function(e){return e._isBuffer=!0,e._get=e.get,e._set=e.set,e.get=t.get,e.set=t.set,e.write=t.write,e.toString=t.toString,e.toLocaleString=t.toString,e.toJSON=t.toJSON,e.copy=t.copy,e.slice=t.slice,e.readUInt8=t.readUInt8,e.readUInt16LE=t.readUInt16LE,e.readUInt16BE=t.readUInt16BE,e.readUInt32LE=t.readUInt32LE,e.readUInt32BE=t.readUInt32BE,e.readInt8=t.readInt8,e.readInt16LE=t.readInt16LE,e.readInt16BE=t.readInt16BE,e.readInt32LE=t.readInt32LE,e.readInt32BE=t.readInt32BE,e.readFloatLE=t.readFloatLE,e.readFloatBE=t.readFloatBE,e.readDoubleLE=t.readDoubleLE,e.readDoubleBE=t.readDoubleBE,e.writeUInt8=t.writeUInt8,e.writeUInt16LE=t.writeUInt16LE,e.writeUInt16BE=t.writeUInt16BE,e.writeUInt32LE=t.writeUInt32LE,e.writeUInt32BE=t.writeUInt32BE,e.writeInt8=t.writeInt8,e.writeInt16LE=t.writeInt16LE,e.writeInt16BE=t.writeInt16BE,e.writeInt32LE=t.writeInt32LE,e.writeInt32BE=t.writeInt32BE,e.writeFloatLE=t.writeFloatLE,e.writeFloatBE=t.writeFloatBE,e.writeDoubleLE=t.writeDoubleLE,e.writeDoubleBE=t.writeDoubleBE,e.fill=t.fill,e.inspect=t.inspect,e.toArrayBuffer=t.toArrayBuffer,e}}.call(this,O(\"lYpoI2\"),\"undefined\"!=typeof self?self:\"undefined\"!=typeof window?window:{},O(\"buffer\").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],\"/node_modules/gulp-browserify/node_modules/buffer/index.js\",\"/node_modules/gulp-browserify/node_modules/buffer\")},{\"base64-js\":2,buffer:3,ieee754:10,lYpoI2:11}],4:[function(c,d,e){!function(e,t,a,n,r,o,i,u,s){var a=c(\"buffer\").Buffer,f=4,l=new a(f);l.fill(0);d.exports={hash:function(e,t,n,r){for(var o=t(function(e,t){e.length%f!=0&&(n=e.length+(f-e.length%f),e=a.concat([e,l],n));for(var n,r=[],o=t?e.readInt32BE:e.readInt32LE,i=0;i<e.length;i+=f)r.push(o.call(e,i));return r}(e=a.isBuffer(e)?e:new a(e),r),8*e.length),t=r,i=new a(n),u=t?i.writeInt32BE:i.writeInt32LE,s=0;s<o.length;s++)u.call(i,o[s],4*s,!0);return i}}}.call(this,c(\"lYpoI2\"),\"undefined\"!=typeof self?self:\"undefined\"!=typeof window?window:{},c(\"buffer\").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],\"/node_modules/gulp-browserify/node_modules/crypto-browserify/helpers.js\",\"/node_modules/gulp-browserify/node_modules/crypto-browserify\")},{buffer:3,lYpoI2:11}],5:[function(v,e,_){!function(l,c,u,d,h,p,g,y,w){var u=v(\"buffer\").Buffer,e=v(\"./sha\"),t=v(\"./sha256\"),n=v(\"./rng\"),b={sha1:e,sha256:t,md5:v(\"./md5\")},s=64,a=new u(s);function r(e,n){var r=b[e=e||\"sha1\"],o=[];return r||i(\"algorithm:\",e,\"is not yet supported\"),{update:function(e){return u.isBuffer(e)||(e=new u(e)),o.push(e),e.length,this},digest:function(e){var t=u.concat(o),t=n?function(e,t,n){u.isBuffer(t)||(t=new u(t)),u.isBuffer(n)||(n=new u(n)),t.length>s?t=e(t):t.length<s&&(t=u.concat([t,a],s));for(var r=new u(s),o=new u(s),i=0;i<s;i++)r[i]=54^t[i],o[i]=92^t[i];return n=e(u.concat([r,n])),e(u.concat([o,n]))}(r,n,t):r(t);return o=null,e?t.toString(e):t}}}function i(){var e=[].slice.call(arguments).join(\" \");throw new Error([e,\"we accept pull requests\",\"http://github.com/dominictarr/crypto-browserify\"].join(\"\\n\"))}a.fill(0),_.createHash=function(e){return r(e)},_.createHmac=r,_.randomBytes=function(e,t){if(!t||!t.call)return new u(n(e));try{t.call(this,void 0,new u(n(e)))}catch(e){t(e)}};var o,f=[\"createCredentials\",\"createCipher\",\"createCipheriv\",\"createDecipher\",\"createDecipheriv\",\"createSign\",\"createVerify\",\"createDiffieHellman\",\"pbkdf2\"],m=function(e){_[e]=function(){i(\"sorry,\",e,\"is not implemented yet\")}};for(o in f)m(f[o],o)}.call(this,v(\"lYpoI2\"),\"undefined\"!=typeof self?self:\"undefined\"!=typeof window?window:{},v(\"buffer\").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],\"/node_modules/gulp-browserify/node_modules/crypto-browserify/index.js\",\"/node_modules/gulp-browserify/node_modules/crypto-browserify\")},{\"./md5\":6,\"./rng\":7,\"./sha\":8,\"./sha256\":9,buffer:3,lYpoI2:11}],6:[function(w,b,e){!function(e,r,o,i,u,a,f,l,y){var t=w(\"./helpers\");function n(e,t){e[t>>5]|=128<<t%32,e[14+(t+64>>>9<<4)]=t;for(var n=1732584193,r=-271733879,o=-1732584194,i=271733878,u=0;u<e.length;u+=16){var s=n,a=r,f=o,l=i,n=c(n,r,o,i,e[u+0],7,-680876936),i=c(i,n,r,o,e[u+1],12,-389564586),o=c(o,i,n,r,e[u+2],17,606105819),r=c(r,o,i,n,e[u+3],22,-1044525330);n=c(n,r,o,i,e[u+4],7,-176418897),i=c(i,n,r,o,e[u+5],12,1200080426),o=c(o,i,n,r,e[u+6],17,-1473231341),r=c(r,o,i,n,e[u+7],22,-45705983),n=c(n,r,o,i,e[u+8],7,1770035416),i=c(i,n,r,o,e[u+9],12,-1958414417),o=c(o,i,n,r,e[u+10],17,-42063),r=c(r,o,i,n,e[u+11],22,-1990404162),n=c(n,r,o,i,e[u+12],7,1804603682),i=c(i,n,r,o,e[u+13],12,-40341101),o=c(o,i,n,r,e[u+14],17,-1502002290),n=d(n,r=c(r,o,i,n,e[u+15],22,1236535329),o,i,e[u+1],5,-165796510),i=d(i,n,r,o,e[u+6],9,-1069501632),o=d(o,i,n,r,e[u+11],14,643717713),r=d(r,o,i,n,e[u+0],20,-373897302),n=d(n,r,o,i,e[u+5],5,-701558691),i=d(i,n,r,o,e[u+10],9,38016083),o=d(o,i,n,r,e[u+15],14,-660478335),r=d(r,o,i,n,e[u+4],20,-405537848),n=d(n,r,o,i,e[u+9],5,568446438),i=d(i,n,r,o,e[u+14],9,-1019803690),o=d(o,i,n,r,e[u+3],14,-187363961),r=d(r,o,i,n,e[u+8],20,1163531501),n=d(n,r,o,i,e[u+13],5,-1444681467),i=d(i,n,r,o,e[u+2],9,-51403784),o=d(o,i,n,r,e[u+7],14,1735328473),n=h(n,r=d(r,o,i,n,e[u+12],20,-1926607734),o,i,e[u+5],4,-378558),i=h(i,n,r,o,e[u+8],11,-2022574463),o=h(o,i,n,r,e[u+11],16,1839030562),r=h(r,o,i,n,e[u+14],23,-35309556),n=h(n,r,o,i,e[u+1],4,-1530992060),i=h(i,n,r,o,e[u+4],11,1272893353),o=h(o,i,n,r,e[u+7],16,-155497632),r=h(r,o,i,n,e[u+10],23,-1094730640),n=h(n,r,o,i,e[u+13],4,681279174),i=h(i,n,r,o,e[u+0],11,-358537222),o=h(o,i,n,r,e[u+3],16,-722521979),r=h(r,o,i,n,e[u+6],23,76029189),n=h(n,r,o,i,e[u+9],4,-640364487),i=h(i,n,r,o,e[u+12],11,-421815835),o=h(o,i,n,r,e[u+15],16,530742520),n=p(n,r=h(r,o,i,n,e[u+2],23,-995338651),o,i,e[u+0],6,-198630844),i=p(i,n,r,o,e[u+7],10,1126891415),o=p(o,i,n,r,e[u+14],15,-1416354905),r=p(r,o,i,n,e[u+5],21,-57434055),n=p(n,r,o,i,e[u+12],6,1700485571),i=p(i,n,r,o,e[u+3],10,-1894986606),o=p(o,i,n,r,e[u+10],15,-1051523),r=p(r,o,i,n,e[u+1],21,-2054922799),n=p(n,r,o,i,e[u+8],6,1873313359),i=p(i,n,r,o,e[u+15],10,-30611744),o=p(o,i,n,r,e[u+6],15,-1560198380),r=p(r,o,i,n,e[u+13],21,1309151649),n=p(n,r,o,i,e[u+4],6,-145523070),i=p(i,n,r,o,e[u+11],10,-1120210379),o=p(o,i,n,r,e[u+2],15,718787259),r=p(r,o,i,n,e[u+9],21,-343485551),n=g(n,s),r=g(r,a),o=g(o,f),i=g(i,l)}return Array(n,r,o,i)}function s(e,t,n,r,o,i){return g((t=g(g(t,e),g(r,i)))<<o|t>>>32-o,n)}function c(e,t,n,r,o,i,u){return s(t&n|~t&r,e,t,o,i,u)}function d(e,t,n,r,o,i,u){return s(t&r|n&~r,e,t,o,i,u)}function h(e,t,n,r,o,i,u){return s(t^n^r,e,t,o,i,u)}function p(e,t,n,r,o,i,u){return s(n^(t|~r),e,t,o,i,u)}function g(e,t){var n=(65535&e)+(65535&t);return(e>>16)+(t>>16)+(n>>16)<<16|65535&n}b.exports=function(e){return t.hash(e,n,16)}}.call(this,w(\"lYpoI2\"),\"undefined\"!=typeof self?self:\"undefined\"!=typeof window?window:{},w(\"buffer\").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],\"/node_modules/gulp-browserify/node_modules/crypto-browserify/md5.js\",\"/node_modules/gulp-browserify/node_modules/crypto-browserify\")},{\"./helpers\":4,buffer:3,lYpoI2:11}],7:[function(e,l,t){!function(e,t,n,r,o,i,u,s,f){var a;l.exports=a||function(e){for(var t,n=new Array(e),r=0;r<e;r++)0==(3&r)&&(t=4294967296*Math.random()),n[r]=t>>>((3&r)<<3)&255;return n}}.call(this,e(\"lYpoI2\"),\"undefined\"!=typeof self?self:\"undefined\"!=typeof window?window:{},e(\"buffer\").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],\"/node_modules/gulp-browserify/node_modules/crypto-browserify/rng.js\",\"/node_modules/gulp-browserify/node_modules/crypto-browserify\")},{buffer:3,lYpoI2:11}],8:[function(c,d,e){!function(e,t,n,r,o,s,a,f,l){var i=c(\"./helpers\");function u(l,c){l[c>>5]|=128<<24-c%32,l[15+(c+64>>9<<4)]=c;for(var e,t,n,r=Array(80),o=1732584193,i=-271733879,u=-1732584194,s=271733878,d=-1009589776,h=0;h<l.length;h+=16){for(var p=o,g=i,y=u,w=s,b=d,a=0;a<80;a++){r[a]=a<16?l[h+a]:v(r[a-3]^r[a-8]^r[a-14]^r[a-16],1);var f=m(m(v(o,5),(f=i,t=u,n=s,(e=a)<20?f&t|~f&n:!(e<40)&&e<60?f&t|f&n|t&n:f^t^n)),m(m(d,r[a]),(e=a)<20?1518500249:e<40?1859775393:e<60?-1894007588:-899497514)),d=s,s=u,u=v(i,30),i=o,o=f}o=m(o,p),i=m(i,g),u=m(u,y),s=m(s,w),d=m(d,b)}return Array(o,i,u,s,d)}function m(e,t){var n=(65535&e)+(65535&t);return(e>>16)+(t>>16)+(n>>16)<<16|65535&n}function v(e,t){return e<<t|e>>>32-t}d.exports=function(e){return i.hash(e,u,20,!0)}}.call(this,c(\"lYpoI2\"),\"undefined\"!=typeof self?self:\"undefined\"!=typeof window?window:{},c(\"buffer\").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],\"/node_modules/gulp-browserify/node_modules/crypto-browserify/sha.js\",\"/node_modules/gulp-browserify/node_modules/crypto-browserify\")},{\"./helpers\":4,buffer:3,lYpoI2:11}],9:[function(c,d,e){!function(e,t,n,r,u,s,a,f,l){function b(e,t){var n=(65535&e)+(65535&t);return(e>>16)+(t>>16)+(n>>16)<<16|65535&n}function o(e,l){var c,d=new Array(1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298),t=new Array(1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225),n=new Array(64);e[l>>5]|=128<<24-l%32,e[15+(l+64>>9<<4)]=l;for(var r,o,h=0;h<e.length;h+=16){for(var i=t[0],u=t[1],s=t[2],p=t[3],a=t[4],g=t[5],y=t[6],w=t[7],f=0;f<64;f++)n[f]=f<16?e[f+h]:b(b(b((o=n[f-2],m(o,17)^m(o,19)^v(o,10)),n[f-7]),(o=n[f-15],m(o,7)^m(o,18)^v(o,3))),n[f-16]),c=b(b(b(b(w,m(o=a,6)^m(o,11)^m(o,25)),a&g^~a&y),d[f]),n[f]),r=b(m(r=i,2)^m(r,13)^m(r,22),i&u^i&s^u&s),w=y,y=g,g=a,a=b(p,c),p=s,s=u,u=i,i=b(c,r);t[0]=b(i,t[0]),t[1]=b(u,t[1]),t[2]=b(s,t[2]),t[3]=b(p,t[3]),t[4]=b(a,t[4]),t[5]=b(g,t[5]),t[6]=b(y,t[6]),t[7]=b(w,t[7])}return t}var i=c(\"./helpers\"),m=function(e,t){return e>>>t|e<<32-t},v=function(e,t){return e>>>t};d.exports=function(e){return i.hash(e,o,32,!0)}}.call(this,c(\"lYpoI2\"),\"undefined\"!=typeof self?self:\"undefined\"!=typeof window?window:{},c(\"buffer\").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],\"/node_modules/gulp-browserify/node_modules/crypto-browserify/sha256.js\",\"/node_modules/gulp-browserify/node_modules/crypto-browserify\")},{\"./helpers\":4,buffer:3,lYpoI2:11}],10:[function(e,t,f){!function(e,t,n,r,o,i,u,s,a){f.read=function(e,t,n,r,o){var i,u,l=8*o-r-1,c=(1<<l)-1,d=c>>1,s=-7,a=n?o-1:0,f=n?-1:1,o=e[t+a];for(a+=f,i=o&(1<<-s)-1,o>>=-s,s+=l;0<s;i=256*i+e[t+a],a+=f,s-=8);for(u=i&(1<<-s)-1,i>>=-s,s+=r;0<s;u=256*u+e[t+a],a+=f,s-=8);if(0===i)i=1-d;else{if(i===c)return u?NaN:1/0*(o?-1:1);u+=Math.pow(2,r),i-=d}return(o?-1:1)*u*Math.pow(2,i-r)},f.write=function(e,t,l,n,r,c){var o,i,u=8*c-r-1,s=(1<<u)-1,a=s>>1,d=23===r?Math.pow(2,-24)-Math.pow(2,-77):0,f=n?0:c-1,h=n?1:-1,c=t<0||0===t&&1/t<0?1:0;for(t=Math.abs(t),isNaN(t)||t===1/0?(i=isNaN(t)?1:0,o=s):(o=Math.floor(Math.log(t)/Math.LN2),t*(n=Math.pow(2,-o))<1&&(o--,n*=2),2<=(t+=1<=o+a?d/n:d*Math.pow(2,1-a))*n&&(o++,n/=2),s<=o+a?(i=0,o=s):1<=o+a?(i=(t*n-1)*Math.pow(2,r),o+=a):(i=t*Math.pow(2,a-1)*Math.pow(2,r),o=0));8<=r;e[l+f]=255&i,f+=h,i/=256,r-=8);for(o=o<<r|i,u+=r;0<u;e[l+f]=255&o,f+=h,o/=256,u-=8);e[l+f-h]|=128*c}}.call(this,e(\"lYpoI2\"),\"undefined\"!=typeof self?self:\"undefined\"!=typeof window?window:{},e(\"buffer\").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],\"/node_modules/gulp-browserify/node_modules/ieee754/index.js\",\"/node_modules/gulp-browserify/node_modules/ieee754\")},{buffer:3,lYpoI2:11}],11:[function(e,h,t){!function(e,t,n,r,o,f,l,c,d){var i,u,s;function a(){}(e=h.exports={}).nextTick=(u=\"undefined\"!=typeof window&&window.setImmediate,s=\"undefined\"!=typeof window&&window.postMessage&&window.addEventListener,u?function(e){return window.setImmediate(e)}:s?(i=[],window.addEventListener(\"message\",function(e){var t=e.source;t!==window&&null!==t||\"process-tick\"!==e.data||(e.stopPropagation(),0<i.length&&i.shift()())},!0),function(e){i.push(e),window.postMessage(\"process-tick\",\"*\")}):function(e){setTimeout(e,0)}),e.title=\"browser\",e.browser=!0,e.env={},e.argv=[],e.on=a,e.addListener=a,e.once=a,e.off=a,e.removeListener=a,e.removeAllListeners=a,e.emit=a,e.binding=function(e){throw new Error(\"process.binding is not supported\")},e.cwd=function(){return\"/\"},e.chdir=function(e){throw new Error(\"process.chdir is not supported\")}}.call(this,e(\"lYpoI2\"),\"undefined\"!=typeof self?self:\"undefined\"!=typeof window?window:{},e(\"buffer\").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],\"/node_modules/gulp-browserify/node_modules/process/browser.js\",\"/node_modules/gulp-browserify/node_modules/process\")},{buffer:3,lYpoI2:11}]},{},[1])(1)});\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/object-hash/dist/object_hash.js?");

/***/ }),

/***/ "./node_modules/path-parse/index.js":
/*!******************************************!*\
  !*** ./node_modules/path-parse/index.js ***!
  \******************************************/
/***/ ((module) => {

"use strict";
eval("\n\nvar isWindows = process.platform === 'win32';\n\n// Regex to split a windows path into into [dir, root, basename, name, ext]\nvar splitWindowsRe =\n    /^(((?:[a-zA-Z]:|[\\\\\\/]{2}[^\\\\\\/]+[\\\\\\/]+[^\\\\\\/]+)?[\\\\\\/]?)(?:[^\\\\\\/]*[\\\\\\/])*)((\\.{1,2}|[^\\\\\\/]+?|)(\\.[^.\\/\\\\]*|))[\\\\\\/]*$/;\n\nvar win32 = {};\n\nfunction win32SplitPath(filename) {\n  return splitWindowsRe.exec(filename).slice(1);\n}\n\nwin32.parse = function(pathString) {\n  if (typeof pathString !== 'string') {\n    throw new TypeError(\n        \"Parameter 'pathString' must be a string, not \" + typeof pathString\n    );\n  }\n  var allParts = win32SplitPath(pathString);\n  if (!allParts || allParts.length !== 5) {\n    throw new TypeError(\"Invalid path '\" + pathString + \"'\");\n  }\n  return {\n    root: allParts[1],\n    dir: allParts[0] === allParts[1] ? allParts[0] : allParts[0].slice(0, -1),\n    base: allParts[2],\n    ext: allParts[4],\n    name: allParts[3]\n  };\n};\n\n\n\n// Split a filename into [dir, root, basename, name, ext], unix version\n// 'root' is just a slash, or nothing.\nvar splitPathRe =\n    /^((\\/?)(?:[^\\/]*\\/)*)((\\.{1,2}|[^\\/]+?|)(\\.[^.\\/]*|))[\\/]*$/;\nvar posix = {};\n\n\nfunction posixSplitPath(filename) {\n  return splitPathRe.exec(filename).slice(1);\n}\n\n\nposix.parse = function(pathString) {\n  if (typeof pathString !== 'string') {\n    throw new TypeError(\n        \"Parameter 'pathString' must be a string, not \" + typeof pathString\n    );\n  }\n  var allParts = posixSplitPath(pathString);\n  if (!allParts || allParts.length !== 5) {\n    throw new TypeError(\"Invalid path '\" + pathString + \"'\");\n  }\n  \n  return {\n    root: allParts[1],\n    dir: allParts[0].slice(0, -1),\n    base: allParts[2],\n    ext: allParts[4],\n    name: allParts[3],\n  };\n};\n\n\nif (isWindows)\n  module.exports = win32.parse;\nelse /* posix */\n  module.exports = posix.parse;\n\nmodule.exports.posix = posix.parse;\nmodule.exports.win32 = win32.parse;\n\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/path-parse/index.js?");

/***/ }),

/***/ "./node_modules/picocolors/picocolors.browser.js":
/*!*******************************************************!*\
  !*** ./node_modules/picocolors/picocolors.browser.js ***!
  \*******************************************************/
/***/ ((module) => {

eval("var x=String;\nvar create=function() {return {isColorSupported:false,reset:x,bold:x,dim:x,italic:x,underline:x,inverse:x,hidden:x,strikethrough:x,black:x,red:x,green:x,yellow:x,blue:x,magenta:x,cyan:x,white:x,gray:x,bgBlack:x,bgRed:x,bgGreen:x,bgYellow:x,bgBlue:x,bgMagenta:x,bgCyan:x,bgWhite:x}};\nmodule.exports=create();\nmodule.exports.createColors = create;\n\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/picocolors/picocolors.browser.js?");

/***/ }),

/***/ "./node_modules/picomatch/index.js":
/*!*****************************************!*\
  !*** ./node_modules/picomatch/index.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nmodule.exports = __webpack_require__(/*! ./lib/picomatch */ \"./node_modules/picomatch/lib/picomatch.js\");\n\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/picomatch/index.js?");

/***/ }),

/***/ "./node_modules/picomatch/lib/constants.js":
/*!*************************************************!*\
  !*** ./node_modules/picomatch/lib/constants.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst path = __webpack_require__(Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'path'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));\nconst WIN_SLASH = '\\\\\\\\/';\nconst WIN_NO_SLASH = `[^${WIN_SLASH}]`;\n\n/**\n * Posix glob regex\n */\n\nconst DOT_LITERAL = '\\\\.';\nconst PLUS_LITERAL = '\\\\+';\nconst QMARK_LITERAL = '\\\\?';\nconst SLASH_LITERAL = '\\\\/';\nconst ONE_CHAR = '(?=.)';\nconst QMARK = '[^/]';\nconst END_ANCHOR = `(?:${SLASH_LITERAL}|$)`;\nconst START_ANCHOR = `(?:^|${SLASH_LITERAL})`;\nconst DOTS_SLASH = `${DOT_LITERAL}{1,2}${END_ANCHOR}`;\nconst NO_DOT = `(?!${DOT_LITERAL})`;\nconst NO_DOTS = `(?!${START_ANCHOR}${DOTS_SLASH})`;\nconst NO_DOT_SLASH = `(?!${DOT_LITERAL}{0,1}${END_ANCHOR})`;\nconst NO_DOTS_SLASH = `(?!${DOTS_SLASH})`;\nconst QMARK_NO_DOT = `[^.${SLASH_LITERAL}]`;\nconst STAR = `${QMARK}*?`;\n\nconst POSIX_CHARS = {\n  DOT_LITERAL,\n  PLUS_LITERAL,\n  QMARK_LITERAL,\n  SLASH_LITERAL,\n  ONE_CHAR,\n  QMARK,\n  END_ANCHOR,\n  DOTS_SLASH,\n  NO_DOT,\n  NO_DOTS,\n  NO_DOT_SLASH,\n  NO_DOTS_SLASH,\n  QMARK_NO_DOT,\n  STAR,\n  START_ANCHOR\n};\n\n/**\n * Windows glob regex\n */\n\nconst WINDOWS_CHARS = {\n  ...POSIX_CHARS,\n\n  SLASH_LITERAL: `[${WIN_SLASH}]`,\n  QMARK: WIN_NO_SLASH,\n  STAR: `${WIN_NO_SLASH}*?`,\n  DOTS_SLASH: `${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$)`,\n  NO_DOT: `(?!${DOT_LITERAL})`,\n  NO_DOTS: `(?!(?:^|[${WIN_SLASH}])${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,\n  NO_DOT_SLASH: `(?!${DOT_LITERAL}{0,1}(?:[${WIN_SLASH}]|$))`,\n  NO_DOTS_SLASH: `(?!${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,\n  QMARK_NO_DOT: `[^.${WIN_SLASH}]`,\n  START_ANCHOR: `(?:^|[${WIN_SLASH}])`,\n  END_ANCHOR: `(?:[${WIN_SLASH}]|$)`\n};\n\n/**\n * POSIX Bracket Regex\n */\n\nconst POSIX_REGEX_SOURCE = {\n  alnum: 'a-zA-Z0-9',\n  alpha: 'a-zA-Z',\n  ascii: '\\\\x00-\\\\x7F',\n  blank: ' \\\\t',\n  cntrl: '\\\\x00-\\\\x1F\\\\x7F',\n  digit: '0-9',\n  graph: '\\\\x21-\\\\x7E',\n  lower: 'a-z',\n  print: '\\\\x20-\\\\x7E ',\n  punct: '\\\\-!\"#$%&\\'()\\\\*+,./:;<=>?@[\\\\]^_`{|}~',\n  space: ' \\\\t\\\\r\\\\n\\\\v\\\\f',\n  upper: 'A-Z',\n  word: 'A-Za-z0-9_',\n  xdigit: 'A-Fa-f0-9'\n};\n\nmodule.exports = {\n  MAX_LENGTH: 1024 * 64,\n  POSIX_REGEX_SOURCE,\n\n  // regular expressions\n  REGEX_BACKSLASH: /\\\\(?![*+?^${}(|)[\\]])/g,\n  REGEX_NON_SPECIAL_CHARS: /^[^@![\\].,$*+?^{}()|\\\\/]+/,\n  REGEX_SPECIAL_CHARS: /[-*+?.^${}(|)[\\]]/,\n  REGEX_SPECIAL_CHARS_BACKREF: /(\\\\?)((\\W)(\\3*))/g,\n  REGEX_SPECIAL_CHARS_GLOBAL: /([-*+?.^${}(|)[\\]])/g,\n  REGEX_REMOVE_BACKSLASH: /(?:\\[.*?[^\\\\]\\]|\\\\(?=.))/g,\n\n  // Replace globs with equivalent patterns to reduce parsing time.\n  REPLACEMENTS: {\n    '***': '*',\n    '**/**': '**',\n    '**/**/**': '**'\n  },\n\n  // Digits\n  CHAR_0: 48, /* 0 */\n  CHAR_9: 57, /* 9 */\n\n  // Alphabet chars.\n  CHAR_UPPERCASE_A: 65, /* A */\n  CHAR_LOWERCASE_A: 97, /* a */\n  CHAR_UPPERCASE_Z: 90, /* Z */\n  CHAR_LOWERCASE_Z: 122, /* z */\n\n  CHAR_LEFT_PARENTHESES: 40, /* ( */\n  CHAR_RIGHT_PARENTHESES: 41, /* ) */\n\n  CHAR_ASTERISK: 42, /* * */\n\n  // Non-alphabetic chars.\n  CHAR_AMPERSAND: 38, /* & */\n  CHAR_AT: 64, /* @ */\n  CHAR_BACKWARD_SLASH: 92, /* \\ */\n  CHAR_CARRIAGE_RETURN: 13, /* \\r */\n  CHAR_CIRCUMFLEX_ACCENT: 94, /* ^ */\n  CHAR_COLON: 58, /* : */\n  CHAR_COMMA: 44, /* , */\n  CHAR_DOT: 46, /* . */\n  CHAR_DOUBLE_QUOTE: 34, /* \" */\n  CHAR_EQUAL: 61, /* = */\n  CHAR_EXCLAMATION_MARK: 33, /* ! */\n  CHAR_FORM_FEED: 12, /* \\f */\n  CHAR_FORWARD_SLASH: 47, /* / */\n  CHAR_GRAVE_ACCENT: 96, /* ` */\n  CHAR_HASH: 35, /* # */\n  CHAR_HYPHEN_MINUS: 45, /* - */\n  CHAR_LEFT_ANGLE_BRACKET: 60, /* < */\n  CHAR_LEFT_CURLY_BRACE: 123, /* { */\n  CHAR_LEFT_SQUARE_BRACKET: 91, /* [ */\n  CHAR_LINE_FEED: 10, /* \\n */\n  CHAR_NO_BREAK_SPACE: 160, /* \\u00A0 */\n  CHAR_PERCENT: 37, /* % */\n  CHAR_PLUS: 43, /* + */\n  CHAR_QUESTION_MARK: 63, /* ? */\n  CHAR_RIGHT_ANGLE_BRACKET: 62, /* > */\n  CHAR_RIGHT_CURLY_BRACE: 125, /* } */\n  CHAR_RIGHT_SQUARE_BRACKET: 93, /* ] */\n  CHAR_SEMICOLON: 59, /* ; */\n  CHAR_SINGLE_QUOTE: 39, /* ' */\n  CHAR_SPACE: 32, /*   */\n  CHAR_TAB: 9, /* \\t */\n  CHAR_UNDERSCORE: 95, /* _ */\n  CHAR_VERTICAL_LINE: 124, /* | */\n  CHAR_ZERO_WIDTH_NOBREAK_SPACE: 65279, /* \\uFEFF */\n\n  SEP: path.sep,\n\n  /**\n   * Create EXTGLOB_CHARS\n   */\n\n  extglobChars(chars) {\n    return {\n      '!': { type: 'negate', open: '(?:(?!(?:', close: `))${chars.STAR})` },\n      '?': { type: 'qmark', open: '(?:', close: ')?' },\n      '+': { type: 'plus', open: '(?:', close: ')+' },\n      '*': { type: 'star', open: '(?:', close: ')*' },\n      '@': { type: 'at', open: '(?:', close: ')' }\n    };\n  },\n\n  /**\n   * Create GLOB_CHARS\n   */\n\n  globChars(win32) {\n    return win32 === true ? WINDOWS_CHARS : POSIX_CHARS;\n  }\n};\n\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/picomatch/lib/constants.js?");

/***/ }),

/***/ "./node_modules/picomatch/lib/parse.js":
/*!*********************************************!*\
  !*** ./node_modules/picomatch/lib/parse.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst constants = __webpack_require__(/*! ./constants */ \"./node_modules/picomatch/lib/constants.js\");\nconst utils = __webpack_require__(/*! ./utils */ \"./node_modules/picomatch/lib/utils.js\");\n\n/**\n * Constants\n */\n\nconst {\n  MAX_LENGTH,\n  POSIX_REGEX_SOURCE,\n  REGEX_NON_SPECIAL_CHARS,\n  REGEX_SPECIAL_CHARS_BACKREF,\n  REPLACEMENTS\n} = constants;\n\n/**\n * Helpers\n */\n\nconst expandRange = (args, options) => {\n  if (typeof options.expandRange === 'function') {\n    return options.expandRange(...args, options);\n  }\n\n  args.sort();\n  const value = `[${args.join('-')}]`;\n\n  try {\n    /* eslint-disable-next-line no-new */\n    new RegExp(value);\n  } catch (ex) {\n    return args.map(v => utils.escapeRegex(v)).join('..');\n  }\n\n  return value;\n};\n\n/**\n * Create the message for a syntax error\n */\n\nconst syntaxError = (type, char) => {\n  return `Missing ${type}: \"${char}\" - use \"\\\\\\\\${char}\" to match literal characters`;\n};\n\n/**\n * Parse the given input string.\n * @param {String} input\n * @param {Object} options\n * @return {Object}\n */\n\nconst parse = (input, options) => {\n  if (typeof input !== 'string') {\n    throw new TypeError('Expected a string');\n  }\n\n  input = REPLACEMENTS[input] || input;\n\n  const opts = { ...options };\n  const max = typeof opts.maxLength === 'number' ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;\n\n  let len = input.length;\n  if (len > max) {\n    throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);\n  }\n\n  const bos = { type: 'bos', value: '', output: opts.prepend || '' };\n  const tokens = [bos];\n\n  const capture = opts.capture ? '' : '?:';\n  const win32 = utils.isWindows(options);\n\n  // create constants based on platform, for windows or posix\n  const PLATFORM_CHARS = constants.globChars(win32);\n  const EXTGLOB_CHARS = constants.extglobChars(PLATFORM_CHARS);\n\n  const {\n    DOT_LITERAL,\n    PLUS_LITERAL,\n    SLASH_LITERAL,\n    ONE_CHAR,\n    DOTS_SLASH,\n    NO_DOT,\n    NO_DOT_SLASH,\n    NO_DOTS_SLASH,\n    QMARK,\n    QMARK_NO_DOT,\n    STAR,\n    START_ANCHOR\n  } = PLATFORM_CHARS;\n\n  const globstar = opts => {\n    return `(${capture}(?:(?!${START_ANCHOR}${opts.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;\n  };\n\n  const nodot = opts.dot ? '' : NO_DOT;\n  const qmarkNoDot = opts.dot ? QMARK : QMARK_NO_DOT;\n  let star = opts.bash === true ? globstar(opts) : STAR;\n\n  if (opts.capture) {\n    star = `(${star})`;\n  }\n\n  // minimatch options support\n  if (typeof opts.noext === 'boolean') {\n    opts.noextglob = opts.noext;\n  }\n\n  const state = {\n    input,\n    index: -1,\n    start: 0,\n    dot: opts.dot === true,\n    consumed: '',\n    output: '',\n    prefix: '',\n    backtrack: false,\n    negated: false,\n    brackets: 0,\n    braces: 0,\n    parens: 0,\n    quotes: 0,\n    globstar: false,\n    tokens\n  };\n\n  input = utils.removePrefix(input, state);\n  len = input.length;\n\n  const extglobs = [];\n  const braces = [];\n  const stack = [];\n  let prev = bos;\n  let value;\n\n  /**\n   * Tokenizing helpers\n   */\n\n  const eos = () => state.index === len - 1;\n  const peek = state.peek = (n = 1) => input[state.index + n];\n  const advance = state.advance = () => input[++state.index] || '';\n  const remaining = () => input.slice(state.index + 1);\n  const consume = (value = '', num = 0) => {\n    state.consumed += value;\n    state.index += num;\n  };\n\n  const append = token => {\n    state.output += token.output != null ? token.output : token.value;\n    consume(token.value);\n  };\n\n  const negate = () => {\n    let count = 1;\n\n    while (peek() === '!' && (peek(2) !== '(' || peek(3) === '?')) {\n      advance();\n      state.start++;\n      count++;\n    }\n\n    if (count % 2 === 0) {\n      return false;\n    }\n\n    state.negated = true;\n    state.start++;\n    return true;\n  };\n\n  const increment = type => {\n    state[type]++;\n    stack.push(type);\n  };\n\n  const decrement = type => {\n    state[type]--;\n    stack.pop();\n  };\n\n  /**\n   * Push tokens onto the tokens array. This helper speeds up\n   * tokenizing by 1) helping us avoid backtracking as much as possible,\n   * and 2) helping us avoid creating extra tokens when consecutive\n   * characters are plain text. This improves performance and simplifies\n   * lookbehinds.\n   */\n\n  const push = tok => {\n    if (prev.type === 'globstar') {\n      const isBrace = state.braces > 0 && (tok.type === 'comma' || tok.type === 'brace');\n      const isExtglob = tok.extglob === true || (extglobs.length && (tok.type === 'pipe' || tok.type === 'paren'));\n\n      if (tok.type !== 'slash' && tok.type !== 'paren' && !isBrace && !isExtglob) {\n        state.output = state.output.slice(0, -prev.output.length);\n        prev.type = 'star';\n        prev.value = '*';\n        prev.output = star;\n        state.output += prev.output;\n      }\n    }\n\n    if (extglobs.length && tok.type !== 'paren') {\n      extglobs[extglobs.length - 1].inner += tok.value;\n    }\n\n    if (tok.value || tok.output) append(tok);\n    if (prev && prev.type === 'text' && tok.type === 'text') {\n      prev.value += tok.value;\n      prev.output = (prev.output || '') + tok.value;\n      return;\n    }\n\n    tok.prev = prev;\n    tokens.push(tok);\n    prev = tok;\n  };\n\n  const extglobOpen = (type, value) => {\n    const token = { ...EXTGLOB_CHARS[value], conditions: 1, inner: '' };\n\n    token.prev = prev;\n    token.parens = state.parens;\n    token.output = state.output;\n    const output = (opts.capture ? '(' : '') + token.open;\n\n    increment('parens');\n    push({ type, value, output: state.output ? '' : ONE_CHAR });\n    push({ type: 'paren', extglob: true, value: advance(), output });\n    extglobs.push(token);\n  };\n\n  const extglobClose = token => {\n    let output = token.close + (opts.capture ? ')' : '');\n    let rest;\n\n    if (token.type === 'negate') {\n      let extglobStar = star;\n\n      if (token.inner && token.inner.length > 1 && token.inner.includes('/')) {\n        extglobStar = globstar(opts);\n      }\n\n      if (extglobStar !== star || eos() || /^\\)+$/.test(remaining())) {\n        output = token.close = `)$))${extglobStar}`;\n      }\n\n      if (token.inner.includes('*') && (rest = remaining()) && /^\\.[^\\\\/.]+$/.test(rest)) {\n        // Any non-magical string (`.ts`) or even nested expression (`.{ts,tsx}`) can follow after the closing parenthesis.\n        // In this case, we need to parse the string and use it in the output of the original pattern.\n        // Suitable patterns: `/!(*.d).ts`, `/!(*.d).{ts,tsx}`, `**/!(*-dbg).@(js)`.\n        //\n        // Disabling the `fastpaths` option due to a problem with parsing strings as `.ts` in the pattern like `**/!(*.d).ts`.\n        const expression = parse(rest, { ...options, fastpaths: false }).output;\n\n        output = token.close = `)${expression})${extglobStar})`;\n      }\n\n      if (token.prev.type === 'bos') {\n        state.negatedExtglob = true;\n      }\n    }\n\n    push({ type: 'paren', extglob: true, value, output });\n    decrement('parens');\n  };\n\n  /**\n   * Fast paths\n   */\n\n  if (opts.fastpaths !== false && !/(^[*!]|[/()[\\]{}\"])/.test(input)) {\n    let backslashes = false;\n\n    let output = input.replace(REGEX_SPECIAL_CHARS_BACKREF, (m, esc, chars, first, rest, index) => {\n      if (first === '\\\\') {\n        backslashes = true;\n        return m;\n      }\n\n      if (first === '?') {\n        if (esc) {\n          return esc + first + (rest ? QMARK.repeat(rest.length) : '');\n        }\n        if (index === 0) {\n          return qmarkNoDot + (rest ? QMARK.repeat(rest.length) : '');\n        }\n        return QMARK.repeat(chars.length);\n      }\n\n      if (first === '.') {\n        return DOT_LITERAL.repeat(chars.length);\n      }\n\n      if (first === '*') {\n        if (esc) {\n          return esc + first + (rest ? star : '');\n        }\n        return star;\n      }\n      return esc ? m : `\\\\${m}`;\n    });\n\n    if (backslashes === true) {\n      if (opts.unescape === true) {\n        output = output.replace(/\\\\/g, '');\n      } else {\n        output = output.replace(/\\\\+/g, m => {\n          return m.length % 2 === 0 ? '\\\\\\\\' : (m ? '\\\\' : '');\n        });\n      }\n    }\n\n    if (output === input && opts.contains === true) {\n      state.output = input;\n      return state;\n    }\n\n    state.output = utils.wrapOutput(output, state, options);\n    return state;\n  }\n\n  /**\n   * Tokenize input until we reach end-of-string\n   */\n\n  while (!eos()) {\n    value = advance();\n\n    if (value === '\\u0000') {\n      continue;\n    }\n\n    /**\n     * Escaped characters\n     */\n\n    if (value === '\\\\') {\n      const next = peek();\n\n      if (next === '/' && opts.bash !== true) {\n        continue;\n      }\n\n      if (next === '.' || next === ';') {\n        continue;\n      }\n\n      if (!next) {\n        value += '\\\\';\n        push({ type: 'text', value });\n        continue;\n      }\n\n      // collapse slashes to reduce potential for exploits\n      const match = /^\\\\+/.exec(remaining());\n      let slashes = 0;\n\n      if (match && match[0].length > 2) {\n        slashes = match[0].length;\n        state.index += slashes;\n        if (slashes % 2 !== 0) {\n          value += '\\\\';\n        }\n      }\n\n      if (opts.unescape === true) {\n        value = advance();\n      } else {\n        value += advance();\n      }\n\n      if (state.brackets === 0) {\n        push({ type: 'text', value });\n        continue;\n      }\n    }\n\n    /**\n     * If we're inside a regex character class, continue\n     * until we reach the closing bracket.\n     */\n\n    if (state.brackets > 0 && (value !== ']' || prev.value === '[' || prev.value === '[^')) {\n      if (opts.posix !== false && value === ':') {\n        const inner = prev.value.slice(1);\n        if (inner.includes('[')) {\n          prev.posix = true;\n\n          if (inner.includes(':')) {\n            const idx = prev.value.lastIndexOf('[');\n            const pre = prev.value.slice(0, idx);\n            const rest = prev.value.slice(idx + 2);\n            const posix = POSIX_REGEX_SOURCE[rest];\n            if (posix) {\n              prev.value = pre + posix;\n              state.backtrack = true;\n              advance();\n\n              if (!bos.output && tokens.indexOf(prev) === 1) {\n                bos.output = ONE_CHAR;\n              }\n              continue;\n            }\n          }\n        }\n      }\n\n      if ((value === '[' && peek() !== ':') || (value === '-' && peek() === ']')) {\n        value = `\\\\${value}`;\n      }\n\n      if (value === ']' && (prev.value === '[' || prev.value === '[^')) {\n        value = `\\\\${value}`;\n      }\n\n      if (opts.posix === true && value === '!' && prev.value === '[') {\n        value = '^';\n      }\n\n      prev.value += value;\n      append({ value });\n      continue;\n    }\n\n    /**\n     * If we're inside a quoted string, continue\n     * until we reach the closing double quote.\n     */\n\n    if (state.quotes === 1 && value !== '\"') {\n      value = utils.escapeRegex(value);\n      prev.value += value;\n      append({ value });\n      continue;\n    }\n\n    /**\n     * Double quotes\n     */\n\n    if (value === '\"') {\n      state.quotes = state.quotes === 1 ? 0 : 1;\n      if (opts.keepQuotes === true) {\n        push({ type: 'text', value });\n      }\n      continue;\n    }\n\n    /**\n     * Parentheses\n     */\n\n    if (value === '(') {\n      increment('parens');\n      push({ type: 'paren', value });\n      continue;\n    }\n\n    if (value === ')') {\n      if (state.parens === 0 && opts.strictBrackets === true) {\n        throw new SyntaxError(syntaxError('opening', '('));\n      }\n\n      const extglob = extglobs[extglobs.length - 1];\n      if (extglob && state.parens === extglob.parens + 1) {\n        extglobClose(extglobs.pop());\n        continue;\n      }\n\n      push({ type: 'paren', value, output: state.parens ? ')' : '\\\\)' });\n      decrement('parens');\n      continue;\n    }\n\n    /**\n     * Square brackets\n     */\n\n    if (value === '[') {\n      if (opts.nobracket === true || !remaining().includes(']')) {\n        if (opts.nobracket !== true && opts.strictBrackets === true) {\n          throw new SyntaxError(syntaxError('closing', ']'));\n        }\n\n        value = `\\\\${value}`;\n      } else {\n        increment('brackets');\n      }\n\n      push({ type: 'bracket', value });\n      continue;\n    }\n\n    if (value === ']') {\n      if (opts.nobracket === true || (prev && prev.type === 'bracket' && prev.value.length === 1)) {\n        push({ type: 'text', value, output: `\\\\${value}` });\n        continue;\n      }\n\n      if (state.brackets === 0) {\n        if (opts.strictBrackets === true) {\n          throw new SyntaxError(syntaxError('opening', '['));\n        }\n\n        push({ type: 'text', value, output: `\\\\${value}` });\n        continue;\n      }\n\n      decrement('brackets');\n\n      const prevValue = prev.value.slice(1);\n      if (prev.posix !== true && prevValue[0] === '^' && !prevValue.includes('/')) {\n        value = `/${value}`;\n      }\n\n      prev.value += value;\n      append({ value });\n\n      // when literal brackets are explicitly disabled\n      // assume we should match with a regex character class\n      if (opts.literalBrackets === false || utils.hasRegexChars(prevValue)) {\n        continue;\n      }\n\n      const escaped = utils.escapeRegex(prev.value);\n      state.output = state.output.slice(0, -prev.value.length);\n\n      // when literal brackets are explicitly enabled\n      // assume we should escape the brackets to match literal characters\n      if (opts.literalBrackets === true) {\n        state.output += escaped;\n        prev.value = escaped;\n        continue;\n      }\n\n      // when the user specifies nothing, try to match both\n      prev.value = `(${capture}${escaped}|${prev.value})`;\n      state.output += prev.value;\n      continue;\n    }\n\n    /**\n     * Braces\n     */\n\n    if (value === '{' && opts.nobrace !== true) {\n      increment('braces');\n\n      const open = {\n        type: 'brace',\n        value,\n        output: '(',\n        outputIndex: state.output.length,\n        tokensIndex: state.tokens.length\n      };\n\n      braces.push(open);\n      push(open);\n      continue;\n    }\n\n    if (value === '}') {\n      const brace = braces[braces.length - 1];\n\n      if (opts.nobrace === true || !brace) {\n        push({ type: 'text', value, output: value });\n        continue;\n      }\n\n      let output = ')';\n\n      if (brace.dots === true) {\n        const arr = tokens.slice();\n        const range = [];\n\n        for (let i = arr.length - 1; i >= 0; i--) {\n          tokens.pop();\n          if (arr[i].type === 'brace') {\n            break;\n          }\n          if (arr[i].type !== 'dots') {\n            range.unshift(arr[i].value);\n          }\n        }\n\n        output = expandRange(range, opts);\n        state.backtrack = true;\n      }\n\n      if (brace.comma !== true && brace.dots !== true) {\n        const out = state.output.slice(0, brace.outputIndex);\n        const toks = state.tokens.slice(brace.tokensIndex);\n        brace.value = brace.output = '\\\\{';\n        value = output = '\\\\}';\n        state.output = out;\n        for (const t of toks) {\n          state.output += (t.output || t.value);\n        }\n      }\n\n      push({ type: 'brace', value, output });\n      decrement('braces');\n      braces.pop();\n      continue;\n    }\n\n    /**\n     * Pipes\n     */\n\n    if (value === '|') {\n      if (extglobs.length > 0) {\n        extglobs[extglobs.length - 1].conditions++;\n      }\n      push({ type: 'text', value });\n      continue;\n    }\n\n    /**\n     * Commas\n     */\n\n    if (value === ',') {\n      let output = value;\n\n      const brace = braces[braces.length - 1];\n      if (brace && stack[stack.length - 1] === 'braces') {\n        brace.comma = true;\n        output = '|';\n      }\n\n      push({ type: 'comma', value, output });\n      continue;\n    }\n\n    /**\n     * Slashes\n     */\n\n    if (value === '/') {\n      // if the beginning of the glob is \"./\", advance the start\n      // to the current index, and don't add the \"./\" characters\n      // to the state. This greatly simplifies lookbehinds when\n      // checking for BOS characters like \"!\" and \".\" (not \"./\")\n      if (prev.type === 'dot' && state.index === state.start + 1) {\n        state.start = state.index + 1;\n        state.consumed = '';\n        state.output = '';\n        tokens.pop();\n        prev = bos; // reset \"prev\" to the first token\n        continue;\n      }\n\n      push({ type: 'slash', value, output: SLASH_LITERAL });\n      continue;\n    }\n\n    /**\n     * Dots\n     */\n\n    if (value === '.') {\n      if (state.braces > 0 && prev.type === 'dot') {\n        if (prev.value === '.') prev.output = DOT_LITERAL;\n        const brace = braces[braces.length - 1];\n        prev.type = 'dots';\n        prev.output += value;\n        prev.value += value;\n        brace.dots = true;\n        continue;\n      }\n\n      if ((state.braces + state.parens) === 0 && prev.type !== 'bos' && prev.type !== 'slash') {\n        push({ type: 'text', value, output: DOT_LITERAL });\n        continue;\n      }\n\n      push({ type: 'dot', value, output: DOT_LITERAL });\n      continue;\n    }\n\n    /**\n     * Question marks\n     */\n\n    if (value === '?') {\n      const isGroup = prev && prev.value === '(';\n      if (!isGroup && opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {\n        extglobOpen('qmark', value);\n        continue;\n      }\n\n      if (prev && prev.type === 'paren') {\n        const next = peek();\n        let output = value;\n\n        if (next === '<' && !utils.supportsLookbehinds()) {\n          throw new Error('Node.js v10 or higher is required for regex lookbehinds');\n        }\n\n        if ((prev.value === '(' && !/[!=<:]/.test(next)) || (next === '<' && !/<([!=]|\\w+>)/.test(remaining()))) {\n          output = `\\\\${value}`;\n        }\n\n        push({ type: 'text', value, output });\n        continue;\n      }\n\n      if (opts.dot !== true && (prev.type === 'slash' || prev.type === 'bos')) {\n        push({ type: 'qmark', value, output: QMARK_NO_DOT });\n        continue;\n      }\n\n      push({ type: 'qmark', value, output: QMARK });\n      continue;\n    }\n\n    /**\n     * Exclamation\n     */\n\n    if (value === '!') {\n      if (opts.noextglob !== true && peek() === '(') {\n        if (peek(2) !== '?' || !/[!=<:]/.test(peek(3))) {\n          extglobOpen('negate', value);\n          continue;\n        }\n      }\n\n      if (opts.nonegate !== true && state.index === 0) {\n        negate();\n        continue;\n      }\n    }\n\n    /**\n     * Plus\n     */\n\n    if (value === '+') {\n      if (opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {\n        extglobOpen('plus', value);\n        continue;\n      }\n\n      if ((prev && prev.value === '(') || opts.regex === false) {\n        push({ type: 'plus', value, output: PLUS_LITERAL });\n        continue;\n      }\n\n      if ((prev && (prev.type === 'bracket' || prev.type === 'paren' || prev.type === 'brace')) || state.parens > 0) {\n        push({ type: 'plus', value });\n        continue;\n      }\n\n      push({ type: 'plus', value: PLUS_LITERAL });\n      continue;\n    }\n\n    /**\n     * Plain text\n     */\n\n    if (value === '@') {\n      if (opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {\n        push({ type: 'at', extglob: true, value, output: '' });\n        continue;\n      }\n\n      push({ type: 'text', value });\n      continue;\n    }\n\n    /**\n     * Plain text\n     */\n\n    if (value !== '*') {\n      if (value === '$' || value === '^') {\n        value = `\\\\${value}`;\n      }\n\n      const match = REGEX_NON_SPECIAL_CHARS.exec(remaining());\n      if (match) {\n        value += match[0];\n        state.index += match[0].length;\n      }\n\n      push({ type: 'text', value });\n      continue;\n    }\n\n    /**\n     * Stars\n     */\n\n    if (prev && (prev.type === 'globstar' || prev.star === true)) {\n      prev.type = 'star';\n      prev.star = true;\n      prev.value += value;\n      prev.output = star;\n      state.backtrack = true;\n      state.globstar = true;\n      consume(value);\n      continue;\n    }\n\n    let rest = remaining();\n    if (opts.noextglob !== true && /^\\([^?]/.test(rest)) {\n      extglobOpen('star', value);\n      continue;\n    }\n\n    if (prev.type === 'star') {\n      if (opts.noglobstar === true) {\n        consume(value);\n        continue;\n      }\n\n      const prior = prev.prev;\n      const before = prior.prev;\n      const isStart = prior.type === 'slash' || prior.type === 'bos';\n      const afterStar = before && (before.type === 'star' || before.type === 'globstar');\n\n      if (opts.bash === true && (!isStart || (rest[0] && rest[0] !== '/'))) {\n        push({ type: 'star', value, output: '' });\n        continue;\n      }\n\n      const isBrace = state.braces > 0 && (prior.type === 'comma' || prior.type === 'brace');\n      const isExtglob = extglobs.length && (prior.type === 'pipe' || prior.type === 'paren');\n      if (!isStart && prior.type !== 'paren' && !isBrace && !isExtglob) {\n        push({ type: 'star', value, output: '' });\n        continue;\n      }\n\n      // strip consecutive `/**/`\n      while (rest.slice(0, 3) === '/**') {\n        const after = input[state.index + 4];\n        if (after && after !== '/') {\n          break;\n        }\n        rest = rest.slice(3);\n        consume('/**', 3);\n      }\n\n      if (prior.type === 'bos' && eos()) {\n        prev.type = 'globstar';\n        prev.value += value;\n        prev.output = globstar(opts);\n        state.output = prev.output;\n        state.globstar = true;\n        consume(value);\n        continue;\n      }\n\n      if (prior.type === 'slash' && prior.prev.type !== 'bos' && !afterStar && eos()) {\n        state.output = state.output.slice(0, -(prior.output + prev.output).length);\n        prior.output = `(?:${prior.output}`;\n\n        prev.type = 'globstar';\n        prev.output = globstar(opts) + (opts.strictSlashes ? ')' : '|$)');\n        prev.value += value;\n        state.globstar = true;\n        state.output += prior.output + prev.output;\n        consume(value);\n        continue;\n      }\n\n      if (prior.type === 'slash' && prior.prev.type !== 'bos' && rest[0] === '/') {\n        const end = rest[1] !== void 0 ? '|$' : '';\n\n        state.output = state.output.slice(0, -(prior.output + prev.output).length);\n        prior.output = `(?:${prior.output}`;\n\n        prev.type = 'globstar';\n        prev.output = `${globstar(opts)}${SLASH_LITERAL}|${SLASH_LITERAL}${end})`;\n        prev.value += value;\n\n        state.output += prior.output + prev.output;\n        state.globstar = true;\n\n        consume(value + advance());\n\n        push({ type: 'slash', value: '/', output: '' });\n        continue;\n      }\n\n      if (prior.type === 'bos' && rest[0] === '/') {\n        prev.type = 'globstar';\n        prev.value += value;\n        prev.output = `(?:^|${SLASH_LITERAL}|${globstar(opts)}${SLASH_LITERAL})`;\n        state.output = prev.output;\n        state.globstar = true;\n        consume(value + advance());\n        push({ type: 'slash', value: '/', output: '' });\n        continue;\n      }\n\n      // remove single star from output\n      state.output = state.output.slice(0, -prev.output.length);\n\n      // reset previous token to globstar\n      prev.type = 'globstar';\n      prev.output = globstar(opts);\n      prev.value += value;\n\n      // reset output with globstar\n      state.output += prev.output;\n      state.globstar = true;\n      consume(value);\n      continue;\n    }\n\n    const token = { type: 'star', value, output: star };\n\n    if (opts.bash === true) {\n      token.output = '.*?';\n      if (prev.type === 'bos' || prev.type === 'slash') {\n        token.output = nodot + token.output;\n      }\n      push(token);\n      continue;\n    }\n\n    if (prev && (prev.type === 'bracket' || prev.type === 'paren') && opts.regex === true) {\n      token.output = value;\n      push(token);\n      continue;\n    }\n\n    if (state.index === state.start || prev.type === 'slash' || prev.type === 'dot') {\n      if (prev.type === 'dot') {\n        state.output += NO_DOT_SLASH;\n        prev.output += NO_DOT_SLASH;\n\n      } else if (opts.dot === true) {\n        state.output += NO_DOTS_SLASH;\n        prev.output += NO_DOTS_SLASH;\n\n      } else {\n        state.output += nodot;\n        prev.output += nodot;\n      }\n\n      if (peek() !== '*') {\n        state.output += ONE_CHAR;\n        prev.output += ONE_CHAR;\n      }\n    }\n\n    push(token);\n  }\n\n  while (state.brackets > 0) {\n    if (opts.strictBrackets === true) throw new SyntaxError(syntaxError('closing', ']'));\n    state.output = utils.escapeLast(state.output, '[');\n    decrement('brackets');\n  }\n\n  while (state.parens > 0) {\n    if (opts.strictBrackets === true) throw new SyntaxError(syntaxError('closing', ')'));\n    state.output = utils.escapeLast(state.output, '(');\n    decrement('parens');\n  }\n\n  while (state.braces > 0) {\n    if (opts.strictBrackets === true) throw new SyntaxError(syntaxError('closing', '}'));\n    state.output = utils.escapeLast(state.output, '{');\n    decrement('braces');\n  }\n\n  if (opts.strictSlashes !== true && (prev.type === 'star' || prev.type === 'bracket')) {\n    push({ type: 'maybe_slash', value: '', output: `${SLASH_LITERAL}?` });\n  }\n\n  // rebuild the output if we had to backtrack at any point\n  if (state.backtrack === true) {\n    state.output = '';\n\n    for (const token of state.tokens) {\n      state.output += token.output != null ? token.output : token.value;\n\n      if (token.suffix) {\n        state.output += token.suffix;\n      }\n    }\n  }\n\n  return state;\n};\n\n/**\n * Fast paths for creating regular expressions for common glob patterns.\n * This can significantly speed up processing and has very little downside\n * impact when none of the fast paths match.\n */\n\nparse.fastpaths = (input, options) => {\n  const opts = { ...options };\n  const max = typeof opts.maxLength === 'number' ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;\n  const len = input.length;\n  if (len > max) {\n    throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);\n  }\n\n  input = REPLACEMENTS[input] || input;\n  const win32 = utils.isWindows(options);\n\n  // create constants based on platform, for windows or posix\n  const {\n    DOT_LITERAL,\n    SLASH_LITERAL,\n    ONE_CHAR,\n    DOTS_SLASH,\n    NO_DOT,\n    NO_DOTS,\n    NO_DOTS_SLASH,\n    STAR,\n    START_ANCHOR\n  } = constants.globChars(win32);\n\n  const nodot = opts.dot ? NO_DOTS : NO_DOT;\n  const slashDot = opts.dot ? NO_DOTS_SLASH : NO_DOT;\n  const capture = opts.capture ? '' : '?:';\n  const state = { negated: false, prefix: '' };\n  let star = opts.bash === true ? '.*?' : STAR;\n\n  if (opts.capture) {\n    star = `(${star})`;\n  }\n\n  const globstar = opts => {\n    if (opts.noglobstar === true) return star;\n    return `(${capture}(?:(?!${START_ANCHOR}${opts.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;\n  };\n\n  const create = str => {\n    switch (str) {\n      case '*':\n        return `${nodot}${ONE_CHAR}${star}`;\n\n      case '.*':\n        return `${DOT_LITERAL}${ONE_CHAR}${star}`;\n\n      case '*.*':\n        return `${nodot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;\n\n      case '*/*':\n        return `${nodot}${star}${SLASH_LITERAL}${ONE_CHAR}${slashDot}${star}`;\n\n      case '**':\n        return nodot + globstar(opts);\n\n      case '**/*':\n        return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${ONE_CHAR}${star}`;\n\n      case '**/*.*':\n        return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;\n\n      case '**/.*':\n        return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${DOT_LITERAL}${ONE_CHAR}${star}`;\n\n      default: {\n        const match = /^(.*?)\\.(\\w+)$/.exec(str);\n        if (!match) return;\n\n        const source = create(match[1]);\n        if (!source) return;\n\n        return source + DOT_LITERAL + match[2];\n      }\n    }\n  };\n\n  const output = utils.removePrefix(input, state);\n  let source = create(output);\n\n  if (source && opts.strictSlashes !== true) {\n    source += `${SLASH_LITERAL}?`;\n  }\n\n  return source;\n};\n\nmodule.exports = parse;\n\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/picomatch/lib/parse.js?");

/***/ }),

/***/ "./node_modules/picomatch/lib/picomatch.js":
/*!*************************************************!*\
  !*** ./node_modules/picomatch/lib/picomatch.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst path = __webpack_require__(Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'path'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));\nconst scan = __webpack_require__(/*! ./scan */ \"./node_modules/picomatch/lib/scan.js\");\nconst parse = __webpack_require__(/*! ./parse */ \"./node_modules/picomatch/lib/parse.js\");\nconst utils = __webpack_require__(/*! ./utils */ \"./node_modules/picomatch/lib/utils.js\");\nconst constants = __webpack_require__(/*! ./constants */ \"./node_modules/picomatch/lib/constants.js\");\nconst isObject = val => val && typeof val === 'object' && !Array.isArray(val);\n\n/**\n * Creates a matcher function from one or more glob patterns. The\n * returned function takes a string to match as its first argument,\n * and returns true if the string is a match. The returned matcher\n * function also takes a boolean as the second argument that, when true,\n * returns an object with additional information.\n *\n * ```js\n * const picomatch = require('picomatch');\n * // picomatch(glob[, options]);\n *\n * const isMatch = picomatch('*.!(*a)');\n * console.log(isMatch('a.a')); //=> false\n * console.log(isMatch('a.b')); //=> true\n * ```\n * @name picomatch\n * @param {String|Array} `globs` One or more glob patterns.\n * @param {Object=} `options`\n * @return {Function=} Returns a matcher function.\n * @api public\n */\n\nconst picomatch = (glob, options, returnState = false) => {\n  if (Array.isArray(glob)) {\n    const fns = glob.map(input => picomatch(input, options, returnState));\n    const arrayMatcher = str => {\n      for (const isMatch of fns) {\n        const state = isMatch(str);\n        if (state) return state;\n      }\n      return false;\n    };\n    return arrayMatcher;\n  }\n\n  const isState = isObject(glob) && glob.tokens && glob.input;\n\n  if (glob === '' || (typeof glob !== 'string' && !isState)) {\n    throw new TypeError('Expected pattern to be a non-empty string');\n  }\n\n  const opts = options || {};\n  const posix = utils.isWindows(options);\n  const regex = isState\n    ? picomatch.compileRe(glob, options)\n    : picomatch.makeRe(glob, options, false, true);\n\n  const state = regex.state;\n  delete regex.state;\n\n  let isIgnored = () => false;\n  if (opts.ignore) {\n    const ignoreOpts = { ...options, ignore: null, onMatch: null, onResult: null };\n    isIgnored = picomatch(opts.ignore, ignoreOpts, returnState);\n  }\n\n  const matcher = (input, returnObject = false) => {\n    const { isMatch, match, output } = picomatch.test(input, regex, options, { glob, posix });\n    const result = { glob, state, regex, posix, input, output, match, isMatch };\n\n    if (typeof opts.onResult === 'function') {\n      opts.onResult(result);\n    }\n\n    if (isMatch === false) {\n      result.isMatch = false;\n      return returnObject ? result : false;\n    }\n\n    if (isIgnored(input)) {\n      if (typeof opts.onIgnore === 'function') {\n        opts.onIgnore(result);\n      }\n      result.isMatch = false;\n      return returnObject ? result : false;\n    }\n\n    if (typeof opts.onMatch === 'function') {\n      opts.onMatch(result);\n    }\n    return returnObject ? result : true;\n  };\n\n  if (returnState) {\n    matcher.state = state;\n  }\n\n  return matcher;\n};\n\n/**\n * Test `input` with the given `regex`. This is used by the main\n * `picomatch()` function to test the input string.\n *\n * ```js\n * const picomatch = require('picomatch');\n * // picomatch.test(input, regex[, options]);\n *\n * console.log(picomatch.test('foo/bar', /^(?:([^/]*?)\\/([^/]*?))$/));\n * // { isMatch: true, match: [ 'foo/', 'foo', 'bar' ], output: 'foo/bar' }\n * ```\n * @param {String} `input` String to test.\n * @param {RegExp} `regex`\n * @return {Object} Returns an object with matching info.\n * @api public\n */\n\npicomatch.test = (input, regex, options, { glob, posix } = {}) => {\n  if (typeof input !== 'string') {\n    throw new TypeError('Expected input to be a string');\n  }\n\n  if (input === '') {\n    return { isMatch: false, output: '' };\n  }\n\n  const opts = options || {};\n  const format = opts.format || (posix ? utils.toPosixSlashes : null);\n  let match = input === glob;\n  let output = (match && format) ? format(input) : input;\n\n  if (match === false) {\n    output = format ? format(input) : input;\n    match = output === glob;\n  }\n\n  if (match === false || opts.capture === true) {\n    if (opts.matchBase === true || opts.basename === true) {\n      match = picomatch.matchBase(input, regex, options, posix);\n    } else {\n      match = regex.exec(output);\n    }\n  }\n\n  return { isMatch: Boolean(match), match, output };\n};\n\n/**\n * Match the basename of a filepath.\n *\n * ```js\n * const picomatch = require('picomatch');\n * // picomatch.matchBase(input, glob[, options]);\n * console.log(picomatch.matchBase('foo/bar.js', '*.js'); // true\n * ```\n * @param {String} `input` String to test.\n * @param {RegExp|String} `glob` Glob pattern or regex created by [.makeRe](#makeRe).\n * @return {Boolean}\n * @api public\n */\n\npicomatch.matchBase = (input, glob, options, posix = utils.isWindows(options)) => {\n  const regex = glob instanceof RegExp ? glob : picomatch.makeRe(glob, options);\n  return regex.test(path.basename(input));\n};\n\n/**\n * Returns true if **any** of the given glob `patterns` match the specified `string`.\n *\n * ```js\n * const picomatch = require('picomatch');\n * // picomatch.isMatch(string, patterns[, options]);\n *\n * console.log(picomatch.isMatch('a.a', ['b.*', '*.a'])); //=> true\n * console.log(picomatch.isMatch('a.a', 'b.*')); //=> false\n * ```\n * @param {String|Array} str The string to test.\n * @param {String|Array} patterns One or more glob patterns to use for matching.\n * @param {Object} [options] See available [options](#options).\n * @return {Boolean} Returns true if any patterns match `str`\n * @api public\n */\n\npicomatch.isMatch = (str, patterns, options) => picomatch(patterns, options)(str);\n\n/**\n * Parse a glob pattern to create the source string for a regular\n * expression.\n *\n * ```js\n * const picomatch = require('picomatch');\n * const result = picomatch.parse(pattern[, options]);\n * ```\n * @param {String} `pattern`\n * @param {Object} `options`\n * @return {Object} Returns an object with useful properties and output to be used as a regex source string.\n * @api public\n */\n\npicomatch.parse = (pattern, options) => {\n  if (Array.isArray(pattern)) return pattern.map(p => picomatch.parse(p, options));\n  return parse(pattern, { ...options, fastpaths: false });\n};\n\n/**\n * Scan a glob pattern to separate the pattern into segments.\n *\n * ```js\n * const picomatch = require('picomatch');\n * // picomatch.scan(input[, options]);\n *\n * const result = picomatch.scan('!./foo/*.js');\n * console.log(result);\n * { prefix: '!./',\n *   input: '!./foo/*.js',\n *   start: 3,\n *   base: 'foo',\n *   glob: '*.js',\n *   isBrace: false,\n *   isBracket: false,\n *   isGlob: true,\n *   isExtglob: false,\n *   isGlobstar: false,\n *   negated: true }\n * ```\n * @param {String} `input` Glob pattern to scan.\n * @param {Object} `options`\n * @return {Object} Returns an object with\n * @api public\n */\n\npicomatch.scan = (input, options) => scan(input, options);\n\n/**\n * Compile a regular expression from the `state` object returned by the\n * [parse()](#parse) method.\n *\n * @param {Object} `state`\n * @param {Object} `options`\n * @param {Boolean} `returnOutput` Intended for implementors, this argument allows you to return the raw output from the parser.\n * @param {Boolean} `returnState` Adds the state to a `state` property on the returned regex. Useful for implementors and debugging.\n * @return {RegExp}\n * @api public\n */\n\npicomatch.compileRe = (state, options, returnOutput = false, returnState = false) => {\n  if (returnOutput === true) {\n    return state.output;\n  }\n\n  const opts = options || {};\n  const prepend = opts.contains ? '' : '^';\n  const append = opts.contains ? '' : '$';\n\n  let source = `${prepend}(?:${state.output})${append}`;\n  if (state && state.negated === true) {\n    source = `^(?!${source}).*$`;\n  }\n\n  const regex = picomatch.toRegex(source, options);\n  if (returnState === true) {\n    regex.state = state;\n  }\n\n  return regex;\n};\n\n/**\n * Create a regular expression from a parsed glob pattern.\n *\n * ```js\n * const picomatch = require('picomatch');\n * const state = picomatch.parse('*.js');\n * // picomatch.compileRe(state[, options]);\n *\n * console.log(picomatch.compileRe(state));\n * //=> /^(?:(?!\\.)(?=.)[^/]*?\\.js)$/\n * ```\n * @param {String} `state` The object returned from the `.parse` method.\n * @param {Object} `options`\n * @param {Boolean} `returnOutput` Implementors may use this argument to return the compiled output, instead of a regular expression. This is not exposed on the options to prevent end-users from mutating the result.\n * @param {Boolean} `returnState` Implementors may use this argument to return the state from the parsed glob with the returned regular expression.\n * @return {RegExp} Returns a regex created from the given pattern.\n * @api public\n */\n\npicomatch.makeRe = (input, options = {}, returnOutput = false, returnState = false) => {\n  if (!input || typeof input !== 'string') {\n    throw new TypeError('Expected a non-empty string');\n  }\n\n  let parsed = { negated: false, fastpaths: true };\n\n  if (options.fastpaths !== false && (input[0] === '.' || input[0] === '*')) {\n    parsed.output = parse.fastpaths(input, options);\n  }\n\n  if (!parsed.output) {\n    parsed = parse(input, options);\n  }\n\n  return picomatch.compileRe(parsed, options, returnOutput, returnState);\n};\n\n/**\n * Create a regular expression from the given regex source string.\n *\n * ```js\n * const picomatch = require('picomatch');\n * // picomatch.toRegex(source[, options]);\n *\n * const { output } = picomatch.parse('*.js');\n * console.log(picomatch.toRegex(output));\n * //=> /^(?:(?!\\.)(?=.)[^/]*?\\.js)$/\n * ```\n * @param {String} `source` Regular expression source string.\n * @param {Object} `options`\n * @return {RegExp}\n * @api public\n */\n\npicomatch.toRegex = (source, options) => {\n  try {\n    const opts = options || {};\n    return new RegExp(source, opts.flags || (opts.nocase ? 'i' : ''));\n  } catch (err) {\n    if (options && options.debug === true) throw err;\n    return /$^/;\n  }\n};\n\n/**\n * Picomatch constants.\n * @return {Object}\n */\n\npicomatch.constants = constants;\n\n/**\n * Expose \"picomatch\"\n */\n\nmodule.exports = picomatch;\n\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/picomatch/lib/picomatch.js?");

/***/ }),

/***/ "./node_modules/picomatch/lib/scan.js":
/*!********************************************!*\
  !*** ./node_modules/picomatch/lib/scan.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst utils = __webpack_require__(/*! ./utils */ \"./node_modules/picomatch/lib/utils.js\");\nconst {\n  CHAR_ASTERISK,             /* * */\n  CHAR_AT,                   /* @ */\n  CHAR_BACKWARD_SLASH,       /* \\ */\n  CHAR_COMMA,                /* , */\n  CHAR_DOT,                  /* . */\n  CHAR_EXCLAMATION_MARK,     /* ! */\n  CHAR_FORWARD_SLASH,        /* / */\n  CHAR_LEFT_CURLY_BRACE,     /* { */\n  CHAR_LEFT_PARENTHESES,     /* ( */\n  CHAR_LEFT_SQUARE_BRACKET,  /* [ */\n  CHAR_PLUS,                 /* + */\n  CHAR_QUESTION_MARK,        /* ? */\n  CHAR_RIGHT_CURLY_BRACE,    /* } */\n  CHAR_RIGHT_PARENTHESES,    /* ) */\n  CHAR_RIGHT_SQUARE_BRACKET  /* ] */\n} = __webpack_require__(/*! ./constants */ \"./node_modules/picomatch/lib/constants.js\");\n\nconst isPathSeparator = code => {\n  return code === CHAR_FORWARD_SLASH || code === CHAR_BACKWARD_SLASH;\n};\n\nconst depth = token => {\n  if (token.isPrefix !== true) {\n    token.depth = token.isGlobstar ? Infinity : 1;\n  }\n};\n\n/**\n * Quickly scans a glob pattern and returns an object with a handful of\n * useful properties, like `isGlob`, `path` (the leading non-glob, if it exists),\n * `glob` (the actual pattern), `negated` (true if the path starts with `!` but not\n * with `!(`) and `negatedExtglob` (true if the path starts with `!(`).\n *\n * ```js\n * const pm = require('picomatch');\n * console.log(pm.scan('foo/bar/*.js'));\n * { isGlob: true, input: 'foo/bar/*.js', base: 'foo/bar', glob: '*.js' }\n * ```\n * @param {String} `str`\n * @param {Object} `options`\n * @return {Object} Returns an object with tokens and regex source string.\n * @api public\n */\n\nconst scan = (input, options) => {\n  const opts = options || {};\n\n  const length = input.length - 1;\n  const scanToEnd = opts.parts === true || opts.scanToEnd === true;\n  const slashes = [];\n  const tokens = [];\n  const parts = [];\n\n  let str = input;\n  let index = -1;\n  let start = 0;\n  let lastIndex = 0;\n  let isBrace = false;\n  let isBracket = false;\n  let isGlob = false;\n  let isExtglob = false;\n  let isGlobstar = false;\n  let braceEscaped = false;\n  let backslashes = false;\n  let negated = false;\n  let negatedExtglob = false;\n  let finished = false;\n  let braces = 0;\n  let prev;\n  let code;\n  let token = { value: '', depth: 0, isGlob: false };\n\n  const eos = () => index >= length;\n  const peek = () => str.charCodeAt(index + 1);\n  const advance = () => {\n    prev = code;\n    return str.charCodeAt(++index);\n  };\n\n  while (index < length) {\n    code = advance();\n    let next;\n\n    if (code === CHAR_BACKWARD_SLASH) {\n      backslashes = token.backslashes = true;\n      code = advance();\n\n      if (code === CHAR_LEFT_CURLY_BRACE) {\n        braceEscaped = true;\n      }\n      continue;\n    }\n\n    if (braceEscaped === true || code === CHAR_LEFT_CURLY_BRACE) {\n      braces++;\n\n      while (eos() !== true && (code = advance())) {\n        if (code === CHAR_BACKWARD_SLASH) {\n          backslashes = token.backslashes = true;\n          advance();\n          continue;\n        }\n\n        if (code === CHAR_LEFT_CURLY_BRACE) {\n          braces++;\n          continue;\n        }\n\n        if (braceEscaped !== true && code === CHAR_DOT && (code = advance()) === CHAR_DOT) {\n          isBrace = token.isBrace = true;\n          isGlob = token.isGlob = true;\n          finished = true;\n\n          if (scanToEnd === true) {\n            continue;\n          }\n\n          break;\n        }\n\n        if (braceEscaped !== true && code === CHAR_COMMA) {\n          isBrace = token.isBrace = true;\n          isGlob = token.isGlob = true;\n          finished = true;\n\n          if (scanToEnd === true) {\n            continue;\n          }\n\n          break;\n        }\n\n        if (code === CHAR_RIGHT_CURLY_BRACE) {\n          braces--;\n\n          if (braces === 0) {\n            braceEscaped = false;\n            isBrace = token.isBrace = true;\n            finished = true;\n            break;\n          }\n        }\n      }\n\n      if (scanToEnd === true) {\n        continue;\n      }\n\n      break;\n    }\n\n    if (code === CHAR_FORWARD_SLASH) {\n      slashes.push(index);\n      tokens.push(token);\n      token = { value: '', depth: 0, isGlob: false };\n\n      if (finished === true) continue;\n      if (prev === CHAR_DOT && index === (start + 1)) {\n        start += 2;\n        continue;\n      }\n\n      lastIndex = index + 1;\n      continue;\n    }\n\n    if (opts.noext !== true) {\n      const isExtglobChar = code === CHAR_PLUS\n        || code === CHAR_AT\n        || code === CHAR_ASTERISK\n        || code === CHAR_QUESTION_MARK\n        || code === CHAR_EXCLAMATION_MARK;\n\n      if (isExtglobChar === true && peek() === CHAR_LEFT_PARENTHESES) {\n        isGlob = token.isGlob = true;\n        isExtglob = token.isExtglob = true;\n        finished = true;\n        if (code === CHAR_EXCLAMATION_MARK && index === start) {\n          negatedExtglob = true;\n        }\n\n        if (scanToEnd === true) {\n          while (eos() !== true && (code = advance())) {\n            if (code === CHAR_BACKWARD_SLASH) {\n              backslashes = token.backslashes = true;\n              code = advance();\n              continue;\n            }\n\n            if (code === CHAR_RIGHT_PARENTHESES) {\n              isGlob = token.isGlob = true;\n              finished = true;\n              break;\n            }\n          }\n          continue;\n        }\n        break;\n      }\n    }\n\n    if (code === CHAR_ASTERISK) {\n      if (prev === CHAR_ASTERISK) isGlobstar = token.isGlobstar = true;\n      isGlob = token.isGlob = true;\n      finished = true;\n\n      if (scanToEnd === true) {\n        continue;\n      }\n      break;\n    }\n\n    if (code === CHAR_QUESTION_MARK) {\n      isGlob = token.isGlob = true;\n      finished = true;\n\n      if (scanToEnd === true) {\n        continue;\n      }\n      break;\n    }\n\n    if (code === CHAR_LEFT_SQUARE_BRACKET) {\n      while (eos() !== true && (next = advance())) {\n        if (next === CHAR_BACKWARD_SLASH) {\n          backslashes = token.backslashes = true;\n          advance();\n          continue;\n        }\n\n        if (next === CHAR_RIGHT_SQUARE_BRACKET) {\n          isBracket = token.isBracket = true;\n          isGlob = token.isGlob = true;\n          finished = true;\n          break;\n        }\n      }\n\n      if (scanToEnd === true) {\n        continue;\n      }\n\n      break;\n    }\n\n    if (opts.nonegate !== true && code === CHAR_EXCLAMATION_MARK && index === start) {\n      negated = token.negated = true;\n      start++;\n      continue;\n    }\n\n    if (opts.noparen !== true && code === CHAR_LEFT_PARENTHESES) {\n      isGlob = token.isGlob = true;\n\n      if (scanToEnd === true) {\n        while (eos() !== true && (code = advance())) {\n          if (code === CHAR_LEFT_PARENTHESES) {\n            backslashes = token.backslashes = true;\n            code = advance();\n            continue;\n          }\n\n          if (code === CHAR_RIGHT_PARENTHESES) {\n            finished = true;\n            break;\n          }\n        }\n        continue;\n      }\n      break;\n    }\n\n    if (isGlob === true) {\n      finished = true;\n\n      if (scanToEnd === true) {\n        continue;\n      }\n\n      break;\n    }\n  }\n\n  if (opts.noext === true) {\n    isExtglob = false;\n    isGlob = false;\n  }\n\n  let base = str;\n  let prefix = '';\n  let glob = '';\n\n  if (start > 0) {\n    prefix = str.slice(0, start);\n    str = str.slice(start);\n    lastIndex -= start;\n  }\n\n  if (base && isGlob === true && lastIndex > 0) {\n    base = str.slice(0, lastIndex);\n    glob = str.slice(lastIndex);\n  } else if (isGlob === true) {\n    base = '';\n    glob = str;\n  } else {\n    base = str;\n  }\n\n  if (base && base !== '' && base !== '/' && base !== str) {\n    if (isPathSeparator(base.charCodeAt(base.length - 1))) {\n      base = base.slice(0, -1);\n    }\n  }\n\n  if (opts.unescape === true) {\n    if (glob) glob = utils.removeBackslashes(glob);\n\n    if (base && backslashes === true) {\n      base = utils.removeBackslashes(base);\n    }\n  }\n\n  const state = {\n    prefix,\n    input,\n    start,\n    base,\n    glob,\n    isBrace,\n    isBracket,\n    isGlob,\n    isExtglob,\n    isGlobstar,\n    negated,\n    negatedExtglob\n  };\n\n  if (opts.tokens === true) {\n    state.maxDepth = 0;\n    if (!isPathSeparator(code)) {\n      tokens.push(token);\n    }\n    state.tokens = tokens;\n  }\n\n  if (opts.parts === true || opts.tokens === true) {\n    let prevIndex;\n\n    for (let idx = 0; idx < slashes.length; idx++) {\n      const n = prevIndex ? prevIndex + 1 : start;\n      const i = slashes[idx];\n      const value = input.slice(n, i);\n      if (opts.tokens) {\n        if (idx === 0 && start !== 0) {\n          tokens[idx].isPrefix = true;\n          tokens[idx].value = prefix;\n        } else {\n          tokens[idx].value = value;\n        }\n        depth(tokens[idx]);\n        state.maxDepth += tokens[idx].depth;\n      }\n      if (idx !== 0 || value !== '') {\n        parts.push(value);\n      }\n      prevIndex = i;\n    }\n\n    if (prevIndex && prevIndex + 1 < input.length) {\n      const value = input.slice(prevIndex + 1);\n      parts.push(value);\n\n      if (opts.tokens) {\n        tokens[tokens.length - 1].value = value;\n        depth(tokens[tokens.length - 1]);\n        state.maxDepth += tokens[tokens.length - 1].depth;\n      }\n    }\n\n    state.slashes = slashes;\n    state.parts = parts;\n  }\n\n  return state;\n};\n\nmodule.exports = scan;\n\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/picomatch/lib/scan.js?");

/***/ }),

/***/ "./node_modules/picomatch/lib/utils.js":
/*!*********************************************!*\
  !*** ./node_modules/picomatch/lib/utils.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nconst path = __webpack_require__(Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'path'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));\nconst win32 = process.platform === 'win32';\nconst {\n  REGEX_BACKSLASH,\n  REGEX_REMOVE_BACKSLASH,\n  REGEX_SPECIAL_CHARS,\n  REGEX_SPECIAL_CHARS_GLOBAL\n} = __webpack_require__(/*! ./constants */ \"./node_modules/picomatch/lib/constants.js\");\n\nexports.isObject = val => val !== null && typeof val === 'object' && !Array.isArray(val);\nexports.hasRegexChars = str => REGEX_SPECIAL_CHARS.test(str);\nexports.isRegexChar = str => str.length === 1 && exports.hasRegexChars(str);\nexports.escapeRegex = str => str.replace(REGEX_SPECIAL_CHARS_GLOBAL, '\\\\$1');\nexports.toPosixSlashes = str => str.replace(REGEX_BACKSLASH, '/');\n\nexports.removeBackslashes = str => {\n  return str.replace(REGEX_REMOVE_BACKSLASH, match => {\n    return match === '\\\\' ? '' : match;\n  });\n};\n\nexports.supportsLookbehinds = () => {\n  const segs = process.version.slice(1).split('.').map(Number);\n  if (segs.length === 3 && segs[0] >= 9 || (segs[0] === 8 && segs[1] >= 10)) {\n    return true;\n  }\n  return false;\n};\n\nexports.isWindows = options => {\n  if (options && typeof options.windows === 'boolean') {\n    return options.windows;\n  }\n  return win32 === true || path.sep === '\\\\';\n};\n\nexports.escapeLast = (input, char, lastIdx) => {\n  const idx = input.lastIndexOf(char, lastIdx);\n  if (idx === -1) return input;\n  if (input[idx - 1] === '\\\\') return exports.escapeLast(input, char, idx - 1);\n  return `${input.slice(0, idx)}\\\\${input.slice(idx)}`;\n};\n\nexports.removePrefix = (input, state = {}) => {\n  let output = input;\n  if (output.startsWith('./')) {\n    output = output.slice(2);\n    state.prefix = './';\n  }\n  return output;\n};\n\nexports.wrapOutput = (input, state = {}, options = {}) => {\n  const prepend = options.contains ? '' : '^';\n  const append = options.contains ? '' : '$';\n\n  let output = `${prepend}(?:${input})${append}`;\n  if (state.negated === true) {\n    output = `(?:^(?!${output}).*$)`;\n  }\n  return output;\n};\n\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/picomatch/lib/utils.js?");

/***/ }),

/***/ "./node_modules/postcss-js/async.js":
/*!******************************************!*\
  !*** ./node_modules/postcss-js/async.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("let postcss = __webpack_require__(/*! postcss */ \"./node_modules/postcss/lib/postcss.js\")\n\nlet processResult = __webpack_require__(/*! ./process-result */ \"./node_modules/postcss-js/process-result.js\")\nlet parse = __webpack_require__(/*! ./parser */ \"./node_modules/postcss-js/parser.js\")\n\nmodule.exports = function async(plugins) {\n  let processor = postcss(plugins)\n  return async input => {\n    let result = await processor.process(input, {\n      parser: parse,\n      from: undefined\n    })\n    return processResult(result)\n  }\n}\n\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/postcss-js/async.js?");

/***/ }),

/***/ "./node_modules/postcss-js/index.js":
/*!******************************************!*\
  !*** ./node_modules/postcss-js/index.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("let objectify = __webpack_require__(/*! ./objectifier */ \"./node_modules/postcss-js/objectifier.js\")\nlet parse = __webpack_require__(/*! ./parser */ \"./node_modules/postcss-js/parser.js\")\nlet async = __webpack_require__(/*! ./async */ \"./node_modules/postcss-js/async.js\")\nlet sync = __webpack_require__(/*! ./sync */ \"./node_modules/postcss-js/sync.js\")\n\nmodule.exports = {\n  objectify,\n  parse,\n  async,\n  sync\n}\n\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/postcss-js/index.js?");

/***/ }),

/***/ "./node_modules/postcss-js/objectifier.js":
/*!************************************************!*\
  !*** ./node_modules/postcss-js/objectifier.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("let camelcase = __webpack_require__(/*! camelcase-css */ \"./node_modules/camelcase-css/index-es5.js\")\n\nlet UNITLESS = {\n  boxFlex: true,\n  boxFlexGroup: true,\n  columnCount: true,\n  flex: true,\n  flexGrow: true,\n  flexPositive: true,\n  flexShrink: true,\n  flexNegative: true,\n  fontWeight: true,\n  lineClamp: true,\n  lineHeight: true,\n  opacity: true,\n  order: true,\n  orphans: true,\n  tabSize: true,\n  widows: true,\n  zIndex: true,\n  zoom: true,\n  fillOpacity: true,\n  strokeDashoffset: true,\n  strokeOpacity: true,\n  strokeWidth: true\n}\n\nfunction atRule(node) {\n  if (typeof node.nodes === 'undefined') {\n    return true\n  } else {\n    return process(node)\n  }\n}\n\nfunction process(node) {\n  let name\n  let result = {}\n\n  node.each(child => {\n    if (child.type === 'atrule') {\n      name = '@' + child.name\n      if (child.params) name += ' ' + child.params\n      if (typeof result[name] === 'undefined') {\n        result[name] = atRule(child)\n      } else if (Array.isArray(result[name])) {\n        result[name].push(atRule(child))\n      } else {\n        result[name] = [result[name], atRule(child)]\n      }\n    } else if (child.type === 'rule') {\n      let body = process(child)\n      if (result[child.selector]) {\n        for (let i in body) {\n          result[child.selector][i] = body[i]\n        }\n      } else {\n        result[child.selector] = body\n      }\n    } else if (child.type === 'decl') {\n      if (child.prop[0] === '-' && child.prop[1] === '-') {\n        name = child.prop\n      } else {\n        name = camelcase(child.prop)\n      }\n      let value = child.value\n      if (!isNaN(child.value) && UNITLESS[name]) {\n        value = parseFloat(child.value)\n      }\n      if (child.important) value += ' !important'\n      if (typeof result[name] === 'undefined') {\n        result[name] = value\n      } else if (Array.isArray(result[name])) {\n        result[name].push(value)\n      } else {\n        result[name] = [result[name], value]\n      }\n    }\n  })\n  return result\n}\n\nmodule.exports = process\n\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/postcss-js/objectifier.js?");

/***/ }),

/***/ "./node_modules/postcss-js/parser.js":
/*!*******************************************!*\
  !*** ./node_modules/postcss-js/parser.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("let postcss = __webpack_require__(/*! postcss */ \"./node_modules/postcss/lib/postcss.js\")\n\nlet IMPORTANT = /\\s*!important\\s*$/i\n\nlet UNITLESS = {\n  'box-flex': true,\n  'box-flex-group': true,\n  'column-count': true,\n  'flex': true,\n  'flex-grow': true,\n  'flex-positive': true,\n  'flex-shrink': true,\n  'flex-negative': true,\n  'font-weight': true,\n  'line-clamp': true,\n  'line-height': true,\n  'opacity': true,\n  'order': true,\n  'orphans': true,\n  'tab-size': true,\n  'widows': true,\n  'z-index': true,\n  'zoom': true,\n  'fill-opacity': true,\n  'stroke-dashoffset': true,\n  'stroke-opacity': true,\n  'stroke-width': true\n}\n\nfunction dashify(str) {\n  return str\n    .replace(/([A-Z])/g, '-$1')\n    .replace(/^ms-/, '-ms-')\n    .toLowerCase()\n}\n\nfunction decl(parent, name, value) {\n  if (value === false || value === null) return\n\n  if (!name.startsWith('--')) {\n    name = dashify(name)\n  }\n\n  if (typeof value === 'number') {\n    if (value === 0 || UNITLESS[name]) {\n      value = value.toString()\n    } else {\n      value += 'px'\n    }\n  }\n\n  if (name === 'css-float') name = 'float'\n\n  if (IMPORTANT.test(value)) {\n    value = value.replace(IMPORTANT, '')\n    parent.push(postcss.decl({ prop: name, value, important: true }))\n  } else {\n    parent.push(postcss.decl({ prop: name, value }))\n  }\n}\n\nfunction atRule(parent, parts, value) {\n  let node = postcss.atRule({ name: parts[1], params: parts[3] || '' })\n  if (typeof value === 'object') {\n    node.nodes = []\n    parse(value, node)\n  }\n  parent.push(node)\n}\n\nfunction parse(obj, parent) {\n  let name, value, node\n  for (name in obj) {\n    value = obj[name]\n    if (value === null || typeof value === 'undefined') {\n      continue\n    } else if (name[0] === '@') {\n      let parts = name.match(/@(\\S+)(\\s+([\\W\\w]*)\\s*)?/)\n      if (Array.isArray(value)) {\n        for (let i of value) {\n          atRule(parent, parts, i)\n        }\n      } else {\n        atRule(parent, parts, value)\n      }\n    } else if (Array.isArray(value)) {\n      for (let i of value) {\n        decl(parent, name, i)\n      }\n    } else if (typeof value === 'object') {\n      node = postcss.rule({ selector: name })\n      parse(value, node)\n      parent.push(node)\n    } else {\n      decl(parent, name, value)\n    }\n  }\n}\n\nmodule.exports = function (obj) {\n  let root = postcss.root()\n  parse(obj, root)\n  return root\n}\n\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/postcss-js/parser.js?");

/***/ }),

/***/ "./node_modules/postcss-js/process-result.js":
/*!***************************************************!*\
  !*** ./node_modules/postcss-js/process-result.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("let objectify = __webpack_require__(/*! ./objectifier */ \"./node_modules/postcss-js/objectifier.js\")\n\nmodule.exports = function processResult(result) {\n  if (console && console.warn) {\n    result.warnings().forEach(warn => {\n      let source = warn.plugin || 'PostCSS'\n      console.warn(source + ': ' + warn.text)\n    })\n  }\n  return objectify(result.root)\n}\n\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/postcss-js/process-result.js?");

/***/ }),

/***/ "./node_modules/postcss-js/sync.js":
/*!*****************************************!*\
  !*** ./node_modules/postcss-js/sync.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("let postcss = __webpack_require__(/*! postcss */ \"./node_modules/postcss/lib/postcss.js\")\n\nlet processResult = __webpack_require__(/*! ./process-result */ \"./node_modules/postcss-js/process-result.js\")\nlet parse = __webpack_require__(/*! ./parser */ \"./node_modules/postcss-js/parser.js\")\n\nmodule.exports = function (plugins) {\n  let processor = postcss(plugins)\n  return input => {\n    let result = processor.process(input, { parser: parse, from: undefined })\n    return processResult(result)\n  }\n}\n\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/postcss-js/sync.js?");

/***/ }),

/***/ "./node_modules/postcss-nested/index.js":
/*!**********************************************!*\
  !*** ./node_modules/postcss-nested/index.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("let parser = __webpack_require__(/*! postcss-selector-parser */ \"./node_modules/postcss-selector-parser/dist/index.js\")\n\nfunction parse (str, rule) {\n  let nodes\n  let saver = parser(parsed => {\n    nodes = parsed\n  })\n  try {\n    saver.processSync(str)\n  } catch (e) {\n    if (str.includes(':')) {\n      throw rule ? rule.error('Missed semicolon') : e\n    } else {\n      throw rule ? rule.error(e.message) : e\n    }\n  }\n  return nodes.at(0)\n}\n\nfunction replace (nodes, parent) {\n  let replaced = false\n  nodes.each(i => {\n    if (i.type === 'nesting') {\n      let clonedParent = parent.clone()\n      if (i.value !== '&') {\n        i.replaceWith(parse(i.value.replace('&', clonedParent.toString())))\n      } else {\n        i.replaceWith(clonedParent)\n      }\n      replaced = true\n    } else if (i.nodes) {\n      if (replace(i, parent)) {\n        replaced = true\n      }\n    }\n  })\n  return replaced\n}\n\nfunction selectors (parent, child) {\n  let result = []\n  parent.selectors.forEach(i => {\n    let parentNode = parse(i, parent)\n\n    child.selectors.forEach(j => {\n      if (j.length) {\n        let node = parse(j, child)\n        let replaced = replace(node, parentNode)\n        if (!replaced) {\n          node.prepend(parser.combinator({ value: ' ' }))\n          node.prepend(parentNode.clone())\n        }\n        result.push(node.toString())\n      }\n    })\n  })\n  return result\n}\n\nfunction pickComment (comment, after) {\n  if (comment && comment.type === 'comment') {\n    after.after(comment)\n    return comment\n  } else {\n    return after\n  }\n}\n\nfunction createFnAtruleChilds (bubble) {\n  return function atruleChilds (rule, atrule, bubbling) {\n    let children = []\n    atrule.each(child => {\n      if (child.type === 'comment') {\n        children.push(child)\n      } else if (child.type === 'decl') {\n        children.push(child)\n      } else if (child.type === 'rule' && bubbling) {\n        child.selectors = selectors(rule, child)\n      } else if (child.type === 'atrule') {\n        if (child.nodes && bubble[child.name]) {\n          atruleChilds(rule, child, true)\n        } else {\n          children.push(child)\n        }\n      }\n    })\n    if (bubbling) {\n      if (children.length) {\n        let clone = rule.clone({ nodes: [] })\n        for (let child of children) {\n          clone.append(child)\n        }\n        atrule.prepend(clone)\n      }\n    }\n  }\n}\n\nfunction pickDeclarations (selector, declarations, after, Rule) {\n  let parent = new Rule({\n    selector,\n    nodes: []\n  })\n\n  for (let declaration of declarations) {\n    parent.append(declaration)\n  }\n\n  after.after(parent)\n  return parent\n}\n\nfunction atruleNames (defaults, custom) {\n  let list = {}\n  for (let i of defaults) {\n    list[i] = true\n  }\n  if (custom) {\n    for (let i of custom) {\n      let name = i.replace(/^@/, '')\n      list[name] = true\n    }\n  }\n  return list\n}\n\nmodule.exports = (opts = {}) => {\n  let bubble = atruleNames(['media', 'supports'], opts.bubble)\n  let atruleChilds = createFnAtruleChilds(bubble)\n  let unwrap = atruleNames(\n    [\n      'document',\n      'font-face',\n      'keyframes',\n      '-webkit-keyframes',\n      '-moz-keyframes'\n    ],\n    opts.unwrap\n  )\n  let preserveEmpty = opts.preserveEmpty\n\n  return {\n    postcssPlugin: 'postcss-nested',\n    Rule (rule, { Rule }) {\n      let unwrapped = false\n      let after = rule\n      let copyDeclarations = false\n      let declarations = []\n\n      rule.each(child => {\n        if (child.type === 'rule') {\n          if (declarations.length) {\n            after = pickDeclarations(rule.selector, declarations, after, Rule)\n            declarations = []\n          }\n\n          copyDeclarations = true\n          unwrapped = true\n          child.selectors = selectors(rule, child)\n          after = pickComment(child.prev(), after)\n          after.after(child)\n          after = child\n        } else if (child.type === 'atrule') {\n          if (declarations.length) {\n            after = pickDeclarations(rule.selector, declarations, after, Rule)\n            declarations = []\n          }\n\n          if (child.name === 'at-root') {\n            unwrapped = true\n            atruleChilds(rule, child, false)\n\n            let nodes = child.nodes\n            if (child.params) {\n              nodes = new Rule({ selector: child.params, nodes })\n            }\n\n            after.after(nodes)\n            after = nodes\n            child.remove()\n          } else if (bubble[child.name]) {\n            copyDeclarations = true\n            unwrapped = true\n            atruleChilds(rule, child, true)\n            after = pickComment(child.prev(), after)\n            after.after(child)\n            after = child\n          } else if (unwrap[child.name]) {\n            copyDeclarations = true\n            unwrapped = true\n            atruleChilds(rule, child, false)\n            after = pickComment(child.prev(), after)\n            after.after(child)\n            after = child\n          } else if (copyDeclarations) {\n            declarations.push(child)\n          }\n        } else if (child.type === 'decl' && copyDeclarations) {\n          declarations.push(child)\n        }\n      })\n\n      if (declarations.length) {\n        after = pickDeclarations(rule.selector, declarations, after, Rule)\n      }\n\n      if (unwrapped && preserveEmpty !== true) {\n        rule.raws.semicolon = true\n        if (rule.nodes.length === 0) rule.remove()\n      }\n    }\n  }\n}\nmodule.exports.postcss = true\n\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/postcss-nested/index.js?");

/***/ }),

/***/ "./node_modules/postcss-selector-parser/dist/index.js":
/*!************************************************************!*\
  !*** ./node_modules/postcss-selector-parser/dist/index.js ***!
  \************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("\n\nexports.__esModule = true;\nexports[\"default\"] = void 0;\n\nvar _processor = _interopRequireDefault(__webpack_require__(/*! ./processor */ \"./node_modules/postcss-selector-parser/dist/processor.js\"));\n\nvar selectors = _interopRequireWildcard(__webpack_require__(/*! ./selectors */ \"./node_modules/postcss-selector-parser/dist/selectors/index.js\"));\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { \"default\": obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj[\"default\"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nvar parser = function parser(processor) {\n  return new _processor[\"default\"](processor);\n};\n\nObject.assign(parser, selectors);\ndelete parser.__esModule;\nvar _default = parser;\nexports[\"default\"] = _default;\nmodule.exports = exports.default;\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/postcss-selector-parser/dist/index.js?");

/***/ }),

/***/ "./node_modules/postcss-selector-parser/dist/parser.js":
/*!*************************************************************!*\
  !*** ./node_modules/postcss-selector-parser/dist/parser.js ***!
  \*************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("\n\nexports.__esModule = true;\nexports[\"default\"] = void 0;\n\nvar _root = _interopRequireDefault(__webpack_require__(/*! ./selectors/root */ \"./node_modules/postcss-selector-parser/dist/selectors/root.js\"));\n\nvar _selector = _interopRequireDefault(__webpack_require__(/*! ./selectors/selector */ \"./node_modules/postcss-selector-parser/dist/selectors/selector.js\"));\n\nvar _className = _interopRequireDefault(__webpack_require__(/*! ./selectors/className */ \"./node_modules/postcss-selector-parser/dist/selectors/className.js\"));\n\nvar _comment = _interopRequireDefault(__webpack_require__(/*! ./selectors/comment */ \"./node_modules/postcss-selector-parser/dist/selectors/comment.js\"));\n\nvar _id = _interopRequireDefault(__webpack_require__(/*! ./selectors/id */ \"./node_modules/postcss-selector-parser/dist/selectors/id.js\"));\n\nvar _tag = _interopRequireDefault(__webpack_require__(/*! ./selectors/tag */ \"./node_modules/postcss-selector-parser/dist/selectors/tag.js\"));\n\nvar _string = _interopRequireDefault(__webpack_require__(/*! ./selectors/string */ \"./node_modules/postcss-selector-parser/dist/selectors/string.js\"));\n\nvar _pseudo = _interopRequireDefault(__webpack_require__(/*! ./selectors/pseudo */ \"./node_modules/postcss-selector-parser/dist/selectors/pseudo.js\"));\n\nvar _attribute = _interopRequireWildcard(__webpack_require__(/*! ./selectors/attribute */ \"./node_modules/postcss-selector-parser/dist/selectors/attribute.js\"));\n\nvar _universal = _interopRequireDefault(__webpack_require__(/*! ./selectors/universal */ \"./node_modules/postcss-selector-parser/dist/selectors/universal.js\"));\n\nvar _combinator = _interopRequireDefault(__webpack_require__(/*! ./selectors/combinator */ \"./node_modules/postcss-selector-parser/dist/selectors/combinator.js\"));\n\nvar _nesting = _interopRequireDefault(__webpack_require__(/*! ./selectors/nesting */ \"./node_modules/postcss-selector-parser/dist/selectors/nesting.js\"));\n\nvar _sortAscending = _interopRequireDefault(__webpack_require__(/*! ./sortAscending */ \"./node_modules/postcss-selector-parser/dist/sortAscending.js\"));\n\nvar _tokenize = _interopRequireWildcard(__webpack_require__(/*! ./tokenize */ \"./node_modules/postcss-selector-parser/dist/tokenize.js\"));\n\nvar tokens = _interopRequireWildcard(__webpack_require__(/*! ./tokenTypes */ \"./node_modules/postcss-selector-parser/dist/tokenTypes.js\"));\n\nvar types = _interopRequireWildcard(__webpack_require__(/*! ./selectors/types */ \"./node_modules/postcss-selector-parser/dist/selectors/types.js\"));\n\nvar _util = __webpack_require__(/*! ./util */ \"./node_modules/postcss-selector-parser/dist/util/index.js\");\n\nvar _WHITESPACE_TOKENS, _Object$assign;\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { \"default\": obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj[\"default\"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar WHITESPACE_TOKENS = (_WHITESPACE_TOKENS = {}, _WHITESPACE_TOKENS[tokens.space] = true, _WHITESPACE_TOKENS[tokens.cr] = true, _WHITESPACE_TOKENS[tokens.feed] = true, _WHITESPACE_TOKENS[tokens.newline] = true, _WHITESPACE_TOKENS[tokens.tab] = true, _WHITESPACE_TOKENS);\nvar WHITESPACE_EQUIV_TOKENS = Object.assign({}, WHITESPACE_TOKENS, (_Object$assign = {}, _Object$assign[tokens.comment] = true, _Object$assign));\n\nfunction tokenStart(token) {\n  return {\n    line: token[_tokenize.FIELDS.START_LINE],\n    column: token[_tokenize.FIELDS.START_COL]\n  };\n}\n\nfunction tokenEnd(token) {\n  return {\n    line: token[_tokenize.FIELDS.END_LINE],\n    column: token[_tokenize.FIELDS.END_COL]\n  };\n}\n\nfunction getSource(startLine, startColumn, endLine, endColumn) {\n  return {\n    start: {\n      line: startLine,\n      column: startColumn\n    },\n    end: {\n      line: endLine,\n      column: endColumn\n    }\n  };\n}\n\nfunction getTokenSource(token) {\n  return getSource(token[_tokenize.FIELDS.START_LINE], token[_tokenize.FIELDS.START_COL], token[_tokenize.FIELDS.END_LINE], token[_tokenize.FIELDS.END_COL]);\n}\n\nfunction getTokenSourceSpan(startToken, endToken) {\n  if (!startToken) {\n    return undefined;\n  }\n\n  return getSource(startToken[_tokenize.FIELDS.START_LINE], startToken[_tokenize.FIELDS.START_COL], endToken[_tokenize.FIELDS.END_LINE], endToken[_tokenize.FIELDS.END_COL]);\n}\n\nfunction unescapeProp(node, prop) {\n  var value = node[prop];\n\n  if (typeof value !== \"string\") {\n    return;\n  }\n\n  if (value.indexOf(\"\\\\\") !== -1) {\n    (0, _util.ensureObject)(node, 'raws');\n    node[prop] = (0, _util.unesc)(value);\n\n    if (node.raws[prop] === undefined) {\n      node.raws[prop] = value;\n    }\n  }\n\n  return node;\n}\n\nfunction indexesOf(array, item) {\n  var i = -1;\n  var indexes = [];\n\n  while ((i = array.indexOf(item, i + 1)) !== -1) {\n    indexes.push(i);\n  }\n\n  return indexes;\n}\n\nfunction uniqs() {\n  var list = Array.prototype.concat.apply([], arguments);\n  return list.filter(function (item, i) {\n    return i === list.indexOf(item);\n  });\n}\n\nvar Parser = /*#__PURE__*/function () {\n  function Parser(rule, options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    this.rule = rule;\n    this.options = Object.assign({\n      lossy: false,\n      safe: false\n    }, options);\n    this.position = 0;\n    this.css = typeof this.rule === 'string' ? this.rule : this.rule.selector;\n    this.tokens = (0, _tokenize[\"default\"])({\n      css: this.css,\n      error: this._errorGenerator(),\n      safe: this.options.safe\n    });\n    var rootSource = getTokenSourceSpan(this.tokens[0], this.tokens[this.tokens.length - 1]);\n    this.root = new _root[\"default\"]({\n      source: rootSource\n    });\n    this.root.errorGenerator = this._errorGenerator();\n    var selector = new _selector[\"default\"]({\n      source: {\n        start: {\n          line: 1,\n          column: 1\n        }\n      }\n    });\n    this.root.append(selector);\n    this.current = selector;\n    this.loop();\n  }\n\n  var _proto = Parser.prototype;\n\n  _proto._errorGenerator = function _errorGenerator() {\n    var _this = this;\n\n    return function (message, errorOptions) {\n      if (typeof _this.rule === 'string') {\n        return new Error(message);\n      }\n\n      return _this.rule.error(message, errorOptions);\n    };\n  };\n\n  _proto.attribute = function attribute() {\n    var attr = [];\n    var startingToken = this.currToken;\n    this.position++;\n\n    while (this.position < this.tokens.length && this.currToken[_tokenize.FIELDS.TYPE] !== tokens.closeSquare) {\n      attr.push(this.currToken);\n      this.position++;\n    }\n\n    if (this.currToken[_tokenize.FIELDS.TYPE] !== tokens.closeSquare) {\n      return this.expected('closing square bracket', this.currToken[_tokenize.FIELDS.START_POS]);\n    }\n\n    var len = attr.length;\n    var node = {\n      source: getSource(startingToken[1], startingToken[2], this.currToken[3], this.currToken[4]),\n      sourceIndex: startingToken[_tokenize.FIELDS.START_POS]\n    };\n\n    if (len === 1 && !~[tokens.word].indexOf(attr[0][_tokenize.FIELDS.TYPE])) {\n      return this.expected('attribute', attr[0][_tokenize.FIELDS.START_POS]);\n    }\n\n    var pos = 0;\n    var spaceBefore = '';\n    var commentBefore = '';\n    var lastAdded = null;\n    var spaceAfterMeaningfulToken = false;\n\n    while (pos < len) {\n      var token = attr[pos];\n      var content = this.content(token);\n      var next = attr[pos + 1];\n\n      switch (token[_tokenize.FIELDS.TYPE]) {\n        case tokens.space:\n          // if (\n          //     len === 1 ||\n          //     pos === 0 && this.content(next) === '|'\n          // ) {\n          //     return this.expected('attribute', token[TOKEN.START_POS], content);\n          // }\n          spaceAfterMeaningfulToken = true;\n\n          if (this.options.lossy) {\n            break;\n          }\n\n          if (lastAdded) {\n            (0, _util.ensureObject)(node, 'spaces', lastAdded);\n            var prevContent = node.spaces[lastAdded].after || '';\n            node.spaces[lastAdded].after = prevContent + content;\n            var existingComment = (0, _util.getProp)(node, 'raws', 'spaces', lastAdded, 'after') || null;\n\n            if (existingComment) {\n              node.raws.spaces[lastAdded].after = existingComment + content;\n            }\n          } else {\n            spaceBefore = spaceBefore + content;\n            commentBefore = commentBefore + content;\n          }\n\n          break;\n\n        case tokens.asterisk:\n          if (next[_tokenize.FIELDS.TYPE] === tokens.equals) {\n            node.operator = content;\n            lastAdded = 'operator';\n          } else if ((!node.namespace || lastAdded === \"namespace\" && !spaceAfterMeaningfulToken) && next) {\n            if (spaceBefore) {\n              (0, _util.ensureObject)(node, 'spaces', 'attribute');\n              node.spaces.attribute.before = spaceBefore;\n              spaceBefore = '';\n            }\n\n            if (commentBefore) {\n              (0, _util.ensureObject)(node, 'raws', 'spaces', 'attribute');\n              node.raws.spaces.attribute.before = spaceBefore;\n              commentBefore = '';\n            }\n\n            node.namespace = (node.namespace || \"\") + content;\n            var rawValue = (0, _util.getProp)(node, 'raws', 'namespace') || null;\n\n            if (rawValue) {\n              node.raws.namespace += content;\n            }\n\n            lastAdded = 'namespace';\n          }\n\n          spaceAfterMeaningfulToken = false;\n          break;\n\n        case tokens.dollar:\n          if (lastAdded === \"value\") {\n            var oldRawValue = (0, _util.getProp)(node, 'raws', 'value');\n            node.value += \"$\";\n\n            if (oldRawValue) {\n              node.raws.value = oldRawValue + \"$\";\n            }\n\n            break;\n          }\n\n        // Falls through\n\n        case tokens.caret:\n          if (next[_tokenize.FIELDS.TYPE] === tokens.equals) {\n            node.operator = content;\n            lastAdded = 'operator';\n          }\n\n          spaceAfterMeaningfulToken = false;\n          break;\n\n        case tokens.combinator:\n          if (content === '~' && next[_tokenize.FIELDS.TYPE] === tokens.equals) {\n            node.operator = content;\n            lastAdded = 'operator';\n          }\n\n          if (content !== '|') {\n            spaceAfterMeaningfulToken = false;\n            break;\n          }\n\n          if (next[_tokenize.FIELDS.TYPE] === tokens.equals) {\n            node.operator = content;\n            lastAdded = 'operator';\n          } else if (!node.namespace && !node.attribute) {\n            node.namespace = true;\n          }\n\n          spaceAfterMeaningfulToken = false;\n          break;\n\n        case tokens.word:\n          if (next && this.content(next) === '|' && attr[pos + 2] && attr[pos + 2][_tokenize.FIELDS.TYPE] !== tokens.equals && // this look-ahead probably fails with comment nodes involved.\n          !node.operator && !node.namespace) {\n            node.namespace = content;\n            lastAdded = 'namespace';\n          } else if (!node.attribute || lastAdded === \"attribute\" && !spaceAfterMeaningfulToken) {\n            if (spaceBefore) {\n              (0, _util.ensureObject)(node, 'spaces', 'attribute');\n              node.spaces.attribute.before = spaceBefore;\n              spaceBefore = '';\n            }\n\n            if (commentBefore) {\n              (0, _util.ensureObject)(node, 'raws', 'spaces', 'attribute');\n              node.raws.spaces.attribute.before = commentBefore;\n              commentBefore = '';\n            }\n\n            node.attribute = (node.attribute || \"\") + content;\n\n            var _rawValue = (0, _util.getProp)(node, 'raws', 'attribute') || null;\n\n            if (_rawValue) {\n              node.raws.attribute += content;\n            }\n\n            lastAdded = 'attribute';\n          } else if (!node.value && node.value !== \"\" || lastAdded === \"value\" && !spaceAfterMeaningfulToken) {\n            var _unescaped = (0, _util.unesc)(content);\n\n            var _oldRawValue = (0, _util.getProp)(node, 'raws', 'value') || '';\n\n            var oldValue = node.value || '';\n            node.value = oldValue + _unescaped;\n            node.quoteMark = null;\n\n            if (_unescaped !== content || _oldRawValue) {\n              (0, _util.ensureObject)(node, 'raws');\n              node.raws.value = (_oldRawValue || oldValue) + content;\n            }\n\n            lastAdded = 'value';\n          } else {\n            var insensitive = content === 'i' || content === \"I\";\n\n            if ((node.value || node.value === '') && (node.quoteMark || spaceAfterMeaningfulToken)) {\n              node.insensitive = insensitive;\n\n              if (!insensitive || content === \"I\") {\n                (0, _util.ensureObject)(node, 'raws');\n                node.raws.insensitiveFlag = content;\n              }\n\n              lastAdded = 'insensitive';\n\n              if (spaceBefore) {\n                (0, _util.ensureObject)(node, 'spaces', 'insensitive');\n                node.spaces.insensitive.before = spaceBefore;\n                spaceBefore = '';\n              }\n\n              if (commentBefore) {\n                (0, _util.ensureObject)(node, 'raws', 'spaces', 'insensitive');\n                node.raws.spaces.insensitive.before = commentBefore;\n                commentBefore = '';\n              }\n            } else if (node.value || node.value === '') {\n              lastAdded = 'value';\n              node.value += content;\n\n              if (node.raws.value) {\n                node.raws.value += content;\n              }\n            }\n          }\n\n          spaceAfterMeaningfulToken = false;\n          break;\n\n        case tokens.str:\n          if (!node.attribute || !node.operator) {\n            return this.error(\"Expected an attribute followed by an operator preceding the string.\", {\n              index: token[_tokenize.FIELDS.START_POS]\n            });\n          }\n\n          var _unescapeValue = (0, _attribute.unescapeValue)(content),\n              unescaped = _unescapeValue.unescaped,\n              quoteMark = _unescapeValue.quoteMark;\n\n          node.value = unescaped;\n          node.quoteMark = quoteMark;\n          lastAdded = 'value';\n          (0, _util.ensureObject)(node, 'raws');\n          node.raws.value = content;\n          spaceAfterMeaningfulToken = false;\n          break;\n\n        case tokens.equals:\n          if (!node.attribute) {\n            return this.expected('attribute', token[_tokenize.FIELDS.START_POS], content);\n          }\n\n          if (node.value) {\n            return this.error('Unexpected \"=\" found; an operator was already defined.', {\n              index: token[_tokenize.FIELDS.START_POS]\n            });\n          }\n\n          node.operator = node.operator ? node.operator + content : content;\n          lastAdded = 'operator';\n          spaceAfterMeaningfulToken = false;\n          break;\n\n        case tokens.comment:\n          if (lastAdded) {\n            if (spaceAfterMeaningfulToken || next && next[_tokenize.FIELDS.TYPE] === tokens.space || lastAdded === 'insensitive') {\n              var lastComment = (0, _util.getProp)(node, 'spaces', lastAdded, 'after') || '';\n              var rawLastComment = (0, _util.getProp)(node, 'raws', 'spaces', lastAdded, 'after') || lastComment;\n              (0, _util.ensureObject)(node, 'raws', 'spaces', lastAdded);\n              node.raws.spaces[lastAdded].after = rawLastComment + content;\n            } else {\n              var lastValue = node[lastAdded] || '';\n              var rawLastValue = (0, _util.getProp)(node, 'raws', lastAdded) || lastValue;\n              (0, _util.ensureObject)(node, 'raws');\n              node.raws[lastAdded] = rawLastValue + content;\n            }\n          } else {\n            commentBefore = commentBefore + content;\n          }\n\n          break;\n\n        default:\n          return this.error(\"Unexpected \\\"\" + content + \"\\\" found.\", {\n            index: token[_tokenize.FIELDS.START_POS]\n          });\n      }\n\n      pos++;\n    }\n\n    unescapeProp(node, \"attribute\");\n    unescapeProp(node, \"namespace\");\n    this.newNode(new _attribute[\"default\"](node));\n    this.position++;\n  }\n  /**\n   * return a node containing meaningless garbage up to (but not including) the specified token position.\n   * if the token position is negative, all remaining tokens are consumed.\n   *\n   * This returns an array containing a single string node if all whitespace,\n   * otherwise an array of comment nodes with space before and after.\n   *\n   * These tokens are not added to the current selector, the caller can add them or use them to amend\n   * a previous node's space metadata.\n   *\n   * In lossy mode, this returns only comments.\n   */\n  ;\n\n  _proto.parseWhitespaceEquivalentTokens = function parseWhitespaceEquivalentTokens(stopPosition) {\n    if (stopPosition < 0) {\n      stopPosition = this.tokens.length;\n    }\n\n    var startPosition = this.position;\n    var nodes = [];\n    var space = \"\";\n    var lastComment = undefined;\n\n    do {\n      if (WHITESPACE_TOKENS[this.currToken[_tokenize.FIELDS.TYPE]]) {\n        if (!this.options.lossy) {\n          space += this.content();\n        }\n      } else if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.comment) {\n        var spaces = {};\n\n        if (space) {\n          spaces.before = space;\n          space = \"\";\n        }\n\n        lastComment = new _comment[\"default\"]({\n          value: this.content(),\n          source: getTokenSource(this.currToken),\n          sourceIndex: this.currToken[_tokenize.FIELDS.START_POS],\n          spaces: spaces\n        });\n        nodes.push(lastComment);\n      }\n    } while (++this.position < stopPosition);\n\n    if (space) {\n      if (lastComment) {\n        lastComment.spaces.after = space;\n      } else if (!this.options.lossy) {\n        var firstToken = this.tokens[startPosition];\n        var lastToken = this.tokens[this.position - 1];\n        nodes.push(new _string[\"default\"]({\n          value: '',\n          source: getSource(firstToken[_tokenize.FIELDS.START_LINE], firstToken[_tokenize.FIELDS.START_COL], lastToken[_tokenize.FIELDS.END_LINE], lastToken[_tokenize.FIELDS.END_COL]),\n          sourceIndex: firstToken[_tokenize.FIELDS.START_POS],\n          spaces: {\n            before: space,\n            after: ''\n          }\n        }));\n      }\n    }\n\n    return nodes;\n  }\n  /**\n   * \n   * @param {*} nodes \n   */\n  ;\n\n  _proto.convertWhitespaceNodesToSpace = function convertWhitespaceNodesToSpace(nodes, requiredSpace) {\n    var _this2 = this;\n\n    if (requiredSpace === void 0) {\n      requiredSpace = false;\n    }\n\n    var space = \"\";\n    var rawSpace = \"\";\n    nodes.forEach(function (n) {\n      var spaceBefore = _this2.lossySpace(n.spaces.before, requiredSpace);\n\n      var rawSpaceBefore = _this2.lossySpace(n.rawSpaceBefore, requiredSpace);\n\n      space += spaceBefore + _this2.lossySpace(n.spaces.after, requiredSpace && spaceBefore.length === 0);\n      rawSpace += spaceBefore + n.value + _this2.lossySpace(n.rawSpaceAfter, requiredSpace && rawSpaceBefore.length === 0);\n    });\n\n    if (rawSpace === space) {\n      rawSpace = undefined;\n    }\n\n    var result = {\n      space: space,\n      rawSpace: rawSpace\n    };\n    return result;\n  };\n\n  _proto.isNamedCombinator = function isNamedCombinator(position) {\n    if (position === void 0) {\n      position = this.position;\n    }\n\n    return this.tokens[position + 0] && this.tokens[position + 0][_tokenize.FIELDS.TYPE] === tokens.slash && this.tokens[position + 1] && this.tokens[position + 1][_tokenize.FIELDS.TYPE] === tokens.word && this.tokens[position + 2] && this.tokens[position + 2][_tokenize.FIELDS.TYPE] === tokens.slash;\n  };\n\n  _proto.namedCombinator = function namedCombinator() {\n    if (this.isNamedCombinator()) {\n      var nameRaw = this.content(this.tokens[this.position + 1]);\n      var name = (0, _util.unesc)(nameRaw).toLowerCase();\n      var raws = {};\n\n      if (name !== nameRaw) {\n        raws.value = \"/\" + nameRaw + \"/\";\n      }\n\n      var node = new _combinator[\"default\"]({\n        value: \"/\" + name + \"/\",\n        source: getSource(this.currToken[_tokenize.FIELDS.START_LINE], this.currToken[_tokenize.FIELDS.START_COL], this.tokens[this.position + 2][_tokenize.FIELDS.END_LINE], this.tokens[this.position + 2][_tokenize.FIELDS.END_COL]),\n        sourceIndex: this.currToken[_tokenize.FIELDS.START_POS],\n        raws: raws\n      });\n      this.position = this.position + 3;\n      return node;\n    } else {\n      this.unexpected();\n    }\n  };\n\n  _proto.combinator = function combinator() {\n    var _this3 = this;\n\n    if (this.content() === '|') {\n      return this.namespace();\n    } // We need to decide between a space that's a descendant combinator and meaningless whitespace at the end of a selector.\n\n\n    var nextSigTokenPos = this.locateNextMeaningfulToken(this.position);\n\n    if (nextSigTokenPos < 0 || this.tokens[nextSigTokenPos][_tokenize.FIELDS.TYPE] === tokens.comma) {\n      var nodes = this.parseWhitespaceEquivalentTokens(nextSigTokenPos);\n\n      if (nodes.length > 0) {\n        var last = this.current.last;\n\n        if (last) {\n          var _this$convertWhitespa = this.convertWhitespaceNodesToSpace(nodes),\n              space = _this$convertWhitespa.space,\n              rawSpace = _this$convertWhitespa.rawSpace;\n\n          if (rawSpace !== undefined) {\n            last.rawSpaceAfter += rawSpace;\n          }\n\n          last.spaces.after += space;\n        } else {\n          nodes.forEach(function (n) {\n            return _this3.newNode(n);\n          });\n        }\n      }\n\n      return;\n    }\n\n    var firstToken = this.currToken;\n    var spaceOrDescendantSelectorNodes = undefined;\n\n    if (nextSigTokenPos > this.position) {\n      spaceOrDescendantSelectorNodes = this.parseWhitespaceEquivalentTokens(nextSigTokenPos);\n    }\n\n    var node;\n\n    if (this.isNamedCombinator()) {\n      node = this.namedCombinator();\n    } else if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.combinator) {\n      node = new _combinator[\"default\"]({\n        value: this.content(),\n        source: getTokenSource(this.currToken),\n        sourceIndex: this.currToken[_tokenize.FIELDS.START_POS]\n      });\n      this.position++;\n    } else if (WHITESPACE_TOKENS[this.currToken[_tokenize.FIELDS.TYPE]]) {// pass\n    } else if (!spaceOrDescendantSelectorNodes) {\n      this.unexpected();\n    }\n\n    if (node) {\n      if (spaceOrDescendantSelectorNodes) {\n        var _this$convertWhitespa2 = this.convertWhitespaceNodesToSpace(spaceOrDescendantSelectorNodes),\n            _space = _this$convertWhitespa2.space,\n            _rawSpace = _this$convertWhitespa2.rawSpace;\n\n        node.spaces.before = _space;\n        node.rawSpaceBefore = _rawSpace;\n      }\n    } else {\n      // descendant combinator\n      var _this$convertWhitespa3 = this.convertWhitespaceNodesToSpace(spaceOrDescendantSelectorNodes, true),\n          _space2 = _this$convertWhitespa3.space,\n          _rawSpace2 = _this$convertWhitespa3.rawSpace;\n\n      if (!_rawSpace2) {\n        _rawSpace2 = _space2;\n      }\n\n      var spaces = {};\n      var raws = {\n        spaces: {}\n      };\n\n      if (_space2.endsWith(' ') && _rawSpace2.endsWith(' ')) {\n        spaces.before = _space2.slice(0, _space2.length - 1);\n        raws.spaces.before = _rawSpace2.slice(0, _rawSpace2.length - 1);\n      } else if (_space2.startsWith(' ') && _rawSpace2.startsWith(' ')) {\n        spaces.after = _space2.slice(1);\n        raws.spaces.after = _rawSpace2.slice(1);\n      } else {\n        raws.value = _rawSpace2;\n      }\n\n      node = new _combinator[\"default\"]({\n        value: ' ',\n        source: getTokenSourceSpan(firstToken, this.tokens[this.position - 1]),\n        sourceIndex: firstToken[_tokenize.FIELDS.START_POS],\n        spaces: spaces,\n        raws: raws\n      });\n    }\n\n    if (this.currToken && this.currToken[_tokenize.FIELDS.TYPE] === tokens.space) {\n      node.spaces.after = this.optionalSpace(this.content());\n      this.position++;\n    }\n\n    return this.newNode(node);\n  };\n\n  _proto.comma = function comma() {\n    if (this.position === this.tokens.length - 1) {\n      this.root.trailingComma = true;\n      this.position++;\n      return;\n    }\n\n    this.current._inferEndPosition();\n\n    var selector = new _selector[\"default\"]({\n      source: {\n        start: tokenStart(this.tokens[this.position + 1])\n      }\n    });\n    this.current.parent.append(selector);\n    this.current = selector;\n    this.position++;\n  };\n\n  _proto.comment = function comment() {\n    var current = this.currToken;\n    this.newNode(new _comment[\"default\"]({\n      value: this.content(),\n      source: getTokenSource(current),\n      sourceIndex: current[_tokenize.FIELDS.START_POS]\n    }));\n    this.position++;\n  };\n\n  _proto.error = function error(message, opts) {\n    throw this.root.error(message, opts);\n  };\n\n  _proto.missingBackslash = function missingBackslash() {\n    return this.error('Expected a backslash preceding the semicolon.', {\n      index: this.currToken[_tokenize.FIELDS.START_POS]\n    });\n  };\n\n  _proto.missingParenthesis = function missingParenthesis() {\n    return this.expected('opening parenthesis', this.currToken[_tokenize.FIELDS.START_POS]);\n  };\n\n  _proto.missingSquareBracket = function missingSquareBracket() {\n    return this.expected('opening square bracket', this.currToken[_tokenize.FIELDS.START_POS]);\n  };\n\n  _proto.unexpected = function unexpected() {\n    return this.error(\"Unexpected '\" + this.content() + \"'. Escaping special characters with \\\\ may help.\", this.currToken[_tokenize.FIELDS.START_POS]);\n  };\n\n  _proto.namespace = function namespace() {\n    var before = this.prevToken && this.content(this.prevToken) || true;\n\n    if (this.nextToken[_tokenize.FIELDS.TYPE] === tokens.word) {\n      this.position++;\n      return this.word(before);\n    } else if (this.nextToken[_tokenize.FIELDS.TYPE] === tokens.asterisk) {\n      this.position++;\n      return this.universal(before);\n    }\n  };\n\n  _proto.nesting = function nesting() {\n    if (this.nextToken) {\n      var nextContent = this.content(this.nextToken);\n\n      if (nextContent === \"|\") {\n        this.position++;\n        return;\n      }\n    }\n\n    var current = this.currToken;\n    this.newNode(new _nesting[\"default\"]({\n      value: this.content(),\n      source: getTokenSource(current),\n      sourceIndex: current[_tokenize.FIELDS.START_POS]\n    }));\n    this.position++;\n  };\n\n  _proto.parentheses = function parentheses() {\n    var last = this.current.last;\n    var unbalanced = 1;\n    this.position++;\n\n    if (last && last.type === types.PSEUDO) {\n      var selector = new _selector[\"default\"]({\n        source: {\n          start: tokenStart(this.tokens[this.position - 1])\n        }\n      });\n      var cache = this.current;\n      last.append(selector);\n      this.current = selector;\n\n      while (this.position < this.tokens.length && unbalanced) {\n        if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.openParenthesis) {\n          unbalanced++;\n        }\n\n        if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.closeParenthesis) {\n          unbalanced--;\n        }\n\n        if (unbalanced) {\n          this.parse();\n        } else {\n          this.current.source.end = tokenEnd(this.currToken);\n          this.current.parent.source.end = tokenEnd(this.currToken);\n          this.position++;\n        }\n      }\n\n      this.current = cache;\n    } else {\n      // I think this case should be an error. It's used to implement a basic parse of media queries\n      // but I don't think it's a good idea.\n      var parenStart = this.currToken;\n      var parenValue = \"(\";\n      var parenEnd;\n\n      while (this.position < this.tokens.length && unbalanced) {\n        if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.openParenthesis) {\n          unbalanced++;\n        }\n\n        if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.closeParenthesis) {\n          unbalanced--;\n        }\n\n        parenEnd = this.currToken;\n        parenValue += this.parseParenthesisToken(this.currToken);\n        this.position++;\n      }\n\n      if (last) {\n        last.appendToPropertyAndEscape(\"value\", parenValue, parenValue);\n      } else {\n        this.newNode(new _string[\"default\"]({\n          value: parenValue,\n          source: getSource(parenStart[_tokenize.FIELDS.START_LINE], parenStart[_tokenize.FIELDS.START_COL], parenEnd[_tokenize.FIELDS.END_LINE], parenEnd[_tokenize.FIELDS.END_COL]),\n          sourceIndex: parenStart[_tokenize.FIELDS.START_POS]\n        }));\n      }\n    }\n\n    if (unbalanced) {\n      return this.expected('closing parenthesis', this.currToken[_tokenize.FIELDS.START_POS]);\n    }\n  };\n\n  _proto.pseudo = function pseudo() {\n    var _this4 = this;\n\n    var pseudoStr = '';\n    var startingToken = this.currToken;\n\n    while (this.currToken && this.currToken[_tokenize.FIELDS.TYPE] === tokens.colon) {\n      pseudoStr += this.content();\n      this.position++;\n    }\n\n    if (!this.currToken) {\n      return this.expected(['pseudo-class', 'pseudo-element'], this.position - 1);\n    }\n\n    if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.word) {\n      this.splitWord(false, function (first, length) {\n        pseudoStr += first;\n\n        _this4.newNode(new _pseudo[\"default\"]({\n          value: pseudoStr,\n          source: getTokenSourceSpan(startingToken, _this4.currToken),\n          sourceIndex: startingToken[_tokenize.FIELDS.START_POS]\n        }));\n\n        if (length > 1 && _this4.nextToken && _this4.nextToken[_tokenize.FIELDS.TYPE] === tokens.openParenthesis) {\n          _this4.error('Misplaced parenthesis.', {\n            index: _this4.nextToken[_tokenize.FIELDS.START_POS]\n          });\n        }\n      });\n    } else {\n      return this.expected(['pseudo-class', 'pseudo-element'], this.currToken[_tokenize.FIELDS.START_POS]);\n    }\n  };\n\n  _proto.space = function space() {\n    var content = this.content(); // Handle space before and after the selector\n\n    if (this.position === 0 || this.prevToken[_tokenize.FIELDS.TYPE] === tokens.comma || this.prevToken[_tokenize.FIELDS.TYPE] === tokens.openParenthesis || this.current.nodes.every(function (node) {\n      return node.type === 'comment';\n    })) {\n      this.spaces = this.optionalSpace(content);\n      this.position++;\n    } else if (this.position === this.tokens.length - 1 || this.nextToken[_tokenize.FIELDS.TYPE] === tokens.comma || this.nextToken[_tokenize.FIELDS.TYPE] === tokens.closeParenthesis) {\n      this.current.last.spaces.after = this.optionalSpace(content);\n      this.position++;\n    } else {\n      this.combinator();\n    }\n  };\n\n  _proto.string = function string() {\n    var current = this.currToken;\n    this.newNode(new _string[\"default\"]({\n      value: this.content(),\n      source: getTokenSource(current),\n      sourceIndex: current[_tokenize.FIELDS.START_POS]\n    }));\n    this.position++;\n  };\n\n  _proto.universal = function universal(namespace) {\n    var nextToken = this.nextToken;\n\n    if (nextToken && this.content(nextToken) === '|') {\n      this.position++;\n      return this.namespace();\n    }\n\n    var current = this.currToken;\n    this.newNode(new _universal[\"default\"]({\n      value: this.content(),\n      source: getTokenSource(current),\n      sourceIndex: current[_tokenize.FIELDS.START_POS]\n    }), namespace);\n    this.position++;\n  };\n\n  _proto.splitWord = function splitWord(namespace, firstCallback) {\n    var _this5 = this;\n\n    var nextToken = this.nextToken;\n    var word = this.content();\n\n    while (nextToken && ~[tokens.dollar, tokens.caret, tokens.equals, tokens.word].indexOf(nextToken[_tokenize.FIELDS.TYPE])) {\n      this.position++;\n      var current = this.content();\n      word += current;\n\n      if (current.lastIndexOf('\\\\') === current.length - 1) {\n        var next = this.nextToken;\n\n        if (next && next[_tokenize.FIELDS.TYPE] === tokens.space) {\n          word += this.requiredSpace(this.content(next));\n          this.position++;\n        }\n      }\n\n      nextToken = this.nextToken;\n    }\n\n    var hasClass = indexesOf(word, '.').filter(function (i) {\n      // Allow escaped dot within class name\n      var escapedDot = word[i - 1] === '\\\\'; // Allow decimal numbers percent in @keyframes\n\n      var isKeyframesPercent = /^\\d+\\.\\d+%$/.test(word);\n      return !escapedDot && !isKeyframesPercent;\n    });\n    var hasId = indexesOf(word, '#').filter(function (i) {\n      return word[i - 1] !== '\\\\';\n    }); // Eliminate Sass interpolations from the list of id indexes\n\n    var interpolations = indexesOf(word, '#{');\n\n    if (interpolations.length) {\n      hasId = hasId.filter(function (hashIndex) {\n        return !~interpolations.indexOf(hashIndex);\n      });\n    }\n\n    var indices = (0, _sortAscending[\"default\"])(uniqs([0].concat(hasClass, hasId)));\n    indices.forEach(function (ind, i) {\n      var index = indices[i + 1] || word.length;\n      var value = word.slice(ind, index);\n\n      if (i === 0 && firstCallback) {\n        return firstCallback.call(_this5, value, indices.length);\n      }\n\n      var node;\n      var current = _this5.currToken;\n      var sourceIndex = current[_tokenize.FIELDS.START_POS] + indices[i];\n      var source = getSource(current[1], current[2] + ind, current[3], current[2] + (index - 1));\n\n      if (~hasClass.indexOf(ind)) {\n        var classNameOpts = {\n          value: value.slice(1),\n          source: source,\n          sourceIndex: sourceIndex\n        };\n        node = new _className[\"default\"](unescapeProp(classNameOpts, \"value\"));\n      } else if (~hasId.indexOf(ind)) {\n        var idOpts = {\n          value: value.slice(1),\n          source: source,\n          sourceIndex: sourceIndex\n        };\n        node = new _id[\"default\"](unescapeProp(idOpts, \"value\"));\n      } else {\n        var tagOpts = {\n          value: value,\n          source: source,\n          sourceIndex: sourceIndex\n        };\n        unescapeProp(tagOpts, \"value\");\n        node = new _tag[\"default\"](tagOpts);\n      }\n\n      _this5.newNode(node, namespace); // Ensure that the namespace is used only once\n\n\n      namespace = null;\n    });\n    this.position++;\n  };\n\n  _proto.word = function word(namespace) {\n    var nextToken = this.nextToken;\n\n    if (nextToken && this.content(nextToken) === '|') {\n      this.position++;\n      return this.namespace();\n    }\n\n    return this.splitWord(namespace);\n  };\n\n  _proto.loop = function loop() {\n    while (this.position < this.tokens.length) {\n      this.parse(true);\n    }\n\n    this.current._inferEndPosition();\n\n    return this.root;\n  };\n\n  _proto.parse = function parse(throwOnParenthesis) {\n    switch (this.currToken[_tokenize.FIELDS.TYPE]) {\n      case tokens.space:\n        this.space();\n        break;\n\n      case tokens.comment:\n        this.comment();\n        break;\n\n      case tokens.openParenthesis:\n        this.parentheses();\n        break;\n\n      case tokens.closeParenthesis:\n        if (throwOnParenthesis) {\n          this.missingParenthesis();\n        }\n\n        break;\n\n      case tokens.openSquare:\n        this.attribute();\n        break;\n\n      case tokens.dollar:\n      case tokens.caret:\n      case tokens.equals:\n      case tokens.word:\n        this.word();\n        break;\n\n      case tokens.colon:\n        this.pseudo();\n        break;\n\n      case tokens.comma:\n        this.comma();\n        break;\n\n      case tokens.asterisk:\n        this.universal();\n        break;\n\n      case tokens.ampersand:\n        this.nesting();\n        break;\n\n      case tokens.slash:\n      case tokens.combinator:\n        this.combinator();\n        break;\n\n      case tokens.str:\n        this.string();\n        break;\n      // These cases throw; no break needed.\n\n      case tokens.closeSquare:\n        this.missingSquareBracket();\n\n      case tokens.semicolon:\n        this.missingBackslash();\n\n      default:\n        this.unexpected();\n    }\n  }\n  /**\n   * Helpers\n   */\n  ;\n\n  _proto.expected = function expected(description, index, found) {\n    if (Array.isArray(description)) {\n      var last = description.pop();\n      description = description.join(', ') + \" or \" + last;\n    }\n\n    var an = /^[aeiou]/.test(description[0]) ? 'an' : 'a';\n\n    if (!found) {\n      return this.error(\"Expected \" + an + \" \" + description + \".\", {\n        index: index\n      });\n    }\n\n    return this.error(\"Expected \" + an + \" \" + description + \", found \\\"\" + found + \"\\\" instead.\", {\n      index: index\n    });\n  };\n\n  _proto.requiredSpace = function requiredSpace(space) {\n    return this.options.lossy ? ' ' : space;\n  };\n\n  _proto.optionalSpace = function optionalSpace(space) {\n    return this.options.lossy ? '' : space;\n  };\n\n  _proto.lossySpace = function lossySpace(space, required) {\n    if (this.options.lossy) {\n      return required ? ' ' : '';\n    } else {\n      return space;\n    }\n  };\n\n  _proto.parseParenthesisToken = function parseParenthesisToken(token) {\n    var content = this.content(token);\n\n    if (token[_tokenize.FIELDS.TYPE] === tokens.space) {\n      return this.requiredSpace(content);\n    } else {\n      return content;\n    }\n  };\n\n  _proto.newNode = function newNode(node, namespace) {\n    if (namespace) {\n      if (/^ +$/.test(namespace)) {\n        if (!this.options.lossy) {\n          this.spaces = (this.spaces || '') + namespace;\n        }\n\n        namespace = true;\n      }\n\n      node.namespace = namespace;\n      unescapeProp(node, \"namespace\");\n    }\n\n    if (this.spaces) {\n      node.spaces.before = this.spaces;\n      this.spaces = '';\n    }\n\n    return this.current.append(node);\n  };\n\n  _proto.content = function content(token) {\n    if (token === void 0) {\n      token = this.currToken;\n    }\n\n    return this.css.slice(token[_tokenize.FIELDS.START_POS], token[_tokenize.FIELDS.END_POS]);\n  };\n\n  /**\n   * returns the index of the next non-whitespace, non-comment token.\n   * returns -1 if no meaningful token is found.\n   */\n  _proto.locateNextMeaningfulToken = function locateNextMeaningfulToken(startPosition) {\n    if (startPosition === void 0) {\n      startPosition = this.position + 1;\n    }\n\n    var searchPosition = startPosition;\n\n    while (searchPosition < this.tokens.length) {\n      if (WHITESPACE_EQUIV_TOKENS[this.tokens[searchPosition][_tokenize.FIELDS.TYPE]]) {\n        searchPosition++;\n        continue;\n      } else {\n        return searchPosition;\n      }\n    }\n\n    return -1;\n  };\n\n  _createClass(Parser, [{\n    key: \"currToken\",\n    get: function get() {\n      return this.tokens[this.position];\n    }\n  }, {\n    key: \"nextToken\",\n    get: function get() {\n      return this.tokens[this.position + 1];\n    }\n  }, {\n    key: \"prevToken\",\n    get: function get() {\n      return this.tokens[this.position - 1];\n    }\n  }]);\n\n  return Parser;\n}();\n\nexports[\"default\"] = Parser;\nmodule.exports = exports.default;\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/postcss-selector-parser/dist/parser.js?");

/***/ }),

/***/ "./node_modules/postcss-selector-parser/dist/processor.js":
/*!****************************************************************!*\
  !*** ./node_modules/postcss-selector-parser/dist/processor.js ***!
  \****************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("\n\nexports.__esModule = true;\nexports[\"default\"] = void 0;\n\nvar _parser = _interopRequireDefault(__webpack_require__(/*! ./parser */ \"./node_modules/postcss-selector-parser/dist/parser.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nvar Processor = /*#__PURE__*/function () {\n  function Processor(func, options) {\n    this.func = func || function noop() {};\n\n    this.funcRes = null;\n    this.options = options;\n  }\n\n  var _proto = Processor.prototype;\n\n  _proto._shouldUpdateSelector = function _shouldUpdateSelector(rule, options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    var merged = Object.assign({}, this.options, options);\n\n    if (merged.updateSelector === false) {\n      return false;\n    } else {\n      return typeof rule !== \"string\";\n    }\n  };\n\n  _proto._isLossy = function _isLossy(options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    var merged = Object.assign({}, this.options, options);\n\n    if (merged.lossless === false) {\n      return true;\n    } else {\n      return false;\n    }\n  };\n\n  _proto._root = function _root(rule, options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    var parser = new _parser[\"default\"](rule, this._parseOptions(options));\n    return parser.root;\n  };\n\n  _proto._parseOptions = function _parseOptions(options) {\n    return {\n      lossy: this._isLossy(options)\n    };\n  };\n\n  _proto._run = function _run(rule, options) {\n    var _this = this;\n\n    if (options === void 0) {\n      options = {};\n    }\n\n    return new Promise(function (resolve, reject) {\n      try {\n        var root = _this._root(rule, options);\n\n        Promise.resolve(_this.func(root)).then(function (transform) {\n          var string = undefined;\n\n          if (_this._shouldUpdateSelector(rule, options)) {\n            string = root.toString();\n            rule.selector = string;\n          }\n\n          return {\n            transform: transform,\n            root: root,\n            string: string\n          };\n        }).then(resolve, reject);\n      } catch (e) {\n        reject(e);\n        return;\n      }\n    });\n  };\n\n  _proto._runSync = function _runSync(rule, options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    var root = this._root(rule, options);\n\n    var transform = this.func(root);\n\n    if (transform && typeof transform.then === \"function\") {\n      throw new Error(\"Selector processor returned a promise to a synchronous call.\");\n    }\n\n    var string = undefined;\n\n    if (options.updateSelector && typeof rule !== \"string\") {\n      string = root.toString();\n      rule.selector = string;\n    }\n\n    return {\n      transform: transform,\n      root: root,\n      string: string\n    };\n  }\n  /**\n   * Process rule into a selector AST.\n   *\n   * @param rule {postcss.Rule | string} The css selector to be processed\n   * @param options The options for processing\n   * @returns {Promise<parser.Root>} The AST of the selector after processing it.\n   */\n  ;\n\n  _proto.ast = function ast(rule, options) {\n    return this._run(rule, options).then(function (result) {\n      return result.root;\n    });\n  }\n  /**\n   * Process rule into a selector AST synchronously.\n   *\n   * @param rule {postcss.Rule | string} The css selector to be processed\n   * @param options The options for processing\n   * @returns {parser.Root} The AST of the selector after processing it.\n   */\n  ;\n\n  _proto.astSync = function astSync(rule, options) {\n    return this._runSync(rule, options).root;\n  }\n  /**\n   * Process a selector into a transformed value asynchronously\n   *\n   * @param rule {postcss.Rule | string} The css selector to be processed\n   * @param options The options for processing\n   * @returns {Promise<any>} The value returned by the processor.\n   */\n  ;\n\n  _proto.transform = function transform(rule, options) {\n    return this._run(rule, options).then(function (result) {\n      return result.transform;\n    });\n  }\n  /**\n   * Process a selector into a transformed value synchronously.\n   *\n   * @param rule {postcss.Rule | string} The css selector to be processed\n   * @param options The options for processing\n   * @returns {any} The value returned by the processor.\n   */\n  ;\n\n  _proto.transformSync = function transformSync(rule, options) {\n    return this._runSync(rule, options).transform;\n  }\n  /**\n   * Process a selector into a new selector string asynchronously.\n   *\n   * @param rule {postcss.Rule | string} The css selector to be processed\n   * @param options The options for processing\n   * @returns {string} the selector after processing.\n   */\n  ;\n\n  _proto.process = function process(rule, options) {\n    return this._run(rule, options).then(function (result) {\n      return result.string || result.root.toString();\n    });\n  }\n  /**\n   * Process a selector into a new selector string synchronously.\n   *\n   * @param rule {postcss.Rule | string} The css selector to be processed\n   * @param options The options for processing\n   * @returns {string} the selector after processing.\n   */\n  ;\n\n  _proto.processSync = function processSync(rule, options) {\n    var result = this._runSync(rule, options);\n\n    return result.string || result.root.toString();\n  };\n\n  return Processor;\n}();\n\nexports[\"default\"] = Processor;\nmodule.exports = exports.default;\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/postcss-selector-parser/dist/processor.js?");

/***/ }),

/***/ "./node_modules/postcss-selector-parser/dist/selectors/attribute.js":
/*!**************************************************************************!*\
  !*** ./node_modules/postcss-selector-parser/dist/selectors/attribute.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nexports.__esModule = true;\nexports.unescapeValue = unescapeValue;\nexports[\"default\"] = void 0;\n\nvar _cssesc = _interopRequireDefault(__webpack_require__(/*! cssesc */ \"./node_modules/cssesc/cssesc.js\"));\n\nvar _unesc = _interopRequireDefault(__webpack_require__(/*! ../util/unesc */ \"./node_modules/postcss-selector-parser/dist/util/unesc.js\"));\n\nvar _namespace = _interopRequireDefault(__webpack_require__(/*! ./namespace */ \"./node_modules/postcss-selector-parser/dist/selectors/namespace.js\"));\n\nvar _types = __webpack_require__(/*! ./types */ \"./node_modules/postcss-selector-parser/dist/selectors/types.js\");\n\nvar _CSSESC_QUOTE_OPTIONS;\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nvar deprecate = __webpack_require__(/*! util-deprecate */ \"./node_modules/util-deprecate/browser.js\");\n\nvar WRAPPED_IN_QUOTES = /^('|\")([^]*)\\1$/;\nvar warnOfDeprecatedValueAssignment = deprecate(function () {}, \"Assigning an attribute a value containing characters that might need to be escaped is deprecated. \" + \"Call attribute.setValue() instead.\");\nvar warnOfDeprecatedQuotedAssignment = deprecate(function () {}, \"Assigning attr.quoted is deprecated and has no effect. Assign to attr.quoteMark instead.\");\nvar warnOfDeprecatedConstructor = deprecate(function () {}, \"Constructing an Attribute selector with a value without specifying quoteMark is deprecated. Note: The value should be unescaped now.\");\n\nfunction unescapeValue(value) {\n  var deprecatedUsage = false;\n  var quoteMark = null;\n  var unescaped = value;\n  var m = unescaped.match(WRAPPED_IN_QUOTES);\n\n  if (m) {\n    quoteMark = m[1];\n    unescaped = m[2];\n  }\n\n  unescaped = (0, _unesc[\"default\"])(unescaped);\n\n  if (unescaped !== value) {\n    deprecatedUsage = true;\n  }\n\n  return {\n    deprecatedUsage: deprecatedUsage,\n    unescaped: unescaped,\n    quoteMark: quoteMark\n  };\n}\n\nfunction handleDeprecatedContructorOpts(opts) {\n  if (opts.quoteMark !== undefined) {\n    return opts;\n  }\n\n  if (opts.value === undefined) {\n    return opts;\n  }\n\n  warnOfDeprecatedConstructor();\n\n  var _unescapeValue = unescapeValue(opts.value),\n      quoteMark = _unescapeValue.quoteMark,\n      unescaped = _unescapeValue.unescaped;\n\n  if (!opts.raws) {\n    opts.raws = {};\n  }\n\n  if (opts.raws.value === undefined) {\n    opts.raws.value = opts.value;\n  }\n\n  opts.value = unescaped;\n  opts.quoteMark = quoteMark;\n  return opts;\n}\n\nvar Attribute = /*#__PURE__*/function (_Namespace) {\n  _inheritsLoose(Attribute, _Namespace);\n\n  function Attribute(opts) {\n    var _this;\n\n    if (opts === void 0) {\n      opts = {};\n    }\n\n    _this = _Namespace.call(this, handleDeprecatedContructorOpts(opts)) || this;\n    _this.type = _types.ATTRIBUTE;\n    _this.raws = _this.raws || {};\n    Object.defineProperty(_this.raws, 'unquoted', {\n      get: deprecate(function () {\n        return _this.value;\n      }, \"attr.raws.unquoted is deprecated. Call attr.value instead.\"),\n      set: deprecate(function () {\n        return _this.value;\n      }, \"Setting attr.raws.unquoted is deprecated and has no effect. attr.value is unescaped by default now.\")\n    });\n    _this._constructed = true;\n    return _this;\n  }\n  /**\n   * Returns the Attribute's value quoted such that it would be legal to use\n   * in the value of a css file. The original value's quotation setting\n   * used for stringification is left unchanged. See `setValue(value, options)`\n   * if you want to control the quote settings of a new value for the attribute.\n   *\n   * You can also change the quotation used for the current value by setting quoteMark.\n   *\n   * Options:\n   *   * quoteMark {'\"' | \"'\" | null} - Use this value to quote the value. If this\n   *     option is not set, the original value for quoteMark will be used. If\n   *     indeterminate, a double quote is used. The legal values are:\n   *     * `null` - the value will be unquoted and characters will be escaped as necessary.\n   *     * `'` - the value will be quoted with a single quote and single quotes are escaped.\n   *     * `\"` - the value will be quoted with a double quote and double quotes are escaped.\n   *   * preferCurrentQuoteMark {boolean} - if true, prefer the source quote mark\n   *     over the quoteMark option value.\n   *   * smart {boolean} - if true, will select a quote mark based on the value\n   *     and the other options specified here. See the `smartQuoteMark()`\n   *     method.\n   **/\n\n\n  var _proto = Attribute.prototype;\n\n  _proto.getQuotedValue = function getQuotedValue(options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    var quoteMark = this._determineQuoteMark(options);\n\n    var cssescopts = CSSESC_QUOTE_OPTIONS[quoteMark];\n    var escaped = (0, _cssesc[\"default\"])(this._value, cssescopts);\n    return escaped;\n  };\n\n  _proto._determineQuoteMark = function _determineQuoteMark(options) {\n    return options.smart ? this.smartQuoteMark(options) : this.preferredQuoteMark(options);\n  }\n  /**\n   * Set the unescaped value with the specified quotation options. The value\n   * provided must not include any wrapping quote marks -- those quotes will\n   * be interpreted as part of the value and escaped accordingly.\n   */\n  ;\n\n  _proto.setValue = function setValue(value, options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    this._value = value;\n    this._quoteMark = this._determineQuoteMark(options);\n\n    this._syncRawValue();\n  }\n  /**\n   * Intelligently select a quoteMark value based on the value's contents. If\n   * the value is a legal CSS ident, it will not be quoted. Otherwise a quote\n   * mark will be picked that minimizes the number of escapes.\n   *\n   * If there's no clear winner, the quote mark from these options is used,\n   * then the source quote mark (this is inverted if `preferCurrentQuoteMark` is\n   * true). If the quoteMark is unspecified, a double quote is used.\n   *\n   * @param options This takes the quoteMark and preferCurrentQuoteMark options\n   * from the quoteValue method.\n   */\n  ;\n\n  _proto.smartQuoteMark = function smartQuoteMark(options) {\n    var v = this.value;\n    var numSingleQuotes = v.replace(/[^']/g, '').length;\n    var numDoubleQuotes = v.replace(/[^\"]/g, '').length;\n\n    if (numSingleQuotes + numDoubleQuotes === 0) {\n      var escaped = (0, _cssesc[\"default\"])(v, {\n        isIdentifier: true\n      });\n\n      if (escaped === v) {\n        return Attribute.NO_QUOTE;\n      } else {\n        var pref = this.preferredQuoteMark(options);\n\n        if (pref === Attribute.NO_QUOTE) {\n          // pick a quote mark that isn't none and see if it's smaller\n          var quote = this.quoteMark || options.quoteMark || Attribute.DOUBLE_QUOTE;\n          var opts = CSSESC_QUOTE_OPTIONS[quote];\n          var quoteValue = (0, _cssesc[\"default\"])(v, opts);\n\n          if (quoteValue.length < escaped.length) {\n            return quote;\n          }\n        }\n\n        return pref;\n      }\n    } else if (numDoubleQuotes === numSingleQuotes) {\n      return this.preferredQuoteMark(options);\n    } else if (numDoubleQuotes < numSingleQuotes) {\n      return Attribute.DOUBLE_QUOTE;\n    } else {\n      return Attribute.SINGLE_QUOTE;\n    }\n  }\n  /**\n   * Selects the preferred quote mark based on the options and the current quote mark value.\n   * If you want the quote mark to depend on the attribute value, call `smartQuoteMark(opts)`\n   * instead.\n   */\n  ;\n\n  _proto.preferredQuoteMark = function preferredQuoteMark(options) {\n    var quoteMark = options.preferCurrentQuoteMark ? this.quoteMark : options.quoteMark;\n\n    if (quoteMark === undefined) {\n      quoteMark = options.preferCurrentQuoteMark ? options.quoteMark : this.quoteMark;\n    }\n\n    if (quoteMark === undefined) {\n      quoteMark = Attribute.DOUBLE_QUOTE;\n    }\n\n    return quoteMark;\n  };\n\n  _proto._syncRawValue = function _syncRawValue() {\n    var rawValue = (0, _cssesc[\"default\"])(this._value, CSSESC_QUOTE_OPTIONS[this.quoteMark]);\n\n    if (rawValue === this._value) {\n      if (this.raws) {\n        delete this.raws.value;\n      }\n    } else {\n      this.raws.value = rawValue;\n    }\n  };\n\n  _proto._handleEscapes = function _handleEscapes(prop, value) {\n    if (this._constructed) {\n      var escaped = (0, _cssesc[\"default\"])(value, {\n        isIdentifier: true\n      });\n\n      if (escaped !== value) {\n        this.raws[prop] = escaped;\n      } else {\n        delete this.raws[prop];\n      }\n    }\n  };\n\n  _proto._spacesFor = function _spacesFor(name) {\n    var attrSpaces = {\n      before: '',\n      after: ''\n    };\n    var spaces = this.spaces[name] || {};\n    var rawSpaces = this.raws.spaces && this.raws.spaces[name] || {};\n    return Object.assign(attrSpaces, spaces, rawSpaces);\n  };\n\n  _proto._stringFor = function _stringFor(name, spaceName, concat) {\n    if (spaceName === void 0) {\n      spaceName = name;\n    }\n\n    if (concat === void 0) {\n      concat = defaultAttrConcat;\n    }\n\n    var attrSpaces = this._spacesFor(spaceName);\n\n    return concat(this.stringifyProperty(name), attrSpaces);\n  }\n  /**\n   * returns the offset of the attribute part specified relative to the\n   * start of the node of the output string.\n   *\n   * * \"ns\" - alias for \"namespace\"\n   * * \"namespace\" - the namespace if it exists.\n   * * \"attribute\" - the attribute name\n   * * \"attributeNS\" - the start of the attribute or its namespace\n   * * \"operator\" - the match operator of the attribute\n   * * \"value\" - The value (string or identifier)\n   * * \"insensitive\" - the case insensitivity flag;\n   * @param part One of the possible values inside an attribute.\n   * @returns -1 if the name is invalid or the value doesn't exist in this attribute.\n   */\n  ;\n\n  _proto.offsetOf = function offsetOf(name) {\n    var count = 1;\n\n    var attributeSpaces = this._spacesFor(\"attribute\");\n\n    count += attributeSpaces.before.length;\n\n    if (name === \"namespace\" || name === \"ns\") {\n      return this.namespace ? count : -1;\n    }\n\n    if (name === \"attributeNS\") {\n      return count;\n    }\n\n    count += this.namespaceString.length;\n\n    if (this.namespace) {\n      count += 1;\n    }\n\n    if (name === \"attribute\") {\n      return count;\n    }\n\n    count += this.stringifyProperty(\"attribute\").length;\n    count += attributeSpaces.after.length;\n\n    var operatorSpaces = this._spacesFor(\"operator\");\n\n    count += operatorSpaces.before.length;\n    var operator = this.stringifyProperty(\"operator\");\n\n    if (name === \"operator\") {\n      return operator ? count : -1;\n    }\n\n    count += operator.length;\n    count += operatorSpaces.after.length;\n\n    var valueSpaces = this._spacesFor(\"value\");\n\n    count += valueSpaces.before.length;\n    var value = this.stringifyProperty(\"value\");\n\n    if (name === \"value\") {\n      return value ? count : -1;\n    }\n\n    count += value.length;\n    count += valueSpaces.after.length;\n\n    var insensitiveSpaces = this._spacesFor(\"insensitive\");\n\n    count += insensitiveSpaces.before.length;\n\n    if (name === \"insensitive\") {\n      return this.insensitive ? count : -1;\n    }\n\n    return -1;\n  };\n\n  _proto.toString = function toString() {\n    var _this2 = this;\n\n    var selector = [this.rawSpaceBefore, '['];\n    selector.push(this._stringFor('qualifiedAttribute', 'attribute'));\n\n    if (this.operator && (this.value || this.value === '')) {\n      selector.push(this._stringFor('operator'));\n      selector.push(this._stringFor('value'));\n      selector.push(this._stringFor('insensitiveFlag', 'insensitive', function (attrValue, attrSpaces) {\n        if (attrValue.length > 0 && !_this2.quoted && attrSpaces.before.length === 0 && !(_this2.spaces.value && _this2.spaces.value.after)) {\n          attrSpaces.before = \" \";\n        }\n\n        return defaultAttrConcat(attrValue, attrSpaces);\n      }));\n    }\n\n    selector.push(']');\n    selector.push(this.rawSpaceAfter);\n    return selector.join('');\n  };\n\n  _createClass(Attribute, [{\n    key: \"quoted\",\n    get: function get() {\n      var qm = this.quoteMark;\n      return qm === \"'\" || qm === '\"';\n    },\n    set: function set(value) {\n      warnOfDeprecatedQuotedAssignment();\n    }\n    /**\n     * returns a single (`'`) or double (`\"`) quote character if the value is quoted.\n     * returns `null` if the value is not quoted.\n     * returns `undefined` if the quotation state is unknown (this can happen when\n     * the attribute is constructed without specifying a quote mark.)\n     */\n\n  }, {\n    key: \"quoteMark\",\n    get: function get() {\n      return this._quoteMark;\n    }\n    /**\n     * Set the quote mark to be used by this attribute's value.\n     * If the quote mark changes, the raw (escaped) value at `attr.raws.value` of the attribute\n     * value is updated accordingly.\n     *\n     * @param {\"'\" | '\"' | null} quoteMark The quote mark or `null` if the value should be unquoted.\n     */\n    ,\n    set: function set(quoteMark) {\n      if (!this._constructed) {\n        this._quoteMark = quoteMark;\n        return;\n      }\n\n      if (this._quoteMark !== quoteMark) {\n        this._quoteMark = quoteMark;\n\n        this._syncRawValue();\n      }\n    }\n  }, {\n    key: \"qualifiedAttribute\",\n    get: function get() {\n      return this.qualifiedName(this.raws.attribute || this.attribute);\n    }\n  }, {\n    key: \"insensitiveFlag\",\n    get: function get() {\n      return this.insensitive ? 'i' : '';\n    }\n  }, {\n    key: \"value\",\n    get: function get() {\n      return this._value;\n    }\n    /**\n     * Before 3.0, the value had to be set to an escaped value including any wrapped\n     * quote marks. In 3.0, the semantics of `Attribute.value` changed so that the value\n     * is unescaped during parsing and any quote marks are removed.\n     *\n     * Because the ambiguity of this semantic change, if you set `attr.value = newValue`,\n     * a deprecation warning is raised when the new value contains any characters that would\n     * require escaping (including if it contains wrapped quotes).\n     *\n     * Instead, you should call `attr.setValue(newValue, opts)` and pass options that describe\n     * how the new value is quoted.\n     */\n    ,\n    set: function set(v) {\n      if (this._constructed) {\n        var _unescapeValue2 = unescapeValue(v),\n            deprecatedUsage = _unescapeValue2.deprecatedUsage,\n            unescaped = _unescapeValue2.unescaped,\n            quoteMark = _unescapeValue2.quoteMark;\n\n        if (deprecatedUsage) {\n          warnOfDeprecatedValueAssignment();\n        }\n\n        if (unescaped === this._value && quoteMark === this._quoteMark) {\n          return;\n        }\n\n        this._value = unescaped;\n        this._quoteMark = quoteMark;\n\n        this._syncRawValue();\n      } else {\n        this._value = v;\n      }\n    }\n  }, {\n    key: \"attribute\",\n    get: function get() {\n      return this._attribute;\n    },\n    set: function set(name) {\n      this._handleEscapes(\"attribute\", name);\n\n      this._attribute = name;\n    }\n  }]);\n\n  return Attribute;\n}(_namespace[\"default\"]);\n\nexports[\"default\"] = Attribute;\nAttribute.NO_QUOTE = null;\nAttribute.SINGLE_QUOTE = \"'\";\nAttribute.DOUBLE_QUOTE = '\"';\nvar CSSESC_QUOTE_OPTIONS = (_CSSESC_QUOTE_OPTIONS = {\n  \"'\": {\n    quotes: 'single',\n    wrap: true\n  },\n  '\"': {\n    quotes: 'double',\n    wrap: true\n  }\n}, _CSSESC_QUOTE_OPTIONS[null] = {\n  isIdentifier: true\n}, _CSSESC_QUOTE_OPTIONS);\n\nfunction defaultAttrConcat(attrValue, attrSpaces) {\n  return \"\" + attrSpaces.before + attrValue + attrSpaces.after;\n}\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/postcss-selector-parser/dist/selectors/attribute.js?");

/***/ }),

/***/ "./node_modules/postcss-selector-parser/dist/selectors/className.js":
/*!**************************************************************************!*\
  !*** ./node_modules/postcss-selector-parser/dist/selectors/className.js ***!
  \**************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("\n\nexports.__esModule = true;\nexports[\"default\"] = void 0;\n\nvar _cssesc = _interopRequireDefault(__webpack_require__(/*! cssesc */ \"./node_modules/cssesc/cssesc.js\"));\n\nvar _util = __webpack_require__(/*! ../util */ \"./node_modules/postcss-selector-parser/dist/util/index.js\");\n\nvar _node = _interopRequireDefault(__webpack_require__(/*! ./node */ \"./node_modules/postcss-selector-parser/dist/selectors/node.js\"));\n\nvar _types = __webpack_require__(/*! ./types */ \"./node_modules/postcss-selector-parser/dist/selectors/types.js\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nvar ClassName = /*#__PURE__*/function (_Node) {\n  _inheritsLoose(ClassName, _Node);\n\n  function ClassName(opts) {\n    var _this;\n\n    _this = _Node.call(this, opts) || this;\n    _this.type = _types.CLASS;\n    _this._constructed = true;\n    return _this;\n  }\n\n  var _proto = ClassName.prototype;\n\n  _proto.valueToString = function valueToString() {\n    return '.' + _Node.prototype.valueToString.call(this);\n  };\n\n  _createClass(ClassName, [{\n    key: \"value\",\n    get: function get() {\n      return this._value;\n    },\n    set: function set(v) {\n      if (this._constructed) {\n        var escaped = (0, _cssesc[\"default\"])(v, {\n          isIdentifier: true\n        });\n\n        if (escaped !== v) {\n          (0, _util.ensureObject)(this, \"raws\");\n          this.raws.value = escaped;\n        } else if (this.raws) {\n          delete this.raws.value;\n        }\n      }\n\n      this._value = v;\n    }\n  }]);\n\n  return ClassName;\n}(_node[\"default\"]);\n\nexports[\"default\"] = ClassName;\nmodule.exports = exports.default;\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/postcss-selector-parser/dist/selectors/className.js?");

/***/ }),

/***/ "./node_modules/postcss-selector-parser/dist/selectors/combinator.js":
/*!***************************************************************************!*\
  !*** ./node_modules/postcss-selector-parser/dist/selectors/combinator.js ***!
  \***************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("\n\nexports.__esModule = true;\nexports[\"default\"] = void 0;\n\nvar _node = _interopRequireDefault(__webpack_require__(/*! ./node */ \"./node_modules/postcss-selector-parser/dist/selectors/node.js\"));\n\nvar _types = __webpack_require__(/*! ./types */ \"./node_modules/postcss-selector-parser/dist/selectors/types.js\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nvar Combinator = /*#__PURE__*/function (_Node) {\n  _inheritsLoose(Combinator, _Node);\n\n  function Combinator(opts) {\n    var _this;\n\n    _this = _Node.call(this, opts) || this;\n    _this.type = _types.COMBINATOR;\n    return _this;\n  }\n\n  return Combinator;\n}(_node[\"default\"]);\n\nexports[\"default\"] = Combinator;\nmodule.exports = exports.default;\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/postcss-selector-parser/dist/selectors/combinator.js?");

/***/ }),

/***/ "./node_modules/postcss-selector-parser/dist/selectors/comment.js":
/*!************************************************************************!*\
  !*** ./node_modules/postcss-selector-parser/dist/selectors/comment.js ***!
  \************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("\n\nexports.__esModule = true;\nexports[\"default\"] = void 0;\n\nvar _node = _interopRequireDefault(__webpack_require__(/*! ./node */ \"./node_modules/postcss-selector-parser/dist/selectors/node.js\"));\n\nvar _types = __webpack_require__(/*! ./types */ \"./node_modules/postcss-selector-parser/dist/selectors/types.js\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nvar Comment = /*#__PURE__*/function (_Node) {\n  _inheritsLoose(Comment, _Node);\n\n  function Comment(opts) {\n    var _this;\n\n    _this = _Node.call(this, opts) || this;\n    _this.type = _types.COMMENT;\n    return _this;\n  }\n\n  return Comment;\n}(_node[\"default\"]);\n\nexports[\"default\"] = Comment;\nmodule.exports = exports.default;\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/postcss-selector-parser/dist/selectors/comment.js?");

/***/ }),

/***/ "./node_modules/postcss-selector-parser/dist/selectors/constructors.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/postcss-selector-parser/dist/selectors/constructors.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nexports.__esModule = true;\nexports.universal = exports.tag = exports.string = exports.selector = exports.root = exports.pseudo = exports.nesting = exports.id = exports.comment = exports.combinator = exports.className = exports.attribute = void 0;\n\nvar _attribute = _interopRequireDefault(__webpack_require__(/*! ./attribute */ \"./node_modules/postcss-selector-parser/dist/selectors/attribute.js\"));\n\nvar _className = _interopRequireDefault(__webpack_require__(/*! ./className */ \"./node_modules/postcss-selector-parser/dist/selectors/className.js\"));\n\nvar _combinator = _interopRequireDefault(__webpack_require__(/*! ./combinator */ \"./node_modules/postcss-selector-parser/dist/selectors/combinator.js\"));\n\nvar _comment = _interopRequireDefault(__webpack_require__(/*! ./comment */ \"./node_modules/postcss-selector-parser/dist/selectors/comment.js\"));\n\nvar _id = _interopRequireDefault(__webpack_require__(/*! ./id */ \"./node_modules/postcss-selector-parser/dist/selectors/id.js\"));\n\nvar _nesting = _interopRequireDefault(__webpack_require__(/*! ./nesting */ \"./node_modules/postcss-selector-parser/dist/selectors/nesting.js\"));\n\nvar _pseudo = _interopRequireDefault(__webpack_require__(/*! ./pseudo */ \"./node_modules/postcss-selector-parser/dist/selectors/pseudo.js\"));\n\nvar _root = _interopRequireDefault(__webpack_require__(/*! ./root */ \"./node_modules/postcss-selector-parser/dist/selectors/root.js\"));\n\nvar _selector = _interopRequireDefault(__webpack_require__(/*! ./selector */ \"./node_modules/postcss-selector-parser/dist/selectors/selector.js\"));\n\nvar _string = _interopRequireDefault(__webpack_require__(/*! ./string */ \"./node_modules/postcss-selector-parser/dist/selectors/string.js\"));\n\nvar _tag = _interopRequireDefault(__webpack_require__(/*! ./tag */ \"./node_modules/postcss-selector-parser/dist/selectors/tag.js\"));\n\nvar _universal = _interopRequireDefault(__webpack_require__(/*! ./universal */ \"./node_modules/postcss-selector-parser/dist/selectors/universal.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nvar attribute = function attribute(opts) {\n  return new _attribute[\"default\"](opts);\n};\n\nexports.attribute = attribute;\n\nvar className = function className(opts) {\n  return new _className[\"default\"](opts);\n};\n\nexports.className = className;\n\nvar combinator = function combinator(opts) {\n  return new _combinator[\"default\"](opts);\n};\n\nexports.combinator = combinator;\n\nvar comment = function comment(opts) {\n  return new _comment[\"default\"](opts);\n};\n\nexports.comment = comment;\n\nvar id = function id(opts) {\n  return new _id[\"default\"](opts);\n};\n\nexports.id = id;\n\nvar nesting = function nesting(opts) {\n  return new _nesting[\"default\"](opts);\n};\n\nexports.nesting = nesting;\n\nvar pseudo = function pseudo(opts) {\n  return new _pseudo[\"default\"](opts);\n};\n\nexports.pseudo = pseudo;\n\nvar root = function root(opts) {\n  return new _root[\"default\"](opts);\n};\n\nexports.root = root;\n\nvar selector = function selector(opts) {\n  return new _selector[\"default\"](opts);\n};\n\nexports.selector = selector;\n\nvar string = function string(opts) {\n  return new _string[\"default\"](opts);\n};\n\nexports.string = string;\n\nvar tag = function tag(opts) {\n  return new _tag[\"default\"](opts);\n};\n\nexports.tag = tag;\n\nvar universal = function universal(opts) {\n  return new _universal[\"default\"](opts);\n};\n\nexports.universal = universal;\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/postcss-selector-parser/dist/selectors/constructors.js?");

/***/ }),

/***/ "./node_modules/postcss-selector-parser/dist/selectors/container.js":
/*!**************************************************************************!*\
  !*** ./node_modules/postcss-selector-parser/dist/selectors/container.js ***!
  \**************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("\n\nexports.__esModule = true;\nexports[\"default\"] = void 0;\n\nvar _node = _interopRequireDefault(__webpack_require__(/*! ./node */ \"./node_modules/postcss-selector-parser/dist/selectors/node.js\"));\n\nvar types = _interopRequireWildcard(__webpack_require__(/*! ./types */ \"./node_modules/postcss-selector-parser/dist/selectors/types.js\"));\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { \"default\": obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj[\"default\"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nfunction _createForOfIteratorHelperLoose(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } it = o[Symbol.iterator](); return it.next.bind(it); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nvar Container = /*#__PURE__*/function (_Node) {\n  _inheritsLoose(Container, _Node);\n\n  function Container(opts) {\n    var _this;\n\n    _this = _Node.call(this, opts) || this;\n\n    if (!_this.nodes) {\n      _this.nodes = [];\n    }\n\n    return _this;\n  }\n\n  var _proto = Container.prototype;\n\n  _proto.append = function append(selector) {\n    selector.parent = this;\n    this.nodes.push(selector);\n    return this;\n  };\n\n  _proto.prepend = function prepend(selector) {\n    selector.parent = this;\n    this.nodes.unshift(selector);\n    return this;\n  };\n\n  _proto.at = function at(index) {\n    return this.nodes[index];\n  };\n\n  _proto.index = function index(child) {\n    if (typeof child === 'number') {\n      return child;\n    }\n\n    return this.nodes.indexOf(child);\n  };\n\n  _proto.removeChild = function removeChild(child) {\n    child = this.index(child);\n    this.at(child).parent = undefined;\n    this.nodes.splice(child, 1);\n    var index;\n\n    for (var id in this.indexes) {\n      index = this.indexes[id];\n\n      if (index >= child) {\n        this.indexes[id] = index - 1;\n      }\n    }\n\n    return this;\n  };\n\n  _proto.removeAll = function removeAll() {\n    for (var _iterator = _createForOfIteratorHelperLoose(this.nodes), _step; !(_step = _iterator()).done;) {\n      var node = _step.value;\n      node.parent = undefined;\n    }\n\n    this.nodes = [];\n    return this;\n  };\n\n  _proto.empty = function empty() {\n    return this.removeAll();\n  };\n\n  _proto.insertAfter = function insertAfter(oldNode, newNode) {\n    newNode.parent = this;\n    var oldIndex = this.index(oldNode);\n    this.nodes.splice(oldIndex + 1, 0, newNode);\n    newNode.parent = this;\n    var index;\n\n    for (var id in this.indexes) {\n      index = this.indexes[id];\n\n      if (oldIndex <= index) {\n        this.indexes[id] = index + 1;\n      }\n    }\n\n    return this;\n  };\n\n  _proto.insertBefore = function insertBefore(oldNode, newNode) {\n    newNode.parent = this;\n    var oldIndex = this.index(oldNode);\n    this.nodes.splice(oldIndex, 0, newNode);\n    newNode.parent = this;\n    var index;\n\n    for (var id in this.indexes) {\n      index = this.indexes[id];\n\n      if (index <= oldIndex) {\n        this.indexes[id] = index + 1;\n      }\n    }\n\n    return this;\n  };\n\n  _proto._findChildAtPosition = function _findChildAtPosition(line, col) {\n    var found = undefined;\n    this.each(function (node) {\n      if (node.atPosition) {\n        var foundChild = node.atPosition(line, col);\n\n        if (foundChild) {\n          found = foundChild;\n          return false;\n        }\n      } else if (node.isAtPosition(line, col)) {\n        found = node;\n        return false;\n      }\n    });\n    return found;\n  }\n  /**\n   * Return the most specific node at the line and column number given.\n   * The source location is based on the original parsed location, locations aren't\n   * updated as selector nodes are mutated.\n   * \n   * Note that this location is relative to the location of the first character\n   * of the selector, and not the location of the selector in the overall document\n   * when used in conjunction with postcss.\n   *\n   * If not found, returns undefined.\n   * @param {number} line The line number of the node to find. (1-based index)\n   * @param {number} col  The column number of the node to find. (1-based index)\n   */\n  ;\n\n  _proto.atPosition = function atPosition(line, col) {\n    if (this.isAtPosition(line, col)) {\n      return this._findChildAtPosition(line, col) || this;\n    } else {\n      return undefined;\n    }\n  };\n\n  _proto._inferEndPosition = function _inferEndPosition() {\n    if (this.last && this.last.source && this.last.source.end) {\n      this.source = this.source || {};\n      this.source.end = this.source.end || {};\n      Object.assign(this.source.end, this.last.source.end);\n    }\n  };\n\n  _proto.each = function each(callback) {\n    if (!this.lastEach) {\n      this.lastEach = 0;\n    }\n\n    if (!this.indexes) {\n      this.indexes = {};\n    }\n\n    this.lastEach++;\n    var id = this.lastEach;\n    this.indexes[id] = 0;\n\n    if (!this.length) {\n      return undefined;\n    }\n\n    var index, result;\n\n    while (this.indexes[id] < this.length) {\n      index = this.indexes[id];\n      result = callback(this.at(index), index);\n\n      if (result === false) {\n        break;\n      }\n\n      this.indexes[id] += 1;\n    }\n\n    delete this.indexes[id];\n\n    if (result === false) {\n      return false;\n    }\n  };\n\n  _proto.walk = function walk(callback) {\n    return this.each(function (node, i) {\n      var result = callback(node, i);\n\n      if (result !== false && node.length) {\n        result = node.walk(callback);\n      }\n\n      if (result === false) {\n        return false;\n      }\n    });\n  };\n\n  _proto.walkAttributes = function walkAttributes(callback) {\n    var _this2 = this;\n\n    return this.walk(function (selector) {\n      if (selector.type === types.ATTRIBUTE) {\n        return callback.call(_this2, selector);\n      }\n    });\n  };\n\n  _proto.walkClasses = function walkClasses(callback) {\n    var _this3 = this;\n\n    return this.walk(function (selector) {\n      if (selector.type === types.CLASS) {\n        return callback.call(_this3, selector);\n      }\n    });\n  };\n\n  _proto.walkCombinators = function walkCombinators(callback) {\n    var _this4 = this;\n\n    return this.walk(function (selector) {\n      if (selector.type === types.COMBINATOR) {\n        return callback.call(_this4, selector);\n      }\n    });\n  };\n\n  _proto.walkComments = function walkComments(callback) {\n    var _this5 = this;\n\n    return this.walk(function (selector) {\n      if (selector.type === types.COMMENT) {\n        return callback.call(_this5, selector);\n      }\n    });\n  };\n\n  _proto.walkIds = function walkIds(callback) {\n    var _this6 = this;\n\n    return this.walk(function (selector) {\n      if (selector.type === types.ID) {\n        return callback.call(_this6, selector);\n      }\n    });\n  };\n\n  _proto.walkNesting = function walkNesting(callback) {\n    var _this7 = this;\n\n    return this.walk(function (selector) {\n      if (selector.type === types.NESTING) {\n        return callback.call(_this7, selector);\n      }\n    });\n  };\n\n  _proto.walkPseudos = function walkPseudos(callback) {\n    var _this8 = this;\n\n    return this.walk(function (selector) {\n      if (selector.type === types.PSEUDO) {\n        return callback.call(_this8, selector);\n      }\n    });\n  };\n\n  _proto.walkTags = function walkTags(callback) {\n    var _this9 = this;\n\n    return this.walk(function (selector) {\n      if (selector.type === types.TAG) {\n        return callback.call(_this9, selector);\n      }\n    });\n  };\n\n  _proto.walkUniversals = function walkUniversals(callback) {\n    var _this10 = this;\n\n    return this.walk(function (selector) {\n      if (selector.type === types.UNIVERSAL) {\n        return callback.call(_this10, selector);\n      }\n    });\n  };\n\n  _proto.split = function split(callback) {\n    var _this11 = this;\n\n    var current = [];\n    return this.reduce(function (memo, node, index) {\n      var split = callback.call(_this11, node);\n      current.push(node);\n\n      if (split) {\n        memo.push(current);\n        current = [];\n      } else if (index === _this11.length - 1) {\n        memo.push(current);\n      }\n\n      return memo;\n    }, []);\n  };\n\n  _proto.map = function map(callback) {\n    return this.nodes.map(callback);\n  };\n\n  _proto.reduce = function reduce(callback, memo) {\n    return this.nodes.reduce(callback, memo);\n  };\n\n  _proto.every = function every(callback) {\n    return this.nodes.every(callback);\n  };\n\n  _proto.some = function some(callback) {\n    return this.nodes.some(callback);\n  };\n\n  _proto.filter = function filter(callback) {\n    return this.nodes.filter(callback);\n  };\n\n  _proto.sort = function sort(callback) {\n    return this.nodes.sort(callback);\n  };\n\n  _proto.toString = function toString() {\n    return this.map(String).join('');\n  };\n\n  _createClass(Container, [{\n    key: \"first\",\n    get: function get() {\n      return this.at(0);\n    }\n  }, {\n    key: \"last\",\n    get: function get() {\n      return this.at(this.length - 1);\n    }\n  }, {\n    key: \"length\",\n    get: function get() {\n      return this.nodes.length;\n    }\n  }]);\n\n  return Container;\n}(_node[\"default\"]);\n\nexports[\"default\"] = Container;\nmodule.exports = exports.default;\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/postcss-selector-parser/dist/selectors/container.js?");

/***/ }),

/***/ "./node_modules/postcss-selector-parser/dist/selectors/guards.js":
/*!***********************************************************************!*\
  !*** ./node_modules/postcss-selector-parser/dist/selectors/guards.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nexports.__esModule = true;\nexports.isNode = isNode;\nexports.isPseudoElement = isPseudoElement;\nexports.isPseudoClass = isPseudoClass;\nexports.isContainer = isContainer;\nexports.isNamespace = isNamespace;\nexports.isUniversal = exports.isTag = exports.isString = exports.isSelector = exports.isRoot = exports.isPseudo = exports.isNesting = exports.isIdentifier = exports.isComment = exports.isCombinator = exports.isClassName = exports.isAttribute = void 0;\n\nvar _types = __webpack_require__(/*! ./types */ \"./node_modules/postcss-selector-parser/dist/selectors/types.js\");\n\nvar _IS_TYPE;\n\nvar IS_TYPE = (_IS_TYPE = {}, _IS_TYPE[_types.ATTRIBUTE] = true, _IS_TYPE[_types.CLASS] = true, _IS_TYPE[_types.COMBINATOR] = true, _IS_TYPE[_types.COMMENT] = true, _IS_TYPE[_types.ID] = true, _IS_TYPE[_types.NESTING] = true, _IS_TYPE[_types.PSEUDO] = true, _IS_TYPE[_types.ROOT] = true, _IS_TYPE[_types.SELECTOR] = true, _IS_TYPE[_types.STRING] = true, _IS_TYPE[_types.TAG] = true, _IS_TYPE[_types.UNIVERSAL] = true, _IS_TYPE);\n\nfunction isNode(node) {\n  return typeof node === \"object\" && IS_TYPE[node.type];\n}\n\nfunction isNodeType(type, node) {\n  return isNode(node) && node.type === type;\n}\n\nvar isAttribute = isNodeType.bind(null, _types.ATTRIBUTE);\nexports.isAttribute = isAttribute;\nvar isClassName = isNodeType.bind(null, _types.CLASS);\nexports.isClassName = isClassName;\nvar isCombinator = isNodeType.bind(null, _types.COMBINATOR);\nexports.isCombinator = isCombinator;\nvar isComment = isNodeType.bind(null, _types.COMMENT);\nexports.isComment = isComment;\nvar isIdentifier = isNodeType.bind(null, _types.ID);\nexports.isIdentifier = isIdentifier;\nvar isNesting = isNodeType.bind(null, _types.NESTING);\nexports.isNesting = isNesting;\nvar isPseudo = isNodeType.bind(null, _types.PSEUDO);\nexports.isPseudo = isPseudo;\nvar isRoot = isNodeType.bind(null, _types.ROOT);\nexports.isRoot = isRoot;\nvar isSelector = isNodeType.bind(null, _types.SELECTOR);\nexports.isSelector = isSelector;\nvar isString = isNodeType.bind(null, _types.STRING);\nexports.isString = isString;\nvar isTag = isNodeType.bind(null, _types.TAG);\nexports.isTag = isTag;\nvar isUniversal = isNodeType.bind(null, _types.UNIVERSAL);\nexports.isUniversal = isUniversal;\n\nfunction isPseudoElement(node) {\n  return isPseudo(node) && node.value && (node.value.startsWith(\"::\") || node.value.toLowerCase() === \":before\" || node.value.toLowerCase() === \":after\" || node.value.toLowerCase() === \":first-letter\" || node.value.toLowerCase() === \":first-line\");\n}\n\nfunction isPseudoClass(node) {\n  return isPseudo(node) && !isPseudoElement(node);\n}\n\nfunction isContainer(node) {\n  return !!(isNode(node) && node.walk);\n}\n\nfunction isNamespace(node) {\n  return isAttribute(node) || isTag(node);\n}\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/postcss-selector-parser/dist/selectors/guards.js?");

/***/ }),

/***/ "./node_modules/postcss-selector-parser/dist/selectors/id.js":
/*!*******************************************************************!*\
  !*** ./node_modules/postcss-selector-parser/dist/selectors/id.js ***!
  \*******************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("\n\nexports.__esModule = true;\nexports[\"default\"] = void 0;\n\nvar _node = _interopRequireDefault(__webpack_require__(/*! ./node */ \"./node_modules/postcss-selector-parser/dist/selectors/node.js\"));\n\nvar _types = __webpack_require__(/*! ./types */ \"./node_modules/postcss-selector-parser/dist/selectors/types.js\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nvar ID = /*#__PURE__*/function (_Node) {\n  _inheritsLoose(ID, _Node);\n\n  function ID(opts) {\n    var _this;\n\n    _this = _Node.call(this, opts) || this;\n    _this.type = _types.ID;\n    return _this;\n  }\n\n  var _proto = ID.prototype;\n\n  _proto.valueToString = function valueToString() {\n    return '#' + _Node.prototype.valueToString.call(this);\n  };\n\n  return ID;\n}(_node[\"default\"]);\n\nexports[\"default\"] = ID;\nmodule.exports = exports.default;\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/postcss-selector-parser/dist/selectors/id.js?");

/***/ }),

/***/ "./node_modules/postcss-selector-parser/dist/selectors/index.js":
/*!**********************************************************************!*\
  !*** ./node_modules/postcss-selector-parser/dist/selectors/index.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nexports.__esModule = true;\n\nvar _types = __webpack_require__(/*! ./types */ \"./node_modules/postcss-selector-parser/dist/selectors/types.js\");\n\nObject.keys(_types).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  if (key in exports && exports[key] === _types[key]) return;\n  exports[key] = _types[key];\n});\n\nvar _constructors = __webpack_require__(/*! ./constructors */ \"./node_modules/postcss-selector-parser/dist/selectors/constructors.js\");\n\nObject.keys(_constructors).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  if (key in exports && exports[key] === _constructors[key]) return;\n  exports[key] = _constructors[key];\n});\n\nvar _guards = __webpack_require__(/*! ./guards */ \"./node_modules/postcss-selector-parser/dist/selectors/guards.js\");\n\nObject.keys(_guards).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  if (key in exports && exports[key] === _guards[key]) return;\n  exports[key] = _guards[key];\n});\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/postcss-selector-parser/dist/selectors/index.js?");

/***/ }),

/***/ "./node_modules/postcss-selector-parser/dist/selectors/namespace.js":
/*!**************************************************************************!*\
  !*** ./node_modules/postcss-selector-parser/dist/selectors/namespace.js ***!
  \**************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("\n\nexports.__esModule = true;\nexports[\"default\"] = void 0;\n\nvar _cssesc = _interopRequireDefault(__webpack_require__(/*! cssesc */ \"./node_modules/cssesc/cssesc.js\"));\n\nvar _util = __webpack_require__(/*! ../util */ \"./node_modules/postcss-selector-parser/dist/util/index.js\");\n\nvar _node = _interopRequireDefault(__webpack_require__(/*! ./node */ \"./node_modules/postcss-selector-parser/dist/selectors/node.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nvar Namespace = /*#__PURE__*/function (_Node) {\n  _inheritsLoose(Namespace, _Node);\n\n  function Namespace() {\n    return _Node.apply(this, arguments) || this;\n  }\n\n  var _proto = Namespace.prototype;\n\n  _proto.qualifiedName = function qualifiedName(value) {\n    if (this.namespace) {\n      return this.namespaceString + \"|\" + value;\n    } else {\n      return value;\n    }\n  };\n\n  _proto.valueToString = function valueToString() {\n    return this.qualifiedName(_Node.prototype.valueToString.call(this));\n  };\n\n  _createClass(Namespace, [{\n    key: \"namespace\",\n    get: function get() {\n      return this._namespace;\n    },\n    set: function set(namespace) {\n      if (namespace === true || namespace === \"*\" || namespace === \"&\") {\n        this._namespace = namespace;\n\n        if (this.raws) {\n          delete this.raws.namespace;\n        }\n\n        return;\n      }\n\n      var escaped = (0, _cssesc[\"default\"])(namespace, {\n        isIdentifier: true\n      });\n      this._namespace = namespace;\n\n      if (escaped !== namespace) {\n        (0, _util.ensureObject)(this, \"raws\");\n        this.raws.namespace = escaped;\n      } else if (this.raws) {\n        delete this.raws.namespace;\n      }\n    }\n  }, {\n    key: \"ns\",\n    get: function get() {\n      return this._namespace;\n    },\n    set: function set(namespace) {\n      this.namespace = namespace;\n    }\n  }, {\n    key: \"namespaceString\",\n    get: function get() {\n      if (this.namespace) {\n        var ns = this.stringifyProperty(\"namespace\");\n\n        if (ns === true) {\n          return '';\n        } else {\n          return ns;\n        }\n      } else {\n        return '';\n      }\n    }\n  }]);\n\n  return Namespace;\n}(_node[\"default\"]);\n\nexports[\"default\"] = Namespace;\n;\nmodule.exports = exports.default;\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/postcss-selector-parser/dist/selectors/namespace.js?");

/***/ }),

/***/ "./node_modules/postcss-selector-parser/dist/selectors/nesting.js":
/*!************************************************************************!*\
  !*** ./node_modules/postcss-selector-parser/dist/selectors/nesting.js ***!
  \************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("\n\nexports.__esModule = true;\nexports[\"default\"] = void 0;\n\nvar _node = _interopRequireDefault(__webpack_require__(/*! ./node */ \"./node_modules/postcss-selector-parser/dist/selectors/node.js\"));\n\nvar _types = __webpack_require__(/*! ./types */ \"./node_modules/postcss-selector-parser/dist/selectors/types.js\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nvar Nesting = /*#__PURE__*/function (_Node) {\n  _inheritsLoose(Nesting, _Node);\n\n  function Nesting(opts) {\n    var _this;\n\n    _this = _Node.call(this, opts) || this;\n    _this.type = _types.NESTING;\n    _this.value = '&';\n    return _this;\n  }\n\n  return Nesting;\n}(_node[\"default\"]);\n\nexports[\"default\"] = Nesting;\nmodule.exports = exports.default;\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/postcss-selector-parser/dist/selectors/nesting.js?");

/***/ }),

/***/ "./node_modules/postcss-selector-parser/dist/selectors/node.js":
/*!*********************************************************************!*\
  !*** ./node_modules/postcss-selector-parser/dist/selectors/node.js ***!
  \*********************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("\n\nexports.__esModule = true;\nexports[\"default\"] = void 0;\n\nvar _util = __webpack_require__(/*! ../util */ \"./node_modules/postcss-selector-parser/dist/util/index.js\");\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar cloneNode = function cloneNode(obj, parent) {\n  if (typeof obj !== 'object' || obj === null) {\n    return obj;\n  }\n\n  var cloned = new obj.constructor();\n\n  for (var i in obj) {\n    if (!obj.hasOwnProperty(i)) {\n      continue;\n    }\n\n    var value = obj[i];\n    var type = typeof value;\n\n    if (i === 'parent' && type === 'object') {\n      if (parent) {\n        cloned[i] = parent;\n      }\n    } else if (value instanceof Array) {\n      cloned[i] = value.map(function (j) {\n        return cloneNode(j, cloned);\n      });\n    } else {\n      cloned[i] = cloneNode(value, cloned);\n    }\n  }\n\n  return cloned;\n};\n\nvar Node = /*#__PURE__*/function () {\n  function Node(opts) {\n    if (opts === void 0) {\n      opts = {};\n    }\n\n    Object.assign(this, opts);\n    this.spaces = this.spaces || {};\n    this.spaces.before = this.spaces.before || '';\n    this.spaces.after = this.spaces.after || '';\n  }\n\n  var _proto = Node.prototype;\n\n  _proto.remove = function remove() {\n    if (this.parent) {\n      this.parent.removeChild(this);\n    }\n\n    this.parent = undefined;\n    return this;\n  };\n\n  _proto.replaceWith = function replaceWith() {\n    if (this.parent) {\n      for (var index in arguments) {\n        this.parent.insertBefore(this, arguments[index]);\n      }\n\n      this.remove();\n    }\n\n    return this;\n  };\n\n  _proto.next = function next() {\n    return this.parent.at(this.parent.index(this) + 1);\n  };\n\n  _proto.prev = function prev() {\n    return this.parent.at(this.parent.index(this) - 1);\n  };\n\n  _proto.clone = function clone(overrides) {\n    if (overrides === void 0) {\n      overrides = {};\n    }\n\n    var cloned = cloneNode(this);\n\n    for (var name in overrides) {\n      cloned[name] = overrides[name];\n    }\n\n    return cloned;\n  }\n  /**\n   * Some non-standard syntax doesn't follow normal escaping rules for css.\n   * This allows non standard syntax to be appended to an existing property\n   * by specifying the escaped value. By specifying the escaped value,\n   * illegal characters are allowed to be directly inserted into css output.\n   * @param {string} name the property to set\n   * @param {any} value the unescaped value of the property\n   * @param {string} valueEscaped optional. the escaped value of the property.\n   */\n  ;\n\n  _proto.appendToPropertyAndEscape = function appendToPropertyAndEscape(name, value, valueEscaped) {\n    if (!this.raws) {\n      this.raws = {};\n    }\n\n    var originalValue = this[name];\n    var originalEscaped = this.raws[name];\n    this[name] = originalValue + value; // this may trigger a setter that updates raws, so it has to be set first.\n\n    if (originalEscaped || valueEscaped !== value) {\n      this.raws[name] = (originalEscaped || originalValue) + valueEscaped;\n    } else {\n      delete this.raws[name]; // delete any escaped value that was created by the setter.\n    }\n  }\n  /**\n   * Some non-standard syntax doesn't follow normal escaping rules for css.\n   * This allows the escaped value to be specified directly, allowing illegal\n   * characters to be directly inserted into css output.\n   * @param {string} name the property to set\n   * @param {any} value the unescaped value of the property\n   * @param {string} valueEscaped the escaped value of the property.\n   */\n  ;\n\n  _proto.setPropertyAndEscape = function setPropertyAndEscape(name, value, valueEscaped) {\n    if (!this.raws) {\n      this.raws = {};\n    }\n\n    this[name] = value; // this may trigger a setter that updates raws, so it has to be set first.\n\n    this.raws[name] = valueEscaped;\n  }\n  /**\n   * When you want a value to passed through to CSS directly. This method\n   * deletes the corresponding raw value causing the stringifier to fallback\n   * to the unescaped value.\n   * @param {string} name the property to set.\n   * @param {any} value The value that is both escaped and unescaped.\n   */\n  ;\n\n  _proto.setPropertyWithoutEscape = function setPropertyWithoutEscape(name, value) {\n    this[name] = value; // this may trigger a setter that updates raws, so it has to be set first.\n\n    if (this.raws) {\n      delete this.raws[name];\n    }\n  }\n  /**\n   *\n   * @param {number} line The number (starting with 1)\n   * @param {number} column The column number (starting with 1)\n   */\n  ;\n\n  _proto.isAtPosition = function isAtPosition(line, column) {\n    if (this.source && this.source.start && this.source.end) {\n      if (this.source.start.line > line) {\n        return false;\n      }\n\n      if (this.source.end.line < line) {\n        return false;\n      }\n\n      if (this.source.start.line === line && this.source.start.column > column) {\n        return false;\n      }\n\n      if (this.source.end.line === line && this.source.end.column < column) {\n        return false;\n      }\n\n      return true;\n    }\n\n    return undefined;\n  };\n\n  _proto.stringifyProperty = function stringifyProperty(name) {\n    return this.raws && this.raws[name] || this[name];\n  };\n\n  _proto.valueToString = function valueToString() {\n    return String(this.stringifyProperty(\"value\"));\n  };\n\n  _proto.toString = function toString() {\n    return [this.rawSpaceBefore, this.valueToString(), this.rawSpaceAfter].join('');\n  };\n\n  _createClass(Node, [{\n    key: \"rawSpaceBefore\",\n    get: function get() {\n      var rawSpace = this.raws && this.raws.spaces && this.raws.spaces.before;\n\n      if (rawSpace === undefined) {\n        rawSpace = this.spaces && this.spaces.before;\n      }\n\n      return rawSpace || \"\";\n    },\n    set: function set(raw) {\n      (0, _util.ensureObject)(this, \"raws\", \"spaces\");\n      this.raws.spaces.before = raw;\n    }\n  }, {\n    key: \"rawSpaceAfter\",\n    get: function get() {\n      var rawSpace = this.raws && this.raws.spaces && this.raws.spaces.after;\n\n      if (rawSpace === undefined) {\n        rawSpace = this.spaces.after;\n      }\n\n      return rawSpace || \"\";\n    },\n    set: function set(raw) {\n      (0, _util.ensureObject)(this, \"raws\", \"spaces\");\n      this.raws.spaces.after = raw;\n    }\n  }]);\n\n  return Node;\n}();\n\nexports[\"default\"] = Node;\nmodule.exports = exports.default;\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/postcss-selector-parser/dist/selectors/node.js?");

/***/ }),

/***/ "./node_modules/postcss-selector-parser/dist/selectors/pseudo.js":
/*!***********************************************************************!*\
  !*** ./node_modules/postcss-selector-parser/dist/selectors/pseudo.js ***!
  \***********************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("\n\nexports.__esModule = true;\nexports[\"default\"] = void 0;\n\nvar _container = _interopRequireDefault(__webpack_require__(/*! ./container */ \"./node_modules/postcss-selector-parser/dist/selectors/container.js\"));\n\nvar _types = __webpack_require__(/*! ./types */ \"./node_modules/postcss-selector-parser/dist/selectors/types.js\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nvar Pseudo = /*#__PURE__*/function (_Container) {\n  _inheritsLoose(Pseudo, _Container);\n\n  function Pseudo(opts) {\n    var _this;\n\n    _this = _Container.call(this, opts) || this;\n    _this.type = _types.PSEUDO;\n    return _this;\n  }\n\n  var _proto = Pseudo.prototype;\n\n  _proto.toString = function toString() {\n    var params = this.length ? '(' + this.map(String).join(',') + ')' : '';\n    return [this.rawSpaceBefore, this.stringifyProperty(\"value\"), params, this.rawSpaceAfter].join('');\n  };\n\n  return Pseudo;\n}(_container[\"default\"]);\n\nexports[\"default\"] = Pseudo;\nmodule.exports = exports.default;\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/postcss-selector-parser/dist/selectors/pseudo.js?");

/***/ }),

/***/ "./node_modules/postcss-selector-parser/dist/selectors/root.js":
/*!*********************************************************************!*\
  !*** ./node_modules/postcss-selector-parser/dist/selectors/root.js ***!
  \*********************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("\n\nexports.__esModule = true;\nexports[\"default\"] = void 0;\n\nvar _container = _interopRequireDefault(__webpack_require__(/*! ./container */ \"./node_modules/postcss-selector-parser/dist/selectors/container.js\"));\n\nvar _types = __webpack_require__(/*! ./types */ \"./node_modules/postcss-selector-parser/dist/selectors/types.js\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nvar Root = /*#__PURE__*/function (_Container) {\n  _inheritsLoose(Root, _Container);\n\n  function Root(opts) {\n    var _this;\n\n    _this = _Container.call(this, opts) || this;\n    _this.type = _types.ROOT;\n    return _this;\n  }\n\n  var _proto = Root.prototype;\n\n  _proto.toString = function toString() {\n    var str = this.reduce(function (memo, selector) {\n      memo.push(String(selector));\n      return memo;\n    }, []).join(',');\n    return this.trailingComma ? str + ',' : str;\n  };\n\n  _proto.error = function error(message, options) {\n    if (this._error) {\n      return this._error(message, options);\n    } else {\n      return new Error(message);\n    }\n  };\n\n  _createClass(Root, [{\n    key: \"errorGenerator\",\n    set: function set(handler) {\n      this._error = handler;\n    }\n  }]);\n\n  return Root;\n}(_container[\"default\"]);\n\nexports[\"default\"] = Root;\nmodule.exports = exports.default;\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/postcss-selector-parser/dist/selectors/root.js?");

/***/ }),

/***/ "./node_modules/postcss-selector-parser/dist/selectors/selector.js":
/*!*************************************************************************!*\
  !*** ./node_modules/postcss-selector-parser/dist/selectors/selector.js ***!
  \*************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("\n\nexports.__esModule = true;\nexports[\"default\"] = void 0;\n\nvar _container = _interopRequireDefault(__webpack_require__(/*! ./container */ \"./node_modules/postcss-selector-parser/dist/selectors/container.js\"));\n\nvar _types = __webpack_require__(/*! ./types */ \"./node_modules/postcss-selector-parser/dist/selectors/types.js\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nvar Selector = /*#__PURE__*/function (_Container) {\n  _inheritsLoose(Selector, _Container);\n\n  function Selector(opts) {\n    var _this;\n\n    _this = _Container.call(this, opts) || this;\n    _this.type = _types.SELECTOR;\n    return _this;\n  }\n\n  return Selector;\n}(_container[\"default\"]);\n\nexports[\"default\"] = Selector;\nmodule.exports = exports.default;\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/postcss-selector-parser/dist/selectors/selector.js?");

/***/ }),

/***/ "./node_modules/postcss-selector-parser/dist/selectors/string.js":
/*!***********************************************************************!*\
  !*** ./node_modules/postcss-selector-parser/dist/selectors/string.js ***!
  \***********************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("\n\nexports.__esModule = true;\nexports[\"default\"] = void 0;\n\nvar _node = _interopRequireDefault(__webpack_require__(/*! ./node */ \"./node_modules/postcss-selector-parser/dist/selectors/node.js\"));\n\nvar _types = __webpack_require__(/*! ./types */ \"./node_modules/postcss-selector-parser/dist/selectors/types.js\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nvar String = /*#__PURE__*/function (_Node) {\n  _inheritsLoose(String, _Node);\n\n  function String(opts) {\n    var _this;\n\n    _this = _Node.call(this, opts) || this;\n    _this.type = _types.STRING;\n    return _this;\n  }\n\n  return String;\n}(_node[\"default\"]);\n\nexports[\"default\"] = String;\nmodule.exports = exports.default;\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/postcss-selector-parser/dist/selectors/string.js?");

/***/ }),

/***/ "./node_modules/postcss-selector-parser/dist/selectors/tag.js":
/*!********************************************************************!*\
  !*** ./node_modules/postcss-selector-parser/dist/selectors/tag.js ***!
  \********************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("\n\nexports.__esModule = true;\nexports[\"default\"] = void 0;\n\nvar _namespace = _interopRequireDefault(__webpack_require__(/*! ./namespace */ \"./node_modules/postcss-selector-parser/dist/selectors/namespace.js\"));\n\nvar _types = __webpack_require__(/*! ./types */ \"./node_modules/postcss-selector-parser/dist/selectors/types.js\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nvar Tag = /*#__PURE__*/function (_Namespace) {\n  _inheritsLoose(Tag, _Namespace);\n\n  function Tag(opts) {\n    var _this;\n\n    _this = _Namespace.call(this, opts) || this;\n    _this.type = _types.TAG;\n    return _this;\n  }\n\n  return Tag;\n}(_namespace[\"default\"]);\n\nexports[\"default\"] = Tag;\nmodule.exports = exports.default;\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/postcss-selector-parser/dist/selectors/tag.js?");

/***/ }),

/***/ "./node_modules/postcss-selector-parser/dist/selectors/types.js":
/*!**********************************************************************!*\
  !*** ./node_modules/postcss-selector-parser/dist/selectors/types.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\nexports.__esModule = true;\nexports.UNIVERSAL = exports.ATTRIBUTE = exports.CLASS = exports.COMBINATOR = exports.COMMENT = exports.ID = exports.NESTING = exports.PSEUDO = exports.ROOT = exports.SELECTOR = exports.STRING = exports.TAG = void 0;\nvar TAG = 'tag';\nexports.TAG = TAG;\nvar STRING = 'string';\nexports.STRING = STRING;\nvar SELECTOR = 'selector';\nexports.SELECTOR = SELECTOR;\nvar ROOT = 'root';\nexports.ROOT = ROOT;\nvar PSEUDO = 'pseudo';\nexports.PSEUDO = PSEUDO;\nvar NESTING = 'nesting';\nexports.NESTING = NESTING;\nvar ID = 'id';\nexports.ID = ID;\nvar COMMENT = 'comment';\nexports.COMMENT = COMMENT;\nvar COMBINATOR = 'combinator';\nexports.COMBINATOR = COMBINATOR;\nvar CLASS = 'class';\nexports.CLASS = CLASS;\nvar ATTRIBUTE = 'attribute';\nexports.ATTRIBUTE = ATTRIBUTE;\nvar UNIVERSAL = 'universal';\nexports.UNIVERSAL = UNIVERSAL;\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/postcss-selector-parser/dist/selectors/types.js?");

/***/ }),

/***/ "./node_modules/postcss-selector-parser/dist/selectors/universal.js":
/*!**************************************************************************!*\
  !*** ./node_modules/postcss-selector-parser/dist/selectors/universal.js ***!
  \**************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("\n\nexports.__esModule = true;\nexports[\"default\"] = void 0;\n\nvar _namespace = _interopRequireDefault(__webpack_require__(/*! ./namespace */ \"./node_modules/postcss-selector-parser/dist/selectors/namespace.js\"));\n\nvar _types = __webpack_require__(/*! ./types */ \"./node_modules/postcss-selector-parser/dist/selectors/types.js\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nvar Universal = /*#__PURE__*/function (_Namespace) {\n  _inheritsLoose(Universal, _Namespace);\n\n  function Universal(opts) {\n    var _this;\n\n    _this = _Namespace.call(this, opts) || this;\n    _this.type = _types.UNIVERSAL;\n    _this.value = '*';\n    return _this;\n  }\n\n  return Universal;\n}(_namespace[\"default\"]);\n\nexports[\"default\"] = Universal;\nmodule.exports = exports.default;\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/postcss-selector-parser/dist/selectors/universal.js?");

/***/ }),

/***/ "./node_modules/postcss-selector-parser/dist/sortAscending.js":
/*!********************************************************************!*\
  !*** ./node_modules/postcss-selector-parser/dist/sortAscending.js ***!
  \********************************************************************/
/***/ ((module, exports) => {

"use strict";
eval("\n\nexports.__esModule = true;\nexports[\"default\"] = sortAscending;\n\nfunction sortAscending(list) {\n  return list.sort(function (a, b) {\n    return a - b;\n  });\n}\n\n;\nmodule.exports = exports.default;\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/postcss-selector-parser/dist/sortAscending.js?");

/***/ }),

/***/ "./node_modules/postcss-selector-parser/dist/tokenTypes.js":
/*!*****************************************************************!*\
  !*** ./node_modules/postcss-selector-parser/dist/tokenTypes.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\nexports.__esModule = true;\nexports.combinator = exports.word = exports.comment = exports.str = exports.tab = exports.newline = exports.feed = exports.cr = exports.backslash = exports.bang = exports.slash = exports.doubleQuote = exports.singleQuote = exports.space = exports.greaterThan = exports.pipe = exports.equals = exports.plus = exports.caret = exports.tilde = exports.dollar = exports.closeSquare = exports.openSquare = exports.closeParenthesis = exports.openParenthesis = exports.semicolon = exports.colon = exports.comma = exports.at = exports.asterisk = exports.ampersand = void 0;\nvar ampersand = 38; // `&`.charCodeAt(0);\n\nexports.ampersand = ampersand;\nvar asterisk = 42; // `*`.charCodeAt(0);\n\nexports.asterisk = asterisk;\nvar at = 64; // `@`.charCodeAt(0);\n\nexports.at = at;\nvar comma = 44; // `,`.charCodeAt(0);\n\nexports.comma = comma;\nvar colon = 58; // `:`.charCodeAt(0);\n\nexports.colon = colon;\nvar semicolon = 59; // `;`.charCodeAt(0);\n\nexports.semicolon = semicolon;\nvar openParenthesis = 40; // `(`.charCodeAt(0);\n\nexports.openParenthesis = openParenthesis;\nvar closeParenthesis = 41; // `)`.charCodeAt(0);\n\nexports.closeParenthesis = closeParenthesis;\nvar openSquare = 91; // `[`.charCodeAt(0);\n\nexports.openSquare = openSquare;\nvar closeSquare = 93; // `]`.charCodeAt(0);\n\nexports.closeSquare = closeSquare;\nvar dollar = 36; // `$`.charCodeAt(0);\n\nexports.dollar = dollar;\nvar tilde = 126; // `~`.charCodeAt(0);\n\nexports.tilde = tilde;\nvar caret = 94; // `^`.charCodeAt(0);\n\nexports.caret = caret;\nvar plus = 43; // `+`.charCodeAt(0);\n\nexports.plus = plus;\nvar equals = 61; // `=`.charCodeAt(0);\n\nexports.equals = equals;\nvar pipe = 124; // `|`.charCodeAt(0);\n\nexports.pipe = pipe;\nvar greaterThan = 62; // `>`.charCodeAt(0);\n\nexports.greaterThan = greaterThan;\nvar space = 32; // ` `.charCodeAt(0);\n\nexports.space = space;\nvar singleQuote = 39; // `'`.charCodeAt(0);\n\nexports.singleQuote = singleQuote;\nvar doubleQuote = 34; // `\"`.charCodeAt(0);\n\nexports.doubleQuote = doubleQuote;\nvar slash = 47; // `/`.charCodeAt(0);\n\nexports.slash = slash;\nvar bang = 33; // `!`.charCodeAt(0);\n\nexports.bang = bang;\nvar backslash = 92; // '\\\\'.charCodeAt(0);\n\nexports.backslash = backslash;\nvar cr = 13; // '\\r'.charCodeAt(0);\n\nexports.cr = cr;\nvar feed = 12; // '\\f'.charCodeAt(0);\n\nexports.feed = feed;\nvar newline = 10; // '\\n'.charCodeAt(0);\n\nexports.newline = newline;\nvar tab = 9; // '\\t'.charCodeAt(0);\n// Expose aliases primarily for readability.\n\nexports.tab = tab;\nvar str = singleQuote; // No good single character representation!\n\nexports.str = str;\nvar comment = -1;\nexports.comment = comment;\nvar word = -2;\nexports.word = word;\nvar combinator = -3;\nexports.combinator = combinator;\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/postcss-selector-parser/dist/tokenTypes.js?");

/***/ }),

/***/ "./node_modules/postcss-selector-parser/dist/tokenize.js":
/*!***************************************************************!*\
  !*** ./node_modules/postcss-selector-parser/dist/tokenize.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nexports.__esModule = true;\nexports[\"default\"] = tokenize;\nexports.FIELDS = void 0;\n\nvar t = _interopRequireWildcard(__webpack_require__(/*! ./tokenTypes */ \"./node_modules/postcss-selector-parser/dist/tokenTypes.js\"));\n\nvar _unescapable, _wordDelimiters;\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { \"default\": obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj[\"default\"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nvar unescapable = (_unescapable = {}, _unescapable[t.tab] = true, _unescapable[t.newline] = true, _unescapable[t.cr] = true, _unescapable[t.feed] = true, _unescapable);\nvar wordDelimiters = (_wordDelimiters = {}, _wordDelimiters[t.space] = true, _wordDelimiters[t.tab] = true, _wordDelimiters[t.newline] = true, _wordDelimiters[t.cr] = true, _wordDelimiters[t.feed] = true, _wordDelimiters[t.ampersand] = true, _wordDelimiters[t.asterisk] = true, _wordDelimiters[t.bang] = true, _wordDelimiters[t.comma] = true, _wordDelimiters[t.colon] = true, _wordDelimiters[t.semicolon] = true, _wordDelimiters[t.openParenthesis] = true, _wordDelimiters[t.closeParenthesis] = true, _wordDelimiters[t.openSquare] = true, _wordDelimiters[t.closeSquare] = true, _wordDelimiters[t.singleQuote] = true, _wordDelimiters[t.doubleQuote] = true, _wordDelimiters[t.plus] = true, _wordDelimiters[t.pipe] = true, _wordDelimiters[t.tilde] = true, _wordDelimiters[t.greaterThan] = true, _wordDelimiters[t.equals] = true, _wordDelimiters[t.dollar] = true, _wordDelimiters[t.caret] = true, _wordDelimiters[t.slash] = true, _wordDelimiters);\nvar hex = {};\nvar hexChars = \"0123456789abcdefABCDEF\";\n\nfor (var i = 0; i < hexChars.length; i++) {\n  hex[hexChars.charCodeAt(i)] = true;\n}\n/**\n *  Returns the last index of the bar css word\n * @param {string} css The string in which the word begins\n * @param {number} start The index into the string where word's first letter occurs\n */\n\n\nfunction consumeWord(css, start) {\n  var next = start;\n  var code;\n\n  do {\n    code = css.charCodeAt(next);\n\n    if (wordDelimiters[code]) {\n      return next - 1;\n    } else if (code === t.backslash) {\n      next = consumeEscape(css, next) + 1;\n    } else {\n      // All other characters are part of the word\n      next++;\n    }\n  } while (next < css.length);\n\n  return next - 1;\n}\n/**\n *  Returns the last index of the escape sequence\n * @param {string} css The string in which the sequence begins\n * @param {number} start The index into the string where escape character (`\\`) occurs.\n */\n\n\nfunction consumeEscape(css, start) {\n  var next = start;\n  var code = css.charCodeAt(next + 1);\n\n  if (unescapable[code]) {// just consume the escape char\n  } else if (hex[code]) {\n    var hexDigits = 0; // consume up to 6 hex chars\n\n    do {\n      next++;\n      hexDigits++;\n      code = css.charCodeAt(next + 1);\n    } while (hex[code] && hexDigits < 6); // if fewer than 6 hex chars, a trailing space ends the escape\n\n\n    if (hexDigits < 6 && code === t.space) {\n      next++;\n    }\n  } else {\n    // the next char is part of the current word\n    next++;\n  }\n\n  return next;\n}\n\nvar FIELDS = {\n  TYPE: 0,\n  START_LINE: 1,\n  START_COL: 2,\n  END_LINE: 3,\n  END_COL: 4,\n  START_POS: 5,\n  END_POS: 6\n};\nexports.FIELDS = FIELDS;\n\nfunction tokenize(input) {\n  var tokens = [];\n  var css = input.css.valueOf();\n  var _css = css,\n      length = _css.length;\n  var offset = -1;\n  var line = 1;\n  var start = 0;\n  var end = 0;\n  var code, content, endColumn, endLine, escaped, escapePos, last, lines, next, nextLine, nextOffset, quote, tokenType;\n\n  function unclosed(what, fix) {\n    if (input.safe) {\n      // fyi: this is never set to true.\n      css += fix;\n      next = css.length - 1;\n    } else {\n      throw input.error('Unclosed ' + what, line, start - offset, start);\n    }\n  }\n\n  while (start < length) {\n    code = css.charCodeAt(start);\n\n    if (code === t.newline) {\n      offset = start;\n      line += 1;\n    }\n\n    switch (code) {\n      case t.space:\n      case t.tab:\n      case t.newline:\n      case t.cr:\n      case t.feed:\n        next = start;\n\n        do {\n          next += 1;\n          code = css.charCodeAt(next);\n\n          if (code === t.newline) {\n            offset = next;\n            line += 1;\n          }\n        } while (code === t.space || code === t.newline || code === t.tab || code === t.cr || code === t.feed);\n\n        tokenType = t.space;\n        endLine = line;\n        endColumn = next - offset - 1;\n        end = next;\n        break;\n\n      case t.plus:\n      case t.greaterThan:\n      case t.tilde:\n      case t.pipe:\n        next = start;\n\n        do {\n          next += 1;\n          code = css.charCodeAt(next);\n        } while (code === t.plus || code === t.greaterThan || code === t.tilde || code === t.pipe);\n\n        tokenType = t.combinator;\n        endLine = line;\n        endColumn = start - offset;\n        end = next;\n        break;\n      // Consume these characters as single tokens.\n\n      case t.asterisk:\n      case t.ampersand:\n      case t.bang:\n      case t.comma:\n      case t.equals:\n      case t.dollar:\n      case t.caret:\n      case t.openSquare:\n      case t.closeSquare:\n      case t.colon:\n      case t.semicolon:\n      case t.openParenthesis:\n      case t.closeParenthesis:\n        next = start;\n        tokenType = code;\n        endLine = line;\n        endColumn = start - offset;\n        end = next + 1;\n        break;\n\n      case t.singleQuote:\n      case t.doubleQuote:\n        quote = code === t.singleQuote ? \"'\" : '\"';\n        next = start;\n\n        do {\n          escaped = false;\n          next = css.indexOf(quote, next + 1);\n\n          if (next === -1) {\n            unclosed('quote', quote);\n          }\n\n          escapePos = next;\n\n          while (css.charCodeAt(escapePos - 1) === t.backslash) {\n            escapePos -= 1;\n            escaped = !escaped;\n          }\n        } while (escaped);\n\n        tokenType = t.str;\n        endLine = line;\n        endColumn = start - offset;\n        end = next + 1;\n        break;\n\n      default:\n        if (code === t.slash && css.charCodeAt(start + 1) === t.asterisk) {\n          next = css.indexOf('*/', start + 2) + 1;\n\n          if (next === 0) {\n            unclosed('comment', '*/');\n          }\n\n          content = css.slice(start, next + 1);\n          lines = content.split('\\n');\n          last = lines.length - 1;\n\n          if (last > 0) {\n            nextLine = line + last;\n            nextOffset = next - lines[last].length;\n          } else {\n            nextLine = line;\n            nextOffset = offset;\n          }\n\n          tokenType = t.comment;\n          line = nextLine;\n          endLine = nextLine;\n          endColumn = next - nextOffset;\n        } else if (code === t.slash) {\n          next = start;\n          tokenType = code;\n          endLine = line;\n          endColumn = start - offset;\n          end = next + 1;\n        } else {\n          next = consumeWord(css, start);\n          tokenType = t.word;\n          endLine = line;\n          endColumn = next - offset;\n        }\n\n        end = next + 1;\n        break;\n    } // Ensure that the token structure remains consistent\n\n\n    tokens.push([tokenType, // [0] Token type\n    line, // [1] Starting line\n    start - offset, // [2] Starting column\n    endLine, // [3] Ending line\n    endColumn, // [4] Ending column\n    start, // [5] Start position / Source index\n    end // [6] End position\n    ]); // Reset offset for the next token\n\n    if (nextOffset) {\n      offset = nextOffset;\n      nextOffset = null;\n    }\n\n    start = end;\n  }\n\n  return tokens;\n}\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/postcss-selector-parser/dist/tokenize.js?");

/***/ }),

/***/ "./node_modules/postcss-selector-parser/dist/util/ensureObject.js":
/*!************************************************************************!*\
  !*** ./node_modules/postcss-selector-parser/dist/util/ensureObject.js ***!
  \************************************************************************/
/***/ ((module, exports) => {

"use strict";
eval("\n\nexports.__esModule = true;\nexports[\"default\"] = ensureObject;\n\nfunction ensureObject(obj) {\n  for (var _len = arguments.length, props = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    props[_key - 1] = arguments[_key];\n  }\n\n  while (props.length > 0) {\n    var prop = props.shift();\n\n    if (!obj[prop]) {\n      obj[prop] = {};\n    }\n\n    obj = obj[prop];\n  }\n}\n\nmodule.exports = exports.default;\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/postcss-selector-parser/dist/util/ensureObject.js?");

/***/ }),

/***/ "./node_modules/postcss-selector-parser/dist/util/getProp.js":
/*!*******************************************************************!*\
  !*** ./node_modules/postcss-selector-parser/dist/util/getProp.js ***!
  \*******************************************************************/
/***/ ((module, exports) => {

"use strict";
eval("\n\nexports.__esModule = true;\nexports[\"default\"] = getProp;\n\nfunction getProp(obj) {\n  for (var _len = arguments.length, props = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    props[_key - 1] = arguments[_key];\n  }\n\n  while (props.length > 0) {\n    var prop = props.shift();\n\n    if (!obj[prop]) {\n      return undefined;\n    }\n\n    obj = obj[prop];\n  }\n\n  return obj;\n}\n\nmodule.exports = exports.default;\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/postcss-selector-parser/dist/util/getProp.js?");

/***/ }),

/***/ "./node_modules/postcss-selector-parser/dist/util/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/postcss-selector-parser/dist/util/index.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nexports.__esModule = true;\nexports.stripComments = exports.ensureObject = exports.getProp = exports.unesc = void 0;\n\nvar _unesc = _interopRequireDefault(__webpack_require__(/*! ./unesc */ \"./node_modules/postcss-selector-parser/dist/util/unesc.js\"));\n\nexports.unesc = _unesc[\"default\"];\n\nvar _getProp = _interopRequireDefault(__webpack_require__(/*! ./getProp */ \"./node_modules/postcss-selector-parser/dist/util/getProp.js\"));\n\nexports.getProp = _getProp[\"default\"];\n\nvar _ensureObject = _interopRequireDefault(__webpack_require__(/*! ./ensureObject */ \"./node_modules/postcss-selector-parser/dist/util/ensureObject.js\"));\n\nexports.ensureObject = _ensureObject[\"default\"];\n\nvar _stripComments = _interopRequireDefault(__webpack_require__(/*! ./stripComments */ \"./node_modules/postcss-selector-parser/dist/util/stripComments.js\"));\n\nexports.stripComments = _stripComments[\"default\"];\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/postcss-selector-parser/dist/util/index.js?");

/***/ }),

/***/ "./node_modules/postcss-selector-parser/dist/util/stripComments.js":
/*!*************************************************************************!*\
  !*** ./node_modules/postcss-selector-parser/dist/util/stripComments.js ***!
  \*************************************************************************/
/***/ ((module, exports) => {

"use strict";
eval("\n\nexports.__esModule = true;\nexports[\"default\"] = stripComments;\n\nfunction stripComments(str) {\n  var s = \"\";\n  var commentStart = str.indexOf(\"/*\");\n  var lastEnd = 0;\n\n  while (commentStart >= 0) {\n    s = s + str.slice(lastEnd, commentStart);\n    var commentEnd = str.indexOf(\"*/\", commentStart + 2);\n\n    if (commentEnd < 0) {\n      return s;\n    }\n\n    lastEnd = commentEnd + 2;\n    commentStart = str.indexOf(\"/*\", lastEnd);\n  }\n\n  s = s + str.slice(lastEnd);\n  return s;\n}\n\nmodule.exports = exports.default;\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/postcss-selector-parser/dist/util/stripComments.js?");

/***/ }),

/***/ "./node_modules/postcss-selector-parser/dist/util/unesc.js":
/*!*****************************************************************!*\
  !*** ./node_modules/postcss-selector-parser/dist/util/unesc.js ***!
  \*****************************************************************/
/***/ ((module, exports) => {

"use strict";
eval("\n\nexports.__esModule = true;\nexports[\"default\"] = unesc;\n\n// Many thanks for this post which made this migration much easier.\n// https://mathiasbynens.be/notes/css-escapes\n\n/**\n * \n * @param {string} str \n * @returns {[string, number]|undefined}\n */\nfunction gobbleHex(str) {\n  var lower = str.toLowerCase();\n  var hex = '';\n  var spaceTerminated = false;\n\n  for (var i = 0; i < 6 && lower[i] !== undefined; i++) {\n    var code = lower.charCodeAt(i); // check to see if we are dealing with a valid hex char [a-f|0-9]\n\n    var valid = code >= 97 && code <= 102 || code >= 48 && code <= 57; // https://drafts.csswg.org/css-syntax/#consume-escaped-code-point\n\n    spaceTerminated = code === 32;\n\n    if (!valid) {\n      break;\n    }\n\n    hex += lower[i];\n  }\n\n  if (hex.length === 0) {\n    return undefined;\n  }\n\n  var codePoint = parseInt(hex, 16);\n  var isSurrogate = codePoint >= 0xD800 && codePoint <= 0xDFFF; // Add special case for\n  // \"If this number is zero, or is for a surrogate, or is greater than the maximum allowed code point\"\n  // https://drafts.csswg.org/css-syntax/#maximum-allowed-code-point\n\n  if (isSurrogate || codePoint === 0x0000 || codePoint > 0x10FFFF) {\n    return [\"\\uFFFD\", hex.length + (spaceTerminated ? 1 : 0)];\n  }\n\n  return [String.fromCodePoint(codePoint), hex.length + (spaceTerminated ? 1 : 0)];\n}\n\nvar CONTAINS_ESCAPE = /\\\\/;\n\nfunction unesc(str) {\n  var needToProcess = CONTAINS_ESCAPE.test(str);\n\n  if (!needToProcess) {\n    return str;\n  }\n\n  var ret = \"\";\n\n  for (var i = 0; i < str.length; i++) {\n    if (str[i] === \"\\\\\") {\n      var gobbled = gobbleHex(str.slice(i + 1, i + 7));\n\n      if (gobbled !== undefined) {\n        ret += gobbled[0];\n        i += gobbled[1];\n        continue;\n      } // Retain a pair of \\\\ if double escaped `\\\\\\\\`\n      // https://github.com/postcss/postcss-selector-parser/commit/268c9a7656fb53f543dc620aa5b73a30ec3ff20e\n\n\n      if (str[i + 1] === \"\\\\\") {\n        ret += \"\\\\\";\n        i++;\n        continue;\n      } // if \\\\ is at the end of the string retain it\n      // https://github.com/postcss/postcss-selector-parser/commit/01a6b346e3612ce1ab20219acc26abdc259ccefb\n\n\n      if (str.length === i + 1) {\n        ret += str[i];\n      }\n\n      continue;\n    }\n\n    ret += str[i];\n  }\n\n  return ret;\n}\n\nmodule.exports = exports.default;\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/postcss-selector-parser/dist/util/unesc.js?");

/***/ }),

/***/ "./node_modules/postcss-value-parser/lib/index.js":
/*!********************************************************!*\
  !*** ./node_modules/postcss-value-parser/lib/index.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var parse = __webpack_require__(/*! ./parse */ \"./node_modules/postcss-value-parser/lib/parse.js\");\nvar walk = __webpack_require__(/*! ./walk */ \"./node_modules/postcss-value-parser/lib/walk.js\");\nvar stringify = __webpack_require__(/*! ./stringify */ \"./node_modules/postcss-value-parser/lib/stringify.js\");\n\nfunction ValueParser(value) {\n  if (this instanceof ValueParser) {\n    this.nodes = parse(value);\n    return this;\n  }\n  return new ValueParser(value);\n}\n\nValueParser.prototype.toString = function() {\n  return Array.isArray(this.nodes) ? stringify(this.nodes) : \"\";\n};\n\nValueParser.prototype.walk = function(cb, bubble) {\n  walk(this.nodes, cb, bubble);\n  return this;\n};\n\nValueParser.unit = __webpack_require__(/*! ./unit */ \"./node_modules/postcss-value-parser/lib/unit.js\");\n\nValueParser.walk = walk;\n\nValueParser.stringify = stringify;\n\nmodule.exports = ValueParser;\n\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/postcss-value-parser/lib/index.js?");

/***/ }),

/***/ "./node_modules/postcss-value-parser/lib/parse.js":
/*!********************************************************!*\
  !*** ./node_modules/postcss-value-parser/lib/parse.js ***!
  \********************************************************/
/***/ ((module) => {

eval("var openParentheses = \"(\".charCodeAt(0);\nvar closeParentheses = \")\".charCodeAt(0);\nvar singleQuote = \"'\".charCodeAt(0);\nvar doubleQuote = '\"'.charCodeAt(0);\nvar backslash = \"\\\\\".charCodeAt(0);\nvar slash = \"/\".charCodeAt(0);\nvar comma = \",\".charCodeAt(0);\nvar colon = \":\".charCodeAt(0);\nvar star = \"*\".charCodeAt(0);\nvar uLower = \"u\".charCodeAt(0);\nvar uUpper = \"U\".charCodeAt(0);\nvar plus = \"+\".charCodeAt(0);\nvar isUnicodeRange = /^[a-f0-9?-]+$/i;\n\nmodule.exports = function(input) {\n  var tokens = [];\n  var value = input;\n\n  var next,\n    quote,\n    prev,\n    token,\n    escape,\n    escapePos,\n    whitespacePos,\n    parenthesesOpenPos;\n  var pos = 0;\n  var code = value.charCodeAt(pos);\n  var max = value.length;\n  var stack = [{ nodes: tokens }];\n  var balanced = 0;\n  var parent;\n\n  var name = \"\";\n  var before = \"\";\n  var after = \"\";\n\n  while (pos < max) {\n    // Whitespaces\n    if (code <= 32) {\n      next = pos;\n      do {\n        next += 1;\n        code = value.charCodeAt(next);\n      } while (code <= 32);\n      token = value.slice(pos, next);\n\n      prev = tokens[tokens.length - 1];\n      if (code === closeParentheses && balanced) {\n        after = token;\n      } else if (prev && prev.type === \"div\") {\n        prev.after = token;\n        prev.sourceEndIndex += token.length;\n      } else if (\n        code === comma ||\n        code === colon ||\n        (code === slash &&\n          value.charCodeAt(next + 1) !== star &&\n          (!parent ||\n            (parent && parent.type === \"function\" && parent.value !== \"calc\")))\n      ) {\n        before = token;\n      } else {\n        tokens.push({\n          type: \"space\",\n          sourceIndex: pos,\n          sourceEndIndex: next,\n          value: token\n        });\n      }\n\n      pos = next;\n\n      // Quotes\n    } else if (code === singleQuote || code === doubleQuote) {\n      next = pos;\n      quote = code === singleQuote ? \"'\" : '\"';\n      token = {\n        type: \"string\",\n        sourceIndex: pos,\n        quote: quote\n      };\n      do {\n        escape = false;\n        next = value.indexOf(quote, next + 1);\n        if (~next) {\n          escapePos = next;\n          while (value.charCodeAt(escapePos - 1) === backslash) {\n            escapePos -= 1;\n            escape = !escape;\n          }\n        } else {\n          value += quote;\n          next = value.length - 1;\n          token.unclosed = true;\n        }\n      } while (escape);\n      token.value = value.slice(pos + 1, next);\n      token.sourceEndIndex = token.unclosed ? next : next + 1;\n      tokens.push(token);\n      pos = next + 1;\n      code = value.charCodeAt(pos);\n\n      // Comments\n    } else if (code === slash && value.charCodeAt(pos + 1) === star) {\n      next = value.indexOf(\"*/\", pos);\n\n      token = {\n        type: \"comment\",\n        sourceIndex: pos,\n        sourceEndIndex: next + 2\n      };\n\n      if (next === -1) {\n        token.unclosed = true;\n        next = value.length;\n        token.sourceEndIndex = next;\n      }\n\n      token.value = value.slice(pos + 2, next);\n      tokens.push(token);\n\n      pos = next + 2;\n      code = value.charCodeAt(pos);\n\n      // Operation within calc\n    } else if (\n      (code === slash || code === star) &&\n      parent &&\n      parent.type === \"function\" &&\n      parent.value === \"calc\"\n    ) {\n      token = value[pos];\n      tokens.push({\n        type: \"word\",\n        sourceIndex: pos - before.length,\n        sourceEndIndex: pos + token.length,\n        value: token\n      });\n      pos += 1;\n      code = value.charCodeAt(pos);\n\n      // Dividers\n    } else if (code === slash || code === comma || code === colon) {\n      token = value[pos];\n\n      tokens.push({\n        type: \"div\",\n        sourceIndex: pos - before.length,\n        sourceEndIndex: pos + token.length,\n        value: token,\n        before: before,\n        after: \"\"\n      });\n      before = \"\";\n\n      pos += 1;\n      code = value.charCodeAt(pos);\n\n      // Open parentheses\n    } else if (openParentheses === code) {\n      // Whitespaces after open parentheses\n      next = pos;\n      do {\n        next += 1;\n        code = value.charCodeAt(next);\n      } while (code <= 32);\n      parenthesesOpenPos = pos;\n      token = {\n        type: \"function\",\n        sourceIndex: pos - name.length,\n        value: name,\n        before: value.slice(parenthesesOpenPos + 1, next)\n      };\n      pos = next;\n\n      if (name === \"url\" && code !== singleQuote && code !== doubleQuote) {\n        next -= 1;\n        do {\n          escape = false;\n          next = value.indexOf(\")\", next + 1);\n          if (~next) {\n            escapePos = next;\n            while (value.charCodeAt(escapePos - 1) === backslash) {\n              escapePos -= 1;\n              escape = !escape;\n            }\n          } else {\n            value += \")\";\n            next = value.length - 1;\n            token.unclosed = true;\n          }\n        } while (escape);\n        // Whitespaces before closed\n        whitespacePos = next;\n        do {\n          whitespacePos -= 1;\n          code = value.charCodeAt(whitespacePos);\n        } while (code <= 32);\n        if (parenthesesOpenPos < whitespacePos) {\n          if (pos !== whitespacePos + 1) {\n            token.nodes = [\n              {\n                type: \"word\",\n                sourceIndex: pos,\n                sourceEndIndex: whitespacePos + 1,\n                value: value.slice(pos, whitespacePos + 1)\n              }\n            ];\n          } else {\n            token.nodes = [];\n          }\n          if (token.unclosed && whitespacePos + 1 !== next) {\n            token.after = \"\";\n            token.nodes.push({\n              type: \"space\",\n              sourceIndex: whitespacePos + 1,\n              sourceEndIndex: next,\n              value: value.slice(whitespacePos + 1, next)\n            });\n          } else {\n            token.after = value.slice(whitespacePos + 1, next);\n            token.sourceEndIndex = next;\n          }\n        } else {\n          token.after = \"\";\n          token.nodes = [];\n        }\n        pos = next + 1;\n        token.sourceEndIndex = token.unclosed ? next : pos;\n        code = value.charCodeAt(pos);\n        tokens.push(token);\n      } else {\n        balanced += 1;\n        token.after = \"\";\n        token.sourceEndIndex = pos + 1;\n        tokens.push(token);\n        stack.push(token);\n        tokens = token.nodes = [];\n        parent = token;\n      }\n      name = \"\";\n\n      // Close parentheses\n    } else if (closeParentheses === code && balanced) {\n      pos += 1;\n      code = value.charCodeAt(pos);\n\n      parent.after = after;\n      parent.sourceEndIndex += after.length;\n      after = \"\";\n      balanced -= 1;\n      stack[stack.length - 1].sourceEndIndex = pos;\n      stack.pop();\n      parent = stack[balanced];\n      tokens = parent.nodes;\n\n      // Words\n    } else {\n      next = pos;\n      do {\n        if (code === backslash) {\n          next += 1;\n        }\n        next += 1;\n        code = value.charCodeAt(next);\n      } while (\n        next < max &&\n        !(\n          code <= 32 ||\n          code === singleQuote ||\n          code === doubleQuote ||\n          code === comma ||\n          code === colon ||\n          code === slash ||\n          code === openParentheses ||\n          (code === star &&\n            parent &&\n            parent.type === \"function\" &&\n            parent.value === \"calc\") ||\n          (code === slash &&\n            parent.type === \"function\" &&\n            parent.value === \"calc\") ||\n          (code === closeParentheses && balanced)\n        )\n      );\n      token = value.slice(pos, next);\n\n      if (openParentheses === code) {\n        name = token;\n      } else if (\n        (uLower === token.charCodeAt(0) || uUpper === token.charCodeAt(0)) &&\n        plus === token.charCodeAt(1) &&\n        isUnicodeRange.test(token.slice(2))\n      ) {\n        tokens.push({\n          type: \"unicode-range\",\n          sourceIndex: pos,\n          sourceEndIndex: next,\n          value: token\n        });\n      } else {\n        tokens.push({\n          type: \"word\",\n          sourceIndex: pos,\n          sourceEndIndex: next,\n          value: token\n        });\n      }\n\n      pos = next;\n    }\n  }\n\n  for (pos = stack.length - 1; pos; pos -= 1) {\n    stack[pos].unclosed = true;\n    stack[pos].sourceEndIndex = value.length;\n  }\n\n  return stack[0].nodes;\n};\n\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/postcss-value-parser/lib/parse.js?");

/***/ }),

/***/ "./node_modules/postcss-value-parser/lib/stringify.js":
/*!************************************************************!*\
  !*** ./node_modules/postcss-value-parser/lib/stringify.js ***!
  \************************************************************/
/***/ ((module) => {

eval("function stringifyNode(node, custom) {\n  var type = node.type;\n  var value = node.value;\n  var buf;\n  var customResult;\n\n  if (custom && (customResult = custom(node)) !== undefined) {\n    return customResult;\n  } else if (type === \"word\" || type === \"space\") {\n    return value;\n  } else if (type === \"string\") {\n    buf = node.quote || \"\";\n    return buf + value + (node.unclosed ? \"\" : buf);\n  } else if (type === \"comment\") {\n    return \"/*\" + value + (node.unclosed ? \"\" : \"*/\");\n  } else if (type === \"div\") {\n    return (node.before || \"\") + value + (node.after || \"\");\n  } else if (Array.isArray(node.nodes)) {\n    buf = stringify(node.nodes, custom);\n    if (type !== \"function\") {\n      return buf;\n    }\n    return (\n      value +\n      \"(\" +\n      (node.before || \"\") +\n      buf +\n      (node.after || \"\") +\n      (node.unclosed ? \"\" : \")\")\n    );\n  }\n  return value;\n}\n\nfunction stringify(nodes, custom) {\n  var result, i;\n\n  if (Array.isArray(nodes)) {\n    result = \"\";\n    for (i = nodes.length - 1; ~i; i -= 1) {\n      result = stringifyNode(nodes[i], custom) + result;\n    }\n    return result;\n  }\n  return stringifyNode(nodes, custom);\n}\n\nmodule.exports = stringify;\n\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/postcss-value-parser/lib/stringify.js?");

/***/ }),

/***/ "./node_modules/postcss-value-parser/lib/unit.js":
/*!*******************************************************!*\
  !*** ./node_modules/postcss-value-parser/lib/unit.js ***!
  \*******************************************************/
/***/ ((module) => {

eval("var minus = \"-\".charCodeAt(0);\nvar plus = \"+\".charCodeAt(0);\nvar dot = \".\".charCodeAt(0);\nvar exp = \"e\".charCodeAt(0);\nvar EXP = \"E\".charCodeAt(0);\n\n// Check if three code points would start a number\n// https://www.w3.org/TR/css-syntax-3/#starts-with-a-number\nfunction likeNumber(value) {\n  var code = value.charCodeAt(0);\n  var nextCode;\n\n  if (code === plus || code === minus) {\n    nextCode = value.charCodeAt(1);\n\n    if (nextCode >= 48 && nextCode <= 57) {\n      return true;\n    }\n\n    var nextNextCode = value.charCodeAt(2);\n\n    if (nextCode === dot && nextNextCode >= 48 && nextNextCode <= 57) {\n      return true;\n    }\n\n    return false;\n  }\n\n  if (code === dot) {\n    nextCode = value.charCodeAt(1);\n\n    if (nextCode >= 48 && nextCode <= 57) {\n      return true;\n    }\n\n    return false;\n  }\n\n  if (code >= 48 && code <= 57) {\n    return true;\n  }\n\n  return false;\n}\n\n// Consume a number\n// https://www.w3.org/TR/css-syntax-3/#consume-number\nmodule.exports = function(value) {\n  var pos = 0;\n  var length = value.length;\n  var code;\n  var nextCode;\n  var nextNextCode;\n\n  if (length === 0 || !likeNumber(value)) {\n    return false;\n  }\n\n  code = value.charCodeAt(pos);\n\n  if (code === plus || code === minus) {\n    pos++;\n  }\n\n  while (pos < length) {\n    code = value.charCodeAt(pos);\n\n    if (code < 48 || code > 57) {\n      break;\n    }\n\n    pos += 1;\n  }\n\n  code = value.charCodeAt(pos);\n  nextCode = value.charCodeAt(pos + 1);\n\n  if (code === dot && nextCode >= 48 && nextCode <= 57) {\n    pos += 2;\n\n    while (pos < length) {\n      code = value.charCodeAt(pos);\n\n      if (code < 48 || code > 57) {\n        break;\n      }\n\n      pos += 1;\n    }\n  }\n\n  code = value.charCodeAt(pos);\n  nextCode = value.charCodeAt(pos + 1);\n  nextNextCode = value.charCodeAt(pos + 2);\n\n  if (\n    (code === exp || code === EXP) &&\n    ((nextCode >= 48 && nextCode <= 57) ||\n      ((nextCode === plus || nextCode === minus) &&\n        nextNextCode >= 48 &&\n        nextNextCode <= 57))\n  ) {\n    pos += nextCode === plus || nextCode === minus ? 3 : 2;\n\n    while (pos < length) {\n      code = value.charCodeAt(pos);\n\n      if (code < 48 || code > 57) {\n        break;\n      }\n\n      pos += 1;\n    }\n  }\n\n  return {\n    number: value.slice(0, pos),\n    unit: value.slice(pos)\n  };\n};\n\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/postcss-value-parser/lib/unit.js?");

/***/ }),

/***/ "./node_modules/postcss-value-parser/lib/walk.js":
/*!*******************************************************!*\
  !*** ./node_modules/postcss-value-parser/lib/walk.js ***!
  \*******************************************************/
/***/ ((module) => {

eval("module.exports = function walk(nodes, cb, bubble) {\n  var i, max, node, result;\n\n  for (i = 0, max = nodes.length; i < max; i += 1) {\n    node = nodes[i];\n    if (!bubble) {\n      result = cb(node, i, nodes);\n    }\n\n    if (\n      result !== false &&\n      node.type === \"function\" &&\n      Array.isArray(node.nodes)\n    ) {\n      walk(node.nodes, cb, bubble);\n    }\n\n    if (bubble) {\n      cb(node, i, nodes);\n    }\n  }\n};\n\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/postcss-value-parser/lib/walk.js?");

/***/ }),

/***/ "./node_modules/postcss/lib/at-rule.js":
/*!*********************************************!*\
  !*** ./node_modules/postcss/lib/at-rule.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nlet Container = __webpack_require__(/*! ./container */ \"./node_modules/postcss/lib/container.js\")\n\nclass AtRule extends Container {\n  constructor(defaults) {\n    super(defaults)\n    this.type = 'atrule'\n  }\n\n  append(...children) {\n    if (!this.proxyOf.nodes) this.nodes = []\n    return super.append(...children)\n  }\n\n  prepend(...children) {\n    if (!this.proxyOf.nodes) this.nodes = []\n    return super.prepend(...children)\n  }\n}\n\nmodule.exports = AtRule\nAtRule.default = AtRule\n\nContainer.registerAtRule(AtRule)\n\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/postcss/lib/at-rule.js?");

/***/ }),

/***/ "./node_modules/postcss/lib/comment.js":
/*!*********************************************!*\
  !*** ./node_modules/postcss/lib/comment.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nlet Node = __webpack_require__(/*! ./node */ \"./node_modules/postcss/lib/node.js\")\n\nclass Comment extends Node {\n  constructor(defaults) {\n    super(defaults)\n    this.type = 'comment'\n  }\n}\n\nmodule.exports = Comment\nComment.default = Comment\n\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/postcss/lib/comment.js?");

/***/ }),

/***/ "./node_modules/postcss/lib/container.js":
/*!***********************************************!*\
  !*** ./node_modules/postcss/lib/container.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nlet { isClean, my } = __webpack_require__(/*! ./symbols */ \"./node_modules/postcss/lib/symbols.js\")\nlet Declaration = __webpack_require__(/*! ./declaration */ \"./node_modules/postcss/lib/declaration.js\")\nlet Comment = __webpack_require__(/*! ./comment */ \"./node_modules/postcss/lib/comment.js\")\nlet Node = __webpack_require__(/*! ./node */ \"./node_modules/postcss/lib/node.js\")\n\nlet parse, Rule, AtRule, Root\n\nfunction cleanSource(nodes) {\n  return nodes.map(i => {\n    if (i.nodes) i.nodes = cleanSource(i.nodes)\n    delete i.source\n    return i\n  })\n}\n\nfunction markDirtyUp(node) {\n  node[isClean] = false\n  if (node.proxyOf.nodes) {\n    for (let i of node.proxyOf.nodes) {\n      markDirtyUp(i)\n    }\n  }\n}\n\nclass Container extends Node {\n  push(child) {\n    child.parent = this\n    this.proxyOf.nodes.push(child)\n    return this\n  }\n\n  each(callback) {\n    if (!this.proxyOf.nodes) return undefined\n    let iterator = this.getIterator()\n\n    let index, result\n    while (this.indexes[iterator] < this.proxyOf.nodes.length) {\n      index = this.indexes[iterator]\n      result = callback(this.proxyOf.nodes[index], index)\n      if (result === false) break\n\n      this.indexes[iterator] += 1\n    }\n\n    delete this.indexes[iterator]\n    return result\n  }\n\n  walk(callback) {\n    return this.each((child, i) => {\n      let result\n      try {\n        result = callback(child, i)\n      } catch (e) {\n        throw child.addToError(e)\n      }\n      if (result !== false && child.walk) {\n        result = child.walk(callback)\n      }\n\n      return result\n    })\n  }\n\n  walkDecls(prop, callback) {\n    if (!callback) {\n      callback = prop\n      return this.walk((child, i) => {\n        if (child.type === 'decl') {\n          return callback(child, i)\n        }\n      })\n    }\n    if (prop instanceof RegExp) {\n      return this.walk((child, i) => {\n        if (child.type === 'decl' && prop.test(child.prop)) {\n          return callback(child, i)\n        }\n      })\n    }\n    return this.walk((child, i) => {\n      if (child.type === 'decl' && child.prop === prop) {\n        return callback(child, i)\n      }\n    })\n  }\n\n  walkRules(selector, callback) {\n    if (!callback) {\n      callback = selector\n\n      return this.walk((child, i) => {\n        if (child.type === 'rule') {\n          return callback(child, i)\n        }\n      })\n    }\n    if (selector instanceof RegExp) {\n      return this.walk((child, i) => {\n        if (child.type === 'rule' && selector.test(child.selector)) {\n          return callback(child, i)\n        }\n      })\n    }\n    return this.walk((child, i) => {\n      if (child.type === 'rule' && child.selector === selector) {\n        return callback(child, i)\n      }\n    })\n  }\n\n  walkAtRules(name, callback) {\n    if (!callback) {\n      callback = name\n      return this.walk((child, i) => {\n        if (child.type === 'atrule') {\n          return callback(child, i)\n        }\n      })\n    }\n    if (name instanceof RegExp) {\n      return this.walk((child, i) => {\n        if (child.type === 'atrule' && name.test(child.name)) {\n          return callback(child, i)\n        }\n      })\n    }\n    return this.walk((child, i) => {\n      if (child.type === 'atrule' && child.name === name) {\n        return callback(child, i)\n      }\n    })\n  }\n\n  walkComments(callback) {\n    return this.walk((child, i) => {\n      if (child.type === 'comment') {\n        return callback(child, i)\n      }\n    })\n  }\n\n  append(...children) {\n    for (let child of children) {\n      let nodes = this.normalize(child, this.last)\n      for (let node of nodes) this.proxyOf.nodes.push(node)\n    }\n\n    this.markDirty()\n\n    return this\n  }\n\n  prepend(...children) {\n    children = children.reverse()\n    for (let child of children) {\n      let nodes = this.normalize(child, this.first, 'prepend').reverse()\n      for (let node of nodes) this.proxyOf.nodes.unshift(node)\n      for (let id in this.indexes) {\n        this.indexes[id] = this.indexes[id] + nodes.length\n      }\n    }\n\n    this.markDirty()\n\n    return this\n  }\n\n  cleanRaws(keepBetween) {\n    super.cleanRaws(keepBetween)\n    if (this.nodes) {\n      for (let node of this.nodes) node.cleanRaws(keepBetween)\n    }\n  }\n\n  insertBefore(exist, add) {\n    let existIndex = this.index(exist)\n    let type = exist === 0 ? 'prepend' : false\n    let nodes = this.normalize(add, this.proxyOf.nodes[existIndex], type).reverse()\n    existIndex = this.index(exist)\n    for (let node of nodes) this.proxyOf.nodes.splice(existIndex, 0, node)\n\n    let index\n    for (let id in this.indexes) {\n      index = this.indexes[id]\n      if (existIndex <= index) {\n        this.indexes[id] = index + nodes.length\n      }\n    }\n\n    this.markDirty()\n\n    return this\n  }\n\n  insertAfter(exist, add) {\n    let existIndex = this.index(exist)\n    let nodes = this.normalize(add, this.proxyOf.nodes[existIndex]).reverse()\n    existIndex = this.index(exist)\n    for (let node of nodes) this.proxyOf.nodes.splice(existIndex + 1, 0, node)\n\n    let index\n    for (let id in this.indexes) {\n      index = this.indexes[id]\n      if (existIndex < index) {\n        this.indexes[id] = index + nodes.length\n      }\n    }\n\n    this.markDirty()\n\n    return this\n  }\n\n  removeChild(child) {\n    child = this.index(child)\n    this.proxyOf.nodes[child].parent = undefined\n    this.proxyOf.nodes.splice(child, 1)\n\n    let index\n    for (let id in this.indexes) {\n      index = this.indexes[id]\n      if (index >= child) {\n        this.indexes[id] = index - 1\n      }\n    }\n\n    this.markDirty()\n\n    return this\n  }\n\n  removeAll() {\n    for (let node of this.proxyOf.nodes) node.parent = undefined\n    this.proxyOf.nodes = []\n\n    this.markDirty()\n\n    return this\n  }\n\n  replaceValues(pattern, opts, callback) {\n    if (!callback) {\n      callback = opts\n      opts = {}\n    }\n\n    this.walkDecls(decl => {\n      if (opts.props && !opts.props.includes(decl.prop)) return\n      if (opts.fast && !decl.value.includes(opts.fast)) return\n\n      decl.value = decl.value.replace(pattern, callback)\n    })\n\n    this.markDirty()\n\n    return this\n  }\n\n  every(condition) {\n    return this.nodes.every(condition)\n  }\n\n  some(condition) {\n    return this.nodes.some(condition)\n  }\n\n  index(child) {\n    if (typeof child === 'number') return child\n    if (child.proxyOf) child = child.proxyOf\n    return this.proxyOf.nodes.indexOf(child)\n  }\n\n  get first() {\n    if (!this.proxyOf.nodes) return undefined\n    return this.proxyOf.nodes[0]\n  }\n\n  get last() {\n    if (!this.proxyOf.nodes) return undefined\n    return this.proxyOf.nodes[this.proxyOf.nodes.length - 1]\n  }\n\n  normalize(nodes, sample) {\n    if (typeof nodes === 'string') {\n      nodes = cleanSource(parse(nodes).nodes)\n    } else if (Array.isArray(nodes)) {\n      nodes = nodes.slice(0)\n      for (let i of nodes) {\n        if (i.parent) i.parent.removeChild(i, 'ignore')\n      }\n    } else if (nodes.type === 'root' && this.type !== 'document') {\n      nodes = nodes.nodes.slice(0)\n      for (let i of nodes) {\n        if (i.parent) i.parent.removeChild(i, 'ignore')\n      }\n    } else if (nodes.type) {\n      nodes = [nodes]\n    } else if (nodes.prop) {\n      if (typeof nodes.value === 'undefined') {\n        throw new Error('Value field is missed in node creation')\n      } else if (typeof nodes.value !== 'string') {\n        nodes.value = String(nodes.value)\n      }\n      nodes = [new Declaration(nodes)]\n    } else if (nodes.selector) {\n      nodes = [new Rule(nodes)]\n    } else if (nodes.name) {\n      nodes = [new AtRule(nodes)]\n    } else if (nodes.text) {\n      nodes = [new Comment(nodes)]\n    } else {\n      throw new Error('Unknown node type in node creation')\n    }\n\n    let processed = nodes.map(i => {\n      /* c8 ignore next */\n      if (!i[my]) Container.rebuild(i)\n      i = i.proxyOf\n      if (i.parent) i.parent.removeChild(i)\n      if (i[isClean]) markDirtyUp(i)\n      if (typeof i.raws.before === 'undefined') {\n        if (sample && typeof sample.raws.before !== 'undefined') {\n          i.raws.before = sample.raws.before.replace(/\\S/g, '')\n        }\n      }\n      i.parent = this.proxyOf\n      return i\n    })\n\n    return processed\n  }\n\n  getProxyProcessor() {\n    return {\n      set(node, prop, value) {\n        if (node[prop] === value) return true\n        node[prop] = value\n        if (prop === 'name' || prop === 'params' || prop === 'selector') {\n          node.markDirty()\n        }\n        return true\n      },\n\n      get(node, prop) {\n        if (prop === 'proxyOf') {\n          return node\n        } else if (!node[prop]) {\n          return node[prop]\n        } else if (\n          prop === 'each' ||\n          (typeof prop === 'string' && prop.startsWith('walk'))\n        ) {\n          return (...args) => {\n            return node[prop](\n              ...args.map(i => {\n                if (typeof i === 'function') {\n                  return (child, index) => i(child.toProxy(), index)\n                } else {\n                  return i\n                }\n              })\n            )\n          }\n        } else if (prop === 'every' || prop === 'some') {\n          return cb => {\n            return node[prop]((child, ...other) =>\n              cb(child.toProxy(), ...other)\n            )\n          }\n        } else if (prop === 'root') {\n          return () => node.root().toProxy()\n        } else if (prop === 'nodes') {\n          return node.nodes.map(i => i.toProxy())\n        } else if (prop === 'first' || prop === 'last') {\n          return node[prop].toProxy()\n        } else {\n          return node[prop]\n        }\n      }\n    }\n  }\n\n  getIterator() {\n    if (!this.lastEach) this.lastEach = 0\n    if (!this.indexes) this.indexes = {}\n\n    this.lastEach += 1\n    let iterator = this.lastEach\n    this.indexes[iterator] = 0\n\n    return iterator\n  }\n}\n\nContainer.registerParse = dependant => {\n  parse = dependant\n}\n\nContainer.registerRule = dependant => {\n  Rule = dependant\n}\n\nContainer.registerAtRule = dependant => {\n  AtRule = dependant\n}\n\nContainer.registerRoot = dependant => {\n  Root = dependant\n}\n\nmodule.exports = Container\nContainer.default = Container\n\n/* c8 ignore start */\nContainer.rebuild = node => {\n  if (node.type === 'atrule') {\n    Object.setPrototypeOf(node, AtRule.prototype)\n  } else if (node.type === 'rule') {\n    Object.setPrototypeOf(node, Rule.prototype)\n  } else if (node.type === 'decl') {\n    Object.setPrototypeOf(node, Declaration.prototype)\n  } else if (node.type === 'comment') {\n    Object.setPrototypeOf(node, Comment.prototype)\n  } else if (node.type === 'root') {\n    Object.setPrototypeOf(node, Root.prototype)\n  }\n\n  node[my] = true\n\n  if (node.nodes) {\n    node.nodes.forEach(child => {\n      Container.rebuild(child)\n    })\n  }\n}\n/* c8 ignore stop */\n\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/postcss/lib/container.js?");

/***/ }),

/***/ "./node_modules/postcss/lib/css-syntax-error.js":
/*!******************************************************!*\
  !*** ./node_modules/postcss/lib/css-syntax-error.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nlet pico = __webpack_require__(/*! picocolors */ \"./node_modules/picocolors/picocolors.browser.js\")\n\nlet terminalHighlight = __webpack_require__(/*! ./terminal-highlight */ \"?5580\")\n\nclass CssSyntaxError extends Error {\n  constructor(message, line, column, source, file, plugin) {\n    super(message)\n    this.name = 'CssSyntaxError'\n    this.reason = message\n\n    if (file) {\n      this.file = file\n    }\n    if (source) {\n      this.source = source\n    }\n    if (plugin) {\n      this.plugin = plugin\n    }\n    if (typeof line !== 'undefined' && typeof column !== 'undefined') {\n      if (typeof line === 'number') {\n        this.line = line\n        this.column = column\n      } else {\n        this.line = line.line\n        this.column = line.column\n        this.endLine = column.line\n        this.endColumn = column.column\n      }\n    }\n\n    this.setMessage()\n\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, CssSyntaxError)\n    }\n  }\n\n  setMessage() {\n    this.message = this.plugin ? this.plugin + ': ' : ''\n    this.message += this.file ? this.file : '<css input>'\n    if (typeof this.line !== 'undefined') {\n      this.message += ':' + this.line + ':' + this.column\n    }\n    this.message += ': ' + this.reason\n  }\n\n  showSourceCode(color) {\n    if (!this.source) return ''\n\n    let css = this.source\n    if (color == null) color = pico.isColorSupported\n    if (terminalHighlight) {\n      if (color) css = terminalHighlight(css)\n    }\n\n    let lines = css.split(/\\r?\\n/)\n    let start = Math.max(this.line - 3, 0)\n    let end = Math.min(this.line + 2, lines.length)\n\n    let maxWidth = String(end).length\n\n    let mark, aside\n    if (color) {\n      let { bold, red, gray } = pico.createColors(true)\n      mark = text => bold(red(text))\n      aside = text => gray(text)\n    } else {\n      mark = aside = str => str\n    }\n\n    return lines\n      .slice(start, end)\n      .map((line, index) => {\n        let number = start + 1 + index\n        let gutter = ' ' + (' ' + number).slice(-maxWidth) + ' | '\n        if (number === this.line) {\n          let spacing =\n            aside(gutter.replace(/\\d/g, ' ')) +\n            line.slice(0, this.column - 1).replace(/[^\\t]/g, ' ')\n          return mark('>') + aside(gutter) + line + '\\n ' + spacing + mark('^')\n        }\n        return ' ' + aside(gutter) + line\n      })\n      .join('\\n')\n  }\n\n  toString() {\n    let code = this.showSourceCode()\n    if (code) {\n      code = '\\n\\n' + code + '\\n'\n    }\n    return this.name + ': ' + this.message + code\n  }\n}\n\nmodule.exports = CssSyntaxError\nCssSyntaxError.default = CssSyntaxError\n\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/postcss/lib/css-syntax-error.js?");

/***/ }),

/***/ "./node_modules/postcss/lib/declaration.js":
/*!*************************************************!*\
  !*** ./node_modules/postcss/lib/declaration.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nlet Node = __webpack_require__(/*! ./node */ \"./node_modules/postcss/lib/node.js\")\n\nclass Declaration extends Node {\n  constructor(defaults) {\n    if (\n      defaults &&\n      typeof defaults.value !== 'undefined' &&\n      typeof defaults.value !== 'string'\n    ) {\n      defaults = { ...defaults, value: String(defaults.value) }\n    }\n    super(defaults)\n    this.type = 'decl'\n  }\n\n  get variable() {\n    return this.prop.startsWith('--') || this.prop[0] === '$'\n  }\n}\n\nmodule.exports = Declaration\nDeclaration.default = Declaration\n\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/postcss/lib/declaration.js?");

/***/ }),

/***/ "./node_modules/postcss/lib/document.js":
/*!**********************************************!*\
  !*** ./node_modules/postcss/lib/document.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nlet Container = __webpack_require__(/*! ./container */ \"./node_modules/postcss/lib/container.js\")\n\nlet LazyResult, Processor\n\nclass Document extends Container {\n  constructor(defaults) {\n    // type needs to be passed to super, otherwise child roots won't be normalized correctly\n    super({ type: 'document', ...defaults })\n\n    if (!this.nodes) {\n      this.nodes = []\n    }\n  }\n\n  toResult(opts = {}) {\n    let lazy = new LazyResult(new Processor(), this, opts)\n\n    return lazy.stringify()\n  }\n}\n\nDocument.registerLazyResult = dependant => {\n  LazyResult = dependant\n}\n\nDocument.registerProcessor = dependant => {\n  Processor = dependant\n}\n\nmodule.exports = Document\nDocument.default = Document\n\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/postcss/lib/document.js?");

/***/ }),

/***/ "./node_modules/postcss/lib/fromJSON.js":
/*!**********************************************!*\
  !*** ./node_modules/postcss/lib/fromJSON.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nlet Declaration = __webpack_require__(/*! ./declaration */ \"./node_modules/postcss/lib/declaration.js\")\nlet PreviousMap = __webpack_require__(/*! ./previous-map */ \"./node_modules/postcss/lib/previous-map.js\")\nlet Comment = __webpack_require__(/*! ./comment */ \"./node_modules/postcss/lib/comment.js\")\nlet AtRule = __webpack_require__(/*! ./at-rule */ \"./node_modules/postcss/lib/at-rule.js\")\nlet Input = __webpack_require__(/*! ./input */ \"./node_modules/postcss/lib/input.js\")\nlet Root = __webpack_require__(/*! ./root */ \"./node_modules/postcss/lib/root.js\")\nlet Rule = __webpack_require__(/*! ./rule */ \"./node_modules/postcss/lib/rule.js\")\n\nfunction fromJSON(json, inputs) {\n  if (Array.isArray(json)) return json.map(n => fromJSON(n))\n\n  let { inputs: ownInputs, ...defaults } = json\n  if (ownInputs) {\n    inputs = []\n    for (let input of ownInputs) {\n      let inputHydrated = { ...input, __proto__: Input.prototype }\n      if (inputHydrated.map) {\n        inputHydrated.map = {\n          ...inputHydrated.map,\n          __proto__: PreviousMap.prototype\n        }\n      }\n      inputs.push(inputHydrated)\n    }\n  }\n  if (defaults.nodes) {\n    defaults.nodes = json.nodes.map(n => fromJSON(n, inputs))\n  }\n  if (defaults.source) {\n    let { inputId, ...source } = defaults.source\n    defaults.source = source\n    if (inputId != null) {\n      defaults.source.input = inputs[inputId]\n    }\n  }\n  if (defaults.type === 'root') {\n    return new Root(defaults)\n  } else if (defaults.type === 'decl') {\n    return new Declaration(defaults)\n  } else if (defaults.type === 'rule') {\n    return new Rule(defaults)\n  } else if (defaults.type === 'comment') {\n    return new Comment(defaults)\n  } else if (defaults.type === 'atrule') {\n    return new AtRule(defaults)\n  } else {\n    throw new Error('Unknown node type: ' + json.type)\n  }\n}\n\nmodule.exports = fromJSON\nfromJSON.default = fromJSON\n\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/postcss/lib/fromJSON.js?");

/***/ }),

/***/ "./node_modules/postcss/lib/input.js":
/*!*******************************************!*\
  !*** ./node_modules/postcss/lib/input.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nlet { SourceMapConsumer, SourceMapGenerator } = __webpack_require__(/*! source-map-js */ \"?b8cb\")\nlet { fileURLToPath, pathToFileURL } = __webpack_require__(/*! url */ \"?c717\")\nlet { resolve, isAbsolute } = __webpack_require__(/*! path */ \"?6197\")\nlet { nanoid } = __webpack_require__(/*! nanoid/non-secure */ \"./node_modules/nanoid/non-secure/index.cjs\")\n\nlet terminalHighlight = __webpack_require__(/*! ./terminal-highlight */ \"?5580\")\nlet CssSyntaxError = __webpack_require__(/*! ./css-syntax-error */ \"./node_modules/postcss/lib/css-syntax-error.js\")\nlet PreviousMap = __webpack_require__(/*! ./previous-map */ \"./node_modules/postcss/lib/previous-map.js\")\n\nlet fromOffsetCache = Symbol('fromOffsetCache')\n\nlet sourceMapAvailable = Boolean(SourceMapConsumer && SourceMapGenerator)\nlet pathAvailable = Boolean(resolve && isAbsolute)\n\nclass Input {\n  constructor(css, opts = {}) {\n    if (\n      css === null ||\n      typeof css === 'undefined' ||\n      (typeof css === 'object' && !css.toString)\n    ) {\n      throw new Error(`PostCSS received ${css} instead of CSS string`)\n    }\n\n    this.css = css.toString()\n\n    if (this.css[0] === '\\uFEFF' || this.css[0] === '\\uFFFE') {\n      this.hasBOM = true\n      this.css = this.css.slice(1)\n    } else {\n      this.hasBOM = false\n    }\n\n    if (opts.from) {\n      if (\n        !pathAvailable ||\n        /^\\w+:\\/\\//.test(opts.from) ||\n        isAbsolute(opts.from)\n      ) {\n        this.file = opts.from\n      } else {\n        this.file = resolve(opts.from)\n      }\n    }\n\n    if (pathAvailable && sourceMapAvailable) {\n      let map = new PreviousMap(this.css, opts)\n      if (map.text) {\n        this.map = map\n        let file = map.consumer().file\n        if (!this.file && file) this.file = this.mapResolve(file)\n      }\n    }\n\n    if (!this.file) {\n      this.id = '<input css ' + nanoid(6) + '>'\n    }\n    if (this.map) this.map.file = this.from\n  }\n\n  fromOffset(offset) {\n    let lastLine, lineToIndex\n    if (!this[fromOffsetCache]) {\n      let lines = this.css.split('\\n')\n      lineToIndex = new Array(lines.length)\n      let prevIndex = 0\n\n      for (let i = 0, l = lines.length; i < l; i++) {\n        lineToIndex[i] = prevIndex\n        prevIndex += lines[i].length + 1\n      }\n\n      this[fromOffsetCache] = lineToIndex\n    } else {\n      lineToIndex = this[fromOffsetCache]\n    }\n    lastLine = lineToIndex[lineToIndex.length - 1]\n\n    let min = 0\n    if (offset >= lastLine) {\n      min = lineToIndex.length - 1\n    } else {\n      let max = lineToIndex.length - 2\n      let mid\n      while (min < max) {\n        mid = min + ((max - min) >> 1)\n        if (offset < lineToIndex[mid]) {\n          max = mid - 1\n        } else if (offset >= lineToIndex[mid + 1]) {\n          min = mid + 1\n        } else {\n          min = mid\n          break\n        }\n      }\n    }\n    return {\n      line: min + 1,\n      col: offset - lineToIndex[min] + 1\n    }\n  }\n\n  error(message, line, column, opts = {}) {\n    let result, endLine, endColumn\n\n    if (line && typeof line === 'object') {\n      let start = line\n      let end = column\n      if (typeof line.offset === 'number') {\n        let pos = this.fromOffset(start.offset)\n        line = pos.line\n        column = pos.col\n      } else {\n        line = start.line\n        column = start.column\n      }\n      if (typeof end.offset === 'number') {\n        let pos = this.fromOffset(end.offset)\n        endLine = pos.line\n        endColumn = pos.col\n      } else {\n        endLine = end.line\n        endColumn = end.column\n      }\n    } else if (!column) {\n      let pos = this.fromOffset(line)\n      line = pos.line\n      column = pos.col\n    }\n\n    let origin = this.origin(line, column, endLine, endColumn)\n    if (origin) {\n      result = new CssSyntaxError(\n        message,\n        origin.endLine === undefined\n          ? origin.line\n          : { line: origin.line, column: origin.column },\n        origin.endLine === undefined\n          ? origin.column\n          : { line: origin.endLine, column: origin.endColumn },\n        origin.source,\n        origin.file,\n        opts.plugin\n      )\n    } else {\n      result = new CssSyntaxError(\n        message,\n        endLine === undefined ? line : { line, column },\n        endLine === undefined ? column : { line: endLine, column: endColumn },\n        this.css,\n        this.file,\n        opts.plugin\n      )\n    }\n\n    result.input = { line, column, endLine, endColumn, source: this.css }\n    if (this.file) {\n      if (pathToFileURL) {\n        result.input.url = pathToFileURL(this.file).toString()\n      }\n      result.input.file = this.file\n    }\n\n    return result\n  }\n\n  origin(line, column, endLine, endColumn) {\n    if (!this.map) return false\n    let consumer = this.map.consumer()\n\n    let from = consumer.originalPositionFor({ line, column })\n    if (!from.source) return false\n\n    let to\n    if (typeof endLine === 'number') {\n      to = consumer.originalPositionFor({ line: endLine, column: endColumn })\n    }\n\n    let fromUrl\n\n    if (isAbsolute(from.source)) {\n      fromUrl = pathToFileURL(from.source)\n    } else {\n      fromUrl = new URL(\n        from.source,\n        this.map.consumer().sourceRoot || pathToFileURL(this.map.mapFile)\n      )\n    }\n\n    let result = {\n      url: fromUrl.toString(),\n      line: from.line,\n      column: from.column,\n      endLine: to && to.line,\n      endColumn: to && to.column\n    }\n\n    if (fromUrl.protocol === 'file:') {\n      if (fileURLToPath) {\n        result.file = fileURLToPath(fromUrl)\n      } else {\n        /* c8 ignore next 2 */\n        throw new Error(`file: protocol is not available in this PostCSS build`)\n      }\n    }\n\n    let source = consumer.sourceContentFor(from.source)\n    if (source) result.source = source\n\n    return result\n  }\n\n  mapResolve(file) {\n    if (/^\\w+:\\/\\//.test(file)) {\n      return file\n    }\n    return resolve(this.map.consumer().sourceRoot || this.map.root || '.', file)\n  }\n\n  get from() {\n    return this.file || this.id\n  }\n\n  toJSON() {\n    let json = {}\n    for (let name of ['hasBOM', 'css', 'file', 'id']) {\n      if (this[name] != null) {\n        json[name] = this[name]\n      }\n    }\n    if (this.map) {\n      json.map = { ...this.map }\n      if (json.map.consumerCache) {\n        json.map.consumerCache = undefined\n      }\n    }\n    return json\n  }\n}\n\nmodule.exports = Input\nInput.default = Input\n\nif (terminalHighlight && terminalHighlight.registerInput) {\n  terminalHighlight.registerInput(Input)\n}\n\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/postcss/lib/input.js?");

/***/ }),

/***/ "./node_modules/postcss/lib/lazy-result.js":
/*!*************************************************!*\
  !*** ./node_modules/postcss/lib/lazy-result.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nlet { isClean, my } = __webpack_require__(/*! ./symbols */ \"./node_modules/postcss/lib/symbols.js\")\nlet MapGenerator = __webpack_require__(/*! ./map-generator */ \"./node_modules/postcss/lib/map-generator.js\")\nlet stringify = __webpack_require__(/*! ./stringify */ \"./node_modules/postcss/lib/stringify.js\")\nlet Container = __webpack_require__(/*! ./container */ \"./node_modules/postcss/lib/container.js\")\nlet Document = __webpack_require__(/*! ./document */ \"./node_modules/postcss/lib/document.js\")\nlet warnOnce = __webpack_require__(/*! ./warn-once */ \"./node_modules/postcss/lib/warn-once.js\")\nlet Result = __webpack_require__(/*! ./result */ \"./node_modules/postcss/lib/result.js\")\nlet parse = __webpack_require__(/*! ./parse */ \"./node_modules/postcss/lib/parse.js\")\nlet Root = __webpack_require__(/*! ./root */ \"./node_modules/postcss/lib/root.js\")\n\nconst TYPE_TO_CLASS_NAME = {\n  document: 'Document',\n  root: 'Root',\n  atrule: 'AtRule',\n  rule: 'Rule',\n  decl: 'Declaration',\n  comment: 'Comment'\n}\n\nconst PLUGIN_PROPS = {\n  postcssPlugin: true,\n  prepare: true,\n  Once: true,\n  Document: true,\n  Root: true,\n  Declaration: true,\n  Rule: true,\n  AtRule: true,\n  Comment: true,\n  DeclarationExit: true,\n  RuleExit: true,\n  AtRuleExit: true,\n  CommentExit: true,\n  RootExit: true,\n  DocumentExit: true,\n  OnceExit: true\n}\n\nconst NOT_VISITORS = {\n  postcssPlugin: true,\n  prepare: true,\n  Once: true\n}\n\nconst CHILDREN = 0\n\nfunction isPromise(obj) {\n  return typeof obj === 'object' && typeof obj.then === 'function'\n}\n\nfunction getEvents(node) {\n  let key = false\n  let type = TYPE_TO_CLASS_NAME[node.type]\n  if (node.type === 'decl') {\n    key = node.prop.toLowerCase()\n  } else if (node.type === 'atrule') {\n    key = node.name.toLowerCase()\n  }\n\n  if (key && node.append) {\n    return [\n      type,\n      type + '-' + key,\n      CHILDREN,\n      type + 'Exit',\n      type + 'Exit-' + key\n    ]\n  } else if (key) {\n    return [type, type + '-' + key, type + 'Exit', type + 'Exit-' + key]\n  } else if (node.append) {\n    return [type, CHILDREN, type + 'Exit']\n  } else {\n    return [type, type + 'Exit']\n  }\n}\n\nfunction toStack(node) {\n  let events\n  if (node.type === 'document') {\n    events = ['Document', CHILDREN, 'DocumentExit']\n  } else if (node.type === 'root') {\n    events = ['Root', CHILDREN, 'RootExit']\n  } else {\n    events = getEvents(node)\n  }\n\n  return {\n    node,\n    events,\n    eventIndex: 0,\n    visitors: [],\n    visitorIndex: 0,\n    iterator: 0\n  }\n}\n\nfunction cleanMarks(node) {\n  node[isClean] = false\n  if (node.nodes) node.nodes.forEach(i => cleanMarks(i))\n  return node\n}\n\nlet postcss = {}\n\nclass LazyResult {\n  constructor(processor, css, opts) {\n    this.stringified = false\n    this.processed = false\n\n    let root\n    if (\n      typeof css === 'object' &&\n      css !== null &&\n      (css.type === 'root' || css.type === 'document')\n    ) {\n      root = cleanMarks(css)\n    } else if (css instanceof LazyResult || css instanceof Result) {\n      root = cleanMarks(css.root)\n      if (css.map) {\n        if (typeof opts.map === 'undefined') opts.map = {}\n        if (!opts.map.inline) opts.map.inline = false\n        opts.map.prev = css.map\n      }\n    } else {\n      let parser = parse\n      if (opts.syntax) parser = opts.syntax.parse\n      if (opts.parser) parser = opts.parser\n      if (parser.parse) parser = parser.parse\n\n      try {\n        root = parser(css, opts)\n      } catch (error) {\n        this.processed = true\n        this.error = error\n      }\n\n      if (root && !root[my]) {\n        /* c8 ignore next 2 */\n        Container.rebuild(root)\n      }\n    }\n\n    this.result = new Result(processor, root, opts)\n    this.helpers = { ...postcss, result: this.result, postcss }\n    this.plugins = this.processor.plugins.map(plugin => {\n      if (typeof plugin === 'object' && plugin.prepare) {\n        return { ...plugin, ...plugin.prepare(this.result) }\n      } else {\n        return plugin\n      }\n    })\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'LazyResult'\n  }\n\n  get processor() {\n    return this.result.processor\n  }\n\n  get opts() {\n    return this.result.opts\n  }\n\n  get css() {\n    return this.stringify().css\n  }\n\n  get content() {\n    return this.stringify().content\n  }\n\n  get map() {\n    return this.stringify().map\n  }\n\n  get root() {\n    return this.sync().root\n  }\n\n  get messages() {\n    return this.sync().messages\n  }\n\n  warnings() {\n    return this.sync().warnings()\n  }\n\n  toString() {\n    return this.css\n  }\n\n  then(onFulfilled, onRejected) {\n    if (true) {\n      if (!('from' in this.opts)) {\n        warnOnce(\n          'Without `from` option PostCSS could generate wrong source map ' +\n            'and will not find Browserslist config. Set it to CSS file path ' +\n            'or to `undefined` to prevent this warning.'\n        )\n      }\n    }\n    return this.async().then(onFulfilled, onRejected)\n  }\n\n  catch(onRejected) {\n    return this.async().catch(onRejected)\n  }\n\n  finally(onFinally) {\n    return this.async().then(onFinally, onFinally)\n  }\n\n  async() {\n    if (this.error) return Promise.reject(this.error)\n    if (this.processed) return Promise.resolve(this.result)\n    if (!this.processing) {\n      this.processing = this.runAsync()\n    }\n    return this.processing\n  }\n\n  sync() {\n    if (this.error) throw this.error\n    if (this.processed) return this.result\n    this.processed = true\n\n    if (this.processing) {\n      throw this.getAsyncError()\n    }\n\n    for (let plugin of this.plugins) {\n      let promise = this.runOnRoot(plugin)\n      if (isPromise(promise)) {\n        throw this.getAsyncError()\n      }\n    }\n\n    this.prepareVisitors()\n    if (this.hasListener) {\n      let root = this.result.root\n      while (!root[isClean]) {\n        root[isClean] = true\n        this.walkSync(root)\n      }\n      if (this.listeners.OnceExit) {\n        if (root.type === 'document') {\n          for (let subRoot of root.nodes) {\n            this.visitSync(this.listeners.OnceExit, subRoot)\n          }\n        } else {\n          this.visitSync(this.listeners.OnceExit, root)\n        }\n      }\n    }\n\n    return this.result\n  }\n\n  stringify() {\n    if (this.error) throw this.error\n    if (this.stringified) return this.result\n    this.stringified = true\n\n    this.sync()\n\n    let opts = this.result.opts\n    let str = stringify\n    if (opts.syntax) str = opts.syntax.stringify\n    if (opts.stringifier) str = opts.stringifier\n    if (str.stringify) str = str.stringify\n\n    let map = new MapGenerator(str, this.result.root, this.result.opts)\n    let data = map.generate()\n    this.result.css = data[0]\n    this.result.map = data[1]\n\n    return this.result\n  }\n\n  walkSync(node) {\n    node[isClean] = true\n    let events = getEvents(node)\n    for (let event of events) {\n      if (event === CHILDREN) {\n        if (node.nodes) {\n          node.each(child => {\n            if (!child[isClean]) this.walkSync(child)\n          })\n        }\n      } else {\n        let visitors = this.listeners[event]\n        if (visitors) {\n          if (this.visitSync(visitors, node.toProxy())) return\n        }\n      }\n    }\n  }\n\n  visitSync(visitors, node) {\n    for (let [plugin, visitor] of visitors) {\n      this.result.lastPlugin = plugin\n      let promise\n      try {\n        promise = visitor(node, this.helpers)\n      } catch (e) {\n        throw this.handleError(e, node.proxyOf)\n      }\n      if (node.type !== 'root' && node.type !== 'document' && !node.parent) {\n        return true\n      }\n      if (isPromise(promise)) {\n        throw this.getAsyncError()\n      }\n    }\n  }\n\n  runOnRoot(plugin) {\n    this.result.lastPlugin = plugin\n    try {\n      if (typeof plugin === 'object' && plugin.Once) {\n        if (this.result.root.type === 'document') {\n          let roots = this.result.root.nodes.map(root =>\n            plugin.Once(root, this.helpers)\n          )\n\n          if (isPromise(roots[0])) {\n            return Promise.all(roots)\n          }\n\n          return roots\n        }\n\n        return plugin.Once(this.result.root, this.helpers)\n      } else if (typeof plugin === 'function') {\n        return plugin(this.result.root, this.result)\n      }\n    } catch (error) {\n      throw this.handleError(error)\n    }\n  }\n\n  getAsyncError() {\n    throw new Error('Use process(css).then(cb) to work with async plugins')\n  }\n\n  handleError(error, node) {\n    let plugin = this.result.lastPlugin\n    try {\n      if (node) node.addToError(error)\n      this.error = error\n      if (error.name === 'CssSyntaxError' && !error.plugin) {\n        error.plugin = plugin.postcssPlugin\n        error.setMessage()\n      } else if (plugin.postcssVersion) {\n        if (true) {\n          let pluginName = plugin.postcssPlugin\n          let pluginVer = plugin.postcssVersion\n          let runtimeVer = this.result.processor.version\n          let a = pluginVer.split('.')\n          let b = runtimeVer.split('.')\n\n          if (a[0] !== b[0] || parseInt(a[1]) > parseInt(b[1])) {\n            // eslint-disable-next-line no-console\n            console.error(\n              'Unknown error from PostCSS plugin. Your current PostCSS ' +\n                'version is ' +\n                runtimeVer +\n                ', but ' +\n                pluginName +\n                ' uses ' +\n                pluginVer +\n                '. Perhaps this is the source of the error below.'\n            )\n          }\n        }\n      }\n    } catch (err) {\n      /* c8 ignore next 3 */\n      // eslint-disable-next-line no-console\n      if (console && console.error) console.error(err)\n    }\n    return error\n  }\n\n  async runAsync() {\n    this.plugin = 0\n    for (let i = 0; i < this.plugins.length; i++) {\n      let plugin = this.plugins[i]\n      let promise = this.runOnRoot(plugin)\n      if (isPromise(promise)) {\n        try {\n          await promise\n        } catch (error) {\n          throw this.handleError(error)\n        }\n      }\n    }\n\n    this.prepareVisitors()\n    if (this.hasListener) {\n      let root = this.result.root\n      while (!root[isClean]) {\n        root[isClean] = true\n        let stack = [toStack(root)]\n        while (stack.length > 0) {\n          let promise = this.visitTick(stack)\n          if (isPromise(promise)) {\n            try {\n              await promise\n            } catch (e) {\n              let node = stack[stack.length - 1].node\n              throw this.handleError(e, node)\n            }\n          }\n        }\n      }\n\n      if (this.listeners.OnceExit) {\n        for (let [plugin, visitor] of this.listeners.OnceExit) {\n          this.result.lastPlugin = plugin\n          try {\n            if (root.type === 'document') {\n              let roots = root.nodes.map(subRoot =>\n                visitor(subRoot, this.helpers)\n              )\n\n              await Promise.all(roots)\n            } else {\n              await visitor(root, this.helpers)\n            }\n          } catch (e) {\n            throw this.handleError(e)\n          }\n        }\n      }\n    }\n\n    this.processed = true\n    return this.stringify()\n  }\n\n  prepareVisitors() {\n    this.listeners = {}\n    let add = (plugin, type, cb) => {\n      if (!this.listeners[type]) this.listeners[type] = []\n      this.listeners[type].push([plugin, cb])\n    }\n    for (let plugin of this.plugins) {\n      if (typeof plugin === 'object') {\n        for (let event in plugin) {\n          if (!PLUGIN_PROPS[event] && /^[A-Z]/.test(event)) {\n            throw new Error(\n              `Unknown event ${event} in ${plugin.postcssPlugin}. ` +\n                `Try to update PostCSS (${this.processor.version} now).`\n            )\n          }\n          if (!NOT_VISITORS[event]) {\n            if (typeof plugin[event] === 'object') {\n              for (let filter in plugin[event]) {\n                if (filter === '*') {\n                  add(plugin, event, plugin[event][filter])\n                } else {\n                  add(\n                    plugin,\n                    event + '-' + filter.toLowerCase(),\n                    plugin[event][filter]\n                  )\n                }\n              }\n            } else if (typeof plugin[event] === 'function') {\n              add(plugin, event, plugin[event])\n            }\n          }\n        }\n      }\n    }\n    this.hasListener = Object.keys(this.listeners).length > 0\n  }\n\n  visitTick(stack) {\n    let visit = stack[stack.length - 1]\n    let { node, visitors } = visit\n\n    if (node.type !== 'root' && node.type !== 'document' && !node.parent) {\n      stack.pop()\n      return\n    }\n\n    if (visitors.length > 0 && visit.visitorIndex < visitors.length) {\n      let [plugin, visitor] = visitors[visit.visitorIndex]\n      visit.visitorIndex += 1\n      if (visit.visitorIndex === visitors.length) {\n        visit.visitors = []\n        visit.visitorIndex = 0\n      }\n      this.result.lastPlugin = plugin\n      try {\n        return visitor(node.toProxy(), this.helpers)\n      } catch (e) {\n        throw this.handleError(e, node)\n      }\n    }\n\n    if (visit.iterator !== 0) {\n      let iterator = visit.iterator\n      let child\n      while ((child = node.nodes[node.indexes[iterator]])) {\n        node.indexes[iterator] += 1\n        if (!child[isClean]) {\n          child[isClean] = true\n          stack.push(toStack(child))\n          return\n        }\n      }\n      visit.iterator = 0\n      delete node.indexes[iterator]\n    }\n\n    let events = visit.events\n    while (visit.eventIndex < events.length) {\n      let event = events[visit.eventIndex]\n      visit.eventIndex += 1\n      if (event === CHILDREN) {\n        if (node.nodes && node.nodes.length) {\n          node[isClean] = true\n          visit.iterator = node.getIterator()\n        }\n        return\n      } else if (this.listeners[event]) {\n        visit.visitors = this.listeners[event]\n        return\n      }\n    }\n    stack.pop()\n  }\n}\n\nLazyResult.registerPostcss = dependant => {\n  postcss = dependant\n}\n\nmodule.exports = LazyResult\nLazyResult.default = LazyResult\n\nRoot.registerLazyResult(LazyResult)\nDocument.registerLazyResult(LazyResult)\n\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/postcss/lib/lazy-result.js?");

/***/ }),

/***/ "./node_modules/postcss/lib/list.js":
/*!******************************************!*\
  !*** ./node_modules/postcss/lib/list.js ***!
  \******************************************/
/***/ ((module) => {

"use strict";
eval("\n\nlet list = {\n  split(string, separators, last) {\n    let array = []\n    let current = ''\n    let split = false\n\n    let func = 0\n    let inQuote = false\n    let prevQuote = ''\n    let escape = false\n\n    for (let letter of string) {\n      if (escape) {\n        escape = false\n      } else if (letter === '\\\\') {\n        escape = true\n      } else if (inQuote) {\n        if (letter === prevQuote) {\n          inQuote = false\n        }\n      } else if (letter === '\"' || letter === \"'\") {\n        inQuote = true\n        prevQuote = letter\n      } else if (letter === '(') {\n        func += 1\n      } else if (letter === ')') {\n        if (func > 0) func -= 1\n      } else if (func === 0) {\n        if (separators.includes(letter)) split = true\n      }\n\n      if (split) {\n        if (current !== '') array.push(current.trim())\n        current = ''\n        split = false\n      } else {\n        current += letter\n      }\n    }\n\n    if (last || current !== '') array.push(current.trim())\n    return array\n  },\n\n  space(string) {\n    let spaces = [' ', '\\n', '\\t']\n    return list.split(string, spaces)\n  },\n\n  comma(string) {\n    return list.split(string, [','], true)\n  }\n}\n\nmodule.exports = list\nlist.default = list\n\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/postcss/lib/list.js?");

/***/ }),

/***/ "./node_modules/postcss/lib/map-generator.js":
/*!***************************************************!*\
  !*** ./node_modules/postcss/lib/map-generator.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nlet { SourceMapConsumer, SourceMapGenerator } = __webpack_require__(/*! source-map-js */ \"?b8cb\")\nlet { dirname, resolve, relative, sep } = __webpack_require__(/*! path */ \"?6197\")\nlet { pathToFileURL } = __webpack_require__(/*! url */ \"?c717\")\n\nlet Input = __webpack_require__(/*! ./input */ \"./node_modules/postcss/lib/input.js\")\n\nlet sourceMapAvailable = Boolean(SourceMapConsumer && SourceMapGenerator)\nlet pathAvailable = Boolean(dirname && resolve && relative && sep)\n\nclass MapGenerator {\n  constructor(stringify, root, opts, cssString) {\n    this.stringify = stringify\n    this.mapOpts = opts.map || {}\n    this.root = root\n    this.opts = opts\n    this.css = cssString\n    this.usesFileUrls = !this.mapOpts.from && this.mapOpts.absolute\n  }\n\n  isMap() {\n    if (typeof this.opts.map !== 'undefined') {\n      return !!this.opts.map\n    }\n    return this.previous().length > 0\n  }\n\n  previous() {\n    if (!this.previousMaps) {\n      this.previousMaps = []\n      if (this.root) {\n        this.root.walk(node => {\n          if (node.source && node.source.input.map) {\n            let map = node.source.input.map\n            if (!this.previousMaps.includes(map)) {\n              this.previousMaps.push(map)\n            }\n          }\n        })\n      } else {\n        let input = new Input(this.css, this.opts)\n        if (input.map) this.previousMaps.push(input.map)\n      }\n    }\n\n    return this.previousMaps\n  }\n\n  isInline() {\n    if (typeof this.mapOpts.inline !== 'undefined') {\n      return this.mapOpts.inline\n    }\n\n    let annotation = this.mapOpts.annotation\n    if (typeof annotation !== 'undefined' && annotation !== true) {\n      return false\n    }\n\n    if (this.previous().length) {\n      return this.previous().some(i => i.inline)\n    }\n    return true\n  }\n\n  isSourcesContent() {\n    if (typeof this.mapOpts.sourcesContent !== 'undefined') {\n      return this.mapOpts.sourcesContent\n    }\n    if (this.previous().length) {\n      return this.previous().some(i => i.withContent())\n    }\n    return true\n  }\n\n  clearAnnotation() {\n    if (this.mapOpts.annotation === false) return\n\n    if (this.root) {\n      let node\n      for (let i = this.root.nodes.length - 1; i >= 0; i--) {\n        node = this.root.nodes[i]\n        if (node.type !== 'comment') continue\n        if (node.text.indexOf('# sourceMappingURL=') === 0) {\n          this.root.removeChild(i)\n        }\n      }\n    } else if (this.css) {\n      this.css = this.css.replace(/(\\n)?\\/\\*#[\\S\\s]*?\\*\\/$/gm, '')\n    }\n  }\n\n  setSourcesContent() {\n    let already = {}\n    if (this.root) {\n      this.root.walk(node => {\n        if (node.source) {\n          let from = node.source.input.from\n          if (from && !already[from]) {\n            already[from] = true\n            let fromUrl = this.usesFileUrls\n              ? this.toFileUrl(from)\n              : this.toUrl(this.path(from))\n            this.map.setSourceContent(fromUrl, node.source.input.css)\n          }\n        }\n      })\n    } else if (this.css) {\n      let from = this.opts.from\n        ? this.toUrl(this.path(this.opts.from))\n        : '<no source>'\n      this.map.setSourceContent(from, this.css)\n    }\n  }\n\n  applyPrevMaps() {\n    for (let prev of this.previous()) {\n      let from = this.toUrl(this.path(prev.file))\n      let root = prev.root || dirname(prev.file)\n      let map\n\n      if (this.mapOpts.sourcesContent === false) {\n        map = new SourceMapConsumer(prev.text)\n        if (map.sourcesContent) {\n          map.sourcesContent = map.sourcesContent.map(() => null)\n        }\n      } else {\n        map = prev.consumer()\n      }\n\n      this.map.applySourceMap(map, from, this.toUrl(this.path(root)))\n    }\n  }\n\n  isAnnotation() {\n    if (this.isInline()) {\n      return true\n    }\n    if (typeof this.mapOpts.annotation !== 'undefined') {\n      return this.mapOpts.annotation\n    }\n    if (this.previous().length) {\n      return this.previous().some(i => i.annotation)\n    }\n    return true\n  }\n\n  toBase64(str) {\n    if (Buffer) {\n      return Buffer.from(str).toString('base64')\n    } else {\n      return window.btoa(unescape(encodeURIComponent(str)))\n    }\n  }\n\n  addAnnotation() {\n    let content\n\n    if (this.isInline()) {\n      content =\n        'data:application/json;base64,' + this.toBase64(this.map.toString())\n    } else if (typeof this.mapOpts.annotation === 'string') {\n      content = this.mapOpts.annotation\n    } else if (typeof this.mapOpts.annotation === 'function') {\n      content = this.mapOpts.annotation(this.opts.to, this.root)\n    } else {\n      content = this.outputFile() + '.map'\n    }\n    let eol = '\\n'\n    if (this.css.includes('\\r\\n')) eol = '\\r\\n'\n\n    this.css += eol + '/*# sourceMappingURL=' + content + ' */'\n  }\n\n  outputFile() {\n    if (this.opts.to) {\n      return this.path(this.opts.to)\n    } else if (this.opts.from) {\n      return this.path(this.opts.from)\n    } else {\n      return 'to.css'\n    }\n  }\n\n  generateMap() {\n    if (this.root) {\n      this.generateString()\n    } else if (this.previous().length === 1) {\n      let prev = this.previous()[0].consumer()\n      prev.file = this.outputFile()\n      this.map = SourceMapGenerator.fromSourceMap(prev)\n    } else {\n      this.map = new SourceMapGenerator({ file: this.outputFile() })\n      this.map.addMapping({\n        source: this.opts.from\n          ? this.toUrl(this.path(this.opts.from))\n          : '<no source>',\n        generated: { line: 1, column: 0 },\n        original: { line: 1, column: 0 }\n      })\n    }\n\n    if (this.isSourcesContent()) this.setSourcesContent()\n    if (this.root && this.previous().length > 0) this.applyPrevMaps()\n    if (this.isAnnotation()) this.addAnnotation()\n\n    if (this.isInline()) {\n      return [this.css]\n    } else {\n      return [this.css, this.map]\n    }\n  }\n\n  path(file) {\n    if (file.indexOf('<') === 0) return file\n    if (/^\\w+:\\/\\//.test(file)) return file\n    if (this.mapOpts.absolute) return file\n\n    let from = this.opts.to ? dirname(this.opts.to) : '.'\n\n    if (typeof this.mapOpts.annotation === 'string') {\n      from = dirname(resolve(from, this.mapOpts.annotation))\n    }\n\n    file = relative(from, file)\n    return file\n  }\n\n  toUrl(path) {\n    if (sep === '\\\\') {\n      path = path.replace(/\\\\/g, '/')\n    }\n    return encodeURI(path).replace(/[#?]/g, encodeURIComponent)\n  }\n\n  toFileUrl(path) {\n    if (pathToFileURL) {\n      return pathToFileURL(path).toString()\n    } else {\n      throw new Error(\n        '`map.absolute` option is not available in this PostCSS build'\n      )\n    }\n  }\n\n  sourcePath(node) {\n    if (this.mapOpts.from) {\n      return this.toUrl(this.mapOpts.from)\n    } else if (this.usesFileUrls) {\n      return this.toFileUrl(node.source.input.from)\n    } else {\n      return this.toUrl(this.path(node.source.input.from))\n    }\n  }\n\n  generateString() {\n    this.css = ''\n    this.map = new SourceMapGenerator({ file: this.outputFile() })\n\n    let line = 1\n    let column = 1\n\n    let noSource = '<no source>'\n    let mapping = {\n      source: '',\n      generated: { line: 0, column: 0 },\n      original: { line: 0, column: 0 }\n    }\n\n    let lines, last\n    this.stringify(this.root, (str, node, type) => {\n      this.css += str\n\n      if (node && type !== 'end') {\n        mapping.generated.line = line\n        mapping.generated.column = column - 1\n        if (node.source && node.source.start) {\n          mapping.source = this.sourcePath(node)\n          mapping.original.line = node.source.start.line\n          mapping.original.column = node.source.start.column - 1\n          this.map.addMapping(mapping)\n        } else {\n          mapping.source = noSource\n          mapping.original.line = 1\n          mapping.original.column = 0\n          this.map.addMapping(mapping)\n        }\n      }\n\n      lines = str.match(/\\n/g)\n      if (lines) {\n        line += lines.length\n        last = str.lastIndexOf('\\n')\n        column = str.length - last\n      } else {\n        column += str.length\n      }\n\n      if (node && type !== 'start') {\n        let p = node.parent || { raws: {} }\n        if (node.type !== 'decl' || node !== p.last || p.raws.semicolon) {\n          if (node.source && node.source.end) {\n            mapping.source = this.sourcePath(node)\n            mapping.original.line = node.source.end.line\n            mapping.original.column = node.source.end.column - 1\n            mapping.generated.line = line\n            mapping.generated.column = column - 2\n            this.map.addMapping(mapping)\n          } else {\n            mapping.source = noSource\n            mapping.original.line = 1\n            mapping.original.column = 0\n            mapping.generated.line = line\n            mapping.generated.column = column - 1\n            this.map.addMapping(mapping)\n          }\n        }\n      }\n    })\n  }\n\n  generate() {\n    this.clearAnnotation()\n    if (pathAvailable && sourceMapAvailable && this.isMap()) {\n      return this.generateMap()\n    } else {\n      let result = ''\n      this.stringify(this.root, i => {\n        result += i\n      })\n      return [result]\n    }\n  }\n}\n\nmodule.exports = MapGenerator\n\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/postcss/lib/map-generator.js?");

/***/ }),

/***/ "./node_modules/postcss/lib/no-work-result.js":
/*!****************************************************!*\
  !*** ./node_modules/postcss/lib/no-work-result.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nlet MapGenerator = __webpack_require__(/*! ./map-generator */ \"./node_modules/postcss/lib/map-generator.js\")\nlet stringify = __webpack_require__(/*! ./stringify */ \"./node_modules/postcss/lib/stringify.js\")\nlet warnOnce = __webpack_require__(/*! ./warn-once */ \"./node_modules/postcss/lib/warn-once.js\")\nlet parse = __webpack_require__(/*! ./parse */ \"./node_modules/postcss/lib/parse.js\")\nconst Result = __webpack_require__(/*! ./result */ \"./node_modules/postcss/lib/result.js\")\n\nclass NoWorkResult {\n  constructor(processor, css, opts) {\n    css = css.toString()\n    this.stringified = false\n\n    this._processor = processor\n    this._css = css\n    this._opts = opts\n    this._map = undefined\n    let root\n\n    let str = stringify\n    this.result = new Result(this._processor, root, this._opts)\n    this.result.css = css\n\n    let self = this\n    Object.defineProperty(this.result, 'root', {\n      get() {\n        return self.root\n      }\n    })\n\n    let map = new MapGenerator(str, root, this._opts, css)\n    if (map.isMap()) {\n      let [generatedCSS, generatedMap] = map.generate()\n      if (generatedCSS) {\n        this.result.css = generatedCSS\n      }\n      if (generatedMap) {\n        this.result.map = generatedMap\n      }\n    }\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'NoWorkResult'\n  }\n\n  get processor() {\n    return this.result.processor\n  }\n\n  get opts() {\n    return this.result.opts\n  }\n\n  get css() {\n    return this.result.css\n  }\n\n  get content() {\n    return this.result.css\n  }\n\n  get map() {\n    return this.result.map\n  }\n\n  get root() {\n    if (this._root) {\n      return this._root\n    }\n\n    let root\n    let parser = parse\n\n    try {\n      root = parser(this._css, this._opts)\n    } catch (error) {\n      this.error = error\n    }\n\n    if (this.error) {\n      throw this.error\n    } else {\n      this._root = root\n      return root\n    }\n  }\n\n  get messages() {\n    return []\n  }\n\n  warnings() {\n    return []\n  }\n\n  toString() {\n    return this._css\n  }\n\n  then(onFulfilled, onRejected) {\n    if (true) {\n      if (!('from' in this._opts)) {\n        warnOnce(\n          'Without `from` option PostCSS could generate wrong source map ' +\n            'and will not find Browserslist config. Set it to CSS file path ' +\n            'or to `undefined` to prevent this warning.'\n        )\n      }\n    }\n\n    return this.async().then(onFulfilled, onRejected)\n  }\n\n  catch(onRejected) {\n    return this.async().catch(onRejected)\n  }\n\n  finally(onFinally) {\n    return this.async().then(onFinally, onFinally)\n  }\n\n  async() {\n    if (this.error) return Promise.reject(this.error)\n    return Promise.resolve(this.result)\n  }\n\n  sync() {\n    if (this.error) throw this.error\n    return this.result\n  }\n}\n\nmodule.exports = NoWorkResult\nNoWorkResult.default = NoWorkResult\n\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/postcss/lib/no-work-result.js?");

/***/ }),

/***/ "./node_modules/postcss/lib/node.js":
/*!******************************************!*\
  !*** ./node_modules/postcss/lib/node.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nlet { isClean, my } = __webpack_require__(/*! ./symbols */ \"./node_modules/postcss/lib/symbols.js\")\nlet CssSyntaxError = __webpack_require__(/*! ./css-syntax-error */ \"./node_modules/postcss/lib/css-syntax-error.js\")\nlet Stringifier = __webpack_require__(/*! ./stringifier */ \"./node_modules/postcss/lib/stringifier.js\")\nlet stringify = __webpack_require__(/*! ./stringify */ \"./node_modules/postcss/lib/stringify.js\")\n\nfunction cloneNode(obj, parent) {\n  let cloned = new obj.constructor()\n\n  for (let i in obj) {\n    if (!Object.prototype.hasOwnProperty.call(obj, i)) {\n      /* c8 ignore next 2 */\n      continue\n    }\n    if (i === 'proxyCache') continue\n    let value = obj[i]\n    let type = typeof value\n\n    if (i === 'parent' && type === 'object') {\n      if (parent) cloned[i] = parent\n    } else if (i === 'source') {\n      cloned[i] = value\n    } else if (Array.isArray(value)) {\n      cloned[i] = value.map(j => cloneNode(j, cloned))\n    } else {\n      if (type === 'object' && value !== null) value = cloneNode(value)\n      cloned[i] = value\n    }\n  }\n\n  return cloned\n}\n\nclass Node {\n  constructor(defaults = {}) {\n    this.raws = {}\n    this[isClean] = false\n    this[my] = true\n\n    for (let name in defaults) {\n      if (name === 'nodes') {\n        this.nodes = []\n        for (let node of defaults[name]) {\n          if (typeof node.clone === 'function') {\n            this.append(node.clone())\n          } else {\n            this.append(node)\n          }\n        }\n      } else {\n        this[name] = defaults[name]\n      }\n    }\n  }\n\n  error(message, opts = {}) {\n    if (this.source) {\n      let { start, end } = this.rangeBy(opts)\n      return this.source.input.error(\n        message,\n        { line: start.line, column: start.column },\n        { line: end.line, column: end.column },\n        opts\n      )\n    }\n    return new CssSyntaxError(message)\n  }\n\n  warn(result, text, opts) {\n    let data = { node: this }\n    for (let i in opts) data[i] = opts[i]\n    return result.warn(text, data)\n  }\n\n  remove() {\n    if (this.parent) {\n      this.parent.removeChild(this)\n    }\n    this.parent = undefined\n    return this\n  }\n\n  toString(stringifier = stringify) {\n    if (stringifier.stringify) stringifier = stringifier.stringify\n    let result = ''\n    stringifier(this, i => {\n      result += i\n    })\n    return result\n  }\n\n  assign(overrides = {}) {\n    for (let name in overrides) {\n      this[name] = overrides[name]\n    }\n    return this\n  }\n\n  clone(overrides = {}) {\n    let cloned = cloneNode(this)\n    for (let name in overrides) {\n      cloned[name] = overrides[name]\n    }\n    return cloned\n  }\n\n  cloneBefore(overrides = {}) {\n    let cloned = this.clone(overrides)\n    this.parent.insertBefore(this, cloned)\n    return cloned\n  }\n\n  cloneAfter(overrides = {}) {\n    let cloned = this.clone(overrides)\n    this.parent.insertAfter(this, cloned)\n    return cloned\n  }\n\n  replaceWith(...nodes) {\n    if (this.parent) {\n      let bookmark = this\n      let foundSelf = false\n      for (let node of nodes) {\n        if (node === this) {\n          foundSelf = true\n        } else if (foundSelf) {\n          this.parent.insertAfter(bookmark, node)\n          bookmark = node\n        } else {\n          this.parent.insertBefore(bookmark, node)\n        }\n      }\n\n      if (!foundSelf) {\n        this.remove()\n      }\n    }\n\n    return this\n  }\n\n  next() {\n    if (!this.parent) return undefined\n    let index = this.parent.index(this)\n    return this.parent.nodes[index + 1]\n  }\n\n  prev() {\n    if (!this.parent) return undefined\n    let index = this.parent.index(this)\n    return this.parent.nodes[index - 1]\n  }\n\n  before(add) {\n    this.parent.insertBefore(this, add)\n    return this\n  }\n\n  after(add) {\n    this.parent.insertAfter(this, add)\n    return this\n  }\n\n  root() {\n    let result = this\n    while (result.parent && result.parent.type !== 'document') {\n      result = result.parent\n    }\n    return result\n  }\n\n  raw(prop, defaultType) {\n    let str = new Stringifier()\n    return str.raw(this, prop, defaultType)\n  }\n\n  cleanRaws(keepBetween) {\n    delete this.raws.before\n    delete this.raws.after\n    if (!keepBetween) delete this.raws.between\n  }\n\n  toJSON(_, inputs) {\n    let fixed = {}\n    let emitInputs = inputs == null\n    inputs = inputs || new Map()\n    let inputsNextIndex = 0\n\n    for (let name in this) {\n      if (!Object.prototype.hasOwnProperty.call(this, name)) {\n        /* c8 ignore next 2 */\n        continue\n      }\n      if (name === 'parent' || name === 'proxyCache') continue\n      let value = this[name]\n\n      if (Array.isArray(value)) {\n        fixed[name] = value.map(i => {\n          if (typeof i === 'object' && i.toJSON) {\n            return i.toJSON(null, inputs)\n          } else {\n            return i\n          }\n        })\n      } else if (typeof value === 'object' && value.toJSON) {\n        fixed[name] = value.toJSON(null, inputs)\n      } else if (name === 'source') {\n        let inputId = inputs.get(value.input)\n        if (inputId == null) {\n          inputId = inputsNextIndex\n          inputs.set(value.input, inputsNextIndex)\n          inputsNextIndex++\n        }\n        fixed[name] = {\n          inputId,\n          start: value.start,\n          end: value.end\n        }\n      } else {\n        fixed[name] = value\n      }\n    }\n\n    if (emitInputs) {\n      fixed.inputs = [...inputs.keys()].map(input => input.toJSON())\n    }\n\n    return fixed\n  }\n\n  positionInside(index) {\n    let string = this.toString()\n    let column = this.source.start.column\n    let line = this.source.start.line\n\n    for (let i = 0; i < index; i++) {\n      if (string[i] === '\\n') {\n        column = 1\n        line += 1\n      } else {\n        column += 1\n      }\n    }\n\n    return { line, column }\n  }\n\n  positionBy(opts) {\n    let pos = this.source.start\n    if (opts.index) {\n      pos = this.positionInside(opts.index)\n    } else if (opts.word) {\n      let index = this.toString().indexOf(opts.word)\n      if (index !== -1) pos = this.positionInside(index)\n    }\n    return pos\n  }\n\n  rangeBy(opts) {\n    let start = {\n      line: this.source.start.line,\n      column: this.source.start.column\n    }\n    let end = this.source.end\n      ? {\n          line: this.source.end.line,\n          column: this.source.end.column + 1\n        }\n      : {\n          line: start.line,\n          column: start.column + 1\n        }\n\n    if (opts.word) {\n      let index = this.toString().indexOf(opts.word)\n      if (index !== -1) {\n        start = this.positionInside(index)\n        end = this.positionInside(index + opts.word.length)\n      }\n    } else {\n      if (opts.start) {\n        start = {\n          line: opts.start.line,\n          column: opts.start.column\n        }\n      } else if (opts.index) {\n        start = this.positionInside(opts.index)\n      }\n\n      if (opts.end) {\n        end = {\n          line: opts.end.line,\n          column: opts.end.column\n        }\n      } else if (opts.endIndex) {\n        end = this.positionInside(opts.endIndex)\n      } else if (opts.index) {\n        end = this.positionInside(opts.index + 1)\n      }\n    }\n\n    if (\n      end.line < start.line ||\n      (end.line === start.line && end.column <= start.column)\n    ) {\n      end = { line: start.line, column: start.column + 1 }\n    }\n\n    return { start, end }\n  }\n\n  getProxyProcessor() {\n    return {\n      set(node, prop, value) {\n        if (node[prop] === value) return true\n        node[prop] = value\n        if (\n          prop === 'prop' ||\n          prop === 'value' ||\n          prop === 'name' ||\n          prop === 'params' ||\n          prop === 'important' ||\n          /* c8 ignore next */\n          prop === 'text'\n        ) {\n          node.markDirty()\n        }\n        return true\n      },\n\n      get(node, prop) {\n        if (prop === 'proxyOf') {\n          return node\n        } else if (prop === 'root') {\n          return () => node.root().toProxy()\n        } else {\n          return node[prop]\n        }\n      }\n    }\n  }\n\n  toProxy() {\n    if (!this.proxyCache) {\n      this.proxyCache = new Proxy(this, this.getProxyProcessor())\n    }\n    return this.proxyCache\n  }\n\n  addToError(error) {\n    error.postcssNode = this\n    if (error.stack && this.source && /\\n\\s{4}at /.test(error.stack)) {\n      let s = this.source\n      error.stack = error.stack.replace(\n        /\\n\\s{4}at /,\n        `$&${s.input.from}:${s.start.line}:${s.start.column}$&`\n      )\n    }\n    return error\n  }\n\n  markDirty() {\n    if (this[isClean]) {\n      this[isClean] = false\n      let next = this\n      while ((next = next.parent)) {\n        next[isClean] = false\n      }\n    }\n  }\n\n  get proxyOf() {\n    return this\n  }\n}\n\nmodule.exports = Node\nNode.default = Node\n\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/postcss/lib/node.js?");

/***/ }),

/***/ "./node_modules/postcss/lib/parse.js":
/*!*******************************************!*\
  !*** ./node_modules/postcss/lib/parse.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nlet Container = __webpack_require__(/*! ./container */ \"./node_modules/postcss/lib/container.js\")\nlet Parser = __webpack_require__(/*! ./parser */ \"./node_modules/postcss/lib/parser.js\")\nlet Input = __webpack_require__(/*! ./input */ \"./node_modules/postcss/lib/input.js\")\n\nfunction parse(css, opts) {\n  let input = new Input(css, opts)\n  let parser = new Parser(input)\n  try {\n    parser.parse()\n  } catch (e) {\n    if (true) {\n      if (e.name === 'CssSyntaxError' && opts && opts.from) {\n        if (/\\.scss$/i.test(opts.from)) {\n          e.message +=\n            '\\nYou tried to parse SCSS with ' +\n            'the standard CSS parser; ' +\n            'try again with the postcss-scss parser'\n        } else if (/\\.sass/i.test(opts.from)) {\n          e.message +=\n            '\\nYou tried to parse Sass with ' +\n            'the standard CSS parser; ' +\n            'try again with the postcss-sass parser'\n        } else if (/\\.less$/i.test(opts.from)) {\n          e.message +=\n            '\\nYou tried to parse Less with ' +\n            'the standard CSS parser; ' +\n            'try again with the postcss-less parser'\n        }\n      }\n    }\n    throw e\n  }\n\n  return parser.root\n}\n\nmodule.exports = parse\nparse.default = parse\n\nContainer.registerParse(parse)\n\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/postcss/lib/parse.js?");

/***/ }),

/***/ "./node_modules/postcss/lib/parser.js":
/*!********************************************!*\
  !*** ./node_modules/postcss/lib/parser.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nlet Declaration = __webpack_require__(/*! ./declaration */ \"./node_modules/postcss/lib/declaration.js\")\nlet tokenizer = __webpack_require__(/*! ./tokenize */ \"./node_modules/postcss/lib/tokenize.js\")\nlet Comment = __webpack_require__(/*! ./comment */ \"./node_modules/postcss/lib/comment.js\")\nlet AtRule = __webpack_require__(/*! ./at-rule */ \"./node_modules/postcss/lib/at-rule.js\")\nlet Root = __webpack_require__(/*! ./root */ \"./node_modules/postcss/lib/root.js\")\nlet Rule = __webpack_require__(/*! ./rule */ \"./node_modules/postcss/lib/rule.js\")\n\nconst SAFE_COMMENT_NEIGHBOR = {\n  empty: true,\n  space: true\n}\n\nfunction findLastWithPosition(tokens) {\n  for (let i = tokens.length - 1; i >= 0; i--) {\n    let token = tokens[i]\n    let pos = token[3] || token[2]\n    if (pos) return pos\n  }\n}\n\nclass Parser {\n  constructor(input) {\n    this.input = input\n\n    this.root = new Root()\n    this.current = this.root\n    this.spaces = ''\n    this.semicolon = false\n    this.customProperty = false\n\n    this.createTokenizer()\n    this.root.source = { input, start: { offset: 0, line: 1, column: 1 } }\n  }\n\n  createTokenizer() {\n    this.tokenizer = tokenizer(this.input)\n  }\n\n  parse() {\n    let token\n    while (!this.tokenizer.endOfFile()) {\n      token = this.tokenizer.nextToken()\n\n      switch (token[0]) {\n        case 'space':\n          this.spaces += token[1]\n          break\n\n        case ';':\n          this.freeSemicolon(token)\n          break\n\n        case '}':\n          this.end(token)\n          break\n\n        case 'comment':\n          this.comment(token)\n          break\n\n        case 'at-word':\n          this.atrule(token)\n          break\n\n        case '{':\n          this.emptyRule(token)\n          break\n\n        default:\n          this.other(token)\n          break\n      }\n    }\n    this.endFile()\n  }\n\n  comment(token) {\n    let node = new Comment()\n    this.init(node, token[2])\n    node.source.end = this.getPosition(token[3] || token[2])\n\n    let text = token[1].slice(2, -2)\n    if (/^\\s*$/.test(text)) {\n      node.text = ''\n      node.raws.left = text\n      node.raws.right = ''\n    } else {\n      let match = text.match(/^(\\s*)([^]*\\S)(\\s*)$/)\n      node.text = match[2]\n      node.raws.left = match[1]\n      node.raws.right = match[3]\n    }\n  }\n\n  emptyRule(token) {\n    let node = new Rule()\n    this.init(node, token[2])\n    node.selector = ''\n    node.raws.between = ''\n    this.current = node\n  }\n\n  other(start) {\n    let end = false\n    let type = null\n    let colon = false\n    let bracket = null\n    let brackets = []\n    let customProperty = start[1].startsWith('--')\n\n    let tokens = []\n    let token = start\n    while (token) {\n      type = token[0]\n      tokens.push(token)\n\n      if (type === '(' || type === '[') {\n        if (!bracket) bracket = token\n        brackets.push(type === '(' ? ')' : ']')\n      } else if (customProperty && colon && type === '{') {\n        if (!bracket) bracket = token\n        brackets.push('}')\n      } else if (brackets.length === 0) {\n        if (type === ';') {\n          if (colon) {\n            this.decl(tokens, customProperty)\n            return\n          } else {\n            break\n          }\n        } else if (type === '{') {\n          this.rule(tokens)\n          return\n        } else if (type === '}') {\n          this.tokenizer.back(tokens.pop())\n          end = true\n          break\n        } else if (type === ':') {\n          colon = true\n        }\n      } else if (type === brackets[brackets.length - 1]) {\n        brackets.pop()\n        if (brackets.length === 0) bracket = null\n      }\n\n      token = this.tokenizer.nextToken()\n    }\n\n    if (this.tokenizer.endOfFile()) end = true\n    if (brackets.length > 0) this.unclosedBracket(bracket)\n\n    if (end && colon) {\n      if (!customProperty) {\n        while (tokens.length) {\n          token = tokens[tokens.length - 1][0]\n          if (token !== 'space' && token !== 'comment') break\n          this.tokenizer.back(tokens.pop())\n        }\n      }\n      this.decl(tokens, customProperty)\n    } else {\n      this.unknownWord(tokens)\n    }\n  }\n\n  rule(tokens) {\n    tokens.pop()\n\n    let node = new Rule()\n    this.init(node, tokens[0][2])\n\n    node.raws.between = this.spacesAndCommentsFromEnd(tokens)\n    this.raw(node, 'selector', tokens)\n    this.current = node\n  }\n\n  decl(tokens, customProperty) {\n    let node = new Declaration()\n    this.init(node, tokens[0][2])\n\n    let last = tokens[tokens.length - 1]\n    if (last[0] === ';') {\n      this.semicolon = true\n      tokens.pop()\n    }\n\n    node.source.end = this.getPosition(\n      last[3] || last[2] || findLastWithPosition(tokens)\n    )\n\n    while (tokens[0][0] !== 'word') {\n      if (tokens.length === 1) this.unknownWord(tokens)\n      node.raws.before += tokens.shift()[1]\n    }\n    node.source.start = this.getPosition(tokens[0][2])\n\n    node.prop = ''\n    while (tokens.length) {\n      let type = tokens[0][0]\n      if (type === ':' || type === 'space' || type === 'comment') {\n        break\n      }\n      node.prop += tokens.shift()[1]\n    }\n\n    node.raws.between = ''\n\n    let token\n    while (tokens.length) {\n      token = tokens.shift()\n\n      if (token[0] === ':') {\n        node.raws.between += token[1]\n        break\n      } else {\n        if (token[0] === 'word' && /\\w/.test(token[1])) {\n          this.unknownWord([token])\n        }\n        node.raws.between += token[1]\n      }\n    }\n\n    if (node.prop[0] === '_' || node.prop[0] === '*') {\n      node.raws.before += node.prop[0]\n      node.prop = node.prop.slice(1)\n    }\n\n    let firstSpaces = []\n    let next\n    while (tokens.length) {\n      next = tokens[0][0]\n      if (next !== 'space' && next !== 'comment') break\n      firstSpaces.push(tokens.shift())\n    }\n\n    this.precheckMissedSemicolon(tokens)\n\n    for (let i = tokens.length - 1; i >= 0; i--) {\n      token = tokens[i]\n      if (token[1].toLowerCase() === '!important') {\n        node.important = true\n        let string = this.stringFrom(tokens, i)\n        string = this.spacesFromEnd(tokens) + string\n        if (string !== ' !important') node.raws.important = string\n        break\n      } else if (token[1].toLowerCase() === 'important') {\n        let cache = tokens.slice(0)\n        let str = ''\n        for (let j = i; j > 0; j--) {\n          let type = cache[j][0]\n          if (str.trim().indexOf('!') === 0 && type !== 'space') {\n            break\n          }\n          str = cache.pop()[1] + str\n        }\n        if (str.trim().indexOf('!') === 0) {\n          node.important = true\n          node.raws.important = str\n          tokens = cache\n        }\n      }\n\n      if (token[0] !== 'space' && token[0] !== 'comment') {\n        break\n      }\n    }\n\n    let hasWord = tokens.some(i => i[0] !== 'space' && i[0] !== 'comment')\n\n    if (hasWord) {\n      node.raws.between += firstSpaces.map(i => i[1]).join('')\n      firstSpaces = []\n    }\n    this.raw(node, 'value', firstSpaces.concat(tokens), customProperty)\n\n    if (node.value.includes(':') && !customProperty) {\n      this.checkMissedSemicolon(tokens)\n    }\n  }\n\n  atrule(token) {\n    let node = new AtRule()\n    node.name = token[1].slice(1)\n    if (node.name === '') {\n      this.unnamedAtrule(node, token)\n    }\n    this.init(node, token[2])\n\n    let type\n    let prev\n    let shift\n    let last = false\n    let open = false\n    let params = []\n    let brackets = []\n\n    while (!this.tokenizer.endOfFile()) {\n      token = this.tokenizer.nextToken()\n      type = token[0]\n\n      if (type === '(' || type === '[') {\n        brackets.push(type === '(' ? ')' : ']')\n      } else if (type === '{' && brackets.length > 0) {\n        brackets.push('}')\n      } else if (type === brackets[brackets.length - 1]) {\n        brackets.pop()\n      }\n\n      if (brackets.length === 0) {\n        if (type === ';') {\n          node.source.end = this.getPosition(token[2])\n          this.semicolon = true\n          break\n        } else if (type === '{') {\n          open = true\n          break\n        } else if (type === '}') {\n          if (params.length > 0) {\n            shift = params.length - 1\n            prev = params[shift]\n            while (prev && prev[0] === 'space') {\n              prev = params[--shift]\n            }\n            if (prev) {\n              node.source.end = this.getPosition(prev[3] || prev[2])\n            }\n          }\n          this.end(token)\n          break\n        } else {\n          params.push(token)\n        }\n      } else {\n        params.push(token)\n      }\n\n      if (this.tokenizer.endOfFile()) {\n        last = true\n        break\n      }\n    }\n\n    node.raws.between = this.spacesAndCommentsFromEnd(params)\n    if (params.length) {\n      node.raws.afterName = this.spacesAndCommentsFromStart(params)\n      this.raw(node, 'params', params)\n      if (last) {\n        token = params[params.length - 1]\n        node.source.end = this.getPosition(token[3] || token[2])\n        this.spaces = node.raws.between\n        node.raws.between = ''\n      }\n    } else {\n      node.raws.afterName = ''\n      node.params = ''\n    }\n\n    if (open) {\n      node.nodes = []\n      this.current = node\n    }\n  }\n\n  end(token) {\n    if (this.current.nodes && this.current.nodes.length) {\n      this.current.raws.semicolon = this.semicolon\n    }\n    this.semicolon = false\n\n    this.current.raws.after = (this.current.raws.after || '') + this.spaces\n    this.spaces = ''\n\n    if (this.current.parent) {\n      this.current.source.end = this.getPosition(token[2])\n      this.current = this.current.parent\n    } else {\n      this.unexpectedClose(token)\n    }\n  }\n\n  endFile() {\n    if (this.current.parent) this.unclosedBlock()\n    if (this.current.nodes && this.current.nodes.length) {\n      this.current.raws.semicolon = this.semicolon\n    }\n    this.current.raws.after = (this.current.raws.after || '') + this.spaces\n  }\n\n  freeSemicolon(token) {\n    this.spaces += token[1]\n    if (this.current.nodes) {\n      let prev = this.current.nodes[this.current.nodes.length - 1]\n      if (prev && prev.type === 'rule' && !prev.raws.ownSemicolon) {\n        prev.raws.ownSemicolon = this.spaces\n        this.spaces = ''\n      }\n    }\n  }\n\n  // Helpers\n\n  getPosition(offset) {\n    let pos = this.input.fromOffset(offset)\n    return {\n      offset,\n      line: pos.line,\n      column: pos.col\n    }\n  }\n\n  init(node, offset) {\n    this.current.push(node)\n    node.source = {\n      start: this.getPosition(offset),\n      input: this.input\n    }\n    node.raws.before = this.spaces\n    this.spaces = ''\n    if (node.type !== 'comment') this.semicolon = false\n  }\n\n  raw(node, prop, tokens, customProperty) {\n    let token, type\n    let length = tokens.length\n    let value = ''\n    let clean = true\n    let next, prev\n\n    for (let i = 0; i < length; i += 1) {\n      token = tokens[i]\n      type = token[0]\n      if (type === 'space' && i === length - 1 && !customProperty) {\n        clean = false\n      } else if (type === 'comment') {\n        prev = tokens[i - 1] ? tokens[i - 1][0] : 'empty'\n        next = tokens[i + 1] ? tokens[i + 1][0] : 'empty'\n        if (!SAFE_COMMENT_NEIGHBOR[prev] && !SAFE_COMMENT_NEIGHBOR[next]) {\n          if (value.slice(-1) === ',') {\n            clean = false\n          } else {\n            value += token[1]\n          }\n        } else {\n          clean = false\n        }\n      } else {\n        value += token[1]\n      }\n    }\n    if (!clean) {\n      let raw = tokens.reduce((all, i) => all + i[1], '')\n      node.raws[prop] = { value, raw }\n    }\n    node[prop] = value\n  }\n\n  spacesAndCommentsFromEnd(tokens) {\n    let lastTokenType\n    let spaces = ''\n    while (tokens.length) {\n      lastTokenType = tokens[tokens.length - 1][0]\n      if (lastTokenType !== 'space' && lastTokenType !== 'comment') break\n      spaces = tokens.pop()[1] + spaces\n    }\n    return spaces\n  }\n\n  spacesAndCommentsFromStart(tokens) {\n    let next\n    let spaces = ''\n    while (tokens.length) {\n      next = tokens[0][0]\n      if (next !== 'space' && next !== 'comment') break\n      spaces += tokens.shift()[1]\n    }\n    return spaces\n  }\n\n  spacesFromEnd(tokens) {\n    let lastTokenType\n    let spaces = ''\n    while (tokens.length) {\n      lastTokenType = tokens[tokens.length - 1][0]\n      if (lastTokenType !== 'space') break\n      spaces = tokens.pop()[1] + spaces\n    }\n    return spaces\n  }\n\n  stringFrom(tokens, from) {\n    let result = ''\n    for (let i = from; i < tokens.length; i++) {\n      result += tokens[i][1]\n    }\n    tokens.splice(from, tokens.length - from)\n    return result\n  }\n\n  colon(tokens) {\n    let brackets = 0\n    let token, type, prev\n    for (let [i, element] of tokens.entries()) {\n      token = element\n      type = token[0]\n\n      if (type === '(') {\n        brackets += 1\n      }\n      if (type === ')') {\n        brackets -= 1\n      }\n      if (brackets === 0 && type === ':') {\n        if (!prev) {\n          this.doubleColon(token)\n        } else if (prev[0] === 'word' && prev[1] === 'progid') {\n          continue\n        } else {\n          return i\n        }\n      }\n\n      prev = token\n    }\n    return false\n  }\n\n  // Errors\n\n  unclosedBracket(bracket) {\n    throw this.input.error(\n      'Unclosed bracket',\n      { offset: bracket[2] },\n      { offset: bracket[2] + 1 }\n    )\n  }\n\n  unknownWord(tokens) {\n    throw this.input.error(\n      'Unknown word',\n      { offset: tokens[0][2] },\n      { offset: tokens[0][2] + tokens[0][1].length }\n    )\n  }\n\n  unexpectedClose(token) {\n    throw this.input.error(\n      'Unexpected }',\n      { offset: token[2] },\n      { offset: token[2] + 1 }\n    )\n  }\n\n  unclosedBlock() {\n    let pos = this.current.source.start\n    throw this.input.error('Unclosed block', pos.line, pos.column)\n  }\n\n  doubleColon(token) {\n    throw this.input.error(\n      'Double colon',\n      { offset: token[2] },\n      { offset: token[2] + token[1].length }\n    )\n  }\n\n  unnamedAtrule(node, token) {\n    throw this.input.error(\n      'At-rule without name',\n      { offset: token[2] },\n      { offset: token[2] + token[1].length }\n    )\n  }\n\n  precheckMissedSemicolon(/* tokens */) {\n    // Hook for Safe Parser\n  }\n\n  checkMissedSemicolon(tokens) {\n    let colon = this.colon(tokens)\n    if (colon === false) return\n\n    let founded = 0\n    let token\n    for (let j = colon - 1; j >= 0; j--) {\n      token = tokens[j]\n      if (token[0] !== 'space') {\n        founded += 1\n        if (founded === 2) break\n      }\n    }\n    // If the token is a word, e.g. `!important`, `red` or any other valid property's value.\n    // Then we need to return the colon after that word token. [3] is the \"end\" colon of that word.\n    // And because we need it after that one we do +1 to get the next one.\n    throw this.input.error(\n      'Missed semicolon',\n      token[0] === 'word' ? token[3] + 1 : token[2]\n    )\n  }\n}\n\nmodule.exports = Parser\n\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/postcss/lib/parser.js?");

/***/ }),

/***/ "./node_modules/postcss/lib/postcss.js":
/*!*********************************************!*\
  !*** ./node_modules/postcss/lib/postcss.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nlet CssSyntaxError = __webpack_require__(/*! ./css-syntax-error */ \"./node_modules/postcss/lib/css-syntax-error.js\")\nlet Declaration = __webpack_require__(/*! ./declaration */ \"./node_modules/postcss/lib/declaration.js\")\nlet LazyResult = __webpack_require__(/*! ./lazy-result */ \"./node_modules/postcss/lib/lazy-result.js\")\nlet Container = __webpack_require__(/*! ./container */ \"./node_modules/postcss/lib/container.js\")\nlet Processor = __webpack_require__(/*! ./processor */ \"./node_modules/postcss/lib/processor.js\")\nlet stringify = __webpack_require__(/*! ./stringify */ \"./node_modules/postcss/lib/stringify.js\")\nlet fromJSON = __webpack_require__(/*! ./fromJSON */ \"./node_modules/postcss/lib/fromJSON.js\")\nlet Document = __webpack_require__(/*! ./document */ \"./node_modules/postcss/lib/document.js\")\nlet Warning = __webpack_require__(/*! ./warning */ \"./node_modules/postcss/lib/warning.js\")\nlet Comment = __webpack_require__(/*! ./comment */ \"./node_modules/postcss/lib/comment.js\")\nlet AtRule = __webpack_require__(/*! ./at-rule */ \"./node_modules/postcss/lib/at-rule.js\")\nlet Result = __webpack_require__(/*! ./result.js */ \"./node_modules/postcss/lib/result.js\")\nlet Input = __webpack_require__(/*! ./input */ \"./node_modules/postcss/lib/input.js\")\nlet parse = __webpack_require__(/*! ./parse */ \"./node_modules/postcss/lib/parse.js\")\nlet list = __webpack_require__(/*! ./list */ \"./node_modules/postcss/lib/list.js\")\nlet Rule = __webpack_require__(/*! ./rule */ \"./node_modules/postcss/lib/rule.js\")\nlet Root = __webpack_require__(/*! ./root */ \"./node_modules/postcss/lib/root.js\")\nlet Node = __webpack_require__(/*! ./node */ \"./node_modules/postcss/lib/node.js\")\n\nfunction postcss(...plugins) {\n  if (plugins.length === 1 && Array.isArray(plugins[0])) {\n    plugins = plugins[0]\n  }\n  return new Processor(plugins)\n}\n\npostcss.plugin = function plugin(name, initializer) {\n  let warningPrinted = false\n  function creator(...args) {\n    // eslint-disable-next-line no-console\n    if (console && console.warn && !warningPrinted) {\n      warningPrinted = true\n      // eslint-disable-next-line no-console\n      console.warn(\n        name +\n          ': postcss.plugin was deprecated. Migration guide:\\n' +\n          'https://evilmartians.com/chronicles/postcss-8-plugin-migration'\n      )\n      if (process.env.LANG && process.env.LANG.startsWith('cn')) {\n        /* c8 ignore next 7 */\n        // eslint-disable-next-line no-console\n        console.warn(\n          name +\n            ': 里面 postcss.plugin 被弃用. 迁移指南:\\n' +\n            'https://www.w3ctech.com/topic/2226'\n        )\n      }\n    }\n    let transformer = initializer(...args)\n    transformer.postcssPlugin = name\n    transformer.postcssVersion = new Processor().version\n    return transformer\n  }\n\n  let cache\n  Object.defineProperty(creator, 'postcss', {\n    get() {\n      if (!cache) cache = creator()\n      return cache\n    }\n  })\n\n  creator.process = function (css, processOpts, pluginOpts) {\n    return postcss([creator(pluginOpts)]).process(css, processOpts)\n  }\n\n  return creator\n}\n\npostcss.stringify = stringify\npostcss.parse = parse\npostcss.fromJSON = fromJSON\npostcss.list = list\n\npostcss.comment = defaults => new Comment(defaults)\npostcss.atRule = defaults => new AtRule(defaults)\npostcss.decl = defaults => new Declaration(defaults)\npostcss.rule = defaults => new Rule(defaults)\npostcss.root = defaults => new Root(defaults)\npostcss.document = defaults => new Document(defaults)\n\npostcss.CssSyntaxError = CssSyntaxError\npostcss.Declaration = Declaration\npostcss.Container = Container\npostcss.Processor = Processor\npostcss.Document = Document\npostcss.Comment = Comment\npostcss.Warning = Warning\npostcss.AtRule = AtRule\npostcss.Result = Result\npostcss.Input = Input\npostcss.Rule = Rule\npostcss.Root = Root\npostcss.Node = Node\n\nLazyResult.registerPostcss(postcss)\n\nmodule.exports = postcss\npostcss.default = postcss\n\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/postcss/lib/postcss.js?");

/***/ }),

/***/ "./node_modules/postcss/lib/previous-map.js":
/*!**************************************************!*\
  !*** ./node_modules/postcss/lib/previous-map.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nlet { SourceMapConsumer, SourceMapGenerator } = __webpack_require__(/*! source-map-js */ \"?b8cb\")\nlet { existsSync, readFileSync } = __webpack_require__(/*! fs */ \"?03fb\")\nlet { dirname, join } = __webpack_require__(/*! path */ \"?6197\")\n\nfunction fromBase64(str) {\n  if (Buffer) {\n    return Buffer.from(str, 'base64').toString()\n  } else {\n    /* c8 ignore next 2 */\n    return window.atob(str)\n  }\n}\n\nclass PreviousMap {\n  constructor(css, opts) {\n    if (opts.map === false) return\n    this.loadAnnotation(css)\n    this.inline = this.startWith(this.annotation, 'data:')\n\n    let prev = opts.map ? opts.map.prev : undefined\n    let text = this.loadMap(opts.from, prev)\n    if (!this.mapFile && opts.from) {\n      this.mapFile = opts.from\n    }\n    if (this.mapFile) this.root = dirname(this.mapFile)\n    if (text) this.text = text\n  }\n\n  consumer() {\n    if (!this.consumerCache) {\n      this.consumerCache = new SourceMapConsumer(this.text)\n    }\n    return this.consumerCache\n  }\n\n  withContent() {\n    return !!(\n      this.consumer().sourcesContent &&\n      this.consumer().sourcesContent.length > 0\n    )\n  }\n\n  startWith(string, start) {\n    if (!string) return false\n    return string.substr(0, start.length) === start\n  }\n\n  getAnnotationURL(sourceMapString) {\n    return sourceMapString.replace(/^\\/\\*\\s*# sourceMappingURL=/, '').trim()\n  }\n\n  loadAnnotation(css) {\n    let comments = css.match(/\\/\\*\\s*# sourceMappingURL=/gm)\n    if (!comments) return\n\n    // sourceMappingURLs from comments, strings, etc.\n    let start = css.lastIndexOf(comments.pop())\n    let end = css.indexOf('*/', start)\n\n    if (start > -1 && end > -1) {\n      // Locate the last sourceMappingURL to avoid pickin\n      this.annotation = this.getAnnotationURL(css.substring(start, end))\n    }\n  }\n\n  decodeInline(text) {\n    let baseCharsetUri = /^data:application\\/json;charset=utf-?8;base64,/\n    let baseUri = /^data:application\\/json;base64,/\n    let charsetUri = /^data:application\\/json;charset=utf-?8,/\n    let uri = /^data:application\\/json,/\n\n    if (charsetUri.test(text) || uri.test(text)) {\n      return decodeURIComponent(text.substr(RegExp.lastMatch.length))\n    }\n\n    if (baseCharsetUri.test(text) || baseUri.test(text)) {\n      return fromBase64(text.substr(RegExp.lastMatch.length))\n    }\n\n    let encoding = text.match(/data:application\\/json;([^,]+),/)[1]\n    throw new Error('Unsupported source map encoding ' + encoding)\n  }\n\n  loadFile(path) {\n    this.root = dirname(path)\n    if (existsSync(path)) {\n      this.mapFile = path\n      return readFileSync(path, 'utf-8').toString().trim()\n    }\n  }\n\n  loadMap(file, prev) {\n    if (prev === false) return false\n\n    if (prev) {\n      if (typeof prev === 'string') {\n        return prev\n      } else if (typeof prev === 'function') {\n        let prevPath = prev(file)\n        if (prevPath) {\n          let map = this.loadFile(prevPath)\n          if (!map) {\n            throw new Error(\n              'Unable to load previous source map: ' + prevPath.toString()\n            )\n          }\n          return map\n        }\n      } else if (prev instanceof SourceMapConsumer) {\n        return SourceMapGenerator.fromSourceMap(prev).toString()\n      } else if (prev instanceof SourceMapGenerator) {\n        return prev.toString()\n      } else if (this.isMap(prev)) {\n        return JSON.stringify(prev)\n      } else {\n        throw new Error(\n          'Unsupported previous source map format: ' + prev.toString()\n        )\n      }\n    } else if (this.inline) {\n      return this.decodeInline(this.annotation)\n    } else if (this.annotation) {\n      let map = this.annotation\n      if (file) map = join(dirname(file), map)\n      return this.loadFile(map)\n    }\n  }\n\n  isMap(map) {\n    if (typeof map !== 'object') return false\n    return (\n      typeof map.mappings === 'string' ||\n      typeof map._mappings === 'string' ||\n      Array.isArray(map.sections)\n    )\n  }\n}\n\nmodule.exports = PreviousMap\nPreviousMap.default = PreviousMap\n\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/postcss/lib/previous-map.js?");

/***/ }),

/***/ "./node_modules/postcss/lib/processor.js":
/*!***********************************************!*\
  !*** ./node_modules/postcss/lib/processor.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nlet NoWorkResult = __webpack_require__(/*! ./no-work-result */ \"./node_modules/postcss/lib/no-work-result.js\")\nlet LazyResult = __webpack_require__(/*! ./lazy-result */ \"./node_modules/postcss/lib/lazy-result.js\")\nlet Document = __webpack_require__(/*! ./document */ \"./node_modules/postcss/lib/document.js\")\nlet Root = __webpack_require__(/*! ./root */ \"./node_modules/postcss/lib/root.js\")\n\nclass Processor {\n  constructor(plugins = []) {\n    this.version = '8.4.18'\n    this.plugins = this.normalize(plugins)\n  }\n\n  use(plugin) {\n    this.plugins = this.plugins.concat(this.normalize([plugin]))\n    return this\n  }\n\n  process(css, opts = {}) {\n    if (\n      this.plugins.length === 0 &&\n      typeof opts.parser === 'undefined' &&\n      typeof opts.stringifier === 'undefined' &&\n      typeof opts.syntax === 'undefined'\n    ) {\n      return new NoWorkResult(this, css, opts)\n    } else {\n      return new LazyResult(this, css, opts)\n    }\n  }\n\n  normalize(plugins) {\n    let normalized = []\n    for (let i of plugins) {\n      if (i.postcss === true) {\n        i = i()\n      } else if (i.postcss) {\n        i = i.postcss\n      }\n\n      if (typeof i === 'object' && Array.isArray(i.plugins)) {\n        normalized = normalized.concat(i.plugins)\n      } else if (typeof i === 'object' && i.postcssPlugin) {\n        normalized.push(i)\n      } else if (typeof i === 'function') {\n        normalized.push(i)\n      } else if (typeof i === 'object' && (i.parse || i.stringify)) {\n        if (true) {\n          throw new Error(\n            'PostCSS syntaxes cannot be used as plugins. Instead, please use ' +\n              'one of the syntax/parser/stringifier options as outlined ' +\n              'in your PostCSS runner documentation.'\n          )\n        }\n      } else {\n        throw new Error(i + ' is not a PostCSS plugin')\n      }\n    }\n    return normalized\n  }\n}\n\nmodule.exports = Processor\nProcessor.default = Processor\n\nRoot.registerProcessor(Processor)\nDocument.registerProcessor(Processor)\n\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/postcss/lib/processor.js?");

/***/ }),

/***/ "./node_modules/postcss/lib/result.js":
/*!********************************************!*\
  !*** ./node_modules/postcss/lib/result.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nlet Warning = __webpack_require__(/*! ./warning */ \"./node_modules/postcss/lib/warning.js\")\n\nclass Result {\n  constructor(processor, root, opts) {\n    this.processor = processor\n    this.messages = []\n    this.root = root\n    this.opts = opts\n    this.css = undefined\n    this.map = undefined\n  }\n\n  toString() {\n    return this.css\n  }\n\n  warn(text, opts = {}) {\n    if (!opts.plugin) {\n      if (this.lastPlugin && this.lastPlugin.postcssPlugin) {\n        opts.plugin = this.lastPlugin.postcssPlugin\n      }\n    }\n\n    let warning = new Warning(text, opts)\n    this.messages.push(warning)\n\n    return warning\n  }\n\n  warnings() {\n    return this.messages.filter(i => i.type === 'warning')\n  }\n\n  get content() {\n    return this.css\n  }\n}\n\nmodule.exports = Result\nResult.default = Result\n\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/postcss/lib/result.js?");

/***/ }),

/***/ "./node_modules/postcss/lib/root.js":
/*!******************************************!*\
  !*** ./node_modules/postcss/lib/root.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nlet Container = __webpack_require__(/*! ./container */ \"./node_modules/postcss/lib/container.js\")\n\nlet LazyResult, Processor\n\nclass Root extends Container {\n  constructor(defaults) {\n    super(defaults)\n    this.type = 'root'\n    if (!this.nodes) this.nodes = []\n  }\n\n  removeChild(child, ignore) {\n    let index = this.index(child)\n\n    if (!ignore && index === 0 && this.nodes.length > 1) {\n      this.nodes[1].raws.before = this.nodes[index].raws.before\n    }\n\n    return super.removeChild(child)\n  }\n\n  normalize(child, sample, type) {\n    let nodes = super.normalize(child)\n\n    if (sample) {\n      if (type === 'prepend') {\n        if (this.nodes.length > 1) {\n          sample.raws.before = this.nodes[1].raws.before\n        } else {\n          delete sample.raws.before\n        }\n      } else if (this.first !== sample) {\n        for (let node of nodes) {\n          node.raws.before = sample.raws.before\n        }\n      }\n    }\n\n    return nodes\n  }\n\n  toResult(opts = {}) {\n    let lazy = new LazyResult(new Processor(), this, opts)\n    return lazy.stringify()\n  }\n}\n\nRoot.registerLazyResult = dependant => {\n  LazyResult = dependant\n}\n\nRoot.registerProcessor = dependant => {\n  Processor = dependant\n}\n\nmodule.exports = Root\nRoot.default = Root\n\nContainer.registerRoot(Root)\n\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/postcss/lib/root.js?");

/***/ }),

/***/ "./node_modules/postcss/lib/rule.js":
/*!******************************************!*\
  !*** ./node_modules/postcss/lib/rule.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nlet Container = __webpack_require__(/*! ./container */ \"./node_modules/postcss/lib/container.js\")\nlet list = __webpack_require__(/*! ./list */ \"./node_modules/postcss/lib/list.js\")\n\nclass Rule extends Container {\n  constructor(defaults) {\n    super(defaults)\n    this.type = 'rule'\n    if (!this.nodes) this.nodes = []\n  }\n\n  get selectors() {\n    return list.comma(this.selector)\n  }\n\n  set selectors(values) {\n    let match = this.selector ? this.selector.match(/,\\s*/) : null\n    let sep = match ? match[0] : ',' + this.raw('between', 'beforeOpen')\n    this.selector = values.join(sep)\n  }\n}\n\nmodule.exports = Rule\nRule.default = Rule\n\nContainer.registerRule(Rule)\n\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/postcss/lib/rule.js?");

/***/ }),

/***/ "./node_modules/postcss/lib/stringifier.js":
/*!*************************************************!*\
  !*** ./node_modules/postcss/lib/stringifier.js ***!
  \*************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nconst DEFAULT_RAW = {\n  colon: ': ',\n  indent: '    ',\n  beforeDecl: '\\n',\n  beforeRule: '\\n',\n  beforeOpen: ' ',\n  beforeClose: '\\n',\n  beforeComment: '\\n',\n  after: '\\n',\n  emptyBody: '',\n  commentLeft: ' ',\n  commentRight: ' ',\n  semicolon: false\n}\n\nfunction capitalize(str) {\n  return str[0].toUpperCase() + str.slice(1)\n}\n\nclass Stringifier {\n  constructor(builder) {\n    this.builder = builder\n  }\n\n  stringify(node, semicolon) {\n    /* c8 ignore start */\n    if (!this[node.type]) {\n      throw new Error(\n        'Unknown AST node type ' +\n          node.type +\n          '. ' +\n          'Maybe you need to change PostCSS stringifier.'\n      )\n    }\n    /* c8 ignore stop */\n    this[node.type](node, semicolon)\n  }\n\n  document(node) {\n    this.body(node)\n  }\n\n  root(node) {\n    this.body(node)\n    if (node.raws.after) this.builder(node.raws.after)\n  }\n\n  comment(node) {\n    let left = this.raw(node, 'left', 'commentLeft')\n    let right = this.raw(node, 'right', 'commentRight')\n    this.builder('/*' + left + node.text + right + '*/', node)\n  }\n\n  decl(node, semicolon) {\n    let between = this.raw(node, 'between', 'colon')\n    let string = node.prop + between + this.rawValue(node, 'value')\n\n    if (node.important) {\n      string += node.raws.important || ' !important'\n    }\n\n    if (semicolon) string += ';'\n    this.builder(string, node)\n  }\n\n  rule(node) {\n    this.block(node, this.rawValue(node, 'selector'))\n    if (node.raws.ownSemicolon) {\n      this.builder(node.raws.ownSemicolon, node, 'end')\n    }\n  }\n\n  atrule(node, semicolon) {\n    let name = '@' + node.name\n    let params = node.params ? this.rawValue(node, 'params') : ''\n\n    if (typeof node.raws.afterName !== 'undefined') {\n      name += node.raws.afterName\n    } else if (params) {\n      name += ' '\n    }\n\n    if (node.nodes) {\n      this.block(node, name + params)\n    } else {\n      let end = (node.raws.between || '') + (semicolon ? ';' : '')\n      this.builder(name + params + end, node)\n    }\n  }\n\n  body(node) {\n    let last = node.nodes.length - 1\n    while (last > 0) {\n      if (node.nodes[last].type !== 'comment') break\n      last -= 1\n    }\n\n    let semicolon = this.raw(node, 'semicolon')\n    for (let i = 0; i < node.nodes.length; i++) {\n      let child = node.nodes[i]\n      let before = this.raw(child, 'before')\n      if (before) this.builder(before)\n      this.stringify(child, last !== i || semicolon)\n    }\n  }\n\n  block(node, start) {\n    let between = this.raw(node, 'between', 'beforeOpen')\n    this.builder(start + between + '{', node, 'start')\n\n    let after\n    if (node.nodes && node.nodes.length) {\n      this.body(node)\n      after = this.raw(node, 'after')\n    } else {\n      after = this.raw(node, 'after', 'emptyBody')\n    }\n\n    if (after) this.builder(after)\n    this.builder('}', node, 'end')\n  }\n\n  raw(node, own, detect) {\n    let value\n    if (!detect) detect = own\n\n    // Already had\n    if (own) {\n      value = node.raws[own]\n      if (typeof value !== 'undefined') return value\n    }\n\n    let parent = node.parent\n\n    if (detect === 'before') {\n      // Hack for first rule in CSS\n      if (!parent || (parent.type === 'root' && parent.first === node)) {\n        return ''\n      }\n\n      // `root` nodes in `document` should use only their own raws\n      if (parent && parent.type === 'document') {\n        return ''\n      }\n    }\n\n    // Floating child without parent\n    if (!parent) return DEFAULT_RAW[detect]\n\n    // Detect style by other nodes\n    let root = node.root()\n    if (!root.rawCache) root.rawCache = {}\n    if (typeof root.rawCache[detect] !== 'undefined') {\n      return root.rawCache[detect]\n    }\n\n    if (detect === 'before' || detect === 'after') {\n      return this.beforeAfter(node, detect)\n    } else {\n      let method = 'raw' + capitalize(detect)\n      if (this[method]) {\n        value = this[method](root, node)\n      } else {\n        root.walk(i => {\n          value = i.raws[own]\n          if (typeof value !== 'undefined') return false\n        })\n      }\n    }\n\n    if (typeof value === 'undefined') value = DEFAULT_RAW[detect]\n\n    root.rawCache[detect] = value\n    return value\n  }\n\n  rawSemicolon(root) {\n    let value\n    root.walk(i => {\n      if (i.nodes && i.nodes.length && i.last.type === 'decl') {\n        value = i.raws.semicolon\n        if (typeof value !== 'undefined') return false\n      }\n    })\n    return value\n  }\n\n  rawEmptyBody(root) {\n    let value\n    root.walk(i => {\n      if (i.nodes && i.nodes.length === 0) {\n        value = i.raws.after\n        if (typeof value !== 'undefined') return false\n      }\n    })\n    return value\n  }\n\n  rawIndent(root) {\n    if (root.raws.indent) return root.raws.indent\n    let value\n    root.walk(i => {\n      let p = i.parent\n      if (p && p !== root && p.parent && p.parent === root) {\n        if (typeof i.raws.before !== 'undefined') {\n          let parts = i.raws.before.split('\\n')\n          value = parts[parts.length - 1]\n          value = value.replace(/\\S/g, '')\n          return false\n        }\n      }\n    })\n    return value\n  }\n\n  rawBeforeComment(root, node) {\n    let value\n    root.walkComments(i => {\n      if (typeof i.raws.before !== 'undefined') {\n        value = i.raws.before\n        if (value.includes('\\n')) {\n          value = value.replace(/[^\\n]+$/, '')\n        }\n        return false\n      }\n    })\n    if (typeof value === 'undefined') {\n      value = this.raw(node, null, 'beforeDecl')\n    } else if (value) {\n      value = value.replace(/\\S/g, '')\n    }\n    return value\n  }\n\n  rawBeforeDecl(root, node) {\n    let value\n    root.walkDecls(i => {\n      if (typeof i.raws.before !== 'undefined') {\n        value = i.raws.before\n        if (value.includes('\\n')) {\n          value = value.replace(/[^\\n]+$/, '')\n        }\n        return false\n      }\n    })\n    if (typeof value === 'undefined') {\n      value = this.raw(node, null, 'beforeRule')\n    } else if (value) {\n      value = value.replace(/\\S/g, '')\n    }\n    return value\n  }\n\n  rawBeforeRule(root) {\n    let value\n    root.walk(i => {\n      if (i.nodes && (i.parent !== root || root.first !== i)) {\n        if (typeof i.raws.before !== 'undefined') {\n          value = i.raws.before\n          if (value.includes('\\n')) {\n            value = value.replace(/[^\\n]+$/, '')\n          }\n          return false\n        }\n      }\n    })\n    if (value) value = value.replace(/\\S/g, '')\n    return value\n  }\n\n  rawBeforeClose(root) {\n    let value\n    root.walk(i => {\n      if (i.nodes && i.nodes.length > 0) {\n        if (typeof i.raws.after !== 'undefined') {\n          value = i.raws.after\n          if (value.includes('\\n')) {\n            value = value.replace(/[^\\n]+$/, '')\n          }\n          return false\n        }\n      }\n    })\n    if (value) value = value.replace(/\\S/g, '')\n    return value\n  }\n\n  rawBeforeOpen(root) {\n    let value\n    root.walk(i => {\n      if (i.type !== 'decl') {\n        value = i.raws.between\n        if (typeof value !== 'undefined') return false\n      }\n    })\n    return value\n  }\n\n  rawColon(root) {\n    let value\n    root.walkDecls(i => {\n      if (typeof i.raws.between !== 'undefined') {\n        value = i.raws.between.replace(/[^\\s:]/g, '')\n        return false\n      }\n    })\n    return value\n  }\n\n  beforeAfter(node, detect) {\n    let value\n    if (node.type === 'decl') {\n      value = this.raw(node, null, 'beforeDecl')\n    } else if (node.type === 'comment') {\n      value = this.raw(node, null, 'beforeComment')\n    } else if (detect === 'before') {\n      value = this.raw(node, null, 'beforeRule')\n    } else {\n      value = this.raw(node, null, 'beforeClose')\n    }\n\n    let buf = node.parent\n    let depth = 0\n    while (buf && buf.type !== 'root') {\n      depth += 1\n      buf = buf.parent\n    }\n\n    if (value.includes('\\n')) {\n      let indent = this.raw(node, null, 'indent')\n      if (indent.length) {\n        for (let step = 0; step < depth; step++) value += indent\n      }\n    }\n\n    return value\n  }\n\n  rawValue(node, prop) {\n    let value = node[prop]\n    let raw = node.raws[prop]\n    if (raw && raw.value === value) {\n      return raw.raw\n    }\n\n    return value\n  }\n}\n\nmodule.exports = Stringifier\nStringifier.default = Stringifier\n\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/postcss/lib/stringifier.js?");

/***/ }),

/***/ "./node_modules/postcss/lib/stringify.js":
/*!***********************************************!*\
  !*** ./node_modules/postcss/lib/stringify.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nlet Stringifier = __webpack_require__(/*! ./stringifier */ \"./node_modules/postcss/lib/stringifier.js\")\n\nfunction stringify(node, builder) {\n  let str = new Stringifier(builder)\n  str.stringify(node)\n}\n\nmodule.exports = stringify\nstringify.default = stringify\n\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/postcss/lib/stringify.js?");

/***/ }),

/***/ "./node_modules/postcss/lib/symbols.js":
/*!*********************************************!*\
  !*** ./node_modules/postcss/lib/symbols.js ***!
  \*********************************************/
/***/ ((module) => {

"use strict";
eval("\n\nmodule.exports.isClean = Symbol('isClean')\n\nmodule.exports.my = Symbol('my')\n\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/postcss/lib/symbols.js?");

/***/ }),

/***/ "./node_modules/postcss/lib/tokenize.js":
/*!**********************************************!*\
  !*** ./node_modules/postcss/lib/tokenize.js ***!
  \**********************************************/
/***/ ((module) => {

"use strict";
eval("\n\nconst SINGLE_QUOTE = \"'\".charCodeAt(0)\nconst DOUBLE_QUOTE = '\"'.charCodeAt(0)\nconst BACKSLASH = '\\\\'.charCodeAt(0)\nconst SLASH = '/'.charCodeAt(0)\nconst NEWLINE = '\\n'.charCodeAt(0)\nconst SPACE = ' '.charCodeAt(0)\nconst FEED = '\\f'.charCodeAt(0)\nconst TAB = '\\t'.charCodeAt(0)\nconst CR = '\\r'.charCodeAt(0)\nconst OPEN_SQUARE = '['.charCodeAt(0)\nconst CLOSE_SQUARE = ']'.charCodeAt(0)\nconst OPEN_PARENTHESES = '('.charCodeAt(0)\nconst CLOSE_PARENTHESES = ')'.charCodeAt(0)\nconst OPEN_CURLY = '{'.charCodeAt(0)\nconst CLOSE_CURLY = '}'.charCodeAt(0)\nconst SEMICOLON = ';'.charCodeAt(0)\nconst ASTERISK = '*'.charCodeAt(0)\nconst COLON = ':'.charCodeAt(0)\nconst AT = '@'.charCodeAt(0)\n\nconst RE_AT_END = /[\\t\\n\\f\\r \"#'()/;[\\\\\\]{}]/g\nconst RE_WORD_END = /[\\t\\n\\f\\r !\"#'():;@[\\\\\\]{}]|\\/(?=\\*)/g\nconst RE_BAD_BRACKET = /.[\\n\"'(/\\\\]/\nconst RE_HEX_ESCAPE = /[\\da-f]/i\n\nmodule.exports = function tokenizer(input, options = {}) {\n  let css = input.css.valueOf()\n  let ignore = options.ignoreErrors\n\n  let code, next, quote, content, escape\n  let escaped, escapePos, prev, n, currentToken\n\n  let length = css.length\n  let pos = 0\n  let buffer = []\n  let returned = []\n\n  function position() {\n    return pos\n  }\n\n  function unclosed(what) {\n    throw input.error('Unclosed ' + what, pos)\n  }\n\n  function endOfFile() {\n    return returned.length === 0 && pos >= length\n  }\n\n  function nextToken(opts) {\n    if (returned.length) return returned.pop()\n    if (pos >= length) return\n\n    let ignoreUnclosed = opts ? opts.ignoreUnclosed : false\n\n    code = css.charCodeAt(pos)\n\n    switch (code) {\n      case NEWLINE:\n      case SPACE:\n      case TAB:\n      case CR:\n      case FEED: {\n        next = pos\n        do {\n          next += 1\n          code = css.charCodeAt(next)\n        } while (\n          code === SPACE ||\n          code === NEWLINE ||\n          code === TAB ||\n          code === CR ||\n          code === FEED\n        )\n\n        currentToken = ['space', css.slice(pos, next)]\n        pos = next - 1\n        break\n      }\n\n      case OPEN_SQUARE:\n      case CLOSE_SQUARE:\n      case OPEN_CURLY:\n      case CLOSE_CURLY:\n      case COLON:\n      case SEMICOLON:\n      case CLOSE_PARENTHESES: {\n        let controlChar = String.fromCharCode(code)\n        currentToken = [controlChar, controlChar, pos]\n        break\n      }\n\n      case OPEN_PARENTHESES: {\n        prev = buffer.length ? buffer.pop()[1] : ''\n        n = css.charCodeAt(pos + 1)\n        if (\n          prev === 'url' &&\n          n !== SINGLE_QUOTE &&\n          n !== DOUBLE_QUOTE &&\n          n !== SPACE &&\n          n !== NEWLINE &&\n          n !== TAB &&\n          n !== FEED &&\n          n !== CR\n        ) {\n          next = pos\n          do {\n            escaped = false\n            next = css.indexOf(')', next + 1)\n            if (next === -1) {\n              if (ignore || ignoreUnclosed) {\n                next = pos\n                break\n              } else {\n                unclosed('bracket')\n              }\n            }\n            escapePos = next\n            while (css.charCodeAt(escapePos - 1) === BACKSLASH) {\n              escapePos -= 1\n              escaped = !escaped\n            }\n          } while (escaped)\n\n          currentToken = ['brackets', css.slice(pos, next + 1), pos, next]\n\n          pos = next\n        } else {\n          next = css.indexOf(')', pos + 1)\n          content = css.slice(pos, next + 1)\n\n          if (next === -1 || RE_BAD_BRACKET.test(content)) {\n            currentToken = ['(', '(', pos]\n          } else {\n            currentToken = ['brackets', content, pos, next]\n            pos = next\n          }\n        }\n\n        break\n      }\n\n      case SINGLE_QUOTE:\n      case DOUBLE_QUOTE: {\n        quote = code === SINGLE_QUOTE ? \"'\" : '\"'\n        next = pos\n        do {\n          escaped = false\n          next = css.indexOf(quote, next + 1)\n          if (next === -1) {\n            if (ignore || ignoreUnclosed) {\n              next = pos + 1\n              break\n            } else {\n              unclosed('string')\n            }\n          }\n          escapePos = next\n          while (css.charCodeAt(escapePos - 1) === BACKSLASH) {\n            escapePos -= 1\n            escaped = !escaped\n          }\n        } while (escaped)\n\n        currentToken = ['string', css.slice(pos, next + 1), pos, next]\n        pos = next\n        break\n      }\n\n      case AT: {\n        RE_AT_END.lastIndex = pos + 1\n        RE_AT_END.test(css)\n        if (RE_AT_END.lastIndex === 0) {\n          next = css.length - 1\n        } else {\n          next = RE_AT_END.lastIndex - 2\n        }\n\n        currentToken = ['at-word', css.slice(pos, next + 1), pos, next]\n\n        pos = next\n        break\n      }\n\n      case BACKSLASH: {\n        next = pos\n        escape = true\n        while (css.charCodeAt(next + 1) === BACKSLASH) {\n          next += 1\n          escape = !escape\n        }\n        code = css.charCodeAt(next + 1)\n        if (\n          escape &&\n          code !== SLASH &&\n          code !== SPACE &&\n          code !== NEWLINE &&\n          code !== TAB &&\n          code !== CR &&\n          code !== FEED\n        ) {\n          next += 1\n          if (RE_HEX_ESCAPE.test(css.charAt(next))) {\n            while (RE_HEX_ESCAPE.test(css.charAt(next + 1))) {\n              next += 1\n            }\n            if (css.charCodeAt(next + 1) === SPACE) {\n              next += 1\n            }\n          }\n        }\n\n        currentToken = ['word', css.slice(pos, next + 1), pos, next]\n\n        pos = next\n        break\n      }\n\n      default: {\n        if (code === SLASH && css.charCodeAt(pos + 1) === ASTERISK) {\n          next = css.indexOf('*/', pos + 2) + 1\n          if (next === 0) {\n            if (ignore || ignoreUnclosed) {\n              next = css.length\n            } else {\n              unclosed('comment')\n            }\n          }\n\n          currentToken = ['comment', css.slice(pos, next + 1), pos, next]\n          pos = next\n        } else {\n          RE_WORD_END.lastIndex = pos + 1\n          RE_WORD_END.test(css)\n          if (RE_WORD_END.lastIndex === 0) {\n            next = css.length - 1\n          } else {\n            next = RE_WORD_END.lastIndex - 2\n          }\n\n          currentToken = ['word', css.slice(pos, next + 1), pos, next]\n          buffer.push(currentToken)\n          pos = next\n        }\n\n        break\n      }\n    }\n\n    pos++\n    return currentToken\n  }\n\n  function back(token) {\n    returned.push(token)\n  }\n\n  return {\n    back,\n    nextToken,\n    endOfFile,\n    position\n  }\n}\n\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/postcss/lib/tokenize.js?");

/***/ }),

/***/ "./node_modules/postcss/lib/warn-once.js":
/*!***********************************************!*\
  !*** ./node_modules/postcss/lib/warn-once.js ***!
  \***********************************************/
/***/ ((module) => {

"use strict";
eval("/* eslint-disable no-console */\n\n\nlet printed = {}\n\nmodule.exports = function warnOnce(message) {\n  if (printed[message]) return\n  printed[message] = true\n\n  if (typeof console !== 'undefined' && console.warn) {\n    console.warn(message)\n  }\n}\n\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/postcss/lib/warn-once.js?");

/***/ }),

/***/ "./node_modules/postcss/lib/warning.js":
/*!*********************************************!*\
  !*** ./node_modules/postcss/lib/warning.js ***!
  \*********************************************/
/***/ ((module) => {

"use strict";
eval("\n\nclass Warning {\n  constructor(text, opts = {}) {\n    this.type = 'warning'\n    this.text = text\n\n    if (opts.node && opts.node.source) {\n      let range = opts.node.rangeBy(opts)\n      this.line = range.start.line\n      this.column = range.start.column\n      this.endLine = range.end.line\n      this.endColumn = range.end.column\n    }\n\n    for (let opt in opts) this[opt] = opts[opt]\n  }\n\n  toString() {\n    if (this.node) {\n      return this.node.error(this.text, {\n        plugin: this.plugin,\n        index: this.index,\n        word: this.word\n      }).message\n    }\n\n    if (this.plugin) {\n      return this.plugin + ': ' + this.text\n    }\n\n    return this.text\n  }\n}\n\nmodule.exports = Warning\nWarning.default = Warning\n\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/postcss/lib/warning.js?");

/***/ }),

/***/ "./node_modules/queue-microtask/index.js":
/*!***********************************************!*\
  !*** ./node_modules/queue-microtask/index.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*! queue-microtask. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */\nlet promise\n\nmodule.exports = typeof queueMicrotask === 'function'\n  ? queueMicrotask.bind(typeof window !== 'undefined' ? window : __webpack_require__.g)\n  // reuse resolved promise, and allocate it lazily\n  : cb => (promise || (promise = Promise.resolve()))\n    .then(cb)\n    .catch(err => setTimeout(() => { throw err }, 0))\n\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/queue-microtask/index.js?");

/***/ }),

/***/ "./node_modules/quick-lru/index.js":
/*!*****************************************!*\
  !*** ./node_modules/quick-lru/index.js ***!
  \*****************************************/
/***/ ((module) => {

"use strict";
eval("\n\nclass QuickLRU {\n\tconstructor(options = {}) {\n\t\tif (!(options.maxSize && options.maxSize > 0)) {\n\t\t\tthrow new TypeError('`maxSize` must be a number greater than 0');\n\t\t}\n\n\t\tthis.maxSize = options.maxSize;\n\t\tthis.onEviction = options.onEviction;\n\t\tthis.cache = new Map();\n\t\tthis.oldCache = new Map();\n\t\tthis._size = 0;\n\t}\n\n\t_set(key, value) {\n\t\tthis.cache.set(key, value);\n\t\tthis._size++;\n\n\t\tif (this._size >= this.maxSize) {\n\t\t\tthis._size = 0;\n\n\t\t\tif (typeof this.onEviction === 'function') {\n\t\t\t\tfor (const [key, value] of this.oldCache.entries()) {\n\t\t\t\t\tthis.onEviction(key, value);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.oldCache = this.cache;\n\t\t\tthis.cache = new Map();\n\t\t}\n\t}\n\n\tget(key) {\n\t\tif (this.cache.has(key)) {\n\t\t\treturn this.cache.get(key);\n\t\t}\n\n\t\tif (this.oldCache.has(key)) {\n\t\t\tconst value = this.oldCache.get(key);\n\t\t\tthis.oldCache.delete(key);\n\t\t\tthis._set(key, value);\n\t\t\treturn value;\n\t\t}\n\t}\n\n\tset(key, value) {\n\t\tif (this.cache.has(key)) {\n\t\t\tthis.cache.set(key, value);\n\t\t} else {\n\t\t\tthis._set(key, value);\n\t\t}\n\n\t\treturn this;\n\t}\n\n\thas(key) {\n\t\treturn this.cache.has(key) || this.oldCache.has(key);\n\t}\n\n\tpeek(key) {\n\t\tif (this.cache.has(key)) {\n\t\t\treturn this.cache.get(key);\n\t\t}\n\n\t\tif (this.oldCache.has(key)) {\n\t\t\treturn this.oldCache.get(key);\n\t\t}\n\t}\n\n\tdelete(key) {\n\t\tconst deleted = this.cache.delete(key);\n\t\tif (deleted) {\n\t\t\tthis._size--;\n\t\t}\n\n\t\treturn this.oldCache.delete(key) || deleted;\n\t}\n\n\tclear() {\n\t\tthis.cache.clear();\n\t\tthis.oldCache.clear();\n\t\tthis._size = 0;\n\t}\n\n\t* keys() {\n\t\tfor (const [key] of this) {\n\t\t\tyield key;\n\t\t}\n\t}\n\n\t* values() {\n\t\tfor (const [, value] of this) {\n\t\t\tyield value;\n\t\t}\n\t}\n\n\t* [Symbol.iterator]() {\n\t\tfor (const item of this.cache) {\n\t\t\tyield item;\n\t\t}\n\n\t\tfor (const item of this.oldCache) {\n\t\t\tconst [key] = item;\n\t\t\tif (!this.cache.has(key)) {\n\t\t\t\tyield item;\n\t\t\t}\n\t\t}\n\t}\n\n\tget size() {\n\t\tlet oldCacheSize = 0;\n\t\tfor (const key of this.oldCache.keys()) {\n\t\t\tif (!this.cache.has(key)) {\n\t\t\t\toldCacheSize++;\n\t\t\t}\n\t\t}\n\n\t\treturn Math.min(this._size + oldCacheSize, this.maxSize);\n\t}\n}\n\nmodule.exports = QuickLRU;\n\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/quick-lru/index.js?");

/***/ }),

/***/ "./node_modules/resolve/index.js":
/*!***************************************!*\
  !*** ./node_modules/resolve/index.js ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var async = __webpack_require__(/*! ./lib/async */ \"./node_modules/resolve/lib/async.js\");\nasync.core = __webpack_require__(/*! ./lib/core */ \"./node_modules/resolve/lib/core.js\");\nasync.isCore = __webpack_require__(/*! ./lib/is-core */ \"./node_modules/resolve/lib/is-core.js\");\nasync.sync = __webpack_require__(/*! ./lib/sync */ \"./node_modules/resolve/lib/sync.js\");\n\nmodule.exports = async;\n\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/resolve/index.js?");

/***/ }),

/***/ "./node_modules/resolve/lib/async.js":
/*!*******************************************!*\
  !*** ./node_modules/resolve/lib/async.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var fs = __webpack_require__(Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'fs'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));\nvar getHomedir = __webpack_require__(/*! ./homedir */ \"./node_modules/resolve/lib/homedir.js\");\nvar path = __webpack_require__(Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'path'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));\nvar caller = __webpack_require__(/*! ./caller */ \"./node_modules/resolve/lib/caller.js\");\nvar nodeModulesPaths = __webpack_require__(/*! ./node-modules-paths */ \"./node_modules/resolve/lib/node-modules-paths.js\");\nvar normalizeOptions = __webpack_require__(/*! ./normalize-options */ \"./node_modules/resolve/lib/normalize-options.js\");\nvar isCore = __webpack_require__(/*! is-core-module */ \"./node_modules/is-core-module/index.js\");\n\nvar realpathFS = process.platform !== 'win32' && fs.realpath && typeof fs.realpath.native === 'function' ? fs.realpath.native : fs.realpath;\n\nvar homedir = getHomedir();\nvar defaultPaths = function () {\n    return [\n        path.join(homedir, '.node_modules'),\n        path.join(homedir, '.node_libraries')\n    ];\n};\n\nvar defaultIsFile = function isFile(file, cb) {\n    fs.stat(file, function (err, stat) {\n        if (!err) {\n            return cb(null, stat.isFile() || stat.isFIFO());\n        }\n        if (err.code === 'ENOENT' || err.code === 'ENOTDIR') return cb(null, false);\n        return cb(err);\n    });\n};\n\nvar defaultIsDir = function isDirectory(dir, cb) {\n    fs.stat(dir, function (err, stat) {\n        if (!err) {\n            return cb(null, stat.isDirectory());\n        }\n        if (err.code === 'ENOENT' || err.code === 'ENOTDIR') return cb(null, false);\n        return cb(err);\n    });\n};\n\nvar defaultRealpath = function realpath(x, cb) {\n    realpathFS(x, function (realpathErr, realPath) {\n        if (realpathErr && realpathErr.code !== 'ENOENT') cb(realpathErr);\n        else cb(null, realpathErr ? x : realPath);\n    });\n};\n\nvar maybeRealpath = function maybeRealpath(realpath, x, opts, cb) {\n    if (opts && opts.preserveSymlinks === false) {\n        realpath(x, cb);\n    } else {\n        cb(null, x);\n    }\n};\n\nvar defaultReadPackage = function defaultReadPackage(readFile, pkgfile, cb) {\n    readFile(pkgfile, function (readFileErr, body) {\n        if (readFileErr) cb(readFileErr);\n        else {\n            try {\n                var pkg = JSON.parse(body);\n                cb(null, pkg);\n            } catch (jsonErr) {\n                cb(null);\n            }\n        }\n    });\n};\n\nvar getPackageCandidates = function getPackageCandidates(x, start, opts) {\n    var dirs = nodeModulesPaths(start, opts, x);\n    for (var i = 0; i < dirs.length; i++) {\n        dirs[i] = path.join(dirs[i], x);\n    }\n    return dirs;\n};\n\nmodule.exports = function resolve(x, options, callback) {\n    var cb = callback;\n    var opts = options;\n    if (typeof options === 'function') {\n        cb = opts;\n        opts = {};\n    }\n    if (typeof x !== 'string') {\n        var err = new TypeError('Path must be a string.');\n        return process.nextTick(function () {\n            cb(err);\n        });\n    }\n\n    opts = normalizeOptions(x, opts);\n\n    var isFile = opts.isFile || defaultIsFile;\n    var isDirectory = opts.isDirectory || defaultIsDir;\n    var readFile = opts.readFile || fs.readFile;\n    var realpath = opts.realpath || defaultRealpath;\n    var readPackage = opts.readPackage || defaultReadPackage;\n    if (opts.readFile && opts.readPackage) {\n        var conflictErr = new TypeError('`readFile` and `readPackage` are mutually exclusive.');\n        return process.nextTick(function () {\n            cb(conflictErr);\n        });\n    }\n    var packageIterator = opts.packageIterator;\n\n    var extensions = opts.extensions || ['.js'];\n    var includeCoreModules = opts.includeCoreModules !== false;\n    var basedir = opts.basedir || path.dirname(caller());\n    var parent = opts.filename || basedir;\n\n    opts.paths = opts.paths || defaultPaths();\n\n    // ensure that `basedir` is an absolute path at this point, resolving against the process' current working directory\n    var absoluteStart = path.resolve(basedir);\n\n    maybeRealpath(\n        realpath,\n        absoluteStart,\n        opts,\n        function (err, realStart) {\n            if (err) cb(err);\n            else init(realStart);\n        }\n    );\n\n    var res;\n    function init(basedir) {\n        if ((/^(?:\\.\\.?(?:\\/|$)|\\/|([A-Za-z]:)?[/\\\\])/).test(x)) {\n            res = path.resolve(basedir, x);\n            if (x === '.' || x === '..' || x.slice(-1) === '/') res += '/';\n            if ((/\\/$/).test(x) && res === basedir) {\n                loadAsDirectory(res, opts.package, onfile);\n            } else loadAsFile(res, opts.package, onfile);\n        } else if (includeCoreModules && isCore(x)) {\n            return cb(null, x);\n        } else loadNodeModules(x, basedir, function (err, n, pkg) {\n            if (err) cb(err);\n            else if (n) {\n                return maybeRealpath(realpath, n, opts, function (err, realN) {\n                    if (err) {\n                        cb(err);\n                    } else {\n                        cb(null, realN, pkg);\n                    }\n                });\n            } else {\n                var moduleError = new Error(\"Cannot find module '\" + x + \"' from '\" + parent + \"'\");\n                moduleError.code = 'MODULE_NOT_FOUND';\n                cb(moduleError);\n            }\n        });\n    }\n\n    function onfile(err, m, pkg) {\n        if (err) cb(err);\n        else if (m) cb(null, m, pkg);\n        else loadAsDirectory(res, function (err, d, pkg) {\n            if (err) cb(err);\n            else if (d) {\n                maybeRealpath(realpath, d, opts, function (err, realD) {\n                    if (err) {\n                        cb(err);\n                    } else {\n                        cb(null, realD, pkg);\n                    }\n                });\n            } else {\n                var moduleError = new Error(\"Cannot find module '\" + x + \"' from '\" + parent + \"'\");\n                moduleError.code = 'MODULE_NOT_FOUND';\n                cb(moduleError);\n            }\n        });\n    }\n\n    function loadAsFile(x, thePackage, callback) {\n        var loadAsFilePackage = thePackage;\n        var cb = callback;\n        if (typeof loadAsFilePackage === 'function') {\n            cb = loadAsFilePackage;\n            loadAsFilePackage = undefined;\n        }\n\n        var exts = [''].concat(extensions);\n        load(exts, x, loadAsFilePackage);\n\n        function load(exts, x, loadPackage) {\n            if (exts.length === 0) return cb(null, undefined, loadPackage);\n            var file = x + exts[0];\n\n            var pkg = loadPackage;\n            if (pkg) onpkg(null, pkg);\n            else loadpkg(path.dirname(file), onpkg);\n\n            function onpkg(err, pkg_, dir) {\n                pkg = pkg_;\n                if (err) return cb(err);\n                if (dir && pkg && opts.pathFilter) {\n                    var rfile = path.relative(dir, file);\n                    var rel = rfile.slice(0, rfile.length - exts[0].length);\n                    var r = opts.pathFilter(pkg, x, rel);\n                    if (r) return load(\n                        [''].concat(extensions.slice()),\n                        path.resolve(dir, r),\n                        pkg\n                    );\n                }\n                isFile(file, onex);\n            }\n            function onex(err, ex) {\n                if (err) return cb(err);\n                if (ex) return cb(null, file, pkg);\n                load(exts.slice(1), x, pkg);\n            }\n        }\n    }\n\n    function loadpkg(dir, cb) {\n        if (dir === '' || dir === '/') return cb(null);\n        if (process.platform === 'win32' && (/^\\w:[/\\\\]*$/).test(dir)) {\n            return cb(null);\n        }\n        if ((/[/\\\\]node_modules[/\\\\]*$/).test(dir)) return cb(null);\n\n        maybeRealpath(realpath, dir, opts, function (unwrapErr, pkgdir) {\n            if (unwrapErr) return loadpkg(path.dirname(dir), cb);\n            var pkgfile = path.join(pkgdir, 'package.json');\n            isFile(pkgfile, function (err, ex) {\n                // on err, ex is false\n                if (!ex) return loadpkg(path.dirname(dir), cb);\n\n                readPackage(readFile, pkgfile, function (err, pkgParam) {\n                    if (err) cb(err);\n\n                    var pkg = pkgParam;\n\n                    if (pkg && opts.packageFilter) {\n                        pkg = opts.packageFilter(pkg, pkgfile);\n                    }\n                    cb(null, pkg, dir);\n                });\n            });\n        });\n    }\n\n    function loadAsDirectory(x, loadAsDirectoryPackage, callback) {\n        var cb = callback;\n        var fpkg = loadAsDirectoryPackage;\n        if (typeof fpkg === 'function') {\n            cb = fpkg;\n            fpkg = opts.package;\n        }\n\n        maybeRealpath(realpath, x, opts, function (unwrapErr, pkgdir) {\n            if (unwrapErr) return cb(unwrapErr);\n            var pkgfile = path.join(pkgdir, 'package.json');\n            isFile(pkgfile, function (err, ex) {\n                if (err) return cb(err);\n                if (!ex) return loadAsFile(path.join(x, 'index'), fpkg, cb);\n\n                readPackage(readFile, pkgfile, function (err, pkgParam) {\n                    if (err) return cb(err);\n\n                    var pkg = pkgParam;\n\n                    if (pkg && opts.packageFilter) {\n                        pkg = opts.packageFilter(pkg, pkgfile);\n                    }\n\n                    if (pkg && pkg.main) {\n                        if (typeof pkg.main !== 'string') {\n                            var mainError = new TypeError('package “' + pkg.name + '” `main` must be a string');\n                            mainError.code = 'INVALID_PACKAGE_MAIN';\n                            return cb(mainError);\n                        }\n                        if (pkg.main === '.' || pkg.main === './') {\n                            pkg.main = 'index';\n                        }\n                        loadAsFile(path.resolve(x, pkg.main), pkg, function (err, m, pkg) {\n                            if (err) return cb(err);\n                            if (m) return cb(null, m, pkg);\n                            if (!pkg) return loadAsFile(path.join(x, 'index'), pkg, cb);\n\n                            var dir = path.resolve(x, pkg.main);\n                            loadAsDirectory(dir, pkg, function (err, n, pkg) {\n                                if (err) return cb(err);\n                                if (n) return cb(null, n, pkg);\n                                loadAsFile(path.join(x, 'index'), pkg, cb);\n                            });\n                        });\n                        return;\n                    }\n\n                    loadAsFile(path.join(x, '/index'), pkg, cb);\n                });\n            });\n        });\n    }\n\n    function processDirs(cb, dirs) {\n        if (dirs.length === 0) return cb(null, undefined);\n        var dir = dirs[0];\n\n        isDirectory(path.dirname(dir), isdir);\n\n        function isdir(err, isdir) {\n            if (err) return cb(err);\n            if (!isdir) return processDirs(cb, dirs.slice(1));\n            loadAsFile(dir, opts.package, onfile);\n        }\n\n        function onfile(err, m, pkg) {\n            if (err) return cb(err);\n            if (m) return cb(null, m, pkg);\n            loadAsDirectory(dir, opts.package, ondir);\n        }\n\n        function ondir(err, n, pkg) {\n            if (err) return cb(err);\n            if (n) return cb(null, n, pkg);\n            processDirs(cb, dirs.slice(1));\n        }\n    }\n    function loadNodeModules(x, start, cb) {\n        var thunk = function () { return getPackageCandidates(x, start, opts); };\n        processDirs(\n            cb,\n            packageIterator ? packageIterator(x, start, thunk, opts) : thunk()\n        );\n    }\n};\n\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/resolve/lib/async.js?");

/***/ }),

/***/ "./node_modules/resolve/lib/caller.js":
/*!********************************************!*\
  !*** ./node_modules/resolve/lib/caller.js ***!
  \********************************************/
/***/ ((module) => {

eval("module.exports = function () {\n    // see https://code.google.com/p/v8/wiki/JavaScriptStackTraceApi\n    var origPrepareStackTrace = Error.prepareStackTrace;\n    Error.prepareStackTrace = function (_, stack) { return stack; };\n    var stack = (new Error()).stack;\n    Error.prepareStackTrace = origPrepareStackTrace;\n    return stack[2].getFileName();\n};\n\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/resolve/lib/caller.js?");

/***/ }),

/***/ "./node_modules/resolve/lib/core.js":
/*!******************************************!*\
  !*** ./node_modules/resolve/lib/core.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var current = (process.versions && process.versions.node && process.versions.node.split('.')) || [];\n\nfunction specifierIncluded(specifier) {\n    var parts = specifier.split(' ');\n    var op = parts.length > 1 ? parts[0] : '=';\n    var versionParts = (parts.length > 1 ? parts[1] : parts[0]).split('.');\n\n    for (var i = 0; i < 3; ++i) {\n        var cur = parseInt(current[i] || 0, 10);\n        var ver = parseInt(versionParts[i] || 0, 10);\n        if (cur === ver) {\n            continue; // eslint-disable-line no-restricted-syntax, no-continue\n        }\n        if (op === '<') {\n            return cur < ver;\n        } else if (op === '>=') {\n            return cur >= ver;\n        }\n        return false;\n    }\n    return op === '>=';\n}\n\nfunction matchesRange(range) {\n    var specifiers = range.split(/ ?&& ?/);\n    if (specifiers.length === 0) { return false; }\n    for (var i = 0; i < specifiers.length; ++i) {\n        if (!specifierIncluded(specifiers[i])) { return false; }\n    }\n    return true;\n}\n\nfunction versionIncluded(specifierValue) {\n    if (typeof specifierValue === 'boolean') { return specifierValue; }\n    if (specifierValue && typeof specifierValue === 'object') {\n        for (var i = 0; i < specifierValue.length; ++i) {\n            if (matchesRange(specifierValue[i])) { return true; }\n        }\n        return false;\n    }\n    return matchesRange(specifierValue);\n}\n\nvar data = __webpack_require__(/*! ./core.json */ \"./node_modules/resolve/lib/core.json\");\n\nvar core = {};\nfor (var mod in data) { // eslint-disable-line no-restricted-syntax\n    if (Object.prototype.hasOwnProperty.call(data, mod)) {\n        core[mod] = versionIncluded(data[mod]);\n    }\n}\nmodule.exports = core;\n\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/resolve/lib/core.js?");

/***/ }),

/***/ "./node_modules/resolve/lib/homedir.js":
/*!*********************************************!*\
  !*** ./node_modules/resolve/lib/homedir.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar os = __webpack_require__(Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'os'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));\n\n// adapted from https://github.com/sindresorhus/os-homedir/blob/11e089f4754db38bb535e5a8416320c4446e8cfd/index.js\n\nmodule.exports = os.homedir || function homedir() {\n    var home = process.env.HOME;\n    var user = process.env.LOGNAME || process.env.USER || process.env.LNAME || process.env.USERNAME;\n\n    if (process.platform === 'win32') {\n        return process.env.USERPROFILE || process.env.HOMEDRIVE + process.env.HOMEPATH || home || null;\n    }\n\n    if (process.platform === 'darwin') {\n        return home || (user ? '/Users/' + user : null);\n    }\n\n    if (process.platform === 'linux') {\n        return home || (process.getuid() === 0 ? '/root' : (user ? '/home/' + user : null)); // eslint-disable-line no-extra-parens\n    }\n\n    return home || null;\n};\n\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/resolve/lib/homedir.js?");

/***/ }),

/***/ "./node_modules/resolve/lib/is-core.js":
/*!*********************************************!*\
  !*** ./node_modules/resolve/lib/is-core.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var isCoreModule = __webpack_require__(/*! is-core-module */ \"./node_modules/is-core-module/index.js\");\n\nmodule.exports = function isCore(x) {\n    return isCoreModule(x);\n};\n\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/resolve/lib/is-core.js?");

/***/ }),

/***/ "./node_modules/resolve/lib/node-modules-paths.js":
/*!********************************************************!*\
  !*** ./node_modules/resolve/lib/node-modules-paths.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var path = __webpack_require__(Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'path'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));\nvar parse = path.parse || __webpack_require__(/*! path-parse */ \"./node_modules/path-parse/index.js\"); // eslint-disable-line global-require\n\nvar getNodeModulesDirs = function getNodeModulesDirs(absoluteStart, modules) {\n    var prefix = '/';\n    if ((/^([A-Za-z]:)/).test(absoluteStart)) {\n        prefix = '';\n    } else if ((/^\\\\\\\\/).test(absoluteStart)) {\n        prefix = '\\\\\\\\';\n    }\n\n    var paths = [absoluteStart];\n    var parsed = parse(absoluteStart);\n    while (parsed.dir !== paths[paths.length - 1]) {\n        paths.push(parsed.dir);\n        parsed = parse(parsed.dir);\n    }\n\n    return paths.reduce(function (dirs, aPath) {\n        return dirs.concat(modules.map(function (moduleDir) {\n            return path.resolve(prefix, aPath, moduleDir);\n        }));\n    }, []);\n};\n\nmodule.exports = function nodeModulesPaths(start, opts, request) {\n    var modules = opts && opts.moduleDirectory\n        ? [].concat(opts.moduleDirectory)\n        : ['node_modules'];\n\n    if (opts && typeof opts.paths === 'function') {\n        return opts.paths(\n            request,\n            start,\n            function () { return getNodeModulesDirs(start, modules); },\n            opts\n        );\n    }\n\n    var dirs = getNodeModulesDirs(start, modules);\n    return opts && opts.paths ? dirs.concat(opts.paths) : dirs;\n};\n\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/resolve/lib/node-modules-paths.js?");

/***/ }),

/***/ "./node_modules/resolve/lib/normalize-options.js":
/*!*******************************************************!*\
  !*** ./node_modules/resolve/lib/normalize-options.js ***!
  \*******************************************************/
/***/ ((module) => {

eval("module.exports = function (x, opts) {\n    /**\n     * This file is purposefully a passthrough. It's expected that third-party\n     * environments will override it at runtime in order to inject special logic\n     * into `resolve` (by manipulating the options). One such example is the PnP\n     * code path in Yarn.\n     */\n\n    return opts || {};\n};\n\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/resolve/lib/normalize-options.js?");

/***/ }),

/***/ "./node_modules/resolve/lib/sync.js":
/*!******************************************!*\
  !*** ./node_modules/resolve/lib/sync.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var isCore = __webpack_require__(/*! is-core-module */ \"./node_modules/is-core-module/index.js\");\nvar fs = __webpack_require__(Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'fs'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));\nvar path = __webpack_require__(Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'path'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));\nvar getHomedir = __webpack_require__(/*! ./homedir */ \"./node_modules/resolve/lib/homedir.js\");\nvar caller = __webpack_require__(/*! ./caller */ \"./node_modules/resolve/lib/caller.js\");\nvar nodeModulesPaths = __webpack_require__(/*! ./node-modules-paths */ \"./node_modules/resolve/lib/node-modules-paths.js\");\nvar normalizeOptions = __webpack_require__(/*! ./normalize-options */ \"./node_modules/resolve/lib/normalize-options.js\");\n\nvar realpathFS = process.platform !== 'win32' && fs.realpathSync && typeof fs.realpathSync.native === 'function' ? fs.realpathSync.native : fs.realpathSync;\n\nvar homedir = getHomedir();\nvar defaultPaths = function () {\n    return [\n        path.join(homedir, '.node_modules'),\n        path.join(homedir, '.node_libraries')\n    ];\n};\n\nvar defaultIsFile = function isFile(file) {\n    try {\n        var stat = fs.statSync(file, { throwIfNoEntry: false });\n    } catch (e) {\n        if (e && (e.code === 'ENOENT' || e.code === 'ENOTDIR')) return false;\n        throw e;\n    }\n    return !!stat && (stat.isFile() || stat.isFIFO());\n};\n\nvar defaultIsDir = function isDirectory(dir) {\n    try {\n        var stat = fs.statSync(dir, { throwIfNoEntry: false });\n    } catch (e) {\n        if (e && (e.code === 'ENOENT' || e.code === 'ENOTDIR')) return false;\n        throw e;\n    }\n    return !!stat && stat.isDirectory();\n};\n\nvar defaultRealpathSync = function realpathSync(x) {\n    try {\n        return realpathFS(x);\n    } catch (realpathErr) {\n        if (realpathErr.code !== 'ENOENT') {\n            throw realpathErr;\n        }\n    }\n    return x;\n};\n\nvar maybeRealpathSync = function maybeRealpathSync(realpathSync, x, opts) {\n    if (opts && opts.preserveSymlinks === false) {\n        return realpathSync(x);\n    }\n    return x;\n};\n\nvar defaultReadPackageSync = function defaultReadPackageSync(readFileSync, pkgfile) {\n    var body = readFileSync(pkgfile);\n    try {\n        var pkg = JSON.parse(body);\n        return pkg;\n    } catch (jsonErr) {}\n};\n\nvar getPackageCandidates = function getPackageCandidates(x, start, opts) {\n    var dirs = nodeModulesPaths(start, opts, x);\n    for (var i = 0; i < dirs.length; i++) {\n        dirs[i] = path.join(dirs[i], x);\n    }\n    return dirs;\n};\n\nmodule.exports = function resolveSync(x, options) {\n    if (typeof x !== 'string') {\n        throw new TypeError('Path must be a string.');\n    }\n    var opts = normalizeOptions(x, options);\n\n    var isFile = opts.isFile || defaultIsFile;\n    var readFileSync = opts.readFileSync || fs.readFileSync;\n    var isDirectory = opts.isDirectory || defaultIsDir;\n    var realpathSync = opts.realpathSync || defaultRealpathSync;\n    var readPackageSync = opts.readPackageSync || defaultReadPackageSync;\n    if (opts.readFileSync && opts.readPackageSync) {\n        throw new TypeError('`readFileSync` and `readPackageSync` are mutually exclusive.');\n    }\n    var packageIterator = opts.packageIterator;\n\n    var extensions = opts.extensions || ['.js'];\n    var includeCoreModules = opts.includeCoreModules !== false;\n    var basedir = opts.basedir || path.dirname(caller());\n    var parent = opts.filename || basedir;\n\n    opts.paths = opts.paths || defaultPaths();\n\n    // ensure that `basedir` is an absolute path at this point, resolving against the process' current working directory\n    var absoluteStart = maybeRealpathSync(realpathSync, path.resolve(basedir), opts);\n\n    if ((/^(?:\\.\\.?(?:\\/|$)|\\/|([A-Za-z]:)?[/\\\\])/).test(x)) {\n        var res = path.resolve(absoluteStart, x);\n        if (x === '.' || x === '..' || x.slice(-1) === '/') res += '/';\n        var m = loadAsFileSync(res) || loadAsDirectorySync(res);\n        if (m) return maybeRealpathSync(realpathSync, m, opts);\n    } else if (includeCoreModules && isCore(x)) {\n        return x;\n    } else {\n        var n = loadNodeModulesSync(x, absoluteStart);\n        if (n) return maybeRealpathSync(realpathSync, n, opts);\n    }\n\n    var err = new Error(\"Cannot find module '\" + x + \"' from '\" + parent + \"'\");\n    err.code = 'MODULE_NOT_FOUND';\n    throw err;\n\n    function loadAsFileSync(x) {\n        var pkg = loadpkg(path.dirname(x));\n\n        if (pkg && pkg.dir && pkg.pkg && opts.pathFilter) {\n            var rfile = path.relative(pkg.dir, x);\n            var r = opts.pathFilter(pkg.pkg, x, rfile);\n            if (r) {\n                x = path.resolve(pkg.dir, r); // eslint-disable-line no-param-reassign\n            }\n        }\n\n        if (isFile(x)) {\n            return x;\n        }\n\n        for (var i = 0; i < extensions.length; i++) {\n            var file = x + extensions[i];\n            if (isFile(file)) {\n                return file;\n            }\n        }\n    }\n\n    function loadpkg(dir) {\n        if (dir === '' || dir === '/') return;\n        if (process.platform === 'win32' && (/^\\w:[/\\\\]*$/).test(dir)) {\n            return;\n        }\n        if ((/[/\\\\]node_modules[/\\\\]*$/).test(dir)) return;\n\n        var pkgfile = path.join(maybeRealpathSync(realpathSync, dir, opts), 'package.json');\n\n        if (!isFile(pkgfile)) {\n            return loadpkg(path.dirname(dir));\n        }\n\n        var pkg = readPackageSync(readFileSync, pkgfile);\n\n        if (pkg && opts.packageFilter) {\n            // v2 will pass pkgfile\n            pkg = opts.packageFilter(pkg, /*pkgfile,*/ dir); // eslint-disable-line spaced-comment\n        }\n\n        return { pkg: pkg, dir: dir };\n    }\n\n    function loadAsDirectorySync(x) {\n        var pkgfile = path.join(maybeRealpathSync(realpathSync, x, opts), '/package.json');\n        if (isFile(pkgfile)) {\n            try {\n                var pkg = readPackageSync(readFileSync, pkgfile);\n            } catch (e) {}\n\n            if (pkg && opts.packageFilter) {\n                // v2 will pass pkgfile\n                pkg = opts.packageFilter(pkg, /*pkgfile,*/ x); // eslint-disable-line spaced-comment\n            }\n\n            if (pkg && pkg.main) {\n                if (typeof pkg.main !== 'string') {\n                    var mainError = new TypeError('package “' + pkg.name + '” `main` must be a string');\n                    mainError.code = 'INVALID_PACKAGE_MAIN';\n                    throw mainError;\n                }\n                if (pkg.main === '.' || pkg.main === './') {\n                    pkg.main = 'index';\n                }\n                try {\n                    var m = loadAsFileSync(path.resolve(x, pkg.main));\n                    if (m) return m;\n                    var n = loadAsDirectorySync(path.resolve(x, pkg.main));\n                    if (n) return n;\n                } catch (e) {}\n            }\n        }\n\n        return loadAsFileSync(path.join(x, '/index'));\n    }\n\n    function loadNodeModulesSync(x, start) {\n        var thunk = function () { return getPackageCandidates(x, start, opts); };\n        var dirs = packageIterator ? packageIterator(x, start, thunk, opts) : thunk();\n\n        for (var i = 0; i < dirs.length; i++) {\n            var dir = dirs[i];\n            if (isDirectory(path.dirname(dir))) {\n                var m = loadAsFileSync(dir);\n                if (m) return m;\n                var n = loadAsDirectorySync(dir);\n                if (n) return n;\n            }\n        }\n    }\n};\n\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/resolve/lib/sync.js?");

/***/ }),

/***/ "./node_modules/reusify/reusify.js":
/*!*****************************************!*\
  !*** ./node_modules/reusify/reusify.js ***!
  \*****************************************/
/***/ ((module) => {

"use strict";
eval("\n\nfunction reusify (Constructor) {\n  var head = new Constructor()\n  var tail = head\n\n  function get () {\n    var current = head\n\n    if (current.next) {\n      head = current.next\n    } else {\n      head = new Constructor()\n      tail = head\n    }\n\n    current.next = null\n\n    return current\n  }\n\n  function release (obj) {\n    tail.next = obj\n    tail = obj\n  }\n\n  return {\n    get: get,\n    release: release\n  }\n}\n\nmodule.exports = reusify\n\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/reusify/reusify.js?");

/***/ }),

/***/ "./node_modules/run-parallel/index.js":
/*!********************************************!*\
  !*** ./node_modules/run-parallel/index.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*! run-parallel. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */\nmodule.exports = runParallel\n\nconst queueMicrotask = __webpack_require__(/*! queue-microtask */ \"./node_modules/queue-microtask/index.js\")\n\nfunction runParallel (tasks, cb) {\n  let results, pending, keys\n  let isSync = true\n\n  if (Array.isArray(tasks)) {\n    results = []\n    pending = tasks.length\n  } else {\n    keys = Object.keys(tasks)\n    results = {}\n    pending = keys.length\n  }\n\n  function done (err) {\n    function end () {\n      if (cb) cb(err, results)\n      cb = null\n    }\n    if (isSync) queueMicrotask(end)\n    else end()\n  }\n\n  function each (i, err, result) {\n    results[i] = result\n    if (--pending === 0 || err) {\n      done(err)\n    }\n  }\n\n  if (!pending) {\n    // empty\n    done(null)\n  } else if (keys) {\n    // object\n    keys.forEach(function (key) {\n      tasks[key](function (err, result) { each(key, err, result) })\n    })\n  } else {\n    // array\n    tasks.forEach(function (task, i) {\n      task(function (err, result) { each(i, err, result) })\n    })\n  }\n\n  isSync = false\n}\n\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/run-parallel/index.js?");

/***/ }),

/***/ "./node_modules/tailwindcss/lib/corePluginList.js":
/*!********************************************************!*\
  !*** ./node_modules/tailwindcss/lib/corePluginList.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"default\", ({\n    enumerable: true,\n    get: ()=>_default\n}));\nconst _default = [\n    \"preflight\",\n    \"container\",\n    \"accessibility\",\n    \"pointerEvents\",\n    \"visibility\",\n    \"position\",\n    \"inset\",\n    \"isolation\",\n    \"zIndex\",\n    \"order\",\n    \"gridColumn\",\n    \"gridColumnStart\",\n    \"gridColumnEnd\",\n    \"gridRow\",\n    \"gridRowStart\",\n    \"gridRowEnd\",\n    \"float\",\n    \"clear\",\n    \"margin\",\n    \"boxSizing\",\n    \"display\",\n    \"aspectRatio\",\n    \"height\",\n    \"maxHeight\",\n    \"minHeight\",\n    \"width\",\n    \"minWidth\",\n    \"maxWidth\",\n    \"flex\",\n    \"flexShrink\",\n    \"flexGrow\",\n    \"flexBasis\",\n    \"tableLayout\",\n    \"borderCollapse\",\n    \"borderSpacing\",\n    \"transformOrigin\",\n    \"translate\",\n    \"rotate\",\n    \"skew\",\n    \"scale\",\n    \"transform\",\n    \"animation\",\n    \"cursor\",\n    \"touchAction\",\n    \"userSelect\",\n    \"resize\",\n    \"scrollSnapType\",\n    \"scrollSnapAlign\",\n    \"scrollSnapStop\",\n    \"scrollMargin\",\n    \"scrollPadding\",\n    \"listStylePosition\",\n    \"listStyleType\",\n    \"appearance\",\n    \"columns\",\n    \"breakBefore\",\n    \"breakInside\",\n    \"breakAfter\",\n    \"gridAutoColumns\",\n    \"gridAutoFlow\",\n    \"gridAutoRows\",\n    \"gridTemplateColumns\",\n    \"gridTemplateRows\",\n    \"flexDirection\",\n    \"flexWrap\",\n    \"placeContent\",\n    \"placeItems\",\n    \"alignContent\",\n    \"alignItems\",\n    \"justifyContent\",\n    \"justifyItems\",\n    \"gap\",\n    \"space\",\n    \"divideWidth\",\n    \"divideStyle\",\n    \"divideColor\",\n    \"divideOpacity\",\n    \"placeSelf\",\n    \"alignSelf\",\n    \"justifySelf\",\n    \"overflow\",\n    \"overscrollBehavior\",\n    \"scrollBehavior\",\n    \"textOverflow\",\n    \"whitespace\",\n    \"wordBreak\",\n    \"borderRadius\",\n    \"borderWidth\",\n    \"borderStyle\",\n    \"borderColor\",\n    \"borderOpacity\",\n    \"backgroundColor\",\n    \"backgroundOpacity\",\n    \"backgroundImage\",\n    \"gradientColorStops\",\n    \"boxDecorationBreak\",\n    \"backgroundSize\",\n    \"backgroundAttachment\",\n    \"backgroundClip\",\n    \"backgroundPosition\",\n    \"backgroundRepeat\",\n    \"backgroundOrigin\",\n    \"fill\",\n    \"stroke\",\n    \"strokeWidth\",\n    \"objectFit\",\n    \"objectPosition\",\n    \"padding\",\n    \"textAlign\",\n    \"textIndent\",\n    \"verticalAlign\",\n    \"fontFamily\",\n    \"fontSize\",\n    \"fontWeight\",\n    \"textTransform\",\n    \"fontStyle\",\n    \"fontVariantNumeric\",\n    \"lineHeight\",\n    \"letterSpacing\",\n    \"textColor\",\n    \"textOpacity\",\n    \"textDecoration\",\n    \"textDecorationColor\",\n    \"textDecorationStyle\",\n    \"textDecorationThickness\",\n    \"textUnderlineOffset\",\n    \"fontSmoothing\",\n    \"placeholderColor\",\n    \"placeholderOpacity\",\n    \"caretColor\",\n    \"accentColor\",\n    \"opacity\",\n    \"backgroundBlendMode\",\n    \"mixBlendMode\",\n    \"boxShadow\",\n    \"boxShadowColor\",\n    \"outlineStyle\",\n    \"outlineWidth\",\n    \"outlineOffset\",\n    \"outlineColor\",\n    \"ringWidth\",\n    \"ringColor\",\n    \"ringOpacity\",\n    \"ringOffsetWidth\",\n    \"ringOffsetColor\",\n    \"blur\",\n    \"brightness\",\n    \"contrast\",\n    \"dropShadow\",\n    \"grayscale\",\n    \"hueRotate\",\n    \"invert\",\n    \"saturate\",\n    \"sepia\",\n    \"filter\",\n    \"backdropBlur\",\n    \"backdropBrightness\",\n    \"backdropContrast\",\n    \"backdropGrayscale\",\n    \"backdropHueRotate\",\n    \"backdropInvert\",\n    \"backdropOpacity\",\n    \"backdropSaturate\",\n    \"backdropSepia\",\n    \"backdropFilter\",\n    \"transitionProperty\",\n    \"transitionDelay\",\n    \"transitionDuration\",\n    \"transitionTimingFunction\",\n    \"willChange\",\n    \"content\"\n];\n\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/tailwindcss/lib/corePluginList.js?");

/***/ }),

/***/ "./node_modules/tailwindcss/lib/corePlugins.js":
/*!*****************************************************!*\
  !*** ./node_modules/tailwindcss/lib/corePlugins.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("var __dirname = \"/\";\n\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    variantPlugins: ()=>variantPlugins,\n    corePlugins: ()=>corePlugins\n});\nconst _fs = /*#__PURE__*/ _interopRequireDefault(__webpack_require__(Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'fs'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }())));\nconst _path = /*#__PURE__*/ _interopRequireWildcard(__webpack_require__(Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'path'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }())));\nconst _postcss = /*#__PURE__*/ _interopRequireDefault(__webpack_require__(/*! postcss */ \"./node_modules/postcss/lib/postcss.js\"));\nconst _createUtilityPlugin = /*#__PURE__*/ _interopRequireDefault(__webpack_require__(/*! ./util/createUtilityPlugin */ \"./node_modules/tailwindcss/lib/util/createUtilityPlugin.js\"));\nconst _buildMediaQuery = /*#__PURE__*/ _interopRequireDefault(__webpack_require__(/*! ./util/buildMediaQuery */ \"./node_modules/tailwindcss/lib/util/buildMediaQuery.js\"));\nconst _escapeClassName = /*#__PURE__*/ _interopRequireDefault(__webpack_require__(/*! ./util/escapeClassName */ \"./node_modules/tailwindcss/lib/util/escapeClassName.js\"));\nconst _parseAnimationValue = /*#__PURE__*/ _interopRequireDefault(__webpack_require__(/*! ./util/parseAnimationValue */ \"./node_modules/tailwindcss/lib/util/parseAnimationValue.js\"));\nconst _flattenColorPalette = /*#__PURE__*/ _interopRequireDefault(__webpack_require__(/*! ./util/flattenColorPalette */ \"./node_modules/tailwindcss/lib/util/flattenColorPalette.js\"));\nconst _withAlphaVariable = /*#__PURE__*/ _interopRequireWildcard(__webpack_require__(/*! ./util/withAlphaVariable */ \"./node_modules/tailwindcss/lib/util/withAlphaVariable.js\"));\nconst _toColorValue = /*#__PURE__*/ _interopRequireDefault(__webpack_require__(/*! ./util/toColorValue */ \"./node_modules/tailwindcss/lib/util/toColorValue.js\"));\nconst _isPlainObject = /*#__PURE__*/ _interopRequireDefault(__webpack_require__(/*! ./util/isPlainObject */ \"./node_modules/tailwindcss/lib/util/isPlainObject.js\"));\nconst _transformThemeValue = /*#__PURE__*/ _interopRequireDefault(__webpack_require__(/*! ./util/transformThemeValue */ \"./node_modules/tailwindcss/lib/util/transformThemeValue.js\"));\nconst _packageJson = __webpack_require__(/*! ../package.json */ \"./node_modules/tailwindcss/package.json\");\nconst _log = /*#__PURE__*/ _interopRequireDefault(__webpack_require__(/*! ./util/log */ \"./node_modules/tailwindcss/lib/util/log.js\"));\nconst _normalizeScreens = __webpack_require__(/*! ./util/normalizeScreens */ \"./node_modules/tailwindcss/lib/util/normalizeScreens.js\");\nconst _parseBoxShadowValue = __webpack_require__(/*! ./util/parseBoxShadowValue */ \"./node_modules/tailwindcss/lib/util/parseBoxShadowValue.js\");\nconst _removeAlphaVariables = __webpack_require__(/*! ./util/removeAlphaVariables */ \"./node_modules/tailwindcss/lib/util/removeAlphaVariables.js\");\nconst _featureFlags = __webpack_require__(/*! ./featureFlags */ \"./node_modules/tailwindcss/lib/featureFlags.js\");\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        default: obj\n    };\n}\nfunction _getRequireWildcardCache(nodeInterop) {\n    if (typeof WeakMap !== \"function\") return null;\n    var cacheBabelInterop = new WeakMap();\n    var cacheNodeInterop = new WeakMap();\n    return (_getRequireWildcardCache = function(nodeInterop) {\n        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;\n    })(nodeInterop);\n}\nfunction _interopRequireWildcard(obj, nodeInterop) {\n    if (!nodeInterop && obj && obj.__esModule) {\n        return obj;\n    }\n    if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n        return {\n            default: obj\n        };\n    }\n    var cache = _getRequireWildcardCache(nodeInterop);\n    if (cache && cache.has(obj)) {\n        return cache.get(obj);\n    }\n    var newObj = {};\n    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n    for(var key in obj){\n        if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) {\n            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n            if (desc && (desc.get || desc.set)) {\n                Object.defineProperty(newObj, key, desc);\n            } else {\n                newObj[key] = obj[key];\n            }\n        }\n    }\n    newObj.default = obj;\n    if (cache) {\n        cache.set(obj, newObj);\n    }\n    return newObj;\n}\nlet variantPlugins = {\n    pseudoElementVariants: ({ addVariant  })=>{\n        addVariant(\"first-letter\", \"&::first-letter\");\n        addVariant(\"first-line\", \"&::first-line\");\n        addVariant(\"marker\", [\n            ({ container  })=>{\n                (0, _removeAlphaVariables.removeAlphaVariables)(container, [\n                    \"--tw-text-opacity\"\n                ]);\n                return \"& *::marker\";\n            },\n            ({ container  })=>{\n                (0, _removeAlphaVariables.removeAlphaVariables)(container, [\n                    \"--tw-text-opacity\"\n                ]);\n                return \"&::marker\";\n            }, \n        ]);\n        addVariant(\"selection\", [\n            \"& *::selection\",\n            \"&::selection\"\n        ]);\n        addVariant(\"file\", \"&::file-selector-button\");\n        addVariant(\"placeholder\", \"&::placeholder\");\n        addVariant(\"backdrop\", \"&::backdrop\");\n        addVariant(\"before\", ({ container  })=>{\n            container.walkRules((rule)=>{\n                let foundContent = false;\n                rule.walkDecls(\"content\", ()=>{\n                    foundContent = true;\n                });\n                if (!foundContent) {\n                    rule.prepend(_postcss.default.decl({\n                        prop: \"content\",\n                        value: \"var(--tw-content)\"\n                    }));\n                }\n            });\n            return \"&::before\";\n        });\n        addVariant(\"after\", ({ container  })=>{\n            container.walkRules((rule)=>{\n                let foundContent = false;\n                rule.walkDecls(\"content\", ()=>{\n                    foundContent = true;\n                });\n                if (!foundContent) {\n                    rule.prepend(_postcss.default.decl({\n                        prop: \"content\",\n                        value: \"var(--tw-content)\"\n                    }));\n                }\n            });\n            return \"&::after\";\n        });\n    },\n    pseudoClassVariants: ({ addVariant , config  })=>{\n        let pseudoVariants = [\n            // Positional\n            [\n                \"first\",\n                \"&:first-child\"\n            ],\n            [\n                \"last\",\n                \"&:last-child\"\n            ],\n            [\n                \"only\",\n                \"&:only-child\"\n            ],\n            [\n                \"odd\",\n                \"&:nth-child(odd)\"\n            ],\n            [\n                \"even\",\n                \"&:nth-child(even)\"\n            ],\n            \"first-of-type\",\n            \"last-of-type\",\n            \"only-of-type\",\n            // State\n            [\n                \"visited\",\n                ({ container  })=>{\n                    (0, _removeAlphaVariables.removeAlphaVariables)(container, [\n                        \"--tw-text-opacity\",\n                        \"--tw-border-opacity\",\n                        \"--tw-bg-opacity\", \n                    ]);\n                    return \"&:visited\";\n                }, \n            ],\n            \"target\",\n            [\n                \"open\",\n                \"&[open]\"\n            ],\n            // Forms\n            \"default\",\n            \"checked\",\n            \"indeterminate\",\n            \"placeholder-shown\",\n            \"autofill\",\n            \"optional\",\n            \"required\",\n            \"valid\",\n            \"invalid\",\n            \"in-range\",\n            \"out-of-range\",\n            \"read-only\",\n            // Content\n            \"empty\",\n            // Interactive\n            \"focus-within\",\n            [\n                \"hover\",\n                !(0, _featureFlags.flagEnabled)(config(), \"hoverOnlyWhenSupported\") ? \"&:hover\" : \"@media (hover: hover) and (pointer: fine) { &:hover }\", \n            ],\n            \"focus\",\n            \"focus-visible\",\n            \"active\",\n            \"enabled\",\n            \"disabled\", \n        ].map((variant)=>Array.isArray(variant) ? variant : [\n                variant,\n                `&:${variant}`\n            ]);\n        for (let [variantName, state] of pseudoVariants){\n            addVariant(variantName, (ctx)=>{\n                let result = typeof state === \"function\" ? state(ctx) : state;\n                return result;\n            });\n        }\n        for (let [variantName1, state1] of pseudoVariants){\n            addVariant(`group-${variantName1}`, (ctx)=>{\n                let result = typeof state1 === \"function\" ? state1(ctx) : state1;\n                return result.replace(/&(\\S+)/, \":merge(.group)$1 &\");\n            });\n        }\n        for (let [variantName2, state2] of pseudoVariants){\n            addVariant(`peer-${variantName2}`, (ctx)=>{\n                let result = typeof state2 === \"function\" ? state2(ctx) : state2;\n                return result.replace(/&(\\S+)/, \":merge(.peer)$1 ~ &\");\n            });\n        }\n    },\n    directionVariants: ({ addVariant  })=>{\n        addVariant(\"ltr\", ()=>{\n            _log.default.warn(\"rtl-experimental\", [\n                \"The RTL features in Tailwind CSS are currently in preview.\",\n                \"Preview features are not covered by semver, and may be improved in breaking ways at any time.\", \n            ]);\n            return '[dir=\"ltr\"] &';\n        });\n        addVariant(\"rtl\", ()=>{\n            _log.default.warn(\"rtl-experimental\", [\n                \"The RTL features in Tailwind CSS are currently in preview.\",\n                \"Preview features are not covered by semver, and may be improved in breaking ways at any time.\", \n            ]);\n            return '[dir=\"rtl\"] &';\n        });\n    },\n    reducedMotionVariants: ({ addVariant  })=>{\n        addVariant(\"motion-safe\", \"@media (prefers-reduced-motion: no-preference)\");\n        addVariant(\"motion-reduce\", \"@media (prefers-reduced-motion: reduce)\");\n    },\n    darkVariants: ({ config , addVariant  })=>{\n        let [mode, className = \".dark\"] = [].concat(config(\"darkMode\", \"media\"));\n        if (mode === false) {\n            mode = \"media\";\n            _log.default.warn(\"darkmode-false\", [\n                \"The `darkMode` option in your Tailwind CSS configuration is set to `false`, which now behaves the same as `media`.\",\n                \"Change `darkMode` to `media` or remove it entirely.\",\n                \"https://tailwindcss.com/docs/upgrade-guide#remove-dark-mode-configuration\", \n            ]);\n        }\n        if (mode === \"class\") {\n            addVariant(\"dark\", `${className} &`);\n        } else if (mode === \"media\") {\n            addVariant(\"dark\", \"@media (prefers-color-scheme: dark)\");\n        }\n    },\n    printVariant: ({ addVariant  })=>{\n        addVariant(\"print\", \"@media print\");\n    },\n    screenVariants: ({ theme , addVariant  })=>{\n        for (let screen of (0, _normalizeScreens.normalizeScreens)(theme(\"screens\"))){\n            let query = (0, _buildMediaQuery.default)(screen);\n            addVariant(screen.name, `@media ${query}`);\n        }\n    },\n    orientationVariants: ({ addVariant  })=>{\n        addVariant(\"portrait\", \"@media (orientation: portrait)\");\n        addVariant(\"landscape\", \"@media (orientation: landscape)\");\n    },\n    prefersContrastVariants: ({ addVariant  })=>{\n        addVariant(\"contrast-more\", \"@media (prefers-contrast: more)\");\n        addVariant(\"contrast-less\", \"@media (prefers-contrast: less)\");\n    }\n};\nlet cssTransformValue = [\n    \"translate(var(--tw-translate-x), var(--tw-translate-y))\",\n    \"rotate(var(--tw-rotate))\",\n    \"skewX(var(--tw-skew-x))\",\n    \"skewY(var(--tw-skew-y))\",\n    \"scaleX(var(--tw-scale-x))\",\n    \"scaleY(var(--tw-scale-y))\", \n].join(\" \");\nlet cssFilterValue = [\n    \"var(--tw-blur)\",\n    \"var(--tw-brightness)\",\n    \"var(--tw-contrast)\",\n    \"var(--tw-grayscale)\",\n    \"var(--tw-hue-rotate)\",\n    \"var(--tw-invert)\",\n    \"var(--tw-saturate)\",\n    \"var(--tw-sepia)\",\n    \"var(--tw-drop-shadow)\", \n].join(\" \");\nlet cssBackdropFilterValue = [\n    \"var(--tw-backdrop-blur)\",\n    \"var(--tw-backdrop-brightness)\",\n    \"var(--tw-backdrop-contrast)\",\n    \"var(--tw-backdrop-grayscale)\",\n    \"var(--tw-backdrop-hue-rotate)\",\n    \"var(--tw-backdrop-invert)\",\n    \"var(--tw-backdrop-opacity)\",\n    \"var(--tw-backdrop-saturate)\",\n    \"var(--tw-backdrop-sepia)\", \n].join(\" \");\nlet corePlugins = {\n    preflight: ({ addBase  })=>{\n        let preflightStyles = _postcss.default.parse(_fs.default.readFileSync(_path.join(__dirname, \"./css/preflight.css\"), \"utf8\"));\n        addBase([\n            _postcss.default.comment({\n                text: `! tailwindcss v${_packageJson.version} | MIT License | https://tailwindcss.com`\n            }),\n            ...preflightStyles.nodes, \n        ]);\n    },\n    container: (()=>{\n        function extractMinWidths(breakpoints = []) {\n            return breakpoints.flatMap((breakpoint)=>breakpoint.values.map((breakpoint)=>breakpoint.min)).filter((v)=>v !== undefined);\n        }\n        function mapMinWidthsToPadding(minWidths, screens, paddings) {\n            if (typeof paddings === \"undefined\") {\n                return [];\n            }\n            if (!(typeof paddings === \"object\" && paddings !== null)) {\n                return [\n                    {\n                        screen: \"DEFAULT\",\n                        minWidth: 0,\n                        padding: paddings\n                    }, \n                ];\n            }\n            let mapping = [];\n            if (paddings.DEFAULT) {\n                mapping.push({\n                    screen: \"DEFAULT\",\n                    minWidth: 0,\n                    padding: paddings.DEFAULT\n                });\n            }\n            for (let minWidth of minWidths){\n                for (let screen of screens){\n                    for (let { min  } of screen.values){\n                        if (min === minWidth) {\n                            mapping.push({\n                                minWidth,\n                                padding: paddings[screen.name]\n                            });\n                        }\n                    }\n                }\n            }\n            return mapping;\n        }\n        return function({ addComponents , theme  }) {\n            let screens = (0, _normalizeScreens.normalizeScreens)(theme(\"container.screens\", theme(\"screens\")));\n            let minWidths = extractMinWidths(screens);\n            let paddings = mapMinWidthsToPadding(minWidths, screens, theme(\"container.padding\"));\n            let generatePaddingFor = (minWidth)=>{\n                let paddingConfig = paddings.find((padding)=>padding.minWidth === minWidth);\n                if (!paddingConfig) {\n                    return {};\n                }\n                return {\n                    paddingRight: paddingConfig.padding,\n                    paddingLeft: paddingConfig.padding\n                };\n            };\n            let atRules = Array.from(new Set(minWidths.slice().sort((a, z)=>parseInt(a) - parseInt(z)))).map((minWidth)=>({\n                    [`@media (min-width: ${minWidth})`]: {\n                        \".container\": {\n                            \"max-width\": minWidth,\n                            ...generatePaddingFor(minWidth)\n                        }\n                    }\n                }));\n            addComponents([\n                {\n                    \".container\": Object.assign({\n                        width: \"100%\"\n                    }, theme(\"container.center\", false) ? {\n                        marginRight: \"auto\",\n                        marginLeft: \"auto\"\n                    } : {}, generatePaddingFor(0))\n                },\n                ...atRules, \n            ]);\n        };\n    })(),\n    accessibility: ({ addUtilities  })=>{\n        addUtilities({\n            \".sr-only\": {\n                position: \"absolute\",\n                width: \"1px\",\n                height: \"1px\",\n                padding: \"0\",\n                margin: \"-1px\",\n                overflow: \"hidden\",\n                clip: \"rect(0, 0, 0, 0)\",\n                whiteSpace: \"nowrap\",\n                borderWidth: \"0\"\n            },\n            \".not-sr-only\": {\n                position: \"static\",\n                width: \"auto\",\n                height: \"auto\",\n                padding: \"0\",\n                margin: \"0\",\n                overflow: \"visible\",\n                clip: \"auto\",\n                whiteSpace: \"normal\"\n            }\n        });\n    },\n    pointerEvents: ({ addUtilities  })=>{\n        addUtilities({\n            \".pointer-events-none\": {\n                \"pointer-events\": \"none\"\n            },\n            \".pointer-events-auto\": {\n                \"pointer-events\": \"auto\"\n            }\n        });\n    },\n    visibility: ({ addUtilities  })=>{\n        addUtilities({\n            \".visible\": {\n                visibility: \"visible\"\n            },\n            \".invisible\": {\n                visibility: \"hidden\"\n            }\n        });\n    },\n    position: ({ addUtilities  })=>{\n        addUtilities({\n            \".static\": {\n                position: \"static\"\n            },\n            \".fixed\": {\n                position: \"fixed\"\n            },\n            \".absolute\": {\n                position: \"absolute\"\n            },\n            \".relative\": {\n                position: \"relative\"\n            },\n            \".sticky\": {\n                position: \"sticky\"\n            }\n        });\n    },\n    inset: (0, _createUtilityPlugin.default)(\"inset\", [\n        [\n            \"inset\",\n            [\n                \"top\",\n                \"right\",\n                \"bottom\",\n                \"left\"\n            ]\n        ],\n        [\n            [\n                \"inset-x\",\n                [\n                    \"left\",\n                    \"right\"\n                ]\n            ],\n            [\n                \"inset-y\",\n                [\n                    \"top\",\n                    \"bottom\"\n                ]\n            ], \n        ],\n        [\n            [\n                \"top\",\n                [\n                    \"top\"\n                ]\n            ],\n            [\n                \"right\",\n                [\n                    \"right\"\n                ]\n            ],\n            [\n                \"bottom\",\n                [\n                    \"bottom\"\n                ]\n            ],\n            [\n                \"left\",\n                [\n                    \"left\"\n                ]\n            ], \n        ], \n    ], {\n        supportsNegativeValues: true\n    }),\n    isolation: ({ addUtilities  })=>{\n        addUtilities({\n            \".isolate\": {\n                isolation: \"isolate\"\n            },\n            \".isolation-auto\": {\n                isolation: \"auto\"\n            }\n        });\n    },\n    zIndex: (0, _createUtilityPlugin.default)(\"zIndex\", [\n        [\n            \"z\",\n            [\n                \"zIndex\"\n            ]\n        ]\n    ], {\n        supportsNegativeValues: true\n    }),\n    order: (0, _createUtilityPlugin.default)(\"order\", undefined, {\n        supportsNegativeValues: true\n    }),\n    gridColumn: (0, _createUtilityPlugin.default)(\"gridColumn\", [\n        [\n            \"col\",\n            [\n                \"gridColumn\"\n            ]\n        ]\n    ]),\n    gridColumnStart: (0, _createUtilityPlugin.default)(\"gridColumnStart\", [\n        [\n            \"col-start\",\n            [\n                \"gridColumnStart\"\n            ]\n        ]\n    ]),\n    gridColumnEnd: (0, _createUtilityPlugin.default)(\"gridColumnEnd\", [\n        [\n            \"col-end\",\n            [\n                \"gridColumnEnd\"\n            ]\n        ]\n    ]),\n    gridRow: (0, _createUtilityPlugin.default)(\"gridRow\", [\n        [\n            \"row\",\n            [\n                \"gridRow\"\n            ]\n        ]\n    ]),\n    gridRowStart: (0, _createUtilityPlugin.default)(\"gridRowStart\", [\n        [\n            \"row-start\",\n            [\n                \"gridRowStart\"\n            ]\n        ]\n    ]),\n    gridRowEnd: (0, _createUtilityPlugin.default)(\"gridRowEnd\", [\n        [\n            \"row-end\",\n            [\n                \"gridRowEnd\"\n            ]\n        ]\n    ]),\n    float: ({ addUtilities  })=>{\n        addUtilities({\n            \".float-right\": {\n                float: \"right\"\n            },\n            \".float-left\": {\n                float: \"left\"\n            },\n            \".float-none\": {\n                float: \"none\"\n            }\n        });\n    },\n    clear: ({ addUtilities  })=>{\n        addUtilities({\n            \".clear-left\": {\n                clear: \"left\"\n            },\n            \".clear-right\": {\n                clear: \"right\"\n            },\n            \".clear-both\": {\n                clear: \"both\"\n            },\n            \".clear-none\": {\n                clear: \"none\"\n            }\n        });\n    },\n    margin: (0, _createUtilityPlugin.default)(\"margin\", [\n        [\n            \"m\",\n            [\n                \"margin\"\n            ]\n        ],\n        [\n            [\n                \"mx\",\n                [\n                    \"margin-left\",\n                    \"margin-right\"\n                ]\n            ],\n            [\n                \"my\",\n                [\n                    \"margin-top\",\n                    \"margin-bottom\"\n                ]\n            ], \n        ],\n        [\n            [\n                \"mt\",\n                [\n                    \"margin-top\"\n                ]\n            ],\n            [\n                \"mr\",\n                [\n                    \"margin-right\"\n                ]\n            ],\n            [\n                \"mb\",\n                [\n                    \"margin-bottom\"\n                ]\n            ],\n            [\n                \"ml\",\n                [\n                    \"margin-left\"\n                ]\n            ], \n        ], \n    ], {\n        supportsNegativeValues: true\n    }),\n    boxSizing: ({ addUtilities  })=>{\n        addUtilities({\n            \".box-border\": {\n                \"box-sizing\": \"border-box\"\n            },\n            \".box-content\": {\n                \"box-sizing\": \"content-box\"\n            }\n        });\n    },\n    display: ({ addUtilities  })=>{\n        addUtilities({\n            \".block\": {\n                display: \"block\"\n            },\n            \".inline-block\": {\n                display: \"inline-block\"\n            },\n            \".inline\": {\n                display: \"inline\"\n            },\n            \".flex\": {\n                display: \"flex\"\n            },\n            \".inline-flex\": {\n                display: \"inline-flex\"\n            },\n            \".table\": {\n                display: \"table\"\n            },\n            \".inline-table\": {\n                display: \"inline-table\"\n            },\n            \".table-caption\": {\n                display: \"table-caption\"\n            },\n            \".table-cell\": {\n                display: \"table-cell\"\n            },\n            \".table-column\": {\n                display: \"table-column\"\n            },\n            \".table-column-group\": {\n                display: \"table-column-group\"\n            },\n            \".table-footer-group\": {\n                display: \"table-footer-group\"\n            },\n            \".table-header-group\": {\n                display: \"table-header-group\"\n            },\n            \".table-row-group\": {\n                display: \"table-row-group\"\n            },\n            \".table-row\": {\n                display: \"table-row\"\n            },\n            \".flow-root\": {\n                display: \"flow-root\"\n            },\n            \".grid\": {\n                display: \"grid\"\n            },\n            \".inline-grid\": {\n                display: \"inline-grid\"\n            },\n            \".contents\": {\n                display: \"contents\"\n            },\n            \".list-item\": {\n                display: \"list-item\"\n            },\n            \".hidden\": {\n                display: \"none\"\n            }\n        });\n    },\n    aspectRatio: (0, _createUtilityPlugin.default)(\"aspectRatio\", [\n        [\n            \"aspect\",\n            [\n                \"aspect-ratio\"\n            ]\n        ]\n    ]),\n    height: (0, _createUtilityPlugin.default)(\"height\", [\n        [\n            \"h\",\n            [\n                \"height\"\n            ]\n        ]\n    ]),\n    maxHeight: (0, _createUtilityPlugin.default)(\"maxHeight\", [\n        [\n            \"max-h\",\n            [\n                \"maxHeight\"\n            ]\n        ]\n    ]),\n    minHeight: (0, _createUtilityPlugin.default)(\"minHeight\", [\n        [\n            \"min-h\",\n            [\n                \"minHeight\"\n            ]\n        ]\n    ]),\n    width: (0, _createUtilityPlugin.default)(\"width\", [\n        [\n            \"w\",\n            [\n                \"width\"\n            ]\n        ]\n    ]),\n    minWidth: (0, _createUtilityPlugin.default)(\"minWidth\", [\n        [\n            \"min-w\",\n            [\n                \"minWidth\"\n            ]\n        ]\n    ]),\n    maxWidth: (0, _createUtilityPlugin.default)(\"maxWidth\", [\n        [\n            \"max-w\",\n            [\n                \"maxWidth\"\n            ]\n        ]\n    ]),\n    flex: (0, _createUtilityPlugin.default)(\"flex\"),\n    flexShrink: (0, _createUtilityPlugin.default)(\"flexShrink\", [\n        [\n            \"flex-shrink\",\n            [\n                \"flex-shrink\"\n            ]\n        ],\n        [\n            \"shrink\",\n            [\n                \"flex-shrink\"\n            ]\n        ], \n    ]),\n    flexGrow: (0, _createUtilityPlugin.default)(\"flexGrow\", [\n        [\n            \"flex-grow\",\n            [\n                \"flex-grow\"\n            ]\n        ],\n        [\n            \"grow\",\n            [\n                \"flex-grow\"\n            ]\n        ], \n    ]),\n    flexBasis: (0, _createUtilityPlugin.default)(\"flexBasis\", [\n        [\n            \"basis\",\n            [\n                \"flex-basis\"\n            ]\n        ]\n    ]),\n    tableLayout: ({ addUtilities  })=>{\n        addUtilities({\n            \".table-auto\": {\n                \"table-layout\": \"auto\"\n            },\n            \".table-fixed\": {\n                \"table-layout\": \"fixed\"\n            }\n        });\n    },\n    borderCollapse: ({ addUtilities  })=>{\n        addUtilities({\n            \".border-collapse\": {\n                \"border-collapse\": \"collapse\"\n            },\n            \".border-separate\": {\n                \"border-collapse\": \"separate\"\n            }\n        });\n    },\n    borderSpacing: ({ addDefaults , matchUtilities , theme  })=>{\n        addDefaults(\"border-spacing\", {\n            \"--tw-border-spacing-x\": 0,\n            \"--tw-border-spacing-y\": 0\n        });\n        matchUtilities({\n            \"border-spacing\": (value)=>{\n                return {\n                    \"--tw-border-spacing-x\": value,\n                    \"--tw-border-spacing-y\": value,\n                    \"@defaults border-spacing\": {},\n                    \"border-spacing\": \"var(--tw-border-spacing-x) var(--tw-border-spacing-y)\"\n                };\n            },\n            \"border-spacing-x\": (value)=>{\n                return {\n                    \"--tw-border-spacing-x\": value,\n                    \"@defaults border-spacing\": {},\n                    \"border-spacing\": \"var(--tw-border-spacing-x) var(--tw-border-spacing-y)\"\n                };\n            },\n            \"border-spacing-y\": (value)=>{\n                return {\n                    \"--tw-border-spacing-y\": value,\n                    \"@defaults border-spacing\": {},\n                    \"border-spacing\": \"var(--tw-border-spacing-x) var(--tw-border-spacing-y)\"\n                };\n            }\n        }, {\n            values: theme(\"borderSpacing\")\n        });\n    },\n    transformOrigin: (0, _createUtilityPlugin.default)(\"transformOrigin\", [\n        [\n            \"origin\",\n            [\n                \"transformOrigin\"\n            ]\n        ]\n    ]),\n    translate: (0, _createUtilityPlugin.default)(\"translate\", [\n        [\n            [\n                \"translate-x\",\n                [\n                    [\n                        \"@defaults transform\",\n                        {}\n                    ],\n                    \"--tw-translate-x\",\n                    [\n                        \"transform\",\n                        cssTransformValue\n                    ]\n                ], \n            ],\n            [\n                \"translate-y\",\n                [\n                    [\n                        \"@defaults transform\",\n                        {}\n                    ],\n                    \"--tw-translate-y\",\n                    [\n                        \"transform\",\n                        cssTransformValue\n                    ]\n                ], \n            ], \n        ], \n    ], {\n        supportsNegativeValues: true\n    }),\n    rotate: (0, _createUtilityPlugin.default)(\"rotate\", [\n        [\n            \"rotate\",\n            [\n                [\n                    \"@defaults transform\",\n                    {}\n                ],\n                \"--tw-rotate\",\n                [\n                    \"transform\",\n                    cssTransformValue\n                ]\n            ]\n        ]\n    ], {\n        supportsNegativeValues: true\n    }),\n    skew: (0, _createUtilityPlugin.default)(\"skew\", [\n        [\n            [\n                \"skew-x\",\n                [\n                    [\n                        \"@defaults transform\",\n                        {}\n                    ],\n                    \"--tw-skew-x\",\n                    [\n                        \"transform\",\n                        cssTransformValue\n                    ]\n                ]\n            ],\n            [\n                \"skew-y\",\n                [\n                    [\n                        \"@defaults transform\",\n                        {}\n                    ],\n                    \"--tw-skew-y\",\n                    [\n                        \"transform\",\n                        cssTransformValue\n                    ]\n                ]\n            ], \n        ], \n    ], {\n        supportsNegativeValues: true\n    }),\n    scale: (0, _createUtilityPlugin.default)(\"scale\", [\n        [\n            \"scale\",\n            [\n                [\n                    \"@defaults transform\",\n                    {}\n                ],\n                \"--tw-scale-x\",\n                \"--tw-scale-y\",\n                [\n                    \"transform\",\n                    cssTransformValue\n                ], \n            ], \n        ],\n        [\n            [\n                \"scale-x\",\n                [\n                    [\n                        \"@defaults transform\",\n                        {}\n                    ],\n                    \"--tw-scale-x\",\n                    [\n                        \"transform\",\n                        cssTransformValue\n                    ]\n                ], \n            ],\n            [\n                \"scale-y\",\n                [\n                    [\n                        \"@defaults transform\",\n                        {}\n                    ],\n                    \"--tw-scale-y\",\n                    [\n                        \"transform\",\n                        cssTransformValue\n                    ]\n                ], \n            ], \n        ], \n    ], {\n        supportsNegativeValues: true\n    }),\n    transform: ({ addDefaults , addUtilities  })=>{\n        addDefaults(\"transform\", {\n            \"--tw-translate-x\": \"0\",\n            \"--tw-translate-y\": \"0\",\n            \"--tw-rotate\": \"0\",\n            \"--tw-skew-x\": \"0\",\n            \"--tw-skew-y\": \"0\",\n            \"--tw-scale-x\": \"1\",\n            \"--tw-scale-y\": \"1\"\n        });\n        addUtilities({\n            \".transform\": {\n                \"@defaults transform\": {},\n                transform: cssTransformValue\n            },\n            \".transform-cpu\": {\n                transform: cssTransformValue\n            },\n            \".transform-gpu\": {\n                transform: cssTransformValue.replace(\"translate(var(--tw-translate-x), var(--tw-translate-y))\", \"translate3d(var(--tw-translate-x), var(--tw-translate-y), 0)\")\n            },\n            \".transform-none\": {\n                transform: \"none\"\n            }\n        });\n    },\n    animation: ({ matchUtilities , theme , config  })=>{\n        let prefixName = (name)=>`${config(\"prefix\")}${(0, _escapeClassName.default)(name)}`;\n        var ref;\n        let keyframes = Object.fromEntries(Object.entries((ref = theme(\"keyframes\")) !== null && ref !== void 0 ? ref : {}).map(([key, value])=>{\n            return [\n                key,\n                {\n                    [`@keyframes ${prefixName(key)}`]: value\n                }\n            ];\n        }));\n        matchUtilities({\n            animate: (value)=>{\n                let animations = (0, _parseAnimationValue.default)(value);\n                return [\n                    ...animations.flatMap((animation)=>keyframes[animation.name]),\n                    {\n                        animation: animations.map(({ name , value  })=>{\n                            if (name === undefined || keyframes[name] === undefined) {\n                                return value;\n                            }\n                            return value.replace(name, prefixName(name));\n                        }).join(\", \")\n                    }, \n                ];\n            }\n        }, {\n            values: theme(\"animation\")\n        });\n    },\n    cursor: (0, _createUtilityPlugin.default)(\"cursor\"),\n    touchAction: ({ addDefaults , addUtilities  })=>{\n        addDefaults(\"touch-action\", {\n            \"--tw-pan-x\": \" \",\n            \"--tw-pan-y\": \" \",\n            \"--tw-pinch-zoom\": \" \"\n        });\n        let cssTouchActionValue = \"var(--tw-pan-x) var(--tw-pan-y) var(--tw-pinch-zoom)\";\n        addUtilities({\n            \".touch-auto\": {\n                \"touch-action\": \"auto\"\n            },\n            \".touch-none\": {\n                \"touch-action\": \"none\"\n            },\n            \".touch-pan-x\": {\n                \"@defaults touch-action\": {},\n                \"--tw-pan-x\": \"pan-x\",\n                \"touch-action\": cssTouchActionValue\n            },\n            \".touch-pan-left\": {\n                \"@defaults touch-action\": {},\n                \"--tw-pan-x\": \"pan-left\",\n                \"touch-action\": cssTouchActionValue\n            },\n            \".touch-pan-right\": {\n                \"@defaults touch-action\": {},\n                \"--tw-pan-x\": \"pan-right\",\n                \"touch-action\": cssTouchActionValue\n            },\n            \".touch-pan-y\": {\n                \"@defaults touch-action\": {},\n                \"--tw-pan-y\": \"pan-y\",\n                \"touch-action\": cssTouchActionValue\n            },\n            \".touch-pan-up\": {\n                \"@defaults touch-action\": {},\n                \"--tw-pan-y\": \"pan-up\",\n                \"touch-action\": cssTouchActionValue\n            },\n            \".touch-pan-down\": {\n                \"@defaults touch-action\": {},\n                \"--tw-pan-y\": \"pan-down\",\n                \"touch-action\": cssTouchActionValue\n            },\n            \".touch-pinch-zoom\": {\n                \"@defaults touch-action\": {},\n                \"--tw-pinch-zoom\": \"pinch-zoom\",\n                \"touch-action\": cssTouchActionValue\n            },\n            \".touch-manipulation\": {\n                \"touch-action\": \"manipulation\"\n            }\n        });\n    },\n    userSelect: ({ addUtilities  })=>{\n        addUtilities({\n            \".select-none\": {\n                \"user-select\": \"none\"\n            },\n            \".select-text\": {\n                \"user-select\": \"text\"\n            },\n            \".select-all\": {\n                \"user-select\": \"all\"\n            },\n            \".select-auto\": {\n                \"user-select\": \"auto\"\n            }\n        });\n    },\n    resize: ({ addUtilities  })=>{\n        addUtilities({\n            \".resize-none\": {\n                resize: \"none\"\n            },\n            \".resize-y\": {\n                resize: \"vertical\"\n            },\n            \".resize-x\": {\n                resize: \"horizontal\"\n            },\n            \".resize\": {\n                resize: \"both\"\n            }\n        });\n    },\n    scrollSnapType: ({ addDefaults , addUtilities  })=>{\n        addDefaults(\"scroll-snap-type\", {\n            \"--tw-scroll-snap-strictness\": \"proximity\"\n        });\n        addUtilities({\n            \".snap-none\": {\n                \"scroll-snap-type\": \"none\"\n            },\n            \".snap-x\": {\n                \"@defaults scroll-snap-type\": {},\n                \"scroll-snap-type\": \"x var(--tw-scroll-snap-strictness)\"\n            },\n            \".snap-y\": {\n                \"@defaults scroll-snap-type\": {},\n                \"scroll-snap-type\": \"y var(--tw-scroll-snap-strictness)\"\n            },\n            \".snap-both\": {\n                \"@defaults scroll-snap-type\": {},\n                \"scroll-snap-type\": \"both var(--tw-scroll-snap-strictness)\"\n            },\n            \".snap-mandatory\": {\n                \"--tw-scroll-snap-strictness\": \"mandatory\"\n            },\n            \".snap-proximity\": {\n                \"--tw-scroll-snap-strictness\": \"proximity\"\n            }\n        });\n    },\n    scrollSnapAlign: ({ addUtilities  })=>{\n        addUtilities({\n            \".snap-start\": {\n                \"scroll-snap-align\": \"start\"\n            },\n            \".snap-end\": {\n                \"scroll-snap-align\": \"end\"\n            },\n            \".snap-center\": {\n                \"scroll-snap-align\": \"center\"\n            },\n            \".snap-align-none\": {\n                \"scroll-snap-align\": \"none\"\n            }\n        });\n    },\n    scrollSnapStop: ({ addUtilities  })=>{\n        addUtilities({\n            \".snap-normal\": {\n                \"scroll-snap-stop\": \"normal\"\n            },\n            \".snap-always\": {\n                \"scroll-snap-stop\": \"always\"\n            }\n        });\n    },\n    scrollMargin: (0, _createUtilityPlugin.default)(\"scrollMargin\", [\n        [\n            \"scroll-m\",\n            [\n                \"scroll-margin\"\n            ]\n        ],\n        [\n            [\n                \"scroll-mx\",\n                [\n                    \"scroll-margin-left\",\n                    \"scroll-margin-right\"\n                ]\n            ],\n            [\n                \"scroll-my\",\n                [\n                    \"scroll-margin-top\",\n                    \"scroll-margin-bottom\"\n                ]\n            ], \n        ],\n        [\n            [\n                \"scroll-mt\",\n                [\n                    \"scroll-margin-top\"\n                ]\n            ],\n            [\n                \"scroll-mr\",\n                [\n                    \"scroll-margin-right\"\n                ]\n            ],\n            [\n                \"scroll-mb\",\n                [\n                    \"scroll-margin-bottom\"\n                ]\n            ],\n            [\n                \"scroll-ml\",\n                [\n                    \"scroll-margin-left\"\n                ]\n            ], \n        ], \n    ], {\n        supportsNegativeValues: true\n    }),\n    scrollPadding: (0, _createUtilityPlugin.default)(\"scrollPadding\", [\n        [\n            \"scroll-p\",\n            [\n                \"scroll-padding\"\n            ]\n        ],\n        [\n            [\n                \"scroll-px\",\n                [\n                    \"scroll-padding-left\",\n                    \"scroll-padding-right\"\n                ]\n            ],\n            [\n                \"scroll-py\",\n                [\n                    \"scroll-padding-top\",\n                    \"scroll-padding-bottom\"\n                ]\n            ], \n        ],\n        [\n            [\n                \"scroll-pt\",\n                [\n                    \"scroll-padding-top\"\n                ]\n            ],\n            [\n                \"scroll-pr\",\n                [\n                    \"scroll-padding-right\"\n                ]\n            ],\n            [\n                \"scroll-pb\",\n                [\n                    \"scroll-padding-bottom\"\n                ]\n            ],\n            [\n                \"scroll-pl\",\n                [\n                    \"scroll-padding-left\"\n                ]\n            ], \n        ], \n    ]),\n    listStylePosition: ({ addUtilities  })=>{\n        addUtilities({\n            \".list-inside\": {\n                \"list-style-position\": \"inside\"\n            },\n            \".list-outside\": {\n                \"list-style-position\": \"outside\"\n            }\n        });\n    },\n    listStyleType: (0, _createUtilityPlugin.default)(\"listStyleType\", [\n        [\n            \"list\",\n            [\n                \"listStyleType\"\n            ]\n        ]\n    ]),\n    appearance: ({ addUtilities  })=>{\n        addUtilities({\n            \".appearance-none\": {\n                appearance: \"none\"\n            }\n        });\n    },\n    columns: (0, _createUtilityPlugin.default)(\"columns\", [\n        [\n            \"columns\",\n            [\n                \"columns\"\n            ]\n        ]\n    ]),\n    breakBefore: ({ addUtilities  })=>{\n        addUtilities({\n            \".break-before-auto\": {\n                \"break-before\": \"auto\"\n            },\n            \".break-before-avoid\": {\n                \"break-before\": \"avoid\"\n            },\n            \".break-before-all\": {\n                \"break-before\": \"all\"\n            },\n            \".break-before-avoid-page\": {\n                \"break-before\": \"avoid-page\"\n            },\n            \".break-before-page\": {\n                \"break-before\": \"page\"\n            },\n            \".break-before-left\": {\n                \"break-before\": \"left\"\n            },\n            \".break-before-right\": {\n                \"break-before\": \"right\"\n            },\n            \".break-before-column\": {\n                \"break-before\": \"column\"\n            }\n        });\n    },\n    breakInside: ({ addUtilities  })=>{\n        addUtilities({\n            \".break-inside-auto\": {\n                \"break-inside\": \"auto\"\n            },\n            \".break-inside-avoid\": {\n                \"break-inside\": \"avoid\"\n            },\n            \".break-inside-avoid-page\": {\n                \"break-inside\": \"avoid-page\"\n            },\n            \".break-inside-avoid-column\": {\n                \"break-inside\": \"avoid-column\"\n            }\n        });\n    },\n    breakAfter: ({ addUtilities  })=>{\n        addUtilities({\n            \".break-after-auto\": {\n                \"break-after\": \"auto\"\n            },\n            \".break-after-avoid\": {\n                \"break-after\": \"avoid\"\n            },\n            \".break-after-all\": {\n                \"break-after\": \"all\"\n            },\n            \".break-after-avoid-page\": {\n                \"break-after\": \"avoid-page\"\n            },\n            \".break-after-page\": {\n                \"break-after\": \"page\"\n            },\n            \".break-after-left\": {\n                \"break-after\": \"left\"\n            },\n            \".break-after-right\": {\n                \"break-after\": \"right\"\n            },\n            \".break-after-column\": {\n                \"break-after\": \"column\"\n            }\n        });\n    },\n    gridAutoColumns: (0, _createUtilityPlugin.default)(\"gridAutoColumns\", [\n        [\n            \"auto-cols\",\n            [\n                \"gridAutoColumns\"\n            ]\n        ]\n    ]),\n    gridAutoFlow: ({ addUtilities  })=>{\n        addUtilities({\n            \".grid-flow-row\": {\n                gridAutoFlow: \"row\"\n            },\n            \".grid-flow-col\": {\n                gridAutoFlow: \"column\"\n            },\n            \".grid-flow-dense\": {\n                gridAutoFlow: \"dense\"\n            },\n            \".grid-flow-row-dense\": {\n                gridAutoFlow: \"row dense\"\n            },\n            \".grid-flow-col-dense\": {\n                gridAutoFlow: \"column dense\"\n            }\n        });\n    },\n    gridAutoRows: (0, _createUtilityPlugin.default)(\"gridAutoRows\", [\n        [\n            \"auto-rows\",\n            [\n                \"gridAutoRows\"\n            ]\n        ]\n    ]),\n    gridTemplateColumns: (0, _createUtilityPlugin.default)(\"gridTemplateColumns\", [\n        [\n            \"grid-cols\",\n            [\n                \"gridTemplateColumns\"\n            ]\n        ], \n    ]),\n    gridTemplateRows: (0, _createUtilityPlugin.default)(\"gridTemplateRows\", [\n        [\n            \"grid-rows\",\n            [\n                \"gridTemplateRows\"\n            ]\n        ]\n    ]),\n    flexDirection: ({ addUtilities  })=>{\n        addUtilities({\n            \".flex-row\": {\n                \"flex-direction\": \"row\"\n            },\n            \".flex-row-reverse\": {\n                \"flex-direction\": \"row-reverse\"\n            },\n            \".flex-col\": {\n                \"flex-direction\": \"column\"\n            },\n            \".flex-col-reverse\": {\n                \"flex-direction\": \"column-reverse\"\n            }\n        });\n    },\n    flexWrap: ({ addUtilities  })=>{\n        addUtilities({\n            \".flex-wrap\": {\n                \"flex-wrap\": \"wrap\"\n            },\n            \".flex-wrap-reverse\": {\n                \"flex-wrap\": \"wrap-reverse\"\n            },\n            \".flex-nowrap\": {\n                \"flex-wrap\": \"nowrap\"\n            }\n        });\n    },\n    placeContent: ({ addUtilities  })=>{\n        addUtilities({\n            \".place-content-center\": {\n                \"place-content\": \"center\"\n            },\n            \".place-content-start\": {\n                \"place-content\": \"start\"\n            },\n            \".place-content-end\": {\n                \"place-content\": \"end\"\n            },\n            \".place-content-between\": {\n                \"place-content\": \"space-between\"\n            },\n            \".place-content-around\": {\n                \"place-content\": \"space-around\"\n            },\n            \".place-content-evenly\": {\n                \"place-content\": \"space-evenly\"\n            },\n            \".place-content-stretch\": {\n                \"place-content\": \"stretch\"\n            }\n        });\n    },\n    placeItems: ({ addUtilities  })=>{\n        addUtilities({\n            \".place-items-start\": {\n                \"place-items\": \"start\"\n            },\n            \".place-items-end\": {\n                \"place-items\": \"end\"\n            },\n            \".place-items-center\": {\n                \"place-items\": \"center\"\n            },\n            \".place-items-stretch\": {\n                \"place-items\": \"stretch\"\n            }\n        });\n    },\n    alignContent: ({ addUtilities  })=>{\n        addUtilities({\n            \".content-center\": {\n                \"align-content\": \"center\"\n            },\n            \".content-start\": {\n                \"align-content\": \"flex-start\"\n            },\n            \".content-end\": {\n                \"align-content\": \"flex-end\"\n            },\n            \".content-between\": {\n                \"align-content\": \"space-between\"\n            },\n            \".content-around\": {\n                \"align-content\": \"space-around\"\n            },\n            \".content-evenly\": {\n                \"align-content\": \"space-evenly\"\n            }\n        });\n    },\n    alignItems: ({ addUtilities  })=>{\n        addUtilities({\n            \".items-start\": {\n                \"align-items\": \"flex-start\"\n            },\n            \".items-end\": {\n                \"align-items\": \"flex-end\"\n            },\n            \".items-center\": {\n                \"align-items\": \"center\"\n            },\n            \".items-baseline\": {\n                \"align-items\": \"baseline\"\n            },\n            \".items-stretch\": {\n                \"align-items\": \"stretch\"\n            }\n        });\n    },\n    justifyContent: ({ addUtilities  })=>{\n        addUtilities({\n            \".justify-start\": {\n                \"justify-content\": \"flex-start\"\n            },\n            \".justify-end\": {\n                \"justify-content\": \"flex-end\"\n            },\n            \".justify-center\": {\n                \"justify-content\": \"center\"\n            },\n            \".justify-between\": {\n                \"justify-content\": \"space-between\"\n            },\n            \".justify-around\": {\n                \"justify-content\": \"space-around\"\n            },\n            \".justify-evenly\": {\n                \"justify-content\": \"space-evenly\"\n            }\n        });\n    },\n    justifyItems: ({ addUtilities  })=>{\n        addUtilities({\n            \".justify-items-start\": {\n                \"justify-items\": \"start\"\n            },\n            \".justify-items-end\": {\n                \"justify-items\": \"end\"\n            },\n            \".justify-items-center\": {\n                \"justify-items\": \"center\"\n            },\n            \".justify-items-stretch\": {\n                \"justify-items\": \"stretch\"\n            }\n        });\n    },\n    gap: (0, _createUtilityPlugin.default)(\"gap\", [\n        [\n            \"gap\",\n            [\n                \"gap\"\n            ]\n        ],\n        [\n            [\n                \"gap-x\",\n                [\n                    \"columnGap\"\n                ]\n            ],\n            [\n                \"gap-y\",\n                [\n                    \"rowGap\"\n                ]\n            ], \n        ], \n    ]),\n    space: ({ matchUtilities , addUtilities , theme  })=>{\n        matchUtilities({\n            \"space-x\": (value)=>{\n                value = value === \"0\" ? \"0px\" : value;\n                return {\n                    \"& > :not([hidden]) ~ :not([hidden])\": {\n                        \"--tw-space-x-reverse\": \"0\",\n                        \"margin-right\": `calc(${value} * var(--tw-space-x-reverse))`,\n                        \"margin-left\": `calc(${value} * calc(1 - var(--tw-space-x-reverse)))`\n                    }\n                };\n            },\n            \"space-y\": (value)=>{\n                value = value === \"0\" ? \"0px\" : value;\n                return {\n                    \"& > :not([hidden]) ~ :not([hidden])\": {\n                        \"--tw-space-y-reverse\": \"0\",\n                        \"margin-top\": `calc(${value} * calc(1 - var(--tw-space-y-reverse)))`,\n                        \"margin-bottom\": `calc(${value} * var(--tw-space-y-reverse))`\n                    }\n                };\n            }\n        }, {\n            values: theme(\"space\"),\n            supportsNegativeValues: true\n        });\n        addUtilities({\n            \".space-y-reverse > :not([hidden]) ~ :not([hidden])\": {\n                \"--tw-space-y-reverse\": \"1\"\n            },\n            \".space-x-reverse > :not([hidden]) ~ :not([hidden])\": {\n                \"--tw-space-x-reverse\": \"1\"\n            }\n        });\n    },\n    divideWidth: ({ matchUtilities , addUtilities , theme  })=>{\n        matchUtilities({\n            \"divide-x\": (value)=>{\n                value = value === \"0\" ? \"0px\" : value;\n                return {\n                    \"& > :not([hidden]) ~ :not([hidden])\": {\n                        \"@defaults border-width\": {},\n                        \"--tw-divide-x-reverse\": \"0\",\n                        \"border-right-width\": `calc(${value} * var(--tw-divide-x-reverse))`,\n                        \"border-left-width\": `calc(${value} * calc(1 - var(--tw-divide-x-reverse)))`\n                    }\n                };\n            },\n            \"divide-y\": (value)=>{\n                value = value === \"0\" ? \"0px\" : value;\n                return {\n                    \"& > :not([hidden]) ~ :not([hidden])\": {\n                        \"@defaults border-width\": {},\n                        \"--tw-divide-y-reverse\": \"0\",\n                        \"border-top-width\": `calc(${value} * calc(1 - var(--tw-divide-y-reverse)))`,\n                        \"border-bottom-width\": `calc(${value} * var(--tw-divide-y-reverse))`\n                    }\n                };\n            }\n        }, {\n            values: theme(\"divideWidth\"),\n            type: [\n                \"line-width\",\n                \"length\"\n            ]\n        });\n        addUtilities({\n            \".divide-y-reverse > :not([hidden]) ~ :not([hidden])\": {\n                \"@defaults border-width\": {},\n                \"--tw-divide-y-reverse\": \"1\"\n            },\n            \".divide-x-reverse > :not([hidden]) ~ :not([hidden])\": {\n                \"@defaults border-width\": {},\n                \"--tw-divide-x-reverse\": \"1\"\n            }\n        });\n    },\n    divideStyle: ({ addUtilities  })=>{\n        addUtilities({\n            \".divide-solid > :not([hidden]) ~ :not([hidden])\": {\n                \"border-style\": \"solid\"\n            },\n            \".divide-dashed > :not([hidden]) ~ :not([hidden])\": {\n                \"border-style\": \"dashed\"\n            },\n            \".divide-dotted > :not([hidden]) ~ :not([hidden])\": {\n                \"border-style\": \"dotted\"\n            },\n            \".divide-double > :not([hidden]) ~ :not([hidden])\": {\n                \"border-style\": \"double\"\n            },\n            \".divide-none > :not([hidden]) ~ :not([hidden])\": {\n                \"border-style\": \"none\"\n            }\n        });\n    },\n    divideColor: ({ matchUtilities , theme , corePlugins  })=>{\n        matchUtilities({\n            divide: (value)=>{\n                if (!corePlugins(\"divideOpacity\")) {\n                    return {\n                        [\"& > :not([hidden]) ~ :not([hidden])\"]: {\n                            \"border-color\": (0, _toColorValue.default)(value)\n                        }\n                    };\n                }\n                return {\n                    [\"& > :not([hidden]) ~ :not([hidden])\"]: (0, _withAlphaVariable.default)({\n                        color: value,\n                        property: \"border-color\",\n                        variable: \"--tw-divide-opacity\"\n                    })\n                };\n            }\n        }, {\n            values: (({ DEFAULT: _ , ...colors })=>colors)((0, _flattenColorPalette.default)(theme(\"divideColor\"))),\n            type: \"color\"\n        });\n    },\n    divideOpacity: ({ matchUtilities , theme  })=>{\n        matchUtilities({\n            \"divide-opacity\": (value)=>{\n                return {\n                    [`& > :not([hidden]) ~ :not([hidden])`]: {\n                        \"--tw-divide-opacity\": value\n                    }\n                };\n            }\n        }, {\n            values: theme(\"divideOpacity\")\n        });\n    },\n    placeSelf: ({ addUtilities  })=>{\n        addUtilities({\n            \".place-self-auto\": {\n                \"place-self\": \"auto\"\n            },\n            \".place-self-start\": {\n                \"place-self\": \"start\"\n            },\n            \".place-self-end\": {\n                \"place-self\": \"end\"\n            },\n            \".place-self-center\": {\n                \"place-self\": \"center\"\n            },\n            \".place-self-stretch\": {\n                \"place-self\": \"stretch\"\n            }\n        });\n    },\n    alignSelf: ({ addUtilities  })=>{\n        addUtilities({\n            \".self-auto\": {\n                \"align-self\": \"auto\"\n            },\n            \".self-start\": {\n                \"align-self\": \"flex-start\"\n            },\n            \".self-end\": {\n                \"align-self\": \"flex-end\"\n            },\n            \".self-center\": {\n                \"align-self\": \"center\"\n            },\n            \".self-stretch\": {\n                \"align-self\": \"stretch\"\n            },\n            \".self-baseline\": {\n                \"align-self\": \"baseline\"\n            }\n        });\n    },\n    justifySelf: ({ addUtilities  })=>{\n        addUtilities({\n            \".justify-self-auto\": {\n                \"justify-self\": \"auto\"\n            },\n            \".justify-self-start\": {\n                \"justify-self\": \"start\"\n            },\n            \".justify-self-end\": {\n                \"justify-self\": \"end\"\n            },\n            \".justify-self-center\": {\n                \"justify-self\": \"center\"\n            },\n            \".justify-self-stretch\": {\n                \"justify-self\": \"stretch\"\n            }\n        });\n    },\n    overflow: ({ addUtilities  })=>{\n        addUtilities({\n            \".overflow-auto\": {\n                overflow: \"auto\"\n            },\n            \".overflow-hidden\": {\n                overflow: \"hidden\"\n            },\n            \".overflow-clip\": {\n                overflow: \"clip\"\n            },\n            \".overflow-visible\": {\n                overflow: \"visible\"\n            },\n            \".overflow-scroll\": {\n                overflow: \"scroll\"\n            },\n            \".overflow-x-auto\": {\n                \"overflow-x\": \"auto\"\n            },\n            \".overflow-y-auto\": {\n                \"overflow-y\": \"auto\"\n            },\n            \".overflow-x-hidden\": {\n                \"overflow-x\": \"hidden\"\n            },\n            \".overflow-y-hidden\": {\n                \"overflow-y\": \"hidden\"\n            },\n            \".overflow-x-clip\": {\n                \"overflow-x\": \"clip\"\n            },\n            \".overflow-y-clip\": {\n                \"overflow-y\": \"clip\"\n            },\n            \".overflow-x-visible\": {\n                \"overflow-x\": \"visible\"\n            },\n            \".overflow-y-visible\": {\n                \"overflow-y\": \"visible\"\n            },\n            \".overflow-x-scroll\": {\n                \"overflow-x\": \"scroll\"\n            },\n            \".overflow-y-scroll\": {\n                \"overflow-y\": \"scroll\"\n            }\n        });\n    },\n    overscrollBehavior: ({ addUtilities  })=>{\n        addUtilities({\n            \".overscroll-auto\": {\n                \"overscroll-behavior\": \"auto\"\n            },\n            \".overscroll-contain\": {\n                \"overscroll-behavior\": \"contain\"\n            },\n            \".overscroll-none\": {\n                \"overscroll-behavior\": \"none\"\n            },\n            \".overscroll-y-auto\": {\n                \"overscroll-behavior-y\": \"auto\"\n            },\n            \".overscroll-y-contain\": {\n                \"overscroll-behavior-y\": \"contain\"\n            },\n            \".overscroll-y-none\": {\n                \"overscroll-behavior-y\": \"none\"\n            },\n            \".overscroll-x-auto\": {\n                \"overscroll-behavior-x\": \"auto\"\n            },\n            \".overscroll-x-contain\": {\n                \"overscroll-behavior-x\": \"contain\"\n            },\n            \".overscroll-x-none\": {\n                \"overscroll-behavior-x\": \"none\"\n            }\n        });\n    },\n    scrollBehavior: ({ addUtilities  })=>{\n        addUtilities({\n            \".scroll-auto\": {\n                \"scroll-behavior\": \"auto\"\n            },\n            \".scroll-smooth\": {\n                \"scroll-behavior\": \"smooth\"\n            }\n        });\n    },\n    textOverflow: ({ addUtilities  })=>{\n        addUtilities({\n            \".truncate\": {\n                overflow: \"hidden\",\n                \"text-overflow\": \"ellipsis\",\n                \"white-space\": \"nowrap\"\n            },\n            \".overflow-ellipsis\": {\n                \"text-overflow\": \"ellipsis\"\n            },\n            \".text-ellipsis\": {\n                \"text-overflow\": \"ellipsis\"\n            },\n            \".text-clip\": {\n                \"text-overflow\": \"clip\"\n            }\n        });\n    },\n    whitespace: ({ addUtilities  })=>{\n        addUtilities({\n            \".whitespace-normal\": {\n                \"white-space\": \"normal\"\n            },\n            \".whitespace-nowrap\": {\n                \"white-space\": \"nowrap\"\n            },\n            \".whitespace-pre\": {\n                \"white-space\": \"pre\"\n            },\n            \".whitespace-pre-line\": {\n                \"white-space\": \"pre-line\"\n            },\n            \".whitespace-pre-wrap\": {\n                \"white-space\": \"pre-wrap\"\n            }\n        });\n    },\n    wordBreak: ({ addUtilities  })=>{\n        addUtilities({\n            \".break-normal\": {\n                \"overflow-wrap\": \"normal\",\n                \"word-break\": \"normal\"\n            },\n            \".break-words\": {\n                \"overflow-wrap\": \"break-word\"\n            },\n            \".break-all\": {\n                \"word-break\": \"break-all\"\n            }\n        });\n    },\n    borderRadius: (0, _createUtilityPlugin.default)(\"borderRadius\", [\n        [\n            \"rounded\",\n            [\n                \"border-radius\"\n            ]\n        ],\n        [\n            [\n                \"rounded-t\",\n                [\n                    \"border-top-left-radius\",\n                    \"border-top-right-radius\"\n                ]\n            ],\n            [\n                \"rounded-r\",\n                [\n                    \"border-top-right-radius\",\n                    \"border-bottom-right-radius\"\n                ]\n            ],\n            [\n                \"rounded-b\",\n                [\n                    \"border-bottom-right-radius\",\n                    \"border-bottom-left-radius\"\n                ]\n            ],\n            [\n                \"rounded-l\",\n                [\n                    \"border-top-left-radius\",\n                    \"border-bottom-left-radius\"\n                ]\n            ], \n        ],\n        [\n            [\n                \"rounded-tl\",\n                [\n                    \"border-top-left-radius\"\n                ]\n            ],\n            [\n                \"rounded-tr\",\n                [\n                    \"border-top-right-radius\"\n                ]\n            ],\n            [\n                \"rounded-br\",\n                [\n                    \"border-bottom-right-radius\"\n                ]\n            ],\n            [\n                \"rounded-bl\",\n                [\n                    \"border-bottom-left-radius\"\n                ]\n            ], \n        ], \n    ]),\n    borderWidth: (0, _createUtilityPlugin.default)(\"borderWidth\", [\n        [\n            \"border\",\n            [\n                [\n                    \"@defaults border-width\",\n                    {}\n                ],\n                \"border-width\"\n            ]\n        ],\n        [\n            [\n                \"border-x\",\n                [\n                    [\n                        \"@defaults border-width\",\n                        {}\n                    ],\n                    \"border-left-width\",\n                    \"border-right-width\"\n                ]\n            ],\n            [\n                \"border-y\",\n                [\n                    [\n                        \"@defaults border-width\",\n                        {}\n                    ],\n                    \"border-top-width\",\n                    \"border-bottom-width\"\n                ]\n            ], \n        ],\n        [\n            [\n                \"border-t\",\n                [\n                    [\n                        \"@defaults border-width\",\n                        {}\n                    ],\n                    \"border-top-width\"\n                ]\n            ],\n            [\n                \"border-r\",\n                [\n                    [\n                        \"@defaults border-width\",\n                        {}\n                    ],\n                    \"border-right-width\"\n                ]\n            ],\n            [\n                \"border-b\",\n                [\n                    [\n                        \"@defaults border-width\",\n                        {}\n                    ],\n                    \"border-bottom-width\"\n                ]\n            ],\n            [\n                \"border-l\",\n                [\n                    [\n                        \"@defaults border-width\",\n                        {}\n                    ],\n                    \"border-left-width\"\n                ]\n            ], \n        ], \n    ], {\n        type: [\n            \"line-width\",\n            \"length\"\n        ]\n    }),\n    borderStyle: ({ addUtilities  })=>{\n        addUtilities({\n            \".border-solid\": {\n                \"border-style\": \"solid\"\n            },\n            \".border-dashed\": {\n                \"border-style\": \"dashed\"\n            },\n            \".border-dotted\": {\n                \"border-style\": \"dotted\"\n            },\n            \".border-double\": {\n                \"border-style\": \"double\"\n            },\n            \".border-hidden\": {\n                \"border-style\": \"hidden\"\n            },\n            \".border-none\": {\n                \"border-style\": \"none\"\n            }\n        });\n    },\n    borderColor: ({ matchUtilities , theme , corePlugins  })=>{\n        matchUtilities({\n            border: (value)=>{\n                if (!corePlugins(\"borderOpacity\")) {\n                    return {\n                        \"border-color\": (0, _toColorValue.default)(value)\n                    };\n                }\n                return (0, _withAlphaVariable.default)({\n                    color: value,\n                    property: \"border-color\",\n                    variable: \"--tw-border-opacity\"\n                });\n            }\n        }, {\n            values: (({ DEFAULT: _ , ...colors })=>colors)((0, _flattenColorPalette.default)(theme(\"borderColor\"))),\n            type: [\n                \"color\"\n            ]\n        });\n        matchUtilities({\n            \"border-x\": (value)=>{\n                if (!corePlugins(\"borderOpacity\")) {\n                    return {\n                        \"border-left-color\": (0, _toColorValue.default)(value),\n                        \"border-right-color\": (0, _toColorValue.default)(value)\n                    };\n                }\n                return (0, _withAlphaVariable.default)({\n                    color: value,\n                    property: [\n                        \"border-left-color\",\n                        \"border-right-color\"\n                    ],\n                    variable: \"--tw-border-opacity\"\n                });\n            },\n            \"border-y\": (value)=>{\n                if (!corePlugins(\"borderOpacity\")) {\n                    return {\n                        \"border-top-color\": (0, _toColorValue.default)(value),\n                        \"border-bottom-color\": (0, _toColorValue.default)(value)\n                    };\n                }\n                return (0, _withAlphaVariable.default)({\n                    color: value,\n                    property: [\n                        \"border-top-color\",\n                        \"border-bottom-color\"\n                    ],\n                    variable: \"--tw-border-opacity\"\n                });\n            }\n        }, {\n            values: (({ DEFAULT: _ , ...colors })=>colors)((0, _flattenColorPalette.default)(theme(\"borderColor\"))),\n            type: \"color\"\n        });\n        matchUtilities({\n            \"border-t\": (value)=>{\n                if (!corePlugins(\"borderOpacity\")) {\n                    return {\n                        \"border-top-color\": (0, _toColorValue.default)(value)\n                    };\n                }\n                return (0, _withAlphaVariable.default)({\n                    color: value,\n                    property: \"border-top-color\",\n                    variable: \"--tw-border-opacity\"\n                });\n            },\n            \"border-r\": (value)=>{\n                if (!corePlugins(\"borderOpacity\")) {\n                    return {\n                        \"border-right-color\": (0, _toColorValue.default)(value)\n                    };\n                }\n                return (0, _withAlphaVariable.default)({\n                    color: value,\n                    property: \"border-right-color\",\n                    variable: \"--tw-border-opacity\"\n                });\n            },\n            \"border-b\": (value)=>{\n                if (!corePlugins(\"borderOpacity\")) {\n                    return {\n                        \"border-bottom-color\": (0, _toColorValue.default)(value)\n                    };\n                }\n                return (0, _withAlphaVariable.default)({\n                    color: value,\n                    property: \"border-bottom-color\",\n                    variable: \"--tw-border-opacity\"\n                });\n            },\n            \"border-l\": (value)=>{\n                if (!corePlugins(\"borderOpacity\")) {\n                    return {\n                        \"border-left-color\": (0, _toColorValue.default)(value)\n                    };\n                }\n                return (0, _withAlphaVariable.default)({\n                    color: value,\n                    property: \"border-left-color\",\n                    variable: \"--tw-border-opacity\"\n                });\n            }\n        }, {\n            values: (({ DEFAULT: _ , ...colors })=>colors)((0, _flattenColorPalette.default)(theme(\"borderColor\"))),\n            type: \"color\"\n        });\n    },\n    borderOpacity: (0, _createUtilityPlugin.default)(\"borderOpacity\", [\n        [\n            \"border-opacity\",\n            [\n                \"--tw-border-opacity\"\n            ]\n        ], \n    ]),\n    backgroundColor: ({ matchUtilities , theme , corePlugins  })=>{\n        matchUtilities({\n            bg: (value)=>{\n                if (!corePlugins(\"backgroundOpacity\")) {\n                    return {\n                        \"background-color\": (0, _toColorValue.default)(value)\n                    };\n                }\n                return (0, _withAlphaVariable.default)({\n                    color: value,\n                    property: \"background-color\",\n                    variable: \"--tw-bg-opacity\"\n                });\n            }\n        }, {\n            values: (0, _flattenColorPalette.default)(theme(\"backgroundColor\")),\n            type: \"color\"\n        });\n    },\n    backgroundOpacity: (0, _createUtilityPlugin.default)(\"backgroundOpacity\", [\n        [\n            \"bg-opacity\",\n            [\n                \"--tw-bg-opacity\"\n            ]\n        ], \n    ]),\n    backgroundImage: (0, _createUtilityPlugin.default)(\"backgroundImage\", [\n        [\n            \"bg\",\n            [\n                \"background-image\"\n            ]\n        ]\n    ], {\n        type: [\n            \"lookup\",\n            \"image\",\n            \"url\"\n        ]\n    }),\n    gradientColorStops: (()=>{\n        function transparentTo(value) {\n            return (0, _withAlphaVariable.withAlphaValue)(value, 0, \"rgb(255 255 255 / 0)\");\n        }\n        return function({ matchUtilities , theme  }) {\n            let options = {\n                values: (0, _flattenColorPalette.default)(theme(\"gradientColorStops\")),\n                type: [\n                    \"color\",\n                    \"any\"\n                ]\n            };\n            matchUtilities({\n                from: (value)=>{\n                    let transparentToValue = transparentTo(value);\n                    return {\n                        \"--tw-gradient-from\": (0, _toColorValue.default)(value, \"from\"),\n                        \"--tw-gradient-to\": transparentToValue,\n                        \"--tw-gradient-stops\": `var(--tw-gradient-from), var(--tw-gradient-to)`\n                    };\n                }\n            }, options);\n            matchUtilities({\n                via: (value)=>{\n                    let transparentToValue = transparentTo(value);\n                    return {\n                        \"--tw-gradient-to\": transparentToValue,\n                        \"--tw-gradient-stops\": `var(--tw-gradient-from), ${(0, _toColorValue.default)(value, \"via\")}, var(--tw-gradient-to)`\n                    };\n                }\n            }, options);\n            matchUtilities({\n                to: (value)=>({\n                        \"--tw-gradient-to\": (0, _toColorValue.default)(value, \"to\")\n                    })\n            }, options);\n        };\n    })(),\n    boxDecorationBreak: ({ addUtilities  })=>{\n        addUtilities({\n            \".decoration-slice\": {\n                \"box-decoration-break\": \"slice\"\n            },\n            \".decoration-clone\": {\n                \"box-decoration-break\": \"clone\"\n            },\n            \".box-decoration-slice\": {\n                \"box-decoration-break\": \"slice\"\n            },\n            \".box-decoration-clone\": {\n                \"box-decoration-break\": \"clone\"\n            }\n        });\n    },\n    backgroundSize: (0, _createUtilityPlugin.default)(\"backgroundSize\", [\n        [\n            \"bg\",\n            [\n                \"background-size\"\n            ]\n        ]\n    ], {\n        type: [\n            \"lookup\",\n            \"length\",\n            \"percentage\"\n        ]\n    }),\n    backgroundAttachment: ({ addUtilities  })=>{\n        addUtilities({\n            \".bg-fixed\": {\n                \"background-attachment\": \"fixed\"\n            },\n            \".bg-local\": {\n                \"background-attachment\": \"local\"\n            },\n            \".bg-scroll\": {\n                \"background-attachment\": \"scroll\"\n            }\n        });\n    },\n    backgroundClip: ({ addUtilities  })=>{\n        addUtilities({\n            \".bg-clip-border\": {\n                \"background-clip\": \"border-box\"\n            },\n            \".bg-clip-padding\": {\n                \"background-clip\": \"padding-box\"\n            },\n            \".bg-clip-content\": {\n                \"background-clip\": \"content-box\"\n            },\n            \".bg-clip-text\": {\n                \"background-clip\": \"text\"\n            }\n        });\n    },\n    backgroundPosition: (0, _createUtilityPlugin.default)(\"backgroundPosition\", [\n        [\n            \"bg\",\n            [\n                \"background-position\"\n            ]\n        ]\n    ], {\n        type: [\n            \"lookup\",\n            \"position\"\n        ]\n    }),\n    backgroundRepeat: ({ addUtilities  })=>{\n        addUtilities({\n            \".bg-repeat\": {\n                \"background-repeat\": \"repeat\"\n            },\n            \".bg-no-repeat\": {\n                \"background-repeat\": \"no-repeat\"\n            },\n            \".bg-repeat-x\": {\n                \"background-repeat\": \"repeat-x\"\n            },\n            \".bg-repeat-y\": {\n                \"background-repeat\": \"repeat-y\"\n            },\n            \".bg-repeat-round\": {\n                \"background-repeat\": \"round\"\n            },\n            \".bg-repeat-space\": {\n                \"background-repeat\": \"space\"\n            }\n        });\n    },\n    backgroundOrigin: ({ addUtilities  })=>{\n        addUtilities({\n            \".bg-origin-border\": {\n                \"background-origin\": \"border-box\"\n            },\n            \".bg-origin-padding\": {\n                \"background-origin\": \"padding-box\"\n            },\n            \".bg-origin-content\": {\n                \"background-origin\": \"content-box\"\n            }\n        });\n    },\n    fill: ({ matchUtilities , theme  })=>{\n        matchUtilities({\n            fill: (value)=>{\n                return {\n                    fill: (0, _toColorValue.default)(value)\n                };\n            }\n        }, {\n            values: (0, _flattenColorPalette.default)(theme(\"fill\")),\n            type: [\n                \"color\",\n                \"any\"\n            ]\n        });\n    },\n    stroke: ({ matchUtilities , theme  })=>{\n        matchUtilities({\n            stroke: (value)=>{\n                return {\n                    stroke: (0, _toColorValue.default)(value)\n                };\n            }\n        }, {\n            values: (0, _flattenColorPalette.default)(theme(\"stroke\")),\n            type: [\n                \"color\",\n                \"url\"\n            ]\n        });\n    },\n    strokeWidth: (0, _createUtilityPlugin.default)(\"strokeWidth\", [\n        [\n            \"stroke\",\n            [\n                \"stroke-width\"\n            ]\n        ]\n    ], {\n        type: [\n            \"length\",\n            \"number\",\n            \"percentage\"\n        ]\n    }),\n    objectFit: ({ addUtilities  })=>{\n        addUtilities({\n            \".object-contain\": {\n                \"object-fit\": \"contain\"\n            },\n            \".object-cover\": {\n                \"object-fit\": \"cover\"\n            },\n            \".object-fill\": {\n                \"object-fit\": \"fill\"\n            },\n            \".object-none\": {\n                \"object-fit\": \"none\"\n            },\n            \".object-scale-down\": {\n                \"object-fit\": \"scale-down\"\n            }\n        });\n    },\n    objectPosition: (0, _createUtilityPlugin.default)(\"objectPosition\", [\n        [\n            \"object\",\n            [\n                \"object-position\"\n            ]\n        ]\n    ]),\n    padding: (0, _createUtilityPlugin.default)(\"padding\", [\n        [\n            \"p\",\n            [\n                \"padding\"\n            ]\n        ],\n        [\n            [\n                \"px\",\n                [\n                    \"padding-left\",\n                    \"padding-right\"\n                ]\n            ],\n            [\n                \"py\",\n                [\n                    \"padding-top\",\n                    \"padding-bottom\"\n                ]\n            ], \n        ],\n        [\n            [\n                \"pt\",\n                [\n                    \"padding-top\"\n                ]\n            ],\n            [\n                \"pr\",\n                [\n                    \"padding-right\"\n                ]\n            ],\n            [\n                \"pb\",\n                [\n                    \"padding-bottom\"\n                ]\n            ],\n            [\n                \"pl\",\n                [\n                    \"padding-left\"\n                ]\n            ], \n        ], \n    ]),\n    textAlign: ({ addUtilities  })=>{\n        addUtilities({\n            \".text-left\": {\n                \"text-align\": \"left\"\n            },\n            \".text-center\": {\n                \"text-align\": \"center\"\n            },\n            \".text-right\": {\n                \"text-align\": \"right\"\n            },\n            \".text-justify\": {\n                \"text-align\": \"justify\"\n            },\n            \".text-start\": {\n                \"text-align\": \"start\"\n            },\n            \".text-end\": {\n                \"text-align\": \"end\"\n            }\n        });\n    },\n    textIndent: (0, _createUtilityPlugin.default)(\"textIndent\", [\n        [\n            \"indent\",\n            [\n                \"text-indent\"\n            ]\n        ]\n    ], {\n        supportsNegativeValues: true\n    }),\n    verticalAlign: ({ addUtilities , matchUtilities  })=>{\n        addUtilities({\n            \".align-baseline\": {\n                \"vertical-align\": \"baseline\"\n            },\n            \".align-top\": {\n                \"vertical-align\": \"top\"\n            },\n            \".align-middle\": {\n                \"vertical-align\": \"middle\"\n            },\n            \".align-bottom\": {\n                \"vertical-align\": \"bottom\"\n            },\n            \".align-text-top\": {\n                \"vertical-align\": \"text-top\"\n            },\n            \".align-text-bottom\": {\n                \"vertical-align\": \"text-bottom\"\n            },\n            \".align-sub\": {\n                \"vertical-align\": \"sub\"\n            },\n            \".align-super\": {\n                \"vertical-align\": \"super\"\n            }\n        });\n        matchUtilities({\n            align: (value)=>({\n                    \"vertical-align\": value\n                })\n        });\n    },\n    fontFamily: (0, _createUtilityPlugin.default)(\"fontFamily\", [\n        [\n            \"font\",\n            [\n                \"fontFamily\"\n            ]\n        ]\n    ], {\n        type: [\n            \"lookup\",\n            \"generic-name\",\n            \"family-name\"\n        ]\n    }),\n    fontSize: ({ matchUtilities , theme  })=>{\n        matchUtilities({\n            text: (value)=>{\n                let [fontSize, options] = Array.isArray(value) ? value : [\n                    value\n                ];\n                let { lineHeight , letterSpacing , fontWeight  } = (0, _isPlainObject.default)(options) ? options : {\n                    lineHeight: options\n                };\n                return {\n                    \"font-size\": fontSize,\n                    ...lineHeight === undefined ? {} : {\n                        \"line-height\": lineHeight\n                    },\n                    ...letterSpacing === undefined ? {} : {\n                        \"letter-spacing\": letterSpacing\n                    },\n                    ...fontWeight === undefined ? {} : {\n                        \"font-weight\": fontWeight\n                    }\n                };\n            }\n        }, {\n            values: theme(\"fontSize\"),\n            type: [\n                \"absolute-size\",\n                \"relative-size\",\n                \"length\",\n                \"percentage\"\n            ]\n        });\n    },\n    fontWeight: (0, _createUtilityPlugin.default)(\"fontWeight\", [\n        [\n            \"font\",\n            [\n                \"fontWeight\"\n            ]\n        ]\n    ], {\n        type: [\n            \"lookup\",\n            \"number\"\n        ]\n    }),\n    textTransform: ({ addUtilities  })=>{\n        addUtilities({\n            \".uppercase\": {\n                \"text-transform\": \"uppercase\"\n            },\n            \".lowercase\": {\n                \"text-transform\": \"lowercase\"\n            },\n            \".capitalize\": {\n                \"text-transform\": \"capitalize\"\n            },\n            \".normal-case\": {\n                \"text-transform\": \"none\"\n            }\n        });\n    },\n    fontStyle: ({ addUtilities  })=>{\n        addUtilities({\n            \".italic\": {\n                \"font-style\": \"italic\"\n            },\n            \".not-italic\": {\n                \"font-style\": \"normal\"\n            }\n        });\n    },\n    fontVariantNumeric: ({ addDefaults , addUtilities  })=>{\n        let cssFontVariantNumericValue = \"var(--tw-ordinal) var(--tw-slashed-zero) var(--tw-numeric-figure) var(--tw-numeric-spacing) var(--tw-numeric-fraction)\";\n        addDefaults(\"font-variant-numeric\", {\n            \"--tw-ordinal\": \" \",\n            \"--tw-slashed-zero\": \" \",\n            \"--tw-numeric-figure\": \" \",\n            \"--tw-numeric-spacing\": \" \",\n            \"--tw-numeric-fraction\": \" \"\n        });\n        addUtilities({\n            \".normal-nums\": {\n                \"font-variant-numeric\": \"normal\"\n            },\n            \".ordinal\": {\n                \"@defaults font-variant-numeric\": {},\n                \"--tw-ordinal\": \"ordinal\",\n                \"font-variant-numeric\": cssFontVariantNumericValue\n            },\n            \".slashed-zero\": {\n                \"@defaults font-variant-numeric\": {},\n                \"--tw-slashed-zero\": \"slashed-zero\",\n                \"font-variant-numeric\": cssFontVariantNumericValue\n            },\n            \".lining-nums\": {\n                \"@defaults font-variant-numeric\": {},\n                \"--tw-numeric-figure\": \"lining-nums\",\n                \"font-variant-numeric\": cssFontVariantNumericValue\n            },\n            \".oldstyle-nums\": {\n                \"@defaults font-variant-numeric\": {},\n                \"--tw-numeric-figure\": \"oldstyle-nums\",\n                \"font-variant-numeric\": cssFontVariantNumericValue\n            },\n            \".proportional-nums\": {\n                \"@defaults font-variant-numeric\": {},\n                \"--tw-numeric-spacing\": \"proportional-nums\",\n                \"font-variant-numeric\": cssFontVariantNumericValue\n            },\n            \".tabular-nums\": {\n                \"@defaults font-variant-numeric\": {},\n                \"--tw-numeric-spacing\": \"tabular-nums\",\n                \"font-variant-numeric\": cssFontVariantNumericValue\n            },\n            \".diagonal-fractions\": {\n                \"@defaults font-variant-numeric\": {},\n                \"--tw-numeric-fraction\": \"diagonal-fractions\",\n                \"font-variant-numeric\": cssFontVariantNumericValue\n            },\n            \".stacked-fractions\": {\n                \"@defaults font-variant-numeric\": {},\n                \"--tw-numeric-fraction\": \"stacked-fractions\",\n                \"font-variant-numeric\": cssFontVariantNumericValue\n            }\n        });\n    },\n    lineHeight: (0, _createUtilityPlugin.default)(\"lineHeight\", [\n        [\n            \"leading\",\n            [\n                \"lineHeight\"\n            ]\n        ]\n    ]),\n    letterSpacing: (0, _createUtilityPlugin.default)(\"letterSpacing\", [\n        [\n            \"tracking\",\n            [\n                \"letterSpacing\"\n            ]\n        ]\n    ], {\n        supportsNegativeValues: true\n    }),\n    textColor: ({ matchUtilities , theme , corePlugins  })=>{\n        matchUtilities({\n            text: (value)=>{\n                if (!corePlugins(\"textOpacity\")) {\n                    return {\n                        color: (0, _toColorValue.default)(value)\n                    };\n                }\n                return (0, _withAlphaVariable.default)({\n                    color: value,\n                    property: \"color\",\n                    variable: \"--tw-text-opacity\"\n                });\n            }\n        }, {\n            values: (0, _flattenColorPalette.default)(theme(\"textColor\")),\n            type: \"color\"\n        });\n    },\n    textOpacity: (0, _createUtilityPlugin.default)(\"textOpacity\", [\n        [\n            \"text-opacity\",\n            [\n                \"--tw-text-opacity\"\n            ]\n        ]\n    ]),\n    textDecoration: ({ addUtilities  })=>{\n        addUtilities({\n            \".underline\": {\n                \"text-decoration-line\": \"underline\"\n            },\n            \".overline\": {\n                \"text-decoration-line\": \"overline\"\n            },\n            \".line-through\": {\n                \"text-decoration-line\": \"line-through\"\n            },\n            \".no-underline\": {\n                \"text-decoration-line\": \"none\"\n            }\n        });\n    },\n    textDecorationColor: ({ matchUtilities , theme  })=>{\n        matchUtilities({\n            decoration: (value)=>{\n                return {\n                    \"text-decoration-color\": (0, _toColorValue.default)(value)\n                };\n            }\n        }, {\n            values: (0, _flattenColorPalette.default)(theme(\"textDecorationColor\")),\n            type: [\n                \"color\"\n            ]\n        });\n    },\n    textDecorationStyle: ({ addUtilities  })=>{\n        addUtilities({\n            \".decoration-solid\": {\n                \"text-decoration-style\": \"solid\"\n            },\n            \".decoration-double\": {\n                \"text-decoration-style\": \"double\"\n            },\n            \".decoration-dotted\": {\n                \"text-decoration-style\": \"dotted\"\n            },\n            \".decoration-dashed\": {\n                \"text-decoration-style\": \"dashed\"\n            },\n            \".decoration-wavy\": {\n                \"text-decoration-style\": \"wavy\"\n            }\n        });\n    },\n    textDecorationThickness: (0, _createUtilityPlugin.default)(\"textDecorationThickness\", [\n        [\n            \"decoration\",\n            [\n                \"text-decoration-thickness\"\n            ]\n        ]\n    ], {\n        type: [\n            \"length\",\n            \"percentage\"\n        ]\n    }),\n    textUnderlineOffset: (0, _createUtilityPlugin.default)(\"textUnderlineOffset\", [\n        [\n            \"underline-offset\",\n            [\n                \"text-underline-offset\"\n            ]\n        ]\n    ], {\n        type: [\n            \"length\",\n            \"percentage\"\n        ]\n    }),\n    fontSmoothing: ({ addUtilities  })=>{\n        addUtilities({\n            \".antialiased\": {\n                \"-webkit-font-smoothing\": \"antialiased\",\n                \"-moz-osx-font-smoothing\": \"grayscale\"\n            },\n            \".subpixel-antialiased\": {\n                \"-webkit-font-smoothing\": \"auto\",\n                \"-moz-osx-font-smoothing\": \"auto\"\n            }\n        });\n    },\n    placeholderColor: ({ matchUtilities , theme , corePlugins  })=>{\n        matchUtilities({\n            placeholder: (value)=>{\n                if (!corePlugins(\"placeholderOpacity\")) {\n                    return {\n                        \"&::placeholder\": {\n                            color: (0, _toColorValue.default)(value)\n                        }\n                    };\n                }\n                return {\n                    \"&::placeholder\": (0, _withAlphaVariable.default)({\n                        color: value,\n                        property: \"color\",\n                        variable: \"--tw-placeholder-opacity\"\n                    })\n                };\n            }\n        }, {\n            values: (0, _flattenColorPalette.default)(theme(\"placeholderColor\")),\n            type: [\n                \"color\",\n                \"any\"\n            ]\n        });\n    },\n    placeholderOpacity: ({ matchUtilities , theme  })=>{\n        matchUtilities({\n            \"placeholder-opacity\": (value)=>{\n                return {\n                    [\"&::placeholder\"]: {\n                        \"--tw-placeholder-opacity\": value\n                    }\n                };\n            }\n        }, {\n            values: theme(\"placeholderOpacity\")\n        });\n    },\n    caretColor: ({ matchUtilities , theme  })=>{\n        matchUtilities({\n            caret: (value)=>{\n                return {\n                    \"caret-color\": (0, _toColorValue.default)(value)\n                };\n            }\n        }, {\n            values: (0, _flattenColorPalette.default)(theme(\"caretColor\")),\n            type: [\n                \"color\",\n                \"any\"\n            ]\n        });\n    },\n    accentColor: ({ matchUtilities , theme  })=>{\n        matchUtilities({\n            accent: (value)=>{\n                return {\n                    \"accent-color\": (0, _toColorValue.default)(value)\n                };\n            }\n        }, {\n            values: (0, _flattenColorPalette.default)(theme(\"accentColor\")),\n            type: [\n                \"color\",\n                \"any\"\n            ]\n        });\n    },\n    opacity: (0, _createUtilityPlugin.default)(\"opacity\", [\n        [\n            \"opacity\",\n            [\n                \"opacity\"\n            ]\n        ]\n    ]),\n    backgroundBlendMode: ({ addUtilities  })=>{\n        addUtilities({\n            \".bg-blend-normal\": {\n                \"background-blend-mode\": \"normal\"\n            },\n            \".bg-blend-multiply\": {\n                \"background-blend-mode\": \"multiply\"\n            },\n            \".bg-blend-screen\": {\n                \"background-blend-mode\": \"screen\"\n            },\n            \".bg-blend-overlay\": {\n                \"background-blend-mode\": \"overlay\"\n            },\n            \".bg-blend-darken\": {\n                \"background-blend-mode\": \"darken\"\n            },\n            \".bg-blend-lighten\": {\n                \"background-blend-mode\": \"lighten\"\n            },\n            \".bg-blend-color-dodge\": {\n                \"background-blend-mode\": \"color-dodge\"\n            },\n            \".bg-blend-color-burn\": {\n                \"background-blend-mode\": \"color-burn\"\n            },\n            \".bg-blend-hard-light\": {\n                \"background-blend-mode\": \"hard-light\"\n            },\n            \".bg-blend-soft-light\": {\n                \"background-blend-mode\": \"soft-light\"\n            },\n            \".bg-blend-difference\": {\n                \"background-blend-mode\": \"difference\"\n            },\n            \".bg-blend-exclusion\": {\n                \"background-blend-mode\": \"exclusion\"\n            },\n            \".bg-blend-hue\": {\n                \"background-blend-mode\": \"hue\"\n            },\n            \".bg-blend-saturation\": {\n                \"background-blend-mode\": \"saturation\"\n            },\n            \".bg-blend-color\": {\n                \"background-blend-mode\": \"color\"\n            },\n            \".bg-blend-luminosity\": {\n                \"background-blend-mode\": \"luminosity\"\n            }\n        });\n    },\n    mixBlendMode: ({ addUtilities  })=>{\n        addUtilities({\n            \".mix-blend-normal\": {\n                \"mix-blend-mode\": \"normal\"\n            },\n            \".mix-blend-multiply\": {\n                \"mix-blend-mode\": \"multiply\"\n            },\n            \".mix-blend-screen\": {\n                \"mix-blend-mode\": \"screen\"\n            },\n            \".mix-blend-overlay\": {\n                \"mix-blend-mode\": \"overlay\"\n            },\n            \".mix-blend-darken\": {\n                \"mix-blend-mode\": \"darken\"\n            },\n            \".mix-blend-lighten\": {\n                \"mix-blend-mode\": \"lighten\"\n            },\n            \".mix-blend-color-dodge\": {\n                \"mix-blend-mode\": \"color-dodge\"\n            },\n            \".mix-blend-color-burn\": {\n                \"mix-blend-mode\": \"color-burn\"\n            },\n            \".mix-blend-hard-light\": {\n                \"mix-blend-mode\": \"hard-light\"\n            },\n            \".mix-blend-soft-light\": {\n                \"mix-blend-mode\": \"soft-light\"\n            },\n            \".mix-blend-difference\": {\n                \"mix-blend-mode\": \"difference\"\n            },\n            \".mix-blend-exclusion\": {\n                \"mix-blend-mode\": \"exclusion\"\n            },\n            \".mix-blend-hue\": {\n                \"mix-blend-mode\": \"hue\"\n            },\n            \".mix-blend-saturation\": {\n                \"mix-blend-mode\": \"saturation\"\n            },\n            \".mix-blend-color\": {\n                \"mix-blend-mode\": \"color\"\n            },\n            \".mix-blend-luminosity\": {\n                \"mix-blend-mode\": \"luminosity\"\n            },\n            \".mix-blend-plus-lighter\": {\n                \"mix-blend-mode\": \"plus-lighter\"\n            }\n        });\n    },\n    boxShadow: (()=>{\n        let transformValue = (0, _transformThemeValue.default)(\"boxShadow\");\n        let defaultBoxShadow = [\n            `var(--tw-ring-offset-shadow, 0 0 #0000)`,\n            `var(--tw-ring-shadow, 0 0 #0000)`,\n            `var(--tw-shadow)`, \n        ].join(\", \");\n        return function({ matchUtilities , addDefaults , theme  }) {\n            addDefaults(\" box-shadow\", {\n                \"--tw-ring-offset-shadow\": \"0 0 #0000\",\n                \"--tw-ring-shadow\": \"0 0 #0000\",\n                \"--tw-shadow\": \"0 0 #0000\",\n                \"--tw-shadow-colored\": \"0 0 #0000\"\n            });\n            matchUtilities({\n                shadow: (value)=>{\n                    value = transformValue(value);\n                    let ast = (0, _parseBoxShadowValue.parseBoxShadowValue)(value);\n                    for (let shadow of ast){\n                        // Don't override color if the whole shadow is a variable\n                        if (!shadow.valid) {\n                            continue;\n                        }\n                        shadow.color = \"var(--tw-shadow-color)\";\n                    }\n                    return {\n                        \"@defaults box-shadow\": {},\n                        \"--tw-shadow\": value === \"none\" ? \"0 0 #0000\" : value,\n                        \"--tw-shadow-colored\": value === \"none\" ? \"0 0 #0000\" : (0, _parseBoxShadowValue.formatBoxShadowValue)(ast),\n                        \"box-shadow\": defaultBoxShadow\n                    };\n                }\n            }, {\n                values: theme(\"boxShadow\"),\n                type: [\n                    \"shadow\"\n                ]\n            });\n        };\n    })(),\n    boxShadowColor: ({ matchUtilities , theme  })=>{\n        matchUtilities({\n            shadow: (value)=>{\n                return {\n                    \"--tw-shadow-color\": (0, _toColorValue.default)(value),\n                    \"--tw-shadow\": \"var(--tw-shadow-colored)\"\n                };\n            }\n        }, {\n            values: (0, _flattenColorPalette.default)(theme(\"boxShadowColor\")),\n            type: [\n                \"color\"\n            ]\n        });\n    },\n    outlineStyle: ({ addUtilities  })=>{\n        addUtilities({\n            \".outline-none\": {\n                outline: \"2px solid transparent\",\n                \"outline-offset\": \"2px\"\n            },\n            \".outline\": {\n                \"outline-style\": \"solid\"\n            },\n            \".outline-dashed\": {\n                \"outline-style\": \"dashed\"\n            },\n            \".outline-dotted\": {\n                \"outline-style\": \"dotted\"\n            },\n            \".outline-double\": {\n                \"outline-style\": \"double\"\n            },\n            \".outline-hidden\": {\n                \"outline-style\": \"hidden\"\n            }\n        });\n    },\n    outlineWidth: (0, _createUtilityPlugin.default)(\"outlineWidth\", [\n        [\n            \"outline\",\n            [\n                \"outline-width\"\n            ]\n        ]\n    ], {\n        type: [\n            \"length\",\n            \"number\",\n            \"percentage\"\n        ]\n    }),\n    outlineOffset: (0, _createUtilityPlugin.default)(\"outlineOffset\", [\n        [\n            \"outline-offset\",\n            [\n                \"outline-offset\"\n            ]\n        ]\n    ], {\n        type: [\n            \"length\",\n            \"number\",\n            \"percentage\"\n        ]\n    }),\n    outlineColor: ({ matchUtilities , theme  })=>{\n        matchUtilities({\n            outline: (value)=>{\n                return {\n                    \"outline-color\": (0, _toColorValue.default)(value)\n                };\n            }\n        }, {\n            values: (0, _flattenColorPalette.default)(theme(\"outlineColor\")),\n            type: [\n                \"color\"\n            ]\n        });\n    },\n    ringWidth: ({ matchUtilities , addDefaults , addUtilities , theme , config  })=>{\n        let ringColorDefault = (()=>{\n            var ref, ref1;\n            if ((0, _featureFlags.flagEnabled)(config(), \"respectDefaultRingColorOpacity\")) {\n                return theme(\"ringColor.DEFAULT\");\n            }\n            let ringOpacityDefault = theme(\"ringOpacity.DEFAULT\", \"0.5\");\n            if (!((ref = theme(\"ringColor\")) === null || ref === void 0 ? void 0 : ref.DEFAULT)) {\n                return `rgb(147 197 253 / ${ringOpacityDefault})`;\n            }\n            return (0, _withAlphaVariable.withAlphaValue)((ref1 = theme(\"ringColor\")) === null || ref1 === void 0 ? void 0 : ref1.DEFAULT, ringOpacityDefault, `rgb(147 197 253 / ${ringOpacityDefault})`);\n        })();\n        addDefaults(\"ring-width\", {\n            \"--tw-ring-inset\": \" \",\n            \"--tw-ring-offset-width\": theme(\"ringOffsetWidth.DEFAULT\", \"0px\"),\n            \"--tw-ring-offset-color\": theme(\"ringOffsetColor.DEFAULT\", \"#fff\"),\n            \"--tw-ring-color\": ringColorDefault,\n            \"--tw-ring-offset-shadow\": \"0 0 #0000\",\n            \"--tw-ring-shadow\": \"0 0 #0000\",\n            \"--tw-shadow\": \"0 0 #0000\",\n            \"--tw-shadow-colored\": \"0 0 #0000\"\n        });\n        matchUtilities({\n            ring: (value)=>{\n                return {\n                    \"@defaults ring-width\": {},\n                    \"--tw-ring-offset-shadow\": `var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color)`,\n                    \"--tw-ring-shadow\": `var(--tw-ring-inset) 0 0 0 calc(${value} + var(--tw-ring-offset-width)) var(--tw-ring-color)`,\n                    \"box-shadow\": [\n                        `var(--tw-ring-offset-shadow)`,\n                        `var(--tw-ring-shadow)`,\n                        `var(--tw-shadow, 0 0 #0000)`, \n                    ].join(\", \")\n                };\n            }\n        }, {\n            values: theme(\"ringWidth\"),\n            type: \"length\"\n        });\n        addUtilities({\n            \".ring-inset\": {\n                \"@defaults ring-width\": {},\n                \"--tw-ring-inset\": \"inset\"\n            }\n        });\n    },\n    ringColor: ({ matchUtilities , theme , corePlugins  })=>{\n        matchUtilities({\n            ring: (value)=>{\n                if (!corePlugins(\"ringOpacity\")) {\n                    return {\n                        \"--tw-ring-color\": (0, _toColorValue.default)(value)\n                    };\n                }\n                return (0, _withAlphaVariable.default)({\n                    color: value,\n                    property: \"--tw-ring-color\",\n                    variable: \"--tw-ring-opacity\"\n                });\n            }\n        }, {\n            values: Object.fromEntries(Object.entries((0, _flattenColorPalette.default)(theme(\"ringColor\"))).filter(([modifier])=>modifier !== \"DEFAULT\")),\n            type: \"color\"\n        });\n    },\n    ringOpacity: (helpers)=>{\n        let { config  } = helpers;\n        return (0, _createUtilityPlugin.default)(\"ringOpacity\", [\n            [\n                \"ring-opacity\",\n                [\n                    \"--tw-ring-opacity\"\n                ]\n            ]\n        ], {\n            filterDefault: !(0, _featureFlags.flagEnabled)(config(), \"respectDefaultRingColorOpacity\")\n        })(helpers);\n    },\n    ringOffsetWidth: (0, _createUtilityPlugin.default)(\"ringOffsetWidth\", [\n        [\n            \"ring-offset\",\n            [\n                \"--tw-ring-offset-width\"\n            ]\n        ]\n    ], {\n        type: \"length\"\n    }),\n    ringOffsetColor: ({ matchUtilities , theme  })=>{\n        matchUtilities({\n            \"ring-offset\": (value)=>{\n                return {\n                    \"--tw-ring-offset-color\": (0, _toColorValue.default)(value)\n                };\n            }\n        }, {\n            values: (0, _flattenColorPalette.default)(theme(\"ringOffsetColor\")),\n            type: \"color\"\n        });\n    },\n    blur: ({ matchUtilities , theme  })=>{\n        matchUtilities({\n            blur: (value)=>{\n                return {\n                    \"--tw-blur\": `blur(${value})`,\n                    \"@defaults filter\": {},\n                    filter: cssFilterValue\n                };\n            }\n        }, {\n            values: theme(\"blur\")\n        });\n    },\n    brightness: ({ matchUtilities , theme  })=>{\n        matchUtilities({\n            brightness: (value)=>{\n                return {\n                    \"--tw-brightness\": `brightness(${value})`,\n                    \"@defaults filter\": {},\n                    filter: cssFilterValue\n                };\n            }\n        }, {\n            values: theme(\"brightness\")\n        });\n    },\n    contrast: ({ matchUtilities , theme  })=>{\n        matchUtilities({\n            contrast: (value)=>{\n                return {\n                    \"--tw-contrast\": `contrast(${value})`,\n                    \"@defaults filter\": {},\n                    filter: cssFilterValue\n                };\n            }\n        }, {\n            values: theme(\"contrast\")\n        });\n    },\n    dropShadow: ({ matchUtilities , theme  })=>{\n        matchUtilities({\n            \"drop-shadow\": (value)=>{\n                return {\n                    \"--tw-drop-shadow\": Array.isArray(value) ? value.map((v)=>`drop-shadow(${v})`).join(\" \") : `drop-shadow(${value})`,\n                    \"@defaults filter\": {},\n                    filter: cssFilterValue\n                };\n            }\n        }, {\n            values: theme(\"dropShadow\")\n        });\n    },\n    grayscale: ({ matchUtilities , theme  })=>{\n        matchUtilities({\n            grayscale: (value)=>{\n                return {\n                    \"--tw-grayscale\": `grayscale(${value})`,\n                    \"@defaults filter\": {},\n                    filter: cssFilterValue\n                };\n            }\n        }, {\n            values: theme(\"grayscale\")\n        });\n    },\n    hueRotate: ({ matchUtilities , theme  })=>{\n        matchUtilities({\n            \"hue-rotate\": (value)=>{\n                return {\n                    \"--tw-hue-rotate\": `hue-rotate(${value})`,\n                    \"@defaults filter\": {},\n                    filter: cssFilterValue\n                };\n            }\n        }, {\n            values: theme(\"hueRotate\"),\n            supportsNegativeValues: true\n        });\n    },\n    invert: ({ matchUtilities , theme  })=>{\n        matchUtilities({\n            invert: (value)=>{\n                return {\n                    \"--tw-invert\": `invert(${value})`,\n                    \"@defaults filter\": {},\n                    filter: cssFilterValue\n                };\n            }\n        }, {\n            values: theme(\"invert\")\n        });\n    },\n    saturate: ({ matchUtilities , theme  })=>{\n        matchUtilities({\n            saturate: (value)=>{\n                return {\n                    \"--tw-saturate\": `saturate(${value})`,\n                    \"@defaults filter\": {},\n                    filter: cssFilterValue\n                };\n            }\n        }, {\n            values: theme(\"saturate\")\n        });\n    },\n    sepia: ({ matchUtilities , theme  })=>{\n        matchUtilities({\n            sepia: (value)=>{\n                return {\n                    \"--tw-sepia\": `sepia(${value})`,\n                    \"@defaults filter\": {},\n                    filter: cssFilterValue\n                };\n            }\n        }, {\n            values: theme(\"sepia\")\n        });\n    },\n    filter: ({ addDefaults , addUtilities  })=>{\n        addDefaults(\"filter\", {\n            \"--tw-blur\": \" \",\n            \"--tw-brightness\": \" \",\n            \"--tw-contrast\": \" \",\n            \"--tw-grayscale\": \" \",\n            \"--tw-hue-rotate\": \" \",\n            \"--tw-invert\": \" \",\n            \"--tw-saturate\": \" \",\n            \"--tw-sepia\": \" \",\n            \"--tw-drop-shadow\": \" \"\n        });\n        addUtilities({\n            \".filter\": {\n                \"@defaults filter\": {},\n                filter: cssFilterValue\n            },\n            \".filter-none\": {\n                filter: \"none\"\n            }\n        });\n    },\n    backdropBlur: ({ matchUtilities , theme  })=>{\n        matchUtilities({\n            \"backdrop-blur\": (value)=>{\n                return {\n                    \"--tw-backdrop-blur\": `blur(${value})`,\n                    \"@defaults backdrop-filter\": {},\n                    \"backdrop-filter\": cssBackdropFilterValue\n                };\n            }\n        }, {\n            values: theme(\"backdropBlur\")\n        });\n    },\n    backdropBrightness: ({ matchUtilities , theme  })=>{\n        matchUtilities({\n            \"backdrop-brightness\": (value)=>{\n                return {\n                    \"--tw-backdrop-brightness\": `brightness(${value})`,\n                    \"@defaults backdrop-filter\": {},\n                    \"backdrop-filter\": cssBackdropFilterValue\n                };\n            }\n        }, {\n            values: theme(\"backdropBrightness\")\n        });\n    },\n    backdropContrast: ({ matchUtilities , theme  })=>{\n        matchUtilities({\n            \"backdrop-contrast\": (value)=>{\n                return {\n                    \"--tw-backdrop-contrast\": `contrast(${value})`,\n                    \"@defaults backdrop-filter\": {},\n                    \"backdrop-filter\": cssBackdropFilterValue\n                };\n            }\n        }, {\n            values: theme(\"backdropContrast\")\n        });\n    },\n    backdropGrayscale: ({ matchUtilities , theme  })=>{\n        matchUtilities({\n            \"backdrop-grayscale\": (value)=>{\n                return {\n                    \"--tw-backdrop-grayscale\": `grayscale(${value})`,\n                    \"@defaults backdrop-filter\": {},\n                    \"backdrop-filter\": cssBackdropFilterValue\n                };\n            }\n        }, {\n            values: theme(\"backdropGrayscale\")\n        });\n    },\n    backdropHueRotate: ({ matchUtilities , theme  })=>{\n        matchUtilities({\n            \"backdrop-hue-rotate\": (value)=>{\n                return {\n                    \"--tw-backdrop-hue-rotate\": `hue-rotate(${value})`,\n                    \"@defaults backdrop-filter\": {},\n                    \"backdrop-filter\": cssBackdropFilterValue\n                };\n            }\n        }, {\n            values: theme(\"backdropHueRotate\"),\n            supportsNegativeValues: true\n        });\n    },\n    backdropInvert: ({ matchUtilities , theme  })=>{\n        matchUtilities({\n            \"backdrop-invert\": (value)=>{\n                return {\n                    \"--tw-backdrop-invert\": `invert(${value})`,\n                    \"@defaults backdrop-filter\": {},\n                    \"backdrop-filter\": cssBackdropFilterValue\n                };\n            }\n        }, {\n            values: theme(\"backdropInvert\")\n        });\n    },\n    backdropOpacity: ({ matchUtilities , theme  })=>{\n        matchUtilities({\n            \"backdrop-opacity\": (value)=>{\n                return {\n                    \"--tw-backdrop-opacity\": `opacity(${value})`,\n                    \"@defaults backdrop-filter\": {},\n                    \"backdrop-filter\": cssBackdropFilterValue\n                };\n            }\n        }, {\n            values: theme(\"backdropOpacity\")\n        });\n    },\n    backdropSaturate: ({ matchUtilities , theme  })=>{\n        matchUtilities({\n            \"backdrop-saturate\": (value)=>{\n                return {\n                    \"--tw-backdrop-saturate\": `saturate(${value})`,\n                    \"@defaults backdrop-filter\": {},\n                    \"backdrop-filter\": cssBackdropFilterValue\n                };\n            }\n        }, {\n            values: theme(\"backdropSaturate\")\n        });\n    },\n    backdropSepia: ({ matchUtilities , theme  })=>{\n        matchUtilities({\n            \"backdrop-sepia\": (value)=>{\n                return {\n                    \"--tw-backdrop-sepia\": `sepia(${value})`,\n                    \"@defaults backdrop-filter\": {},\n                    \"backdrop-filter\": cssBackdropFilterValue\n                };\n            }\n        }, {\n            values: theme(\"backdropSepia\")\n        });\n    },\n    backdropFilter: ({ addDefaults , addUtilities  })=>{\n        addDefaults(\"backdrop-filter\", {\n            \"--tw-backdrop-blur\": \" \",\n            \"--tw-backdrop-brightness\": \" \",\n            \"--tw-backdrop-contrast\": \" \",\n            \"--tw-backdrop-grayscale\": \" \",\n            \"--tw-backdrop-hue-rotate\": \" \",\n            \"--tw-backdrop-invert\": \" \",\n            \"--tw-backdrop-opacity\": \" \",\n            \"--tw-backdrop-saturate\": \" \",\n            \"--tw-backdrop-sepia\": \" \"\n        });\n        addUtilities({\n            \".backdrop-filter\": {\n                \"@defaults backdrop-filter\": {},\n                \"backdrop-filter\": cssBackdropFilterValue\n            },\n            \".backdrop-filter-none\": {\n                \"backdrop-filter\": \"none\"\n            }\n        });\n    },\n    transitionProperty: ({ matchUtilities , theme  })=>{\n        let defaultTimingFunction = theme(\"transitionTimingFunction.DEFAULT\");\n        let defaultDuration = theme(\"transitionDuration.DEFAULT\");\n        matchUtilities({\n            transition: (value)=>{\n                return {\n                    \"transition-property\": value,\n                    ...value === \"none\" ? {} : {\n                        \"transition-timing-function\": defaultTimingFunction,\n                        \"transition-duration\": defaultDuration\n                    }\n                };\n            }\n        }, {\n            values: theme(\"transitionProperty\")\n        });\n    },\n    transitionDelay: (0, _createUtilityPlugin.default)(\"transitionDelay\", [\n        [\n            \"delay\",\n            [\n                \"transitionDelay\"\n            ]\n        ]\n    ]),\n    transitionDuration: (0, _createUtilityPlugin.default)(\"transitionDuration\", [\n        [\n            \"duration\",\n            [\n                \"transitionDuration\"\n            ]\n        ]\n    ], {\n        filterDefault: true\n    }),\n    transitionTimingFunction: (0, _createUtilityPlugin.default)(\"transitionTimingFunction\", [\n        [\n            \"ease\",\n            [\n                \"transitionTimingFunction\"\n            ]\n        ]\n    ], {\n        filterDefault: true\n    }),\n    willChange: (0, _createUtilityPlugin.default)(\"willChange\", [\n        [\n            \"will-change\",\n            [\n                \"will-change\"\n            ]\n        ]\n    ]),\n    content: (0, _createUtilityPlugin.default)(\"content\", [\n        [\n            \"content\",\n            [\n                \"--tw-content\",\n                [\n                    \"content\",\n                    \"var(--tw-content)\"\n                ]\n            ]\n        ], \n    ])\n};\n\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/tailwindcss/lib/corePlugins.js?");

/***/ }),

/***/ "./node_modules/tailwindcss/lib/featureFlags.js":
/*!******************************************************!*\
  !*** ./node_modules/tailwindcss/lib/featureFlags.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    flagEnabled: ()=>flagEnabled,\n    issueFlagNotices: ()=>issueFlagNotices,\n    default: ()=>_default\n});\nconst _picocolors = /*#__PURE__*/ _interopRequireDefault(__webpack_require__(/*! picocolors */ \"./node_modules/picocolors/picocolors.browser.js\"));\nconst _log = /*#__PURE__*/ _interopRequireDefault(__webpack_require__(/*! ./util/log */ \"./node_modules/tailwindcss/lib/util/log.js\"));\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        default: obj\n    };\n}\nlet defaults = {\n    optimizeUniversalDefaults: false\n};\nlet featureFlags = {\n    future: [\n        \"hoverOnlyWhenSupported\",\n        \"respectDefaultRingColorOpacity\"\n    ],\n    experimental: [\n        \"optimizeUniversalDefaults\",\n        \"matchVariant\" /* , 'variantGrouping' */ \n    ]\n};\nfunction flagEnabled(config, flag) {\n    if (featureFlags.future.includes(flag)) {\n        var ref;\n        var ref1, ref2;\n        return config.future === \"all\" || ((ref2 = (ref1 = config === null || config === void 0 ? void 0 : (ref = config.future) === null || ref === void 0 ? void 0 : ref[flag]) !== null && ref1 !== void 0 ? ref1 : defaults[flag]) !== null && ref2 !== void 0 ? ref2 : false);\n    }\n    if (featureFlags.experimental.includes(flag)) {\n        var ref3;\n        var ref4, ref5;\n        return config.experimental === \"all\" || ((ref5 = (ref4 = config === null || config === void 0 ? void 0 : (ref3 = config.experimental) === null || ref3 === void 0 ? void 0 : ref3[flag]) !== null && ref4 !== void 0 ? ref4 : defaults[flag]) !== null && ref5 !== void 0 ? ref5 : false);\n    }\n    return false;\n}\nfunction experimentalFlagsEnabled(config) {\n    if (config.experimental === \"all\") {\n        return featureFlags.experimental;\n    }\n    var ref;\n    return Object.keys((ref = config === null || config === void 0 ? void 0 : config.experimental) !== null && ref !== void 0 ? ref : {}).filter((flag)=>featureFlags.experimental.includes(flag) && config.experimental[flag]);\n}\nfunction issueFlagNotices(config) {\n    if (process.env.JEST_WORKER_ID !== undefined) {\n        return;\n    }\n    if (experimentalFlagsEnabled(config).length > 0) {\n        let changes = experimentalFlagsEnabled(config).map((s)=>_picocolors.default.yellow(s)).join(\", \");\n        _log.default.warn(\"experimental-flags-enabled\", [\n            `You have enabled experimental features: ${changes}`,\n            \"Experimental features in Tailwind CSS are not covered by semver, may introduce breaking changes, and can change at any time.\", \n        ]);\n    }\n}\nconst _default = featureFlags;\n\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/tailwindcss/lib/featureFlags.js?");

/***/ }),

/***/ "./node_modules/tailwindcss/lib/index.js":
/*!***********************************************!*\
  !*** ./node_modules/tailwindcss/lib/index.js ***!
  \***********************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nconst _setupTrackingContext = /*#__PURE__*/ _interopRequireDefault(__webpack_require__(/*! ./lib/setupTrackingContext */ \"./node_modules/tailwindcss/lib/lib/setupTrackingContext.js\"));\nconst _processTailwindFeatures = /*#__PURE__*/ _interopRequireDefault(__webpack_require__(/*! ./processTailwindFeatures */ \"./node_modules/tailwindcss/lib/processTailwindFeatures.js\"));\nconst _sharedState = __webpack_require__(/*! ./lib/sharedState */ \"./node_modules/tailwindcss/lib/lib/sharedState.js\");\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        default: obj\n    };\n}\nmodule.exports = function tailwindcss(configOrPath) {\n    return {\n        postcssPlugin: \"tailwindcss\",\n        plugins: [\n            _sharedState.env.DEBUG && function(root) {\n                console.log(\"\\n\");\n                console.time(\"JIT TOTAL\");\n                return root;\n            },\n            function(root, result) {\n                let context = (0, _setupTrackingContext.default)(configOrPath);\n                if (root.type === \"document\") {\n                    let roots = root.nodes.filter((node)=>node.type === \"root\");\n                    for (const root1 of roots){\n                        if (root1.type === \"root\") {\n                            (0, _processTailwindFeatures.default)(context)(root1, result);\n                        }\n                    }\n                    return;\n                }\n                (0, _processTailwindFeatures.default)(context)(root, result);\n            },\n            _sharedState.env.DEBUG && function(root) {\n                console.timeEnd(\"JIT TOTAL\");\n                console.log(\"\\n\");\n                return root;\n            }, \n        ].filter(Boolean)\n    };\n};\nmodule.exports.postcss = true;\n\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/tailwindcss/lib/index.js?");

/***/ }),

/***/ "./node_modules/tailwindcss/lib/lib/cacheInvalidation.js":
/*!***************************************************************!*\
  !*** ./node_modules/tailwindcss/lib/lib/cacheInvalidation.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"hasContentChanged\", ({\n    enumerable: true,\n    get: ()=>hasContentChanged\n}));\nconst _crypto = /*#__PURE__*/ _interopRequireDefault(__webpack_require__(Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'crypto'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }())));\nconst _sharedState = /*#__PURE__*/ _interopRequireWildcard(__webpack_require__(/*! ./sharedState */ \"./node_modules/tailwindcss/lib/lib/sharedState.js\"));\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        default: obj\n    };\n}\nfunction _getRequireWildcardCache(nodeInterop) {\n    if (typeof WeakMap !== \"function\") return null;\n    var cacheBabelInterop = new WeakMap();\n    var cacheNodeInterop = new WeakMap();\n    return (_getRequireWildcardCache = function(nodeInterop) {\n        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;\n    })(nodeInterop);\n}\nfunction _interopRequireWildcard(obj, nodeInterop) {\n    if (!nodeInterop && obj && obj.__esModule) {\n        return obj;\n    }\n    if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n        return {\n            default: obj\n        };\n    }\n    var cache = _getRequireWildcardCache(nodeInterop);\n    if (cache && cache.has(obj)) {\n        return cache.get(obj);\n    }\n    var newObj = {};\n    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n    for(var key in obj){\n        if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) {\n            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n            if (desc && (desc.get || desc.set)) {\n                Object.defineProperty(newObj, key, desc);\n            } else {\n                newObj[key] = obj[key];\n            }\n        }\n    }\n    newObj.default = obj;\n    if (cache) {\n        cache.set(obj, newObj);\n    }\n    return newObj;\n}\n/**\n * Calculate the hash of a string.\n *\n * This doesn't need to be cryptographically secure or\n * anything like that since it's used only to detect\n * when the CSS changes to invalidate the context.\n *\n * This is wrapped in a try/catch because it's really dependent\n * on how Node itself is build and the environment and OpenSSL\n * version / build that is installed on the user's machine.\n *\n * Based on the environment this can just outright fail.\n *\n * See https://github.com/nodejs/node/issues/40455\n *\n * @param {string} str\n */ function getHash(str) {\n    try {\n        return _crypto.default.createHash(\"md5\").update(str, \"utf-8\").digest(\"binary\");\n    } catch (err) {\n        return \"\";\n    }\n}\nfunction hasContentChanged(sourcePath, root) {\n    let css = root.toString();\n    // We only care about files with @tailwind directives\n    // Other files use an existing context\n    if (!css.includes(\"@tailwind\")) {\n        return false;\n    }\n    let existingHash = _sharedState.sourceHashMap.get(sourcePath);\n    let rootHash = getHash(css);\n    let didChange = existingHash !== rootHash;\n    _sharedState.sourceHashMap.set(sourcePath, rootHash);\n    return didChange;\n}\n\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/tailwindcss/lib/lib/cacheInvalidation.js?");

/***/ }),

/***/ "./node_modules/tailwindcss/lib/lib/collapseAdjacentRules.js":
/*!*******************************************************************!*\
  !*** ./node_modules/tailwindcss/lib/lib/collapseAdjacentRules.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"default\", ({\n    enumerable: true,\n    get: ()=>collapseAdjacentRules\n}));\nlet comparisonMap = {\n    atrule: [\n        \"name\",\n        \"params\"\n    ],\n    rule: [\n        \"selector\"\n    ]\n};\nlet types = new Set(Object.keys(comparisonMap));\nfunction collapseAdjacentRules() {\n    function collapseRulesIn(root) {\n        let currentRule = null;\n        root.each((node)=>{\n            if (!types.has(node.type)) {\n                currentRule = null;\n                return;\n            }\n            if (currentRule === null) {\n                currentRule = node;\n                return;\n            }\n            let properties = comparisonMap[node.type];\n            var _property, _property1;\n            if (node.type === \"atrule\" && node.name === \"font-face\") {\n                currentRule = node;\n            } else if (properties.every((property)=>((_property = node[property]) !== null && _property !== void 0 ? _property : \"\").replace(/\\s+/g, \" \") === ((_property1 = currentRule[property]) !== null && _property1 !== void 0 ? _property1 : \"\").replace(/\\s+/g, \" \"))) {\n                // An AtRule may not have children (for example if we encounter duplicate @import url(…) rules)\n                if (node.nodes) {\n                    currentRule.append(node.nodes);\n                }\n                node.remove();\n            } else {\n                currentRule = node;\n            }\n        });\n        // After we've collapsed adjacent rules & at-rules, we need to collapse\n        // adjacent rules & at-rules that are children of at-rules.\n        // We do not care about nesting rules because Tailwind CSS\n        // explicitly does not handle rule nesting on its own as\n        // the user is expected to use a nesting plugin\n        root.each((node)=>{\n            if (node.type === \"atrule\") {\n                collapseRulesIn(node);\n            }\n        });\n    }\n    return (root)=>{\n        collapseRulesIn(root);\n    };\n}\n\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/tailwindcss/lib/lib/collapseAdjacentRules.js?");

/***/ }),

/***/ "./node_modules/tailwindcss/lib/lib/collapseDuplicateDeclarations.js":
/*!***************************************************************************!*\
  !*** ./node_modules/tailwindcss/lib/lib/collapseDuplicateDeclarations.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"default\", ({\n    enumerable: true,\n    get: ()=>collapseDuplicateDeclarations\n}));\nfunction collapseDuplicateDeclarations() {\n    return (root)=>{\n        root.walkRules((node)=>{\n            let seen = new Map();\n            let droppable = new Set([]);\n            let byProperty = new Map();\n            node.walkDecls((decl)=>{\n                // This could happen if we have nested selectors. In that case the\n                // parent will loop over all its declarations but also the declarations\n                // of nested rules. With this we ensure that we are shallowly checking\n                // declarations.\n                if (decl.parent !== node) {\n                    return;\n                }\n                if (seen.has(decl.prop)) {\n                    // Exact same value as what we have seen so far\n                    if (seen.get(decl.prop).value === decl.value) {\n                        // Keep the last one, drop the one we've seen so far\n                        droppable.add(seen.get(decl.prop));\n                        // Override the existing one with the new value. This is necessary\n                        // so that if we happen to have more than one declaration with the\n                        // same value, that we keep removing the previous one. Otherwise we\n                        // will only remove the *first* one.\n                        seen.set(decl.prop, decl);\n                        return;\n                    }\n                    // Not the same value, so we need to check if we can merge it so\n                    // let's collect it first.\n                    if (!byProperty.has(decl.prop)) {\n                        byProperty.set(decl.prop, new Set());\n                    }\n                    byProperty.get(decl.prop).add(seen.get(decl.prop));\n                    byProperty.get(decl.prop).add(decl);\n                }\n                seen.set(decl.prop, decl);\n            });\n            // Drop all the duplicate declarations with the exact same value we've\n            // already seen so far.\n            for (let decl of droppable){\n                decl.remove();\n            }\n            // Analyze the declarations based on its unit, drop all the declarations\n            // with the same unit but the last one in the list.\n            for (let declarations of byProperty.values()){\n                let byUnit = new Map();\n                for (let decl1 of declarations){\n                    let unit = resolveUnit(decl1.value);\n                    if (unit === null) {\n                        continue;\n                    }\n                    if (!byUnit.has(unit)) {\n                        byUnit.set(unit, new Set());\n                    }\n                    byUnit.get(unit).add(decl1);\n                }\n                for (let declarations1 of byUnit.values()){\n                    // Get all but the last one\n                    let removableDeclarations = Array.from(declarations1).slice(0, -1);\n                    for (let decl2 of removableDeclarations){\n                        decl2.remove();\n                    }\n                }\n            }\n        });\n    };\n}\nlet UNITLESS_NUMBER = Symbol(\"unitless-number\");\nfunction resolveUnit(input) {\n    let result = /^-?\\d*.?\\d+([\\w%]+)?$/g.exec(input);\n    if (result) {\n        var ref;\n        return (ref = result[1]) !== null && ref !== void 0 ? ref : UNITLESS_NUMBER;\n    }\n    return null;\n}\n\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/tailwindcss/lib/lib/collapseDuplicateDeclarations.js?");

/***/ }),

/***/ "./node_modules/tailwindcss/lib/lib/defaultExtractor.js":
/*!**************************************************************!*\
  !*** ./node_modules/tailwindcss/lib/lib/defaultExtractor.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"defaultExtractor\", ({\n    enumerable: true,\n    get: ()=>defaultExtractor\n}));\nconst _featureFlags = __webpack_require__(/*! ../featureFlags */ \"./node_modules/tailwindcss/lib/featureFlags.js\");\nconst _regex = /*#__PURE__*/ _interopRequireWildcard(__webpack_require__(/*! ./regex */ \"./node_modules/tailwindcss/lib/lib/regex.js\"));\nfunction _getRequireWildcardCache(nodeInterop) {\n    if (typeof WeakMap !== \"function\") return null;\n    var cacheBabelInterop = new WeakMap();\n    var cacheNodeInterop = new WeakMap();\n    return (_getRequireWildcardCache = function(nodeInterop) {\n        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;\n    })(nodeInterop);\n}\nfunction _interopRequireWildcard(obj, nodeInterop) {\n    if (!nodeInterop && obj && obj.__esModule) {\n        return obj;\n    }\n    if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n        return {\n            default: obj\n        };\n    }\n    var cache = _getRequireWildcardCache(nodeInterop);\n    if (cache && cache.has(obj)) {\n        return cache.get(obj);\n    }\n    var newObj = {};\n    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n    for(var key in obj){\n        if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) {\n            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n            if (desc && (desc.get || desc.set)) {\n                Object.defineProperty(newObj, key, desc);\n            } else {\n                newObj[key] = obj[key];\n            }\n        }\n    }\n    newObj.default = obj;\n    if (cache) {\n        cache.set(obj, newObj);\n    }\n    return newObj;\n}\nfunction defaultExtractor(context) {\n    let patterns = Array.from(buildRegExps(context));\n    /**\n   * @param {string} content\n   */ return (content)=>{\n        /** @type {(string|string)[]} */ let results = [];\n        for (let pattern of patterns){\n            var ref;\n            results = [\n                ...results,\n                ...(ref = content.match(pattern)) !== null && ref !== void 0 ? ref : []\n            ];\n        }\n        return results.filter((v)=>v !== undefined).map(clipAtBalancedParens);\n    };\n}\nfunction* buildRegExps(context) {\n    let separator = context.tailwindConfig.separator;\n    let variantGroupingEnabled = (0, _featureFlags.flagEnabled)(context.tailwindConfig, \"variantGrouping\");\n    let prefix = context.tailwindConfig.prefix !== \"\" ? _regex.optional(_regex.pattern([\n        /-?/,\n        _regex.escape(context.tailwindConfig.prefix)\n    ])) : \"\";\n    let utility = _regex.any([\n        // Arbitrary properties\n        /\\[[^\\s:'\"`]+:[^\\s\\]]+\\]/,\n        // Utilities\n        _regex.pattern([\n            // Utility Name / Group Name\n            /-?(?:\\w+)/,\n            // Normal/Arbitrary values\n            _regex.optional(_regex.any([\n                _regex.pattern([\n                    // Arbitrary values\n                    /-(?:\\w+-)*\\[[^\\s:]+\\]/,\n                    // Not immediately followed by an `{[(`\n                    /(?![{([]])/,\n                    // optionally followed by an opacity modifier\n                    /(?:\\/[^\\s'\"`\\\\><$]*)?/, \n                ]),\n                _regex.pattern([\n                    // Arbitrary values\n                    /-(?:\\w+-)*\\[[^\\s]+\\]/,\n                    // Not immediately followed by an `{[(`\n                    /(?![{([]])/,\n                    // optionally followed by an opacity modifier\n                    /(?:\\/[^\\s'\"`\\\\$]*)?/, \n                ]),\n                // Normal values w/o quotes — may include an opacity modifier\n                /[-\\/][^\\s'\"`\\\\$={><]*/, \n            ])), \n        ]), \n    ]);\n    let variantPatterns = [\n        // Without quotes\n        _regex.any([\n            _regex.pattern([\n                /([^\\s\"'`\\[\\\\]+-)?\\[[^\\s\"'`]+\\]/,\n                separator\n            ]),\n            _regex.pattern([\n                /[^\\s\"'`\\[\\\\]+/,\n                separator\n            ]), \n        ]),\n        // With quotes allowed\n        _regex.any([\n            _regex.pattern([\n                /([^\\s\"'`\\[\\\\]+-)?\\[[^\\s`]+\\]/,\n                separator\n            ]),\n            _regex.pattern([\n                /[^\\s`\\[\\\\]+/,\n                separator\n            ]), \n        ]), \n    ];\n    for (const variantPattern of variantPatterns){\n        yield _regex.pattern([\n            // Variants\n            \"((?=((\",\n            variantPattern,\n            \")+))\\\\2)?\",\n            // Important (optional)\n            /!?/,\n            prefix,\n            variantGroupingEnabled ? _regex.any([\n                // Or any of those things but grouped separated by commas\n                _regex.pattern([\n                    /\\(/,\n                    utility,\n                    _regex.zeroOrMore([\n                        /,/,\n                        utility\n                    ]),\n                    /\\)/\n                ]),\n                // Arbitrary properties, constrained utilities, arbitrary values, etc…\n                utility, \n            ]) : utility, \n        ]);\n    }\n    // 5. Inner matches\n    yield /[^<>\"'`\\s.(){}[\\]#=%$]*[^<>\"'`\\s.(){}[\\]#=%:$]/g;\n}\n// We want to capture any \"special\" characters\n// AND the characters immediately following them (if there is one)\nlet SPECIALS = /([\\[\\]'\"`])([^\\[\\]'\"`])?/g;\nlet ALLOWED_CLASS_CHARACTERS = /[^\"'`\\s<>\\]]+/;\n/**\n * Clips a string ensuring that parentheses, quotes, etc… are balanced\n * Used for arbitrary values only\n *\n * We will go past the end of the balanced parens until we find a non-class character\n *\n * Depth matching behavior:\n * w-[calc(100%-theme('spacing[some_key][1.5]'))]']\n *   ┬    ┬          ┬┬       ┬        ┬┬   ┬┬┬┬┬┬┬\n *   1    2          3        4        34   3 210 END\n *   ╰────┴──────────┴────────┴────────┴┴───┴─┴┴┴\n *\n * @param {string} input\n */ function clipAtBalancedParens(input) {\n    // We are care about this for arbitrary values\n    if (!input.includes(\"-[\")) {\n        return input;\n    }\n    let depth = 0;\n    let openStringTypes = [];\n    // Find all parens, brackets, quotes, etc\n    // Stop when we end at a balanced pair\n    // This is naive and will treat mismatched parens as balanced\n    // This shouldn't be a problem in practice though\n    let matches = input.matchAll(SPECIALS);\n    // We can't use lookbehind assertions because we have to support Safari\n    // So, instead, we've emulated it using capture groups and we'll re-work the matches to accommodate\n    matches = Array.from(matches).flatMap((match)=>{\n        const [, ...groups] = match;\n        return groups.map((group, idx)=>Object.assign([], match, {\n                index: match.index + idx,\n                0: group\n            }));\n    });\n    for (let match of matches){\n        let char = match[0];\n        let inStringType = openStringTypes[openStringTypes.length - 1];\n        if (char === inStringType) {\n            openStringTypes.pop();\n        } else if (char === \"'\" || char === '\"' || char === \"`\") {\n            openStringTypes.push(char);\n        }\n        if (inStringType) {\n            continue;\n        } else if (char === \"[\") {\n            depth++;\n            continue;\n        } else if (char === \"]\") {\n            depth--;\n            continue;\n        }\n        // We've gone one character past the point where we should stop\n        // This means that there was an extra closing `]`\n        // We'll clip to just before it\n        if (depth < 0) {\n            return input.substring(0, match.index);\n        }\n        // We've finished balancing the brackets but there still may be characters that can be included\n        // For example in the class `text-[#336699]/[.35]`\n        // The depth goes to `0` at the closing `]` but goes up again at the `[`\n        // If we're at zero and encounter a non-class character then we clip the class there\n        if (depth === 0 && !ALLOWED_CLASS_CHARACTERS.test(char)) {\n            return input.substring(0, match.index);\n        }\n    }\n    return input;\n} // Regular utilities\n // {{modifier}:}*{namespace}{-{suffix}}*{/{opacityModifier}}?\n // Arbitrary values\n // {{modifier}:}*{namespace}-[{arbitraryValue}]{/{opacityModifier}}?\n // arbitraryValue: no whitespace, balanced quotes unless within quotes, balanced brackets unless within quotes\n // Arbitrary properties\n // {{modifier}:}*[{validCssPropertyName}:{arbitraryValue}]\n\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/tailwindcss/lib/lib/defaultExtractor.js?");

/***/ }),

/***/ "./node_modules/tailwindcss/lib/lib/detectNesting.js":
/*!***********************************************************!*\
  !*** ./node_modules/tailwindcss/lib/lib/detectNesting.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"default\", ({\n    enumerable: true,\n    get: ()=>_default\n}));\nfunction _default(_context) {\n    return (root, result)=>{\n        let found = false;\n        root.walkAtRules(\"tailwind\", (node)=>{\n            if (found) return false;\n            if (node.parent && node.parent.type !== \"root\") {\n                found = true;\n                node.warn(result, [\n                    \"Nested @tailwind rules were detected, but are not supported.\",\n                    \"Consider using a prefix to scope Tailwind's classes: https://tailwindcss.com/docs/configuration#prefix\",\n                    \"Alternatively, use the important selector strategy: https://tailwindcss.com/docs/configuration#selector-strategy\", \n                ].join(\"\\n\"));\n                return false;\n            }\n        });\n        root.walkRules((rule)=>{\n            if (found) return false;\n            rule.walkRules((nestedRule)=>{\n                found = true;\n                nestedRule.warn(result, [\n                    \"Nested CSS was detected, but CSS nesting has not been configured correctly.\",\n                    \"Please enable a CSS nesting plugin *before* Tailwind in your configuration.\",\n                    \"See how here: https://tailwindcss.com/docs/using-with-preprocessors#nesting\", \n                ].join(\"\\n\"));\n                return false;\n            });\n        });\n    };\n}\n\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/tailwindcss/lib/lib/detectNesting.js?");

/***/ }),

/***/ "./node_modules/tailwindcss/lib/lib/evaluateTailwindFunctions.js":
/*!***********************************************************************!*\
  !*** ./node_modules/tailwindcss/lib/lib/evaluateTailwindFunctions.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"default\", ({\n    enumerable: true,\n    get: ()=>_default\n}));\nconst _dlv = /*#__PURE__*/ _interopRequireDefault(__webpack_require__(/*! dlv */ \"./node_modules/dlv/dist/dlv.umd.js\"));\nconst _didyoumean = /*#__PURE__*/ _interopRequireDefault(__webpack_require__(/*! didyoumean */ \"./node_modules/didyoumean/didYouMean-1.2.1.js\"));\nconst _transformThemeValue = /*#__PURE__*/ _interopRequireDefault(__webpack_require__(/*! ../util/transformThemeValue */ \"./node_modules/tailwindcss/lib/util/transformThemeValue.js\"));\nconst _postcssValueParser = /*#__PURE__*/ _interopRequireDefault(__webpack_require__(/*! postcss-value-parser */ \"./node_modules/postcss-value-parser/lib/index.js\"));\nconst _normalizeScreens = __webpack_require__(/*! ../util/normalizeScreens */ \"./node_modules/tailwindcss/lib/util/normalizeScreens.js\");\nconst _buildMediaQuery = /*#__PURE__*/ _interopRequireDefault(__webpack_require__(/*! ../util/buildMediaQuery */ \"./node_modules/tailwindcss/lib/util/buildMediaQuery.js\"));\nconst _toPath = __webpack_require__(/*! ../util/toPath */ \"./node_modules/tailwindcss/lib/util/toPath.js\");\nconst _withAlphaVariable = __webpack_require__(/*! ../util/withAlphaVariable */ \"./node_modules/tailwindcss/lib/util/withAlphaVariable.js\");\nconst _pluginUtils = __webpack_require__(/*! ../util/pluginUtils */ \"./node_modules/tailwindcss/lib/util/pluginUtils.js\");\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        default: obj\n    };\n}\nfunction isObject(input) {\n    return typeof input === \"object\" && input !== null;\n}\nfunction findClosestExistingPath(theme, path) {\n    let parts = (0, _toPath.toPath)(path);\n    do {\n        parts.pop();\n        if ((0, _dlv.default)(theme, parts) !== undefined) break;\n    }while (parts.length);\n    return parts.length ? parts : undefined;\n}\nfunction pathToString(path) {\n    if (typeof path === \"string\") return path;\n    return path.reduce((acc, cur, i)=>{\n        if (cur.includes(\".\")) return `${acc}[${cur}]`;\n        return i === 0 ? cur : `${acc}.${cur}`;\n    }, \"\");\n}\nfunction list(items) {\n    return items.map((key)=>`'${key}'`).join(\", \");\n}\nfunction listKeys(obj) {\n    return list(Object.keys(obj));\n}\nfunction validatePath(config, path, defaultValue, themeOpts = {}) {\n    const pathString = Array.isArray(path) ? pathToString(path) : path.replace(/^['\"]+|['\"]+$/g, \"\");\n    const pathSegments = Array.isArray(path) ? path : (0, _toPath.toPath)(pathString);\n    const value = (0, _dlv.default)(config.theme, pathSegments, defaultValue);\n    if (value === undefined) {\n        let error = `'${pathString}' does not exist in your theme config.`;\n        const parentSegments = pathSegments.slice(0, -1);\n        const parentValue = (0, _dlv.default)(config.theme, parentSegments);\n        if (isObject(parentValue)) {\n            const validKeys = Object.keys(parentValue).filter((key)=>validatePath(config, [\n                    ...parentSegments,\n                    key\n                ]).isValid);\n            const suggestion = (0, _didyoumean.default)(pathSegments[pathSegments.length - 1], validKeys);\n            if (suggestion) {\n                error += ` Did you mean '${pathToString([\n                    ...parentSegments,\n                    suggestion\n                ])}'?`;\n            } else if (validKeys.length > 0) {\n                error += ` '${pathToString(parentSegments)}' has the following valid keys: ${list(validKeys)}`;\n            }\n        } else {\n            const closestPath = findClosestExistingPath(config.theme, pathString);\n            if (closestPath) {\n                const closestValue = (0, _dlv.default)(config.theme, closestPath);\n                if (isObject(closestValue)) {\n                    error += ` '${pathToString(closestPath)}' has the following keys: ${listKeys(closestValue)}`;\n                } else {\n                    error += ` '${pathToString(closestPath)}' is not an object.`;\n                }\n            } else {\n                error += ` Your theme has the following top-level keys: ${listKeys(config.theme)}`;\n            }\n        }\n        return {\n            isValid: false,\n            error\n        };\n    }\n    if (!(typeof value === \"string\" || typeof value === \"number\" || typeof value === \"function\" || value instanceof String || value instanceof Number || Array.isArray(value))) {\n        let error1 = `'${pathString}' was found but does not resolve to a string.`;\n        if (isObject(value)) {\n            let validKeys1 = Object.keys(value).filter((key)=>validatePath(config, [\n                    ...pathSegments,\n                    key\n                ]).isValid);\n            if (validKeys1.length) {\n                error1 += ` Did you mean something like '${pathToString([\n                    ...pathSegments,\n                    validKeys1[0]\n                ])}'?`;\n            }\n        }\n        return {\n            isValid: false,\n            error: error1\n        };\n    }\n    const [themeSection] = pathSegments;\n    return {\n        isValid: true,\n        value: (0, _transformThemeValue.default)(themeSection)(value, themeOpts)\n    };\n}\nfunction extractArgs(node, vNodes, functions) {\n    vNodes = vNodes.map((vNode)=>resolveVNode(node, vNode, functions));\n    let args = [\n        \"\"\n    ];\n    for (let vNode of vNodes){\n        if (vNode.type === \"div\" && vNode.value === \",\") {\n            args.push(\"\");\n        } else {\n            args[args.length - 1] += _postcssValueParser.default.stringify(vNode);\n        }\n    }\n    return args;\n}\nfunction resolveVNode(node, vNode, functions) {\n    if (vNode.type === \"function\" && functions[vNode.value] !== undefined) {\n        let args = extractArgs(node, vNode.nodes, functions);\n        vNode.type = \"word\";\n        vNode.value = functions[vNode.value](node, ...args);\n    }\n    return vNode;\n}\nfunction resolveFunctions(node, input, functions) {\n    return (0, _postcssValueParser.default)(input).walk((vNode)=>{\n        resolveVNode(node, vNode, functions);\n    }).toString();\n}\nlet nodeTypePropertyMap = {\n    atrule: \"params\",\n    decl: \"value\"\n};\n/**\n * @param {string} path\n * @returns {Iterable<[path: string, alpha: string|undefined]>}\n */ function* toPaths(path) {\n    // Strip quotes from beginning and end of string\n    // This allows the alpha value to be present inside of quotes\n    path = path.replace(/^['\"]+|['\"]+$/g, \"\");\n    let matches = path.match(/^([^\\s]+)(?![^\\[]*\\])(?:\\s*\\/\\s*([^\\/\\s]+))$/);\n    let alpha = undefined;\n    yield [\n        path,\n        undefined\n    ];\n    if (matches) {\n        path = matches[1];\n        alpha = matches[2];\n        yield [\n            path,\n            alpha\n        ];\n    }\n}\n/**\n *\n * @param {any} config\n * @param {string} path\n * @param {any} defaultValue\n */ function resolvePath(config, path, defaultValue) {\n    const results = Array.from(toPaths(path)).map(([path, alpha])=>{\n        return Object.assign(validatePath(config, path, defaultValue, {\n            opacityValue: alpha\n        }), {\n            resolvedPath: path,\n            alpha\n        });\n    });\n    var ref;\n    return (ref = results.find((result)=>result.isValid)) !== null && ref !== void 0 ? ref : results[0];\n}\nfunction _default({ tailwindConfig: config  }) {\n    let functions = {\n        theme: (node, path, ...defaultValue)=>{\n            let { isValid , value , error , alpha  } = resolvePath(config, path, defaultValue.length ? defaultValue : undefined);\n            if (!isValid) {\n                throw node.error(error);\n            }\n            let maybeColor = (0, _pluginUtils.parseColorFormat)(value);\n            let isColorFunction = maybeColor !== undefined && typeof maybeColor === \"function\";\n            if (alpha !== undefined || isColorFunction) {\n                if (alpha === undefined) {\n                    alpha = 1.0;\n                }\n                value = (0, _withAlphaVariable.withAlphaValue)(maybeColor, alpha, maybeColor);\n            }\n            return value;\n        },\n        screen: (node, screen)=>{\n            screen = screen.replace(/^['\"]+/g, \"\").replace(/['\"]+$/g, \"\");\n            let screens = (0, _normalizeScreens.normalizeScreens)(config.theme.screens);\n            let screenDefinition = screens.find(({ name  })=>name === screen);\n            if (!screenDefinition) {\n                throw node.error(`The '${screen}' screen does not exist in your theme.`);\n            }\n            return (0, _buildMediaQuery.default)(screenDefinition);\n        }\n    };\n    return (root)=>{\n        root.walk((node)=>{\n            let property = nodeTypePropertyMap[node.type];\n            if (property === undefined) {\n                return;\n            }\n            node[property] = resolveFunctions(node, node[property], functions);\n        });\n    };\n}\n\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/tailwindcss/lib/lib/evaluateTailwindFunctions.js?");

/***/ }),

/***/ "./node_modules/tailwindcss/lib/lib/expandApplyAtRules.js":
/*!****************************************************************!*\
  !*** ./node_modules/tailwindcss/lib/lib/expandApplyAtRules.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"default\", ({\n    enumerable: true,\n    get: ()=>expandApplyAtRules\n}));\nconst _postcss = /*#__PURE__*/ _interopRequireDefault(__webpack_require__(/*! postcss */ \"./node_modules/postcss/lib/postcss.js\"));\nconst _postcssSelectorParser = /*#__PURE__*/ _interopRequireDefault(__webpack_require__(/*! postcss-selector-parser */ \"./node_modules/postcss-selector-parser/dist/index.js\"));\nconst _generateRules = __webpack_require__(/*! ./generateRules */ \"./node_modules/tailwindcss/lib/lib/generateRules.js\");\nconst _bigSign = /*#__PURE__*/ _interopRequireDefault(__webpack_require__(/*! ../util/bigSign */ \"./node_modules/tailwindcss/lib/util/bigSign.js\"));\nconst _escapeClassName = /*#__PURE__*/ _interopRequireDefault(__webpack_require__(/*! ../util/escapeClassName */ \"./node_modules/tailwindcss/lib/util/escapeClassName.js\"));\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        default: obj\n    };\n}\n/** @typedef {Map<string, [any, import('postcss').Rule[]]>} ApplyCache */ function extractClasses(node) {\n    /** @type {Map<string, Set<string>>} */ let groups = new Map();\n    let container = _postcss.default.root({\n        nodes: [\n            node.clone()\n        ]\n    });\n    container.walkRules((rule)=>{\n        (0, _postcssSelectorParser.default)((selectors)=>{\n            selectors.walkClasses((classSelector)=>{\n                let parentSelector = classSelector.parent.toString();\n                let classes = groups.get(parentSelector);\n                if (!classes) {\n                    groups.set(parentSelector, classes = new Set());\n                }\n                classes.add(classSelector.value);\n            });\n        }).processSync(rule.selector);\n    });\n    let normalizedGroups = Array.from(groups.values(), (classes)=>Array.from(classes));\n    let classes = normalizedGroups.flat();\n    return Object.assign(classes, {\n        groups: normalizedGroups\n    });\n}\nlet selectorExtractor = (0, _postcssSelectorParser.default)((root)=>root.nodes.map((node)=>node.toString()));\n/**\n * @param {string} ruleSelectors\n */ function extractSelectors(ruleSelectors) {\n    return selectorExtractor.transformSync(ruleSelectors);\n}\nfunction extractBaseCandidates(candidates, separator) {\n    let baseClasses = new Set();\n    for (let candidate of candidates){\n        baseClasses.add(candidate.split(separator).pop());\n    }\n    return Array.from(baseClasses);\n}\nfunction prefix(context, selector) {\n    let prefix = context.tailwindConfig.prefix;\n    return typeof prefix === \"function\" ? prefix(selector) : prefix + selector;\n}\nfunction* pathToRoot(node) {\n    yield node;\n    while(node.parent){\n        yield node.parent;\n        node = node.parent;\n    }\n}\n/**\n * Only clone the node itself and not its children\n *\n * @param {*} node\n * @param {*} overrides\n * @returns\n */ function shallowClone(node, overrides = {}) {\n    let children = node.nodes;\n    node.nodes = [];\n    let tmp = node.clone(overrides);\n    node.nodes = children;\n    return tmp;\n}\n/**\n * Clone just the nodes all the way to the top that are required to represent\n * this singular rule in the tree.\n *\n * For example, if we have CSS like this:\n * ```css\n * @media (min-width: 768px) {\n *   @supports (display: grid) {\n *     .foo {\n *       display: grid;\n *       grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));\n *     }\n *   }\n *\n *   @supports (backdrop-filter: blur(1px)) {\n *     .bar {\n *       backdrop-filter: blur(1px);\n *     }\n *   }\n *\n *   .baz {\n *     color: orange;\n *   }\n * }\n * ```\n *\n * And we're cloning `.bar` it'll return a cloned version of what's required for just that single node:\n *\n * ```css\n * @media (min-width: 768px) {\n *   @supports (backdrop-filter: blur(1px)) {\n *     .bar {\n *       backdrop-filter: blur(1px);\n *     }\n *   }\n * }\n * ```\n *\n * @param {import('postcss').Node} node\n */ function nestedClone(node) {\n    for (let parent of pathToRoot(node)){\n        if (node === parent) {\n            continue;\n        }\n        if (parent.type === \"root\") {\n            break;\n        }\n        node = shallowClone(parent, {\n            nodes: [\n                node\n            ]\n        });\n    }\n    return node;\n}\n/**\n * @param {import('postcss').Root} root\n */ function buildLocalApplyCache(root, context) {\n    /** @type {ApplyCache} */ let cache = new Map();\n    let highestOffset = context.layerOrder.user >> 4n;\n    root.walkRules((rule, idx)=>{\n        // Ignore rules generated by Tailwind\n        for (let node of pathToRoot(rule)){\n            var ref;\n            if (((ref = node.raws.tailwind) === null || ref === void 0 ? void 0 : ref.layer) !== undefined) {\n                return;\n            }\n        }\n        // Clone what's required to represent this singular rule in the tree\n        let container = nestedClone(rule);\n        for (let className of extractClasses(rule)){\n            let list = cache.get(className) || [];\n            cache.set(className, list);\n            list.push([\n                {\n                    layer: \"user\",\n                    sort: BigInt(idx) + highestOffset,\n                    important: false\n                },\n                container, \n            ]);\n        }\n    });\n    return cache;\n}\n/**\n * @returns {ApplyCache}\n */ function buildApplyCache(applyCandidates, context) {\n    for (let candidate of applyCandidates){\n        if (context.notClassCache.has(candidate) || context.applyClassCache.has(candidate)) {\n            continue;\n        }\n        if (context.classCache.has(candidate)) {\n            context.applyClassCache.set(candidate, context.classCache.get(candidate).map(([meta, rule])=>[\n                    meta,\n                    rule.clone()\n                ]));\n            continue;\n        }\n        let matches = Array.from((0, _generateRules.resolveMatches)(candidate, context));\n        if (matches.length === 0) {\n            context.notClassCache.add(candidate);\n            continue;\n        }\n        context.applyClassCache.set(candidate, matches);\n    }\n    return context.applyClassCache;\n}\n/**\n * Build a cache only when it's first used\n *\n * @param {() => ApplyCache} buildCacheFn\n * @returns {ApplyCache}\n */ function lazyCache(buildCacheFn) {\n    let cache = null;\n    return {\n        get: (name)=>{\n            cache = cache || buildCacheFn();\n            return cache.get(name);\n        },\n        has: (name)=>{\n            cache = cache || buildCacheFn();\n            return cache.has(name);\n        }\n    };\n}\n/**\n * Take a series of multiple caches and merge\n * them so they act like one large cache\n *\n * @param {ApplyCache[]} caches\n * @returns {ApplyCache}\n */ function combineCaches(caches) {\n    return {\n        get: (name)=>caches.flatMap((cache)=>cache.get(name) || []),\n        has: (name)=>caches.some((cache)=>cache.has(name))\n    };\n}\nfunction extractApplyCandidates(params) {\n    let candidates = params.split(/[\\s\\t\\n]+/g);\n    if (candidates[candidates.length - 1] === \"!important\") {\n        return [\n            candidates.slice(0, -1),\n            true\n        ];\n    }\n    return [\n        candidates,\n        false\n    ];\n}\nfunction processApply(root, context, localCache) {\n    let applyCandidates = new Set();\n    // Collect all @apply rules and candidates\n    let applies = [];\n    root.walkAtRules(\"apply\", (rule)=>{\n        let [candidates] = extractApplyCandidates(rule.params);\n        for (let util of candidates){\n            applyCandidates.add(util);\n        }\n        applies.push(rule);\n    });\n    // Start the @apply process if we have rules with @apply in them\n    if (applies.length === 0) {\n        return;\n    }\n    // Fill up some caches!\n    let applyClassCache = combineCaches([\n        localCache,\n        buildApplyCache(applyCandidates, context)\n    ]);\n    /**\n   * When we have an apply like this:\n   *\n   * .abc {\n   *    @apply hover:font-bold;\n   * }\n   *\n   * What we essentially will do is resolve to this:\n   *\n   * .abc {\n   *    @apply .hover\\:font-bold:hover {\n   *      font-weight: 500;\n   *    }\n   * }\n   *\n   * Notice that the to-be-applied class is `.hover\\:font-bold:hover` and that the utility candidate was `hover:font-bold`.\n   * What happens in this function is that we prepend a `.` and escape the candidate.\n   * This will result in `.hover\\:font-bold`\n   * Which means that we can replace `.hover\\:font-bold` with `.abc` in `.hover\\:font-bold:hover` resulting in `.abc:hover`\n   */ // TODO: Should we use postcss-selector-parser for this instead?\n    function replaceSelector(selector, utilitySelectors, candidate) {\n        let needle = `.${(0, _escapeClassName.default)(candidate)}`;\n        let needles = [\n            ...new Set([\n                needle,\n                needle.replace(/\\\\2c /g, \"\\\\,\")\n            ])\n        ];\n        let utilitySelectorsList = extractSelectors(utilitySelectors);\n        return extractSelectors(selector).map((s)=>{\n            let replaced = [];\n            for (let utilitySelector of utilitySelectorsList){\n                let replacedSelector = utilitySelector;\n                for (const needle of needles){\n                    replacedSelector = replacedSelector.replace(needle, s);\n                }\n                if (replacedSelector === utilitySelector) {\n                    continue;\n                }\n                replaced.push(replacedSelector);\n            }\n            return replaced.join(\", \");\n        }).join(\", \");\n    }\n    let perParentApplies = new Map();\n    // Collect all apply candidates and their rules\n    for (let apply of applies){\n        let [candidates] = perParentApplies.get(apply.parent) || [\n            [],\n            apply.source\n        ];\n        perParentApplies.set(apply.parent, [\n            candidates,\n            apply.source\n        ]);\n        let [applyCandidates1, important] = extractApplyCandidates(apply.params);\n        if (apply.parent.type === \"atrule\") {\n            if (apply.parent.name === \"screen\") {\n                const screenType = apply.parent.params;\n                throw apply.error(`@apply is not supported within nested at-rules like @screen. We suggest you write this as @apply ${applyCandidates1.map((c)=>`${screenType}:${c}`).join(\" \")} instead.`);\n            }\n            throw apply.error(`@apply is not supported within nested at-rules like @${apply.parent.name}. You can fix this by un-nesting @${apply.parent.name}.`);\n        }\n        for (let applyCandidate of applyCandidates1){\n            if ([\n                prefix(context, \"group\"),\n                prefix(context, \"peer\")\n            ].includes(applyCandidate)) {\n                // TODO: Link to specific documentation page with error code.\n                throw apply.error(`@apply should not be used with the '${applyCandidate}' utility`);\n            }\n            if (!applyClassCache.has(applyCandidate)) {\n                throw apply.error(`The \\`${applyCandidate}\\` class does not exist. If \\`${applyCandidate}\\` is a custom class, make sure it is defined within a \\`@layer\\` directive.`);\n            }\n            let rules = applyClassCache.get(applyCandidate);\n            candidates.push([\n                applyCandidate,\n                important,\n                rules\n            ]);\n        }\n    }\n    for (const [parent, [candidates1, atApplySource]] of perParentApplies){\n        let siblings = [];\n        for (let [applyCandidate1, important1, rules1] of candidates1){\n            let potentialApplyCandidates = [\n                applyCandidate1,\n                ...extractBaseCandidates([\n                    applyCandidate1\n                ], context.tailwindConfig.separator), \n            ];\n            for (let [meta, node] of rules1){\n                let parentClasses = extractClasses(parent);\n                let nodeClasses = extractClasses(node);\n                // When we encounter a rule like `.dark .a, .b { … }` we only want to be left with `[.dark, .a]` if the base applyCandidate is `.a` or with `[.b]` if the base applyCandidate is `.b`\n                // So we've split them into groups\n                nodeClasses = nodeClasses.groups.filter((classList)=>classList.some((className)=>potentialApplyCandidates.includes(className))).flat();\n                // Add base utility classes from the @apply node to the list of\n                // classes to check whether it intersects and therefore results in a\n                // circular dependency or not.\n                //\n                // E.g.:\n                // .foo {\n                //   @apply hover:a; // This applies \"a\" but with a modifier\n                // }\n                //\n                // We only have to do that with base classes of the `node`, not of the `parent`\n                // E.g.:\n                // .hover\\:foo {\n                //   @apply bar;\n                // }\n                // .bar {\n                //   @apply foo;\n                // }\n                //\n                // This should not result in a circular dependency because we are\n                // just applying `.foo` and the rule above is `.hover\\:foo` which is\n                // unrelated. However, if we were to apply `hover:foo` then we _did_\n                // have to include this one.\n                nodeClasses = nodeClasses.concat(extractBaseCandidates(nodeClasses, context.tailwindConfig.separator));\n                let intersects = parentClasses.some((selector)=>nodeClasses.includes(selector));\n                if (intersects) {\n                    throw node.error(`You cannot \\`@apply\\` the \\`${applyCandidate1}\\` utility here because it creates a circular dependency.`);\n                }\n                let root1 = _postcss.default.root({\n                    nodes: [\n                        node.clone()\n                    ]\n                });\n                // Make sure every node in the entire tree points back at the @apply rule that generated it\n                root1.walk((node)=>{\n                    node.source = atApplySource;\n                });\n                let canRewriteSelector = node.type !== \"atrule\" || node.type === \"atrule\" && node.name !== \"keyframes\";\n                if (canRewriteSelector) {\n                    root1.walkRules((rule)=>{\n                        // Let's imagine you have the following structure:\n                        //\n                        // .foo {\n                        //   @apply bar;\n                        // }\n                        //\n                        // @supports (a: b) {\n                        //   .bar {\n                        //     color: blue\n                        //   }\n                        //\n                        //   .something-unrelated {}\n                        // }\n                        //\n                        // In this case we want to apply `.bar` but it happens to be in\n                        // an atrule node. We clone that node instead of the nested one\n                        // because we still want that @supports rule to be there once we\n                        // applied everything.\n                        //\n                        // However it happens to be that the `.something-unrelated` is\n                        // also in that same shared @supports atrule. This is not good,\n                        // and this should not be there. The good part is that this is\n                        // a clone already and it can be safely removed. The question is\n                        // how do we know we can remove it. Basically what we can do is\n                        // match it against the applyCandidate that you want to apply. If\n                        // it doesn't match the we can safely delete it.\n                        //\n                        // If we didn't do this, then the `replaceSelector` function\n                        // would have replaced this with something that didn't exist and\n                        // therefore it removed the selector altogether. In this specific\n                        // case it would result in `{}` instead of `.something-unrelated {}`\n                        if (!extractClasses(rule).some((candidate)=>candidate === applyCandidate1)) {\n                            rule.remove();\n                            return;\n                        }\n                        // Strip the important selector from the parent selector if at the beginning\n                        let importantSelector = typeof context.tailwindConfig.important === \"string\" ? context.tailwindConfig.important : null;\n                        // We only want to move the \"important\" selector if this is a Tailwind-generated utility\n                        // We do *not* want to do this for user CSS that happens to be structured the same\n                        let isGenerated = parent.raws.tailwind !== undefined;\n                        let parentSelector = isGenerated && importantSelector && parent.selector.indexOf(importantSelector) === 0 ? parent.selector.slice(importantSelector.length) : parent.selector;\n                        rule.selector = replaceSelector(parentSelector, rule.selector, applyCandidate1);\n                        // And then re-add it if it was removed\n                        if (importantSelector && parentSelector !== parent.selector) {\n                            rule.selector = `${importantSelector} ${rule.selector}`;\n                        }\n                        rule.walkDecls((d)=>{\n                            d.important = meta.important || important1;\n                        });\n                    });\n                }\n                // It could be that the node we were inserted was removed because the class didn't match\n                // If that was the *only* rule in the parent, then we have nothing add so we skip it\n                if (!root1.nodes[0]) {\n                    continue;\n                }\n                // Insert it\n                siblings.push([\n                    // Ensure that when we are sorting, that we take the layer order into account\n                    {\n                        ...meta,\n                        sort: meta.sort | context.layerOrder[meta.layer]\n                    },\n                    root1.nodes[0], \n                ]);\n            }\n        }\n        // Inject the rules, sorted, correctly\n        let nodes = siblings.sort(([a], [z])=>(0, _bigSign.default)(a.sort - z.sort)).map((s)=>s[1]);\n        // `parent` refers to the node at `.abc` in: .abc { @apply mt-2 }\n        parent.after(nodes);\n    }\n    for (let apply1 of applies){\n        // If there are left-over declarations, just remove the @apply\n        if (apply1.parent.nodes.length > 1) {\n            apply1.remove();\n        } else {\n            // The node is empty, drop the full node\n            apply1.parent.remove();\n        }\n    }\n    // Do it again, in case we have other `@apply` rules\n    processApply(root, context, localCache);\n}\nfunction expandApplyAtRules(context) {\n    return (root)=>{\n        // Build a cache of the user's CSS so we can use it to resolve classes used by @apply\n        let localCache = lazyCache(()=>buildLocalApplyCache(root, context));\n        processApply(root, context, localCache);\n    };\n}\n\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/tailwindcss/lib/lib/expandApplyAtRules.js?");

/***/ }),

/***/ "./node_modules/tailwindcss/lib/lib/expandTailwindAtRules.js":
/*!*******************************************************************!*\
  !*** ./node_modules/tailwindcss/lib/lib/expandTailwindAtRules.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"default\", ({\n    enumerable: true,\n    get: ()=>expandTailwindAtRules\n}));\nconst _quickLru = /*#__PURE__*/ _interopRequireDefault(__webpack_require__(/*! quick-lru */ \"./node_modules/quick-lru/index.js\"));\nconst _sharedState = /*#__PURE__*/ _interopRequireWildcard(__webpack_require__(/*! ./sharedState */ \"./node_modules/tailwindcss/lib/lib/sharedState.js\"));\nconst _generateRules = __webpack_require__(/*! ./generateRules */ \"./node_modules/tailwindcss/lib/lib/generateRules.js\");\nconst _bigSign = /*#__PURE__*/ _interopRequireDefault(__webpack_require__(/*! ../util/bigSign */ \"./node_modules/tailwindcss/lib/util/bigSign.js\"));\nconst _log = /*#__PURE__*/ _interopRequireDefault(__webpack_require__(/*! ../util/log */ \"./node_modules/tailwindcss/lib/util/log.js\"));\nconst _cloneNodes = /*#__PURE__*/ _interopRequireDefault(__webpack_require__(/*! ../util/cloneNodes */ \"./node_modules/tailwindcss/lib/util/cloneNodes.js\"));\nconst _defaultExtractor = __webpack_require__(/*! ./defaultExtractor */ \"./node_modules/tailwindcss/lib/lib/defaultExtractor.js\");\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        default: obj\n    };\n}\nfunction _getRequireWildcardCache(nodeInterop) {\n    if (typeof WeakMap !== \"function\") return null;\n    var cacheBabelInterop = new WeakMap();\n    var cacheNodeInterop = new WeakMap();\n    return (_getRequireWildcardCache = function(nodeInterop) {\n        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;\n    })(nodeInterop);\n}\nfunction _interopRequireWildcard(obj, nodeInterop) {\n    if (!nodeInterop && obj && obj.__esModule) {\n        return obj;\n    }\n    if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n        return {\n            default: obj\n        };\n    }\n    var cache = _getRequireWildcardCache(nodeInterop);\n    if (cache && cache.has(obj)) {\n        return cache.get(obj);\n    }\n    var newObj = {};\n    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n    for(var key in obj){\n        if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) {\n            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n            if (desc && (desc.get || desc.set)) {\n                Object.defineProperty(newObj, key, desc);\n            } else {\n                newObj[key] = obj[key];\n            }\n        }\n    }\n    newObj.default = obj;\n    if (cache) {\n        cache.set(obj, newObj);\n    }\n    return newObj;\n}\nlet env = _sharedState.env;\nconst builtInExtractors = {\n    DEFAULT: _defaultExtractor.defaultExtractor\n};\nconst builtInTransformers = {\n    DEFAULT: (content)=>content,\n    svelte: (content)=>content.replace(/(?:^|\\s)class:/g, \" \")\n};\nfunction getExtractor(context, fileExtension) {\n    let extractors = context.tailwindConfig.content.extract;\n    return extractors[fileExtension] || extractors.DEFAULT || builtInExtractors[fileExtension] || builtInExtractors.DEFAULT(context);\n}\nfunction getTransformer(tailwindConfig, fileExtension) {\n    let transformers = tailwindConfig.content.transform;\n    return transformers[fileExtension] || transformers.DEFAULT || builtInTransformers[fileExtension] || builtInTransformers.DEFAULT;\n}\nlet extractorCache = new WeakMap();\n// Scans template contents for possible classes. This is a hot path on initial build but\n// not too important for subsequent builds. The faster the better though — if we can speed\n// up these regexes by 50% that could cut initial build time by like 20%.\nfunction getClassCandidates(content, extractor, candidates, seen) {\n    if (!extractorCache.has(extractor)) {\n        extractorCache.set(extractor, new _quickLru.default({\n            maxSize: 25000\n        }));\n    }\n    for (let line of content.split(\"\\n\")){\n        line = line.trim();\n        if (seen.has(line)) {\n            continue;\n        }\n        seen.add(line);\n        if (extractorCache.get(extractor).has(line)) {\n            for (let match of extractorCache.get(extractor).get(line)){\n                candidates.add(match);\n            }\n        } else {\n            let extractorMatches = extractor(line).filter((s)=>s !== \"!*\");\n            let lineMatchesSet = new Set(extractorMatches);\n            for (let match1 of lineMatchesSet){\n                candidates.add(match1);\n            }\n            extractorCache.get(extractor).set(line, lineMatchesSet);\n        }\n    }\n}\nfunction buildStylesheet(rules, context) {\n    let sortedRules = rules.sort(([a], [z])=>(0, _bigSign.default)(a - z));\n    let returnValue = {\n        base: new Set(),\n        defaults: new Set(),\n        components: new Set(),\n        utilities: new Set(),\n        variants: new Set(),\n        // All the CSS that is not Tailwind related can be put in this bucket. This\n        // will make it easier to later use this information when we want to\n        // `@apply` for example. The main reason we do this here is because we\n        // still need to make sure the order is correct. Last but not least, we\n        // will make sure to always re-inject this section into the css, even if\n        // certain rules were not used. This means that it will look like a no-op\n        // from the user's perspective, but we gathered all the useful information\n        // we need.\n        user: new Set()\n    };\n    for (let [sort, rule] of sortedRules){\n        if (sort >= context.minimumScreen) {\n            returnValue.variants.add(rule);\n            continue;\n        }\n        if (sort & context.layerOrder.base) {\n            returnValue.base.add(rule);\n            continue;\n        }\n        if (sort & context.layerOrder.defaults) {\n            returnValue.defaults.add(rule);\n            continue;\n        }\n        if (sort & context.layerOrder.components) {\n            returnValue.components.add(rule);\n            continue;\n        }\n        if (sort & context.layerOrder.utilities) {\n            returnValue.utilities.add(rule);\n            continue;\n        }\n        if (sort & context.layerOrder.user) {\n            returnValue.user.add(rule);\n            continue;\n        }\n    }\n    return returnValue;\n}\nfunction expandTailwindAtRules(context) {\n    return (root)=>{\n        let layerNodes = {\n            base: null,\n            components: null,\n            utilities: null,\n            variants: null\n        };\n        root.walkAtRules((rule)=>{\n            // Make sure this file contains Tailwind directives. If not, we can save\n            // a lot of work and bail early. Also we don't have to register our touch\n            // file as a dependency since the output of this CSS does not depend on\n            // the source of any templates. Think Vue <style> blocks for example.\n            if (rule.name === \"tailwind\") {\n                if (Object.keys(layerNodes).includes(rule.params)) {\n                    layerNodes[rule.params] = rule;\n                }\n            }\n        });\n        if (Object.values(layerNodes).every((n)=>n === null)) {\n            return root;\n        }\n        // ---\n        // Find potential rules in changed files\n        let candidates = new Set([\n            _sharedState.NOT_ON_DEMAND\n        ]);\n        let seen = new Set();\n        env.DEBUG && console.time(\"Reading changed files\");\n        for (let { content , extension  } of context.changedContent){\n            let transformer = getTransformer(context.tailwindConfig, extension);\n            let extractor = getExtractor(context, extension);\n            getClassCandidates(transformer(content), extractor, candidates, seen);\n        }\n        env.DEBUG && console.timeEnd(\"Reading changed files\");\n        // ---\n        // Generate the actual CSS\n        let classCacheCount = context.classCache.size;\n        env.DEBUG && console.time(\"Generate rules\");\n        let rules = (0, _generateRules.generateRules)(candidates, context);\n        env.DEBUG && console.timeEnd(\"Generate rules\");\n        // We only ever add to the classCache, so if it didn't grow, there is nothing new.\n        env.DEBUG && console.time(\"Build stylesheet\");\n        if (context.stylesheetCache === null || context.classCache.size !== classCacheCount) {\n            for (let rule of rules){\n                context.ruleCache.add(rule);\n            }\n            context.stylesheetCache = buildStylesheet([\n                ...context.ruleCache\n            ], context);\n        }\n        env.DEBUG && console.timeEnd(\"Build stylesheet\");\n        let { defaults: defaultNodes , base: baseNodes , components: componentNodes , utilities: utilityNodes , variants: screenNodes ,  } = context.stylesheetCache;\n        // ---\n        // Replace any Tailwind directives with generated CSS\n        if (layerNodes.base) {\n            layerNodes.base.before((0, _cloneNodes.default)([\n                ...baseNodes,\n                ...defaultNodes\n            ], layerNodes.base.source, {\n                layer: \"base\"\n            }));\n            layerNodes.base.remove();\n        }\n        if (layerNodes.components) {\n            layerNodes.components.before((0, _cloneNodes.default)([\n                ...componentNodes\n            ], layerNodes.components.source, {\n                layer: \"components\"\n            }));\n            layerNodes.components.remove();\n        }\n        if (layerNodes.utilities) {\n            layerNodes.utilities.before((0, _cloneNodes.default)([\n                ...utilityNodes\n            ], layerNodes.utilities.source, {\n                layer: \"utilities\"\n            }));\n            layerNodes.utilities.remove();\n        }\n        // We do post-filtering to not alter the emitted order of the variants\n        const variantNodes = Array.from(screenNodes).filter((node)=>{\n            var ref;\n            const parentLayer = (ref = node.raws.tailwind) === null || ref === void 0 ? void 0 : ref.parentLayer;\n            if (parentLayer === \"components\") {\n                return layerNodes.components !== null;\n            }\n            if (parentLayer === \"utilities\") {\n                return layerNodes.utilities !== null;\n            }\n            return true;\n        });\n        if (layerNodes.variants) {\n            layerNodes.variants.before((0, _cloneNodes.default)(variantNodes, layerNodes.variants.source, {\n                layer: \"variants\"\n            }));\n            layerNodes.variants.remove();\n        } else if (variantNodes.length > 0) {\n            root.append((0, _cloneNodes.default)(variantNodes, root.source, {\n                layer: \"variants\"\n            }));\n        }\n        // If we've got a utility layer and no utilities are generated there's likely something wrong\n        const hasUtilityVariants = variantNodes.some((node)=>{\n            var ref;\n            return ((ref = node.raws.tailwind) === null || ref === void 0 ? void 0 : ref.parentLayer) === \"utilities\";\n        });\n        if (layerNodes.utilities && utilityNodes.size === 0 && !hasUtilityVariants) {\n            _log.default.warn(\"content-problems\", [\n                \"No utility classes were detected in your source files. If this is unexpected, double-check the `content` option in your Tailwind CSS configuration.\",\n                \"https://tailwindcss.com/docs/content-configuration\", \n            ]);\n        }\n        // ---\n        if (env.DEBUG) {\n            console.log(\"Potential classes: \", candidates.size);\n            console.log(\"Active contexts: \", _sharedState.contextSourcesMap.size);\n        }\n        // Clear the cache for the changed files\n        context.changedContent = [];\n        // Cleanup any leftover @layer atrules\n        root.walkAtRules(\"layer\", (rule)=>{\n            if (Object.keys(layerNodes).includes(rule.params)) {\n                rule.remove();\n            }\n        });\n    };\n}\n\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/tailwindcss/lib/lib/expandTailwindAtRules.js?");

/***/ }),

/***/ "./node_modules/tailwindcss/lib/lib/generateRules.js":
/*!***********************************************************!*\
  !*** ./node_modules/tailwindcss/lib/lib/generateRules.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    resolveMatches: ()=>resolveMatches,\n    generateRules: ()=>generateRules\n});\nconst _postcss = /*#__PURE__*/ _interopRequireDefault(__webpack_require__(/*! postcss */ \"./node_modules/postcss/lib/postcss.js\"));\nconst _postcssSelectorParser = /*#__PURE__*/ _interopRequireDefault(__webpack_require__(/*! postcss-selector-parser */ \"./node_modules/postcss-selector-parser/dist/index.js\"));\nconst _parseObjectStyles = /*#__PURE__*/ _interopRequireDefault(__webpack_require__(/*! ../util/parseObjectStyles */ \"./node_modules/tailwindcss/lib/util/parseObjectStyles.js\"));\nconst _isPlainObject = /*#__PURE__*/ _interopRequireDefault(__webpack_require__(/*! ../util/isPlainObject */ \"./node_modules/tailwindcss/lib/util/isPlainObject.js\"));\nconst _prefixSelector = /*#__PURE__*/ _interopRequireDefault(__webpack_require__(/*! ../util/prefixSelector */ \"./node_modules/tailwindcss/lib/util/prefixSelector.js\"));\nconst _pluginUtils = __webpack_require__(/*! ../util/pluginUtils */ \"./node_modules/tailwindcss/lib/util/pluginUtils.js\");\nconst _log = /*#__PURE__*/ _interopRequireDefault(__webpack_require__(/*! ../util/log */ \"./node_modules/tailwindcss/lib/util/log.js\"));\nconst _sharedState = /*#__PURE__*/ _interopRequireWildcard(__webpack_require__(/*! ./sharedState */ \"./node_modules/tailwindcss/lib/lib/sharedState.js\"));\nconst _formatVariantSelector = __webpack_require__(/*! ../util/formatVariantSelector */ \"./node_modules/tailwindcss/lib/util/formatVariantSelector.js\");\nconst _nameClass = __webpack_require__(/*! ../util/nameClass */ \"./node_modules/tailwindcss/lib/util/nameClass.js\");\nconst _dataTypes = __webpack_require__(/*! ../util/dataTypes */ \"./node_modules/tailwindcss/lib/util/dataTypes.js\");\nconst _setupContextUtils = __webpack_require__(/*! ./setupContextUtils */ \"./node_modules/tailwindcss/lib/lib/setupContextUtils.js\");\nconst _isValidArbitraryValue = /*#__PURE__*/ _interopRequireDefault(__webpack_require__(/*! ../util/isValidArbitraryValue */ \"./node_modules/tailwindcss/lib/util/isValidArbitraryValue.js\"));\nconst _splitAtTopLevelOnlyJs = __webpack_require__(/*! ../util/splitAtTopLevelOnly.js */ \"./node_modules/tailwindcss/lib/util/splitAtTopLevelOnly.js\");\nconst _featureFlags = __webpack_require__(/*! ../featureFlags */ \"./node_modules/tailwindcss/lib/featureFlags.js\");\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        default: obj\n    };\n}\nfunction _getRequireWildcardCache(nodeInterop) {\n    if (typeof WeakMap !== \"function\") return null;\n    var cacheBabelInterop = new WeakMap();\n    var cacheNodeInterop = new WeakMap();\n    return (_getRequireWildcardCache = function(nodeInterop) {\n        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;\n    })(nodeInterop);\n}\nfunction _interopRequireWildcard(obj, nodeInterop) {\n    if (!nodeInterop && obj && obj.__esModule) {\n        return obj;\n    }\n    if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n        return {\n            default: obj\n        };\n    }\n    var cache = _getRequireWildcardCache(nodeInterop);\n    if (cache && cache.has(obj)) {\n        return cache.get(obj);\n    }\n    var newObj = {};\n    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n    for(var key in obj){\n        if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) {\n            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n            if (desc && (desc.get || desc.set)) {\n                Object.defineProperty(newObj, key, desc);\n            } else {\n                newObj[key] = obj[key];\n            }\n        }\n    }\n    newObj.default = obj;\n    if (cache) {\n        cache.set(obj, newObj);\n    }\n    return newObj;\n}\nlet classNameParser = (0, _postcssSelectorParser.default)((selectors)=>{\n    return selectors.first.filter(({ type  })=>type === \"class\").pop().value;\n});\nfunction getClassNameFromSelector(selector) {\n    return classNameParser.transformSync(selector);\n}\n// Generate match permutations for a class candidate, like:\n// ['ring-offset-blue', '100']\n// ['ring-offset', 'blue-100']\n// ['ring', 'offset-blue-100']\n// Example with dynamic classes:\n// ['grid-cols', '[[linename],1fr,auto]']\n// ['grid', 'cols-[[linename],1fr,auto]']\nfunction* candidatePermutations(candidate) {\n    let lastIndex = Infinity;\n    while(lastIndex >= 0){\n        let dashIdx;\n        if (lastIndex === Infinity && candidate.endsWith(\"]\")) {\n            let bracketIdx = candidate.indexOf(\"[\");\n            // If character before `[` isn't a dash or a slash, this isn't a dynamic class\n            // eg. string[]\n            dashIdx = [\n                \"-\",\n                \"/\"\n            ].includes(candidate[bracketIdx - 1]) ? bracketIdx - 1 : -1;\n        } else {\n            dashIdx = candidate.lastIndexOf(\"-\", lastIndex);\n        }\n        if (dashIdx < 0) {\n            break;\n        }\n        let prefix = candidate.slice(0, dashIdx);\n        let modifier = candidate.slice(dashIdx + 1);\n        yield [\n            prefix,\n            modifier\n        ];\n        lastIndex = dashIdx - 1;\n    }\n}\nfunction applyPrefix(matches, context) {\n    if (matches.length === 0 || context.tailwindConfig.prefix === \"\") {\n        return matches;\n    }\n    for (let match of matches){\n        let [meta] = match;\n        if (meta.options.respectPrefix) {\n            let container = _postcss.default.root({\n                nodes: [\n                    match[1].clone()\n                ]\n            });\n            let classCandidate = match[1].raws.tailwind.classCandidate;\n            container.walkRules((r)=>{\n                // If this is a negative utility with a dash *before* the prefix we\n                // have to ensure that the generated selector matches the candidate\n                // Not doing this will cause `-tw-top-1` to generate the class `.tw--top-1`\n                // The disconnect between candidate <-> class can cause @apply to hard crash.\n                let shouldPrependNegative = classCandidate.startsWith(\"-\");\n                r.selector = (0, _prefixSelector.default)(context.tailwindConfig.prefix, r.selector, shouldPrependNegative);\n            });\n            match[1] = container.nodes[0];\n        }\n    }\n    return matches;\n}\nfunction applyImportant(matches, classCandidate) {\n    if (matches.length === 0) {\n        return matches;\n    }\n    let result = [];\n    for (let [meta, rule] of matches){\n        let container = _postcss.default.root({\n            nodes: [\n                rule.clone()\n            ]\n        });\n        container.walkRules((r)=>{\n            r.selector = (0, _pluginUtils.updateAllClasses)(r.selector, (className)=>{\n                if (className === classCandidate) {\n                    return `!${className}`;\n                }\n                return className;\n            });\n            r.walkDecls((d)=>d.important = true);\n        });\n        result.push([\n            {\n                ...meta,\n                important: true\n            },\n            container.nodes[0]\n        ]);\n    }\n    return result;\n}\n// Takes a list of rule tuples and applies a variant like `hover`, sm`,\n// whatever to it. We used to do some extra caching here to avoid generating\n// a variant of the same rule more than once, but this was never hit because\n// we cache at the entire selector level further up the tree.\n//\n// Technically you can get a cache hit if you have `hover:focus:text-center`\n// and `focus:hover:text-center` in the same project, but it doesn't feel\n// worth the complexity for that case.\nfunction applyVariant(variant, matches, context) {\n    if (matches.length === 0) {\n        return matches;\n    }\n    let args;\n    // Find partial arbitrary variants\n    if (variant.endsWith(\"]\") && !variant.startsWith(\"[\")) {\n        args = variant.slice(variant.lastIndexOf(\"[\") + 1, -1);\n        variant = variant.slice(0, variant.indexOf(args) - 1 /* - */  - 1 /* [ */ );\n    }\n    // Register arbitrary variants\n    if (isArbitraryValue(variant) && !context.variantMap.has(variant)) {\n        let selector = (0, _dataTypes.normalize)(variant.slice(1, -1));\n        if (!(0, _setupContextUtils.isValidVariantFormatString)(selector)) {\n            return [];\n        }\n        let fn = (0, _setupContextUtils.parseVariant)(selector);\n        let sort = Array.from(context.variantOrder.values()).pop() << 1n;\n        context.variantMap.set(variant, [\n            [\n                sort,\n                fn\n            ]\n        ]);\n        context.variantOrder.set(variant, sort);\n    }\n    if (context.variantMap.has(variant)) {\n        let variantFunctionTuples = context.variantMap.get(variant).slice();\n        let result = [];\n        for (let [meta, rule] of matches){\n            // Don't generate variants for user css\n            if (meta.layer === \"user\") {\n                continue;\n            }\n            let container = _postcss.default.root({\n                nodes: [\n                    rule.clone()\n                ]\n            });\n            for (let [variantSort, variantFunction, containerFromArray] of variantFunctionTuples){\n                let clone = containerFromArray !== null && containerFromArray !== void 0 ? containerFromArray : container.clone();\n                let collectedFormats = [];\n                function prepareBackup() {\n                    // Already prepared, chicken out\n                    if (clone.raws.neededBackup) {\n                        return;\n                    }\n                    clone.raws.neededBackup = true;\n                    clone.walkRules((rule)=>rule.raws.originalSelector = rule.selector);\n                }\n                function modifySelectors(modifierFunction) {\n                    prepareBackup();\n                    clone.each((rule)=>{\n                        if (rule.type !== \"rule\") {\n                            return;\n                        }\n                        rule.selectors = rule.selectors.map((selector)=>{\n                            return modifierFunction({\n                                get className () {\n                                    return getClassNameFromSelector(selector);\n                                },\n                                selector\n                            });\n                        });\n                    });\n                    return clone;\n                }\n                let ruleWithVariant = variantFunction({\n                    // Public API\n                    get container () {\n                        prepareBackup();\n                        return clone;\n                    },\n                    separator: context.tailwindConfig.separator,\n                    modifySelectors,\n                    // Private API for now\n                    wrap (wrapper) {\n                        let nodes = clone.nodes;\n                        clone.removeAll();\n                        wrapper.append(nodes);\n                        clone.append(wrapper);\n                    },\n                    format (selectorFormat) {\n                        collectedFormats.push(selectorFormat);\n                    },\n                    args\n                });\n                // It can happen that a list of format strings is returned from within the function. In that\n                // case, we have to process them as well. We can use the existing `variantSort`.\n                if (Array.isArray(ruleWithVariant)) {\n                    for (let [idx, variantFunction1] of ruleWithVariant.entries()){\n                        // This is a little bit scary since we are pushing to an array of items that we are\n                        // currently looping over. However, you can also think of it like a processing queue\n                        // where you keep handling jobs until everything is done and each job can queue more\n                        // jobs if needed.\n                        variantFunctionTuples.push([\n                            // TODO: This could have potential bugs if we shift the sort order from variant A far\n                            // enough into the sort space of variant B. The chances are low, but if this happens\n                            // then this might be the place too look at. One potential solution to this problem is\n                            // reserving additional X places for these 'unknown' variants in between.\n                            variantSort | BigInt(idx << ruleWithVariant.length),\n                            variantFunction1,\n                            // If the clone has been modified we have to pass that back\n                            // though so each rule can use the modified container\n                            clone.clone(), \n                        ]);\n                    }\n                    continue;\n                }\n                if (typeof ruleWithVariant === \"string\") {\n                    collectedFormats.push(ruleWithVariant);\n                }\n                if (ruleWithVariant === null) {\n                    continue;\n                }\n                // We had to backup selectors, therefore we assume that somebody touched\n                // `container` or `modifySelectors`. Let's see if they did, so that we\n                // can restore the selectors, and collect the format strings.\n                if (clone.raws.neededBackup) {\n                    delete clone.raws.neededBackup;\n                    clone.walkRules((rule)=>{\n                        let before = rule.raws.originalSelector;\n                        if (!before) return;\n                        delete rule.raws.originalSelector;\n                        if (before === rule.selector) return; // No mutation happened\n                        let modified = rule.selector;\n                        // Rebuild the base selector, this is what plugin authors would do\n                        // as well. E.g.: `${variant}${separator}${className}`.\n                        // However, plugin authors probably also prepend or append certain\n                        // classes, pseudos, ids, ...\n                        let rebuiltBase = (0, _postcssSelectorParser.default)((selectors)=>{\n                            selectors.walkClasses((classNode)=>{\n                                classNode.value = `${variant}${context.tailwindConfig.separator}${classNode.value}`;\n                            });\n                        }).processSync(before);\n                        // Now that we know the original selector, the new selector, and\n                        // the rebuild part in between, we can replace the part that plugin\n                        // authors need to rebuild with `&`, and eventually store it in the\n                        // collectedFormats. Similar to what `format('...')` would do.\n                        //\n                        // E.g.:\n                        //                   variant: foo\n                        //                  selector: .markdown > p\n                        //      modified (by plugin): .foo .foo\\\\:markdown > p\n                        //    rebuiltBase (internal): .foo\\\\:markdown > p\n                        //                    format: .foo &\n                        collectedFormats.push(modified.replace(rebuiltBase, \"&\"));\n                        rule.selector = before;\n                    });\n                }\n                // This tracks the originating layer for the variant\n                // For example:\n                // .sm:underline {} is a variant of something in the utilities layer\n                // .sm:container {} is a variant of the container component\n                clone.nodes[0].raws.tailwind = {\n                    ...clone.nodes[0].raws.tailwind,\n                    parentLayer: meta.layer\n                };\n                var _collectedFormats;\n                let withOffset = [\n                    {\n                        ...meta,\n                        sort: variantSort | meta.sort,\n                        collectedFormats: ((_collectedFormats = meta.collectedFormats) !== null && _collectedFormats !== void 0 ? _collectedFormats : []).concat(collectedFormats),\n                        isArbitraryVariant: isArbitraryValue(variant)\n                    },\n                    clone.nodes[0], \n                ];\n                result.push(withOffset);\n            }\n        }\n        return result;\n    }\n    return [];\n}\nfunction parseRules(rule, cache, options = {}) {\n    // PostCSS node\n    if (!(0, _isPlainObject.default)(rule) && !Array.isArray(rule)) {\n        return [\n            [\n                rule\n            ],\n            options\n        ];\n    }\n    // Tuple\n    if (Array.isArray(rule)) {\n        return parseRules(rule[0], cache, rule[1]);\n    }\n    // Simple object\n    if (!cache.has(rule)) {\n        cache.set(rule, (0, _parseObjectStyles.default)(rule));\n    }\n    return [\n        cache.get(rule),\n        options\n    ];\n}\nconst IS_VALID_PROPERTY_NAME = /^[a-z_-]/;\nfunction isValidPropName(name) {\n    return IS_VALID_PROPERTY_NAME.test(name);\n}\n/**\n * @param {string} declaration\n * @returns {boolean}\n */ function looksLikeUri(declaration) {\n    // Quick bailout for obvious non-urls\n    // This doesn't support schemes that don't use a leading // but that's unlikely to be a problem\n    if (!declaration.includes(\"://\")) {\n        return false;\n    }\n    try {\n        const url = new URL(declaration);\n        return url.scheme !== \"\" && url.host !== \"\";\n    } catch (err) {\n        // Definitely not a valid url\n        return false;\n    }\n}\nfunction isParsableNode(node) {\n    let isParsable = true;\n    node.walkDecls((decl)=>{\n        if (!isParsableCssValue(decl.name, decl.value)) {\n            isParsable = false;\n            return false;\n        }\n    });\n    return isParsable;\n}\nfunction isParsableCssValue(property, value) {\n    // We don't want to to treat [https://example.com] as a custom property\n    // Even though, according to the CSS grammar, it's a totally valid CSS declaration\n    // So we short-circuit here by checking if the custom property looks like a url\n    if (looksLikeUri(`${property}:${value}`)) {\n        return false;\n    }\n    try {\n        _postcss.default.parse(`a{${property}:${value}}`).toResult();\n        return true;\n    } catch (err) {\n        return false;\n    }\n}\nfunction extractArbitraryProperty(classCandidate, context) {\n    var ref;\n    let [, property, value] = (ref = classCandidate.match(/^\\[([a-zA-Z0-9-_]+):(\\S+)\\]$/)) !== null && ref !== void 0 ? ref : [];\n    if (value === undefined) {\n        return null;\n    }\n    if (!isValidPropName(property)) {\n        return null;\n    }\n    if (!(0, _isValidArbitraryValue.default)(value)) {\n        return null;\n    }\n    let normalized = (0, _dataTypes.normalize)(value);\n    if (!isParsableCssValue(property, normalized)) {\n        return null;\n    }\n    return [\n        [\n            {\n                sort: context.arbitraryPropertiesSort,\n                layer: \"utilities\"\n            },\n            ()=>({\n                    [(0, _nameClass.asClass)(classCandidate)]: {\n                        [property]: normalized\n                    }\n                }), \n        ], \n    ];\n}\nfunction* resolveMatchedPlugins(classCandidate, context) {\n    if (context.candidateRuleMap.has(classCandidate)) {\n        yield [\n            context.candidateRuleMap.get(classCandidate),\n            \"DEFAULT\"\n        ];\n    }\n    yield* function*(arbitraryPropertyRule) {\n        if (arbitraryPropertyRule !== null) {\n            yield [\n                arbitraryPropertyRule,\n                \"DEFAULT\"\n            ];\n        }\n    }(extractArbitraryProperty(classCandidate, context));\n    let candidatePrefix = classCandidate;\n    let negative = false;\n    const twConfigPrefix = context.tailwindConfig.prefix;\n    const twConfigPrefixLen = twConfigPrefix.length;\n    const hasMatchingPrefix = candidatePrefix.startsWith(twConfigPrefix) || candidatePrefix.startsWith(`-${twConfigPrefix}`);\n    if (candidatePrefix[twConfigPrefixLen] === \"-\" && hasMatchingPrefix) {\n        negative = true;\n        candidatePrefix = twConfigPrefix + candidatePrefix.slice(twConfigPrefixLen + 1);\n    }\n    if (negative && context.candidateRuleMap.has(candidatePrefix)) {\n        yield [\n            context.candidateRuleMap.get(candidatePrefix),\n            \"-DEFAULT\"\n        ];\n    }\n    for (let [prefix, modifier] of candidatePermutations(candidatePrefix)){\n        if (context.candidateRuleMap.has(prefix)) {\n            yield [\n                context.candidateRuleMap.get(prefix),\n                negative ? `-${modifier}` : modifier\n            ];\n        }\n    }\n}\nfunction splitWithSeparator(input, separator) {\n    if (input === _sharedState.NOT_ON_DEMAND) {\n        return [\n            _sharedState.NOT_ON_DEMAND\n        ];\n    }\n    return Array.from((0, _splitAtTopLevelOnlyJs.splitAtTopLevelOnly)(input, separator));\n}\nfunction* recordCandidates(matches, classCandidate) {\n    for (const match of matches){\n        var ref;\n        var ref1;\n        match[1].raws.tailwind = {\n            ...match[1].raws.tailwind,\n            classCandidate,\n            preserveSource: (ref1 = (ref = match[0].options) === null || ref === void 0 ? void 0 : ref.preserveSource) !== null && ref1 !== void 0 ? ref1 : false\n        };\n        yield match;\n    }\n}\nfunction* resolveMatches(candidate, context, original = candidate) {\n    let separator = context.tailwindConfig.separator;\n    let [classCandidate, ...variants] = splitWithSeparator(candidate, separator).reverse();\n    let important = false;\n    if (classCandidate.startsWith(\"!\")) {\n        important = true;\n        classCandidate = classCandidate.slice(1);\n    }\n    if ((0, _featureFlags.flagEnabled)(context.tailwindConfig, \"variantGrouping\")) {\n        if (classCandidate.startsWith(\"(\") && classCandidate.endsWith(\")\")) {\n            let base = variants.slice().reverse().join(separator);\n            for (let part of (0, _splitAtTopLevelOnlyJs.splitAtTopLevelOnly)(classCandidate.slice(1, -1), \",\")){\n                yield* resolveMatches(base + separator + part, context, original);\n            }\n        }\n    }\n    // TODO: Reintroduce this in ways that doesn't break on false positives\n    // function sortAgainst(toSort, against) {\n    //   return toSort.slice().sort((a, z) => {\n    //     return bigSign(against.get(a)[0] - against.get(z)[0])\n    //   })\n    // }\n    // let sorted = sortAgainst(variants, context.variantMap)\n    // if (sorted.toString() !== variants.toString()) {\n    //   let corrected = sorted.reverse().concat(classCandidate).join(':')\n    //   throw new Error(`Class ${candidate} should be written as ${corrected}`)\n    // }\n    for (let matchedPlugins of resolveMatchedPlugins(classCandidate, context)){\n        let matches = [];\n        let typesByMatches = new Map();\n        let [plugins, modifier] = matchedPlugins;\n        let isOnlyPlugin = plugins.length === 1;\n        for (let [sort, plugin] of plugins){\n            let matchesPerPlugin = [];\n            if (typeof plugin === \"function\") {\n                for (let ruleSet of [].concat(plugin(modifier, {\n                    isOnlyPlugin\n                }))){\n                    let [rules, options] = parseRules(ruleSet, context.postCssNodeCache);\n                    for (let rule of rules){\n                        matchesPerPlugin.push([\n                            {\n                                ...sort,\n                                options: {\n                                    ...sort.options,\n                                    ...options\n                                }\n                            },\n                            rule\n                        ]);\n                    }\n                }\n            } else if (modifier === \"DEFAULT\" || modifier === \"-DEFAULT\") {\n                let ruleSet1 = plugin;\n                let [rules1, options1] = parseRules(ruleSet1, context.postCssNodeCache);\n                for (let rule1 of rules1){\n                    matchesPerPlugin.push([\n                        {\n                            ...sort,\n                            options: {\n                                ...sort.options,\n                                ...options1\n                            }\n                        },\n                        rule1\n                    ]);\n                }\n            }\n            if (matchesPerPlugin.length > 0) {\n                var ref;\n                typesByMatches.set(matchesPerPlugin, (ref = sort.options) === null || ref === void 0 ? void 0 : ref.type);\n                matches.push(matchesPerPlugin);\n            }\n        }\n        if (isArbitraryValue(modifier)) {\n            // When generated arbitrary values are ambiguous, we can't know\n            // which to pick so don't generate any utilities for them\n            if (matches.length > 1) {\n                var ref1;\n                let typesPerPlugin = matches.map((match)=>new Set([\n                        ...(ref1 = typesByMatches.get(match)) !== null && ref1 !== void 0 ? ref1 : []\n                    ]));\n                // Remove duplicates, so that we can detect proper unique types for each plugin.\n                for (let pluginTypes of typesPerPlugin){\n                    for (let type of pluginTypes){\n                        let removeFromOwnGroup = false;\n                        for (let otherGroup of typesPerPlugin){\n                            if (pluginTypes === otherGroup) continue;\n                            if (otherGroup.has(type)) {\n                                otherGroup.delete(type);\n                                removeFromOwnGroup = true;\n                            }\n                        }\n                        if (removeFromOwnGroup) pluginTypes.delete(type);\n                    }\n                }\n                let messages = [];\n                for (let [idx, group] of typesPerPlugin.entries()){\n                    for (let type1 of group){\n                        let rules2 = matches[idx].map(([, rule])=>rule).flat().map((rule)=>rule.toString().split(\"\\n\").slice(1, -1) // Remove selector and closing '}'\n                            .map((line)=>line.trim()).map((x)=>`      ${x}`) // Re-indent\n                            .join(\"\\n\")).join(\"\\n\\n\");\n                        messages.push(`  Use \\`${candidate.replace(\"[\", `[${type1}:`)}\\` for \\`${rules2.trim()}\\``);\n                        break;\n                    }\n                }\n                _log.default.warn([\n                    `The class \\`${candidate}\\` is ambiguous and matches multiple utilities.`,\n                    ...messages,\n                    `If this is content and not a class, replace it with \\`${candidate.replace(\"[\", \"&lsqb;\").replace(\"]\", \"&rsqb;\")}\\` to silence this warning.`, \n                ]);\n                continue;\n            }\n            matches = matches.map((list)=>list.filter((match)=>isParsableNode(match[1])));\n        }\n        matches = matches.flat();\n        matches = Array.from(recordCandidates(matches, classCandidate));\n        matches = applyPrefix(matches, context);\n        if (important) {\n            matches = applyImportant(matches, classCandidate);\n        }\n        for (let variant of variants){\n            matches = applyVariant(variant, matches, context);\n        }\n        for (let match of matches){\n            match[1].raws.tailwind = {\n                ...match[1].raws.tailwind,\n                candidate\n            };\n            // Apply final format selector\n            if (match[0].collectedFormats) {\n                let finalFormat = (0, _formatVariantSelector.formatVariantSelector)(\"&\", ...match[0].collectedFormats);\n                let container = _postcss.default.root({\n                    nodes: [\n                        match[1].clone()\n                    ]\n                });\n                container.walkRules((rule)=>{\n                    var ref;\n                    if (inKeyframes(rule)) return;\n                    var ref1;\n                    rule.selector = (0, _formatVariantSelector.finalizeSelector)(finalFormat, {\n                        selector: rule.selector,\n                        candidate: original,\n                        base: candidate.split(new RegExp(`\\\\${(ref1 = context === null || context === void 0 ? void 0 : (ref = context.tailwindConfig) === null || ref === void 0 ? void 0 : ref.separator) !== null && ref1 !== void 0 ? ref1 : \":\"}(?![^[]*\\\\])`)).pop(),\n                        isArbitraryVariant: match[0].isArbitraryVariant,\n                        context\n                    });\n                });\n                match[1] = container.nodes[0];\n            }\n            yield match;\n        }\n    }\n}\nfunction inKeyframes(rule) {\n    return rule.parent && rule.parent.type === \"atrule\" && rule.parent.name === \"keyframes\";\n}\nfunction generateRules(candidates, context) {\n    let allRules = [];\n    for (let candidate of candidates){\n        if (context.notClassCache.has(candidate)) {\n            continue;\n        }\n        if (context.classCache.has(candidate)) {\n            allRules.push(context.classCache.get(candidate));\n            continue;\n        }\n        let matches = Array.from(resolveMatches(candidate, context));\n        if (matches.length === 0) {\n            context.notClassCache.add(candidate);\n            continue;\n        }\n        context.classCache.set(candidate, matches);\n        allRules.push(matches);\n    }\n    // Strategy based on `tailwindConfig.important`\n    let strategy = ((important)=>{\n        if (important === true) {\n            return (rule)=>{\n                rule.walkDecls((d)=>{\n                    if (d.parent.type === \"rule\" && !inKeyframes(d.parent)) {\n                        d.important = true;\n                    }\n                });\n            };\n        }\n        if (typeof important === \"string\") {\n            return (rule)=>{\n                rule.selectors = rule.selectors.map((selector)=>{\n                    return `${important} ${selector}`;\n                });\n            };\n        }\n    })(context.tailwindConfig.important);\n    return allRules.flat(1).map(([{ sort , layer , options  }, rule])=>{\n        if (options.respectImportant) {\n            if (strategy) {\n                let container = _postcss.default.root({\n                    nodes: [\n                        rule.clone()\n                    ]\n                });\n                container.walkRules((r)=>{\n                    if (inKeyframes(r)) {\n                        return;\n                    }\n                    strategy(r);\n                });\n                rule = container.nodes[0];\n            }\n        }\n        return [\n            sort | context.layerOrder[layer],\n            rule\n        ];\n    });\n}\nfunction isArbitraryValue(input) {\n    return input.startsWith(\"[\") && input.endsWith(\"]\");\n}\n\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/tailwindcss/lib/lib/generateRules.js?");

/***/ }),

/***/ "./node_modules/tailwindcss/lib/lib/getModuleDependencies.js":
/*!*******************************************************************!*\
  !*** ./node_modules/tailwindcss/lib/lib/getModuleDependencies.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"default\", ({\n    enumerable: true,\n    get: ()=>getModuleDependencies\n}));\nconst _fs = /*#__PURE__*/ _interopRequireDefault(__webpack_require__(Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'fs'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }())));\nconst _path = /*#__PURE__*/ _interopRequireDefault(__webpack_require__(Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'path'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }())));\nconst _resolve = /*#__PURE__*/ _interopRequireDefault(__webpack_require__(/*! resolve */ \"./node_modules/resolve/index.js\"));\nconst _detective = /*#__PURE__*/ _interopRequireDefault(__webpack_require__(/*! detective */ \"./node_modules/detective/index.js\"));\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        default: obj\n    };\n}\nfunction createModule(file) {\n    const source = _fs.default.readFileSync(file, \"utf-8\");\n    const requires = (0, _detective.default)(source);\n    return {\n        file,\n        requires\n    };\n}\nfunction getModuleDependencies(entryFile) {\n    const rootModule = createModule(entryFile);\n    const modules = [\n        rootModule\n    ];\n    // Iterate over the modules, even when new\n    // ones are being added\n    for (const mdl of modules){\n        mdl.requires.filter((dep)=>{\n            // Only track local modules, not node_modules\n            return dep.startsWith(\"./\") || dep.startsWith(\"../\");\n        }).forEach((dep)=>{\n            try {\n                const basedir = _path.default.dirname(mdl.file);\n                const depPath = _resolve.default.sync(dep, {\n                    basedir\n                });\n                const depModule = createModule(depPath);\n                modules.push(depModule);\n            } catch (_err) {\n            // eslint-disable-next-line no-empty\n            }\n        });\n    }\n    return modules;\n}\n\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/tailwindcss/lib/lib/getModuleDependencies.js?");

/***/ }),

/***/ "./node_modules/tailwindcss/lib/lib/normalizeTailwindDirectives.js":
/*!*************************************************************************!*\
  !*** ./node_modules/tailwindcss/lib/lib/normalizeTailwindDirectives.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"default\", ({\n    enumerable: true,\n    get: ()=>normalizeTailwindDirectives\n}));\nconst _log = /*#__PURE__*/ _interopRequireDefault(__webpack_require__(/*! ../util/log */ \"./node_modules/tailwindcss/lib/util/log.js\"));\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        default: obj\n    };\n}\nfunction normalizeTailwindDirectives(root) {\n    let tailwindDirectives = new Set();\n    let layerDirectives = new Set();\n    let applyDirectives = new Set();\n    root.walkAtRules((atRule)=>{\n        if (atRule.name === \"apply\") {\n            applyDirectives.add(atRule);\n        }\n        if (atRule.name === \"import\") {\n            if (atRule.params === '\"tailwindcss/base\"' || atRule.params === \"'tailwindcss/base'\") {\n                atRule.name = \"tailwind\";\n                atRule.params = \"base\";\n            } else if (atRule.params === '\"tailwindcss/components\"' || atRule.params === \"'tailwindcss/components'\") {\n                atRule.name = \"tailwind\";\n                atRule.params = \"components\";\n            } else if (atRule.params === '\"tailwindcss/utilities\"' || atRule.params === \"'tailwindcss/utilities'\") {\n                atRule.name = \"tailwind\";\n                atRule.params = \"utilities\";\n            } else if (atRule.params === '\"tailwindcss/screens\"' || atRule.params === \"'tailwindcss/screens'\" || atRule.params === '\"tailwindcss/variants\"' || atRule.params === \"'tailwindcss/variants'\") {\n                atRule.name = \"tailwind\";\n                atRule.params = \"variants\";\n            }\n        }\n        if (atRule.name === \"tailwind\") {\n            if (atRule.params === \"screens\") {\n                atRule.params = \"variants\";\n            }\n            tailwindDirectives.add(atRule.params);\n        }\n        if ([\n            \"layer\",\n            \"responsive\",\n            \"variants\"\n        ].includes(atRule.name)) {\n            if ([\n                \"responsive\",\n                \"variants\"\n            ].includes(atRule.name)) {\n                _log.default.warn(`${atRule.name}-at-rule-deprecated`, [\n                    `The \\`@${atRule.name}\\` directive has been deprecated in Tailwind CSS v3.0.`,\n                    `Use \\`@layer utilities\\` or \\`@layer components\\` instead.`,\n                    \"https://tailwindcss.com/docs/upgrade-guide#replace-variants-with-layer\", \n                ]);\n            }\n            layerDirectives.add(atRule);\n        }\n    });\n    if (!tailwindDirectives.has(\"base\") || !tailwindDirectives.has(\"components\") || !tailwindDirectives.has(\"utilities\")) {\n        for (let rule of layerDirectives){\n            if (rule.name === \"layer\" && [\n                \"base\",\n                \"components\",\n                \"utilities\"\n            ].includes(rule.params)) {\n                if (!tailwindDirectives.has(rule.params)) {\n                    throw rule.error(`\\`@layer ${rule.params}\\` is used but no matching \\`@tailwind ${rule.params}\\` directive is present.`);\n                }\n            } else if (rule.name === \"responsive\") {\n                if (!tailwindDirectives.has(\"utilities\")) {\n                    throw rule.error(\"`@responsive` is used but `@tailwind utilities` is missing.\");\n                }\n            } else if (rule.name === \"variants\") {\n                if (!tailwindDirectives.has(\"utilities\")) {\n                    throw rule.error(\"`@variants` is used but `@tailwind utilities` is missing.\");\n                }\n            }\n        }\n    }\n    return {\n        tailwindDirectives,\n        applyDirectives\n    };\n}\n\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/tailwindcss/lib/lib/normalizeTailwindDirectives.js?");

/***/ }),

/***/ "./node_modules/tailwindcss/lib/lib/partitionApplyAtRules.js":
/*!*******************************************************************!*\
  !*** ./node_modules/tailwindcss/lib/lib/partitionApplyAtRules.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"default\", ({\n    enumerable: true,\n    get: ()=>expandApplyAtRules\n}));\nfunction partitionRules(root) {\n    if (!root.walkAtRules) return;\n    let applyParents = new Set();\n    root.walkAtRules(\"apply\", (rule)=>{\n        applyParents.add(rule.parent);\n    });\n    if (applyParents.size === 0) {\n        return;\n    }\n    for (let rule of applyParents){\n        let nodeGroups = [];\n        let lastGroup = [];\n        for (let node of rule.nodes){\n            if (node.type === \"atrule\" && node.name === \"apply\") {\n                if (lastGroup.length > 0) {\n                    nodeGroups.push(lastGroup);\n                    lastGroup = [];\n                }\n                nodeGroups.push([\n                    node\n                ]);\n            } else {\n                lastGroup.push(node);\n            }\n        }\n        if (lastGroup.length > 0) {\n            nodeGroups.push(lastGroup);\n        }\n        if (nodeGroups.length === 1) {\n            continue;\n        }\n        for (let group of [\n            ...nodeGroups\n        ].reverse()){\n            let clone = rule.clone({\n                nodes: []\n            });\n            clone.append(group);\n            rule.after(clone);\n        }\n        rule.remove();\n    }\n}\nfunction expandApplyAtRules() {\n    return (root)=>{\n        partitionRules(root);\n    };\n}\n\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/tailwindcss/lib/lib/partitionApplyAtRules.js?");

/***/ }),

/***/ "./node_modules/tailwindcss/lib/lib/regex.js":
/*!***************************************************!*\
  !*** ./node_modules/tailwindcss/lib/lib/regex.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    pattern: ()=>pattern,\n    withoutCapturing: ()=>withoutCapturing,\n    any: ()=>any,\n    optional: ()=>optional,\n    zeroOrMore: ()=>zeroOrMore,\n    nestedBrackets: ()=>nestedBrackets,\n    escape: ()=>escape\n});\nconst REGEX_SPECIAL = /[\\\\^$.*+?()[\\]{}|]/g;\nconst REGEX_HAS_SPECIAL = RegExp(REGEX_SPECIAL.source);\n/**\n * @param {string|RegExp|Array<string|RegExp>} source\n */ function toSource(source) {\n    source = Array.isArray(source) ? source : [\n        source\n    ];\n    source = source.map((item)=>item instanceof RegExp ? item.source : item);\n    return source.join(\"\");\n}\nfunction pattern(source) {\n    return new RegExp(toSource(source), \"g\");\n}\nfunction withoutCapturing(source) {\n    return new RegExp(`(?:${toSource(source)})`, \"g\");\n}\nfunction any(sources) {\n    return `(?:${sources.map(toSource).join(\"|\")})`;\n}\nfunction optional(source) {\n    return `(?:${toSource(source)})?`;\n}\nfunction zeroOrMore(source) {\n    return `(?:${toSource(source)})*`;\n}\nfunction nestedBrackets(open, close, depth = 1) {\n    return withoutCapturing([\n        escape(open),\n        /[^\\s]*/,\n        depth === 1 ? `[^${escape(open)}${escape(close)}\\s]*` : any([\n            `[^${escape(open)}${escape(close)}\\s]*`,\n            nestedBrackets(open, close, depth - 1)\n        ]),\n        /[^\\s]*/,\n        escape(close), \n    ]);\n}\nfunction escape(string) {\n    return string && REGEX_HAS_SPECIAL.test(string) ? string.replace(REGEX_SPECIAL, \"\\\\$&\") : string || \"\";\n}\n\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/tailwindcss/lib/lib/regex.js?");

/***/ }),

/***/ "./node_modules/tailwindcss/lib/lib/resolveDefaultsAtRules.js":
/*!********************************************************************!*\
  !*** ./node_modules/tailwindcss/lib/lib/resolveDefaultsAtRules.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    elementSelectorParser: ()=>elementSelectorParser,\n    default: ()=>resolveDefaultsAtRules\n});\nconst _postcss = /*#__PURE__*/ _interopRequireDefault(__webpack_require__(/*! postcss */ \"./node_modules/postcss/lib/postcss.js\"));\nconst _postcssSelectorParser = /*#__PURE__*/ _interopRequireDefault(__webpack_require__(/*! postcss-selector-parser */ \"./node_modules/postcss-selector-parser/dist/index.js\"));\nconst _featureFlags = __webpack_require__(/*! ../featureFlags */ \"./node_modules/tailwindcss/lib/featureFlags.js\");\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        default: obj\n    };\n}\nlet getNode = {\n    id (node) {\n        return _postcssSelectorParser.default.attribute({\n            attribute: \"id\",\n            operator: \"=\",\n            value: node.value,\n            quoteMark: '\"'\n        });\n    }\n};\nfunction minimumImpactSelector(nodes) {\n    let rest = nodes.filter((node)=>{\n        // Keep non-pseudo nodes\n        if (node.type !== \"pseudo\") return true;\n        // Keep pseudo nodes that have subnodes\n        // E.g.: `:not()` contains subnodes inside the parentheses\n        if (node.nodes.length > 0) return true;\n        // Keep pseudo `elements`\n        // This implicitly means that we ignore pseudo `classes`\n        return node.value.startsWith(\"::\") || [\n            \":before\",\n            \":after\",\n            \":first-line\",\n            \":first-letter\"\n        ].includes(node.value);\n    }).reverse();\n    let searchFor = new Set([\n        \"tag\",\n        \"class\",\n        \"id\",\n        \"attribute\"\n    ]);\n    let splitPointIdx = rest.findIndex((n)=>searchFor.has(n.type));\n    if (splitPointIdx === -1) return rest.reverse().join(\"\").trim();\n    let node = rest[splitPointIdx];\n    let bestNode = getNode[node.type] ? getNode[node.type](node) : node;\n    rest = rest.slice(0, splitPointIdx);\n    let combinatorIdx = rest.findIndex((n)=>n.type === \"combinator\" && n.value === \">\");\n    if (combinatorIdx !== -1) {\n        rest.splice(0, combinatorIdx);\n        rest.unshift(_postcssSelectorParser.default.universal());\n    }\n    return [\n        bestNode,\n        ...rest.reverse()\n    ].join(\"\").trim();\n}\nlet elementSelectorParser = (0, _postcssSelectorParser.default)((selectors)=>{\n    return selectors.map((s)=>{\n        let nodes = s.split((n)=>n.type === \"combinator\" && n.value === \" \").pop();\n        return minimumImpactSelector(nodes);\n    });\n});\nlet cache = new Map();\nfunction extractElementSelector(selector) {\n    if (!cache.has(selector)) {\n        cache.set(selector, elementSelectorParser.transformSync(selector));\n    }\n    return cache.get(selector);\n}\nfunction resolveDefaultsAtRules({ tailwindConfig  }) {\n    return (root)=>{\n        let variableNodeMap = new Map();\n        /** @type {Set<import('postcss').AtRule>} */ let universals = new Set();\n        root.walkAtRules(\"defaults\", (rule)=>{\n            if (rule.nodes && rule.nodes.length > 0) {\n                universals.add(rule);\n                return;\n            }\n            let variable = rule.params;\n            if (!variableNodeMap.has(variable)) {\n                variableNodeMap.set(variable, new Set());\n            }\n            variableNodeMap.get(variable).add(rule.parent);\n            rule.remove();\n        });\n        if ((0, _featureFlags.flagEnabled)(tailwindConfig, \"optimizeUniversalDefaults\")) {\n            for (let universal of universals){\n                /** @type {Map<string, Set<string>>} */ let selectorGroups = new Map();\n                var ref;\n                let rules = (ref = variableNodeMap.get(universal.params)) !== null && ref !== void 0 ? ref : [];\n                for (let rule of rules){\n                    for (let selector of extractElementSelector(rule.selector)){\n                        // If selector contains a vendor prefix after a pseudo element or class,\n                        // we consider them separately because merging the declarations into\n                        // a single rule will cause browsers that do not understand the\n                        // vendor prefix to throw out the whole rule\n                        let selectorGroupName = selector.includes(\":-\") || selector.includes(\"::-\") ? selector : \"__DEFAULT__\";\n                        var ref1;\n                        let selectors = (ref1 = selectorGroups.get(selectorGroupName)) !== null && ref1 !== void 0 ? ref1 : new Set();\n                        selectorGroups.set(selectorGroupName, selectors);\n                        selectors.add(selector);\n                    }\n                }\n                if ((0, _featureFlags.flagEnabled)(tailwindConfig, \"optimizeUniversalDefaults\")) {\n                    if (selectorGroups.size === 0) {\n                        universal.remove();\n                        continue;\n                    }\n                    for (let [, selectors1] of selectorGroups){\n                        let universalRule = _postcss.default.rule({\n                            source: universal.source\n                        });\n                        universalRule.selectors = [\n                            ...selectors1\n                        ];\n                        universalRule.append(universal.nodes.map((node)=>node.clone()));\n                        universal.before(universalRule);\n                    }\n                }\n                universal.remove();\n            }\n        } else if (universals.size) {\n            let universalRule1 = _postcss.default.rule({\n                selectors: [\n                    \"*\",\n                    \"::before\",\n                    \"::after\"\n                ]\n            });\n            for (let universal1 of universals){\n                universalRule1.append(universal1.nodes);\n                if (!universalRule1.parent) {\n                    universal1.before(universalRule1);\n                }\n                if (!universalRule1.source) {\n                    universalRule1.source = universal1.source;\n                }\n                universal1.remove();\n            }\n            let backdropRule = universalRule1.clone({\n                selectors: [\n                    \"::backdrop\"\n                ]\n            });\n            universalRule1.after(backdropRule);\n        }\n    };\n}\n\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/tailwindcss/lib/lib/resolveDefaultsAtRules.js?");

/***/ }),

/***/ "./node_modules/tailwindcss/lib/lib/setupContextUtils.js":
/*!***************************************************************!*\
  !*** ./node_modules/tailwindcss/lib/lib/setupContextUtils.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    isValidVariantFormatString: ()=>isValidVariantFormatString,\n    parseVariant: ()=>parseVariant,\n    getFileModifiedMap: ()=>getFileModifiedMap,\n    createContext: ()=>createContext,\n    getContext: ()=>getContext\n});\nconst _fs = /*#__PURE__*/ _interopRequireDefault(__webpack_require__(Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'fs'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }())));\nconst _url = /*#__PURE__*/ _interopRequireDefault(__webpack_require__(Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'url'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }())));\nconst _postcss = /*#__PURE__*/ _interopRequireDefault(__webpack_require__(/*! postcss */ \"./node_modules/postcss/lib/postcss.js\"));\nconst _dlv = /*#__PURE__*/ _interopRequireDefault(__webpack_require__(/*! dlv */ \"./node_modules/dlv/dist/dlv.umd.js\"));\nconst _postcssSelectorParser = /*#__PURE__*/ _interopRequireDefault(__webpack_require__(/*! postcss-selector-parser */ \"./node_modules/postcss-selector-parser/dist/index.js\"));\nconst _featureFlagsJs = __webpack_require__(/*! ../featureFlags.js */ \"./node_modules/tailwindcss/lib/featureFlags.js\");\nconst _transformThemeValue = /*#__PURE__*/ _interopRequireDefault(__webpack_require__(/*! ../util/transformThemeValue */ \"./node_modules/tailwindcss/lib/util/transformThemeValue.js\"));\nconst _parseObjectStyles = /*#__PURE__*/ _interopRequireDefault(__webpack_require__(/*! ../util/parseObjectStyles */ \"./node_modules/tailwindcss/lib/util/parseObjectStyles.js\"));\nconst _prefixSelector = /*#__PURE__*/ _interopRequireDefault(__webpack_require__(/*! ../util/prefixSelector */ \"./node_modules/tailwindcss/lib/util/prefixSelector.js\"));\nconst _isPlainObject = /*#__PURE__*/ _interopRequireDefault(__webpack_require__(/*! ../util/isPlainObject */ \"./node_modules/tailwindcss/lib/util/isPlainObject.js\"));\nconst _escapeClassName = /*#__PURE__*/ _interopRequireDefault(__webpack_require__(/*! ../util/escapeClassName */ \"./node_modules/tailwindcss/lib/util/escapeClassName.js\"));\nconst _nameClass = /*#__PURE__*/ _interopRequireWildcard(__webpack_require__(/*! ../util/nameClass */ \"./node_modules/tailwindcss/lib/util/nameClass.js\"));\nconst _pluginUtils = __webpack_require__(/*! ../util/pluginUtils */ \"./node_modules/tailwindcss/lib/util/pluginUtils.js\");\nconst _bigSign = /*#__PURE__*/ _interopRequireDefault(__webpack_require__(/*! ../util/bigSign */ \"./node_modules/tailwindcss/lib/util/bigSign.js\"));\nconst _corePlugins = __webpack_require__(/*! ../corePlugins */ \"./node_modules/tailwindcss/lib/corePlugins.js\");\nconst _sharedState = /*#__PURE__*/ _interopRequireWildcard(__webpack_require__(/*! ./sharedState */ \"./node_modules/tailwindcss/lib/lib/sharedState.js\"));\nconst _toPath = __webpack_require__(/*! ../util/toPath */ \"./node_modules/tailwindcss/lib/util/toPath.js\");\nconst _log = /*#__PURE__*/ _interopRequireDefault(__webpack_require__(/*! ../util/log */ \"./node_modules/tailwindcss/lib/util/log.js\"));\nconst _negateValue = /*#__PURE__*/ _interopRequireDefault(__webpack_require__(/*! ../util/negateValue */ \"./node_modules/tailwindcss/lib/util/negateValue.js\"));\nconst _isValidArbitraryValue = /*#__PURE__*/ _interopRequireDefault(__webpack_require__(/*! ../util/isValidArbitraryValue */ \"./node_modules/tailwindcss/lib/util/isValidArbitraryValue.js\"));\nconst _generateRules = __webpack_require__(/*! ./generateRules */ \"./node_modules/tailwindcss/lib/lib/generateRules.js\");\nconst _cacheInvalidationJs = __webpack_require__(/*! ./cacheInvalidation.js */ \"./node_modules/tailwindcss/lib/lib/cacheInvalidation.js\");\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        default: obj\n    };\n}\nfunction _getRequireWildcardCache(nodeInterop) {\n    if (typeof WeakMap !== \"function\") return null;\n    var cacheBabelInterop = new WeakMap();\n    var cacheNodeInterop = new WeakMap();\n    return (_getRequireWildcardCache = function(nodeInterop) {\n        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;\n    })(nodeInterop);\n}\nfunction _interopRequireWildcard(obj, nodeInterop) {\n    if (!nodeInterop && obj && obj.__esModule) {\n        return obj;\n    }\n    if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n        return {\n            default: obj\n        };\n    }\n    var cache = _getRequireWildcardCache(nodeInterop);\n    if (cache && cache.has(obj)) {\n        return cache.get(obj);\n    }\n    var newObj = {};\n    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n    for(var key in obj){\n        if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) {\n            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n            if (desc && (desc.get || desc.set)) {\n                Object.defineProperty(newObj, key, desc);\n            } else {\n                newObj[key] = obj[key];\n            }\n        }\n    }\n    newObj.default = obj;\n    if (cache) {\n        cache.set(obj, newObj);\n    }\n    return newObj;\n}\nlet MATCH_VARIANT = Symbol();\nfunction prefix(context, selector) {\n    let prefix = context.tailwindConfig.prefix;\n    return typeof prefix === \"function\" ? prefix(selector) : prefix + selector;\n}\nfunction parseVariantFormatString(input) {\n    if (input.includes(\"{\")) {\n        if (!isBalanced(input)) throw new Error(`Your { and } are unbalanced.`);\n        return input.split(/{(.*)}/gim).flatMap((line)=>parseVariantFormatString(line)).filter(Boolean);\n    }\n    return [\n        input.trim()\n    ];\n}\nfunction isBalanced(input) {\n    let count = 0;\n    for (let char of input){\n        if (char === \"{\") {\n            count++;\n        } else if (char === \"}\") {\n            if (--count < 0) {\n                return false // unbalanced\n                ;\n            }\n        }\n    }\n    return count === 0;\n}\nfunction insertInto(list, value, { before =[]  } = {}) {\n    before = [].concat(before);\n    if (before.length <= 0) {\n        list.push(value);\n        return;\n    }\n    let idx = list.length - 1;\n    for (let other of before){\n        let iidx = list.indexOf(other);\n        if (iidx === -1) continue;\n        idx = Math.min(idx, iidx);\n    }\n    list.splice(idx, 0, value);\n}\nfunction parseStyles(styles) {\n    if (!Array.isArray(styles)) {\n        return parseStyles([\n            styles\n        ]);\n    }\n    return styles.flatMap((style)=>{\n        let isNode = !Array.isArray(style) && !(0, _isPlainObject.default)(style);\n        return isNode ? style : (0, _parseObjectStyles.default)(style);\n    });\n}\nfunction getClasses(selector, mutate) {\n    let parser = (0, _postcssSelectorParser.default)((selectors)=>{\n        let allClasses = [];\n        if (mutate) {\n            mutate(selectors);\n        }\n        selectors.walkClasses((classNode)=>{\n            allClasses.push(classNode.value);\n        });\n        return allClasses;\n    });\n    return parser.transformSync(selector);\n}\nfunction extractCandidates(node, state = {\n    containsNonOnDemandable: false\n}, depth = 0) {\n    let classes = [];\n    // Handle normal rules\n    if (node.type === \"rule\") {\n        // Ignore everything inside a :not(...). This allows you to write code like\n        // `div:not(.foo)`. If `.foo` is never found in your code, then we used to\n        // not generated it. But now we will ignore everything inside a `:not`, so\n        // that it still gets generated.\n        function ignoreNot(selectors) {\n            selectors.walkPseudos((pseudo)=>{\n                if (pseudo.value === \":not\") {\n                    pseudo.remove();\n                }\n            });\n        }\n        for (let selector of node.selectors){\n            let classCandidates = getClasses(selector, ignoreNot);\n            // At least one of the selectors contains non-\"on-demandable\" candidates.\n            if (classCandidates.length === 0) {\n                state.containsNonOnDemandable = true;\n            }\n            for (let classCandidate of classCandidates){\n                classes.push(classCandidate);\n            }\n        }\n    } else if (node.type === \"atrule\") {\n        node.walkRules((rule)=>{\n            for (let classCandidate of rule.selectors.flatMap((selector)=>getClasses(selector))){\n                classes.push(classCandidate);\n            }\n        });\n    }\n    if (depth === 0) {\n        return [\n            state.containsNonOnDemandable || classes.length === 0,\n            classes\n        ];\n    }\n    return classes;\n}\nfunction withIdentifiers(styles) {\n    return parseStyles(styles).flatMap((node)=>{\n        let nodeMap = new Map();\n        let [containsNonOnDemandableSelectors, candidates] = extractCandidates(node);\n        // If this isn't \"on-demandable\", assign it a universal candidate to always include it.\n        if (containsNonOnDemandableSelectors) {\n            candidates.unshift(_sharedState.NOT_ON_DEMAND);\n        }\n        // However, it could be that it also contains \"on-demandable\" candidates.\n        // E.g.: `span, .foo {}`, in that case it should still be possible to use\n        // `@apply foo` for example.\n        return candidates.map((c)=>{\n            if (!nodeMap.has(node)) {\n                nodeMap.set(node, node);\n            }\n            return [\n                c,\n                nodeMap.get(node)\n            ];\n        });\n    });\n}\nfunction isValidVariantFormatString(format) {\n    return format.startsWith(\"@\") || format.includes(\"&\");\n}\nfunction parseVariant(variant) {\n    variant = variant.replace(/\\n+/g, \"\").replace(/\\s{1,}/g, \" \").trim();\n    let fns = parseVariantFormatString(variant).map((str)=>{\n        if (!str.startsWith(\"@\")) {\n            return ({ format  })=>format(str);\n        }\n        let [, name, params] = /@(.*?)( .+|[({].*)/g.exec(str);\n        return ({ wrap  })=>wrap(_postcss.default.atRule({\n                name,\n                params: params.trim()\n            }));\n    }).reverse();\n    return (api)=>{\n        for (let fn of fns){\n            fn(api);\n        }\n    };\n}\nfunction buildPluginApi(tailwindConfig, context, { variantList , variantMap , offsets , classList  }) {\n    function getConfigValue(path, defaultValue) {\n        return path ? (0, _dlv.default)(tailwindConfig, path, defaultValue) : tailwindConfig;\n    }\n    function applyConfiguredPrefix(selector) {\n        return (0, _prefixSelector.default)(tailwindConfig.prefix, selector);\n    }\n    function prefixIdentifier(identifier, options) {\n        if (identifier === _sharedState.NOT_ON_DEMAND) {\n            return _sharedState.NOT_ON_DEMAND;\n        }\n        if (!options.respectPrefix) {\n            return identifier;\n        }\n        return context.tailwindConfig.prefix + identifier;\n    }\n    function resolveThemeValue(path, defaultValue, opts = {}) {\n        const [pathRoot, ...subPaths] = (0, _toPath.toPath)(path);\n        const value = getConfigValue([\n            \"theme\",\n            pathRoot,\n            ...subPaths\n        ], defaultValue);\n        return (0, _transformThemeValue.default)(pathRoot)(value, opts);\n    }\n    const theme = Object.assign((path, defaultValue = undefined)=>resolveThemeValue(path, defaultValue), {\n        withAlpha: (path, opacityValue)=>resolveThemeValue(path, undefined, {\n                opacityValue\n            })\n    });\n    let api = {\n        postcss: _postcss.default,\n        prefix: applyConfiguredPrefix,\n        e: _escapeClassName.default,\n        config: getConfigValue,\n        theme,\n        corePlugins: (path)=>{\n            if (Array.isArray(tailwindConfig.corePlugins)) {\n                return tailwindConfig.corePlugins.includes(path);\n            }\n            return getConfigValue([\n                \"corePlugins\",\n                path\n            ], true);\n        },\n        variants: ()=>{\n            // Preserved for backwards compatibility but not used in v3.0+\n            return [];\n        },\n        addBase (base) {\n            for (let [identifier, rule] of withIdentifiers(base)){\n                let prefixedIdentifier = prefixIdentifier(identifier, {});\n                let offset = offsets.base++;\n                if (!context.candidateRuleMap.has(prefixedIdentifier)) {\n                    context.candidateRuleMap.set(prefixedIdentifier, []);\n                }\n                context.candidateRuleMap.get(prefixedIdentifier).push([\n                    {\n                        sort: offset,\n                        layer: \"base\"\n                    },\n                    rule\n                ]);\n            }\n        },\n        /**\n     * @param {string} group\n     * @param {Record<string, string | string[]>} declarations\n     */ addDefaults (group, declarations) {\n            const groups = {\n                [`@defaults ${group}`]: declarations\n            };\n            for (let [identifier, rule] of withIdentifiers(groups)){\n                let prefixedIdentifier = prefixIdentifier(identifier, {});\n                if (!context.candidateRuleMap.has(prefixedIdentifier)) {\n                    context.candidateRuleMap.set(prefixedIdentifier, []);\n                }\n                context.candidateRuleMap.get(prefixedIdentifier).push([\n                    {\n                        sort: offsets.base++,\n                        layer: \"defaults\"\n                    },\n                    rule\n                ]);\n            }\n        },\n        addComponents (components, options) {\n            let defaultOptions = {\n                preserveSource: false,\n                respectPrefix: true,\n                respectImportant: false\n            };\n            options = Object.assign({}, defaultOptions, Array.isArray(options) ? {} : options);\n            for (let [identifier, rule] of withIdentifiers(components)){\n                let prefixedIdentifier = prefixIdentifier(identifier, options);\n                classList.add(prefixedIdentifier);\n                if (!context.candidateRuleMap.has(prefixedIdentifier)) {\n                    context.candidateRuleMap.set(prefixedIdentifier, []);\n                }\n                context.candidateRuleMap.get(prefixedIdentifier).push([\n                    {\n                        sort: offsets.components++,\n                        layer: \"components\",\n                        options\n                    },\n                    rule\n                ]);\n            }\n        },\n        addUtilities (utilities, options) {\n            let defaultOptions = {\n                preserveSource: false,\n                respectPrefix: true,\n                respectImportant: true\n            };\n            options = Object.assign({}, defaultOptions, Array.isArray(options) ? {} : options);\n            for (let [identifier, rule] of withIdentifiers(utilities)){\n                let prefixedIdentifier = prefixIdentifier(identifier, options);\n                classList.add(prefixedIdentifier);\n                if (!context.candidateRuleMap.has(prefixedIdentifier)) {\n                    context.candidateRuleMap.set(prefixedIdentifier, []);\n                }\n                context.candidateRuleMap.get(prefixedIdentifier).push([\n                    {\n                        sort: offsets.utilities++,\n                        layer: \"utilities\",\n                        options\n                    },\n                    rule\n                ]);\n            }\n        },\n        matchUtilities: function(utilities, options) {\n            let defaultOptions = {\n                respectPrefix: true,\n                respectImportant: true\n            };\n            options = {\n                ...defaultOptions,\n                ...options\n            };\n            let offset = offsets.utilities++;\n            for(let identifier in utilities){\n                let prefixedIdentifier = prefixIdentifier(identifier, options);\n                let rule = utilities[identifier];\n                classList.add([\n                    prefixedIdentifier,\n                    options\n                ]);\n                function wrapped(modifier, { isOnlyPlugin  }) {\n                    let { type =\"any\"  } = options;\n                    type = [].concat(type);\n                    let [value, coercedType] = (0, _pluginUtils.coerceValue)(type, modifier, options, tailwindConfig);\n                    if (value === undefined) {\n                        return [];\n                    }\n                    if (!type.includes(coercedType) && !isOnlyPlugin) {\n                        return [];\n                    }\n                    if (!(0, _isValidArbitraryValue.default)(value)) {\n                        return [];\n                    }\n                    let ruleSets = [].concat(rule(value)).filter(Boolean).map((declaration)=>({\n                            [(0, _nameClass.default)(identifier, modifier)]: declaration\n                        }));\n                    return ruleSets;\n                }\n                let withOffsets = [\n                    {\n                        sort: offset,\n                        layer: \"utilities\",\n                        options\n                    },\n                    wrapped\n                ];\n                if (!context.candidateRuleMap.has(prefixedIdentifier)) {\n                    context.candidateRuleMap.set(prefixedIdentifier, []);\n                }\n                context.candidateRuleMap.get(prefixedIdentifier).push(withOffsets);\n            }\n        },\n        matchComponents: function(components, options) {\n            let defaultOptions = {\n                respectPrefix: true,\n                respectImportant: false\n            };\n            options = {\n                ...defaultOptions,\n                ...options\n            };\n            let offset = offsets.components++;\n            for(let identifier in components){\n                let prefixedIdentifier = prefixIdentifier(identifier, options);\n                let rule = components[identifier];\n                classList.add([\n                    prefixedIdentifier,\n                    options\n                ]);\n                function wrapped(modifier, { isOnlyPlugin  }) {\n                    let { type =\"any\"  } = options;\n                    type = [].concat(type);\n                    let [value, coercedType] = (0, _pluginUtils.coerceValue)(type, modifier, options, tailwindConfig);\n                    if (value === undefined) {\n                        return [];\n                    }\n                    if (!type.includes(coercedType)) {\n                        if (isOnlyPlugin) {\n                            _log.default.warn([\n                                `Unnecessary typehint \\`${coercedType}\\` in \\`${identifier}-${modifier}\\`.`,\n                                `You can safely update it to \\`${identifier}-${modifier.replace(coercedType + \":\", \"\")}\\`.`, \n                            ]);\n                        } else {\n                            return [];\n                        }\n                    }\n                    if (!(0, _isValidArbitraryValue.default)(value)) {\n                        return [];\n                    }\n                    let ruleSets = [].concat(rule(value)).filter(Boolean).map((declaration)=>({\n                            [(0, _nameClass.default)(identifier, modifier)]: declaration\n                        }));\n                    return ruleSets;\n                }\n                let withOffsets = [\n                    {\n                        sort: offset,\n                        layer: \"components\",\n                        options\n                    },\n                    wrapped\n                ];\n                if (!context.candidateRuleMap.has(prefixedIdentifier)) {\n                    context.candidateRuleMap.set(prefixedIdentifier, []);\n                }\n                context.candidateRuleMap.get(prefixedIdentifier).push(withOffsets);\n            }\n        },\n        addVariant (variantName, variantFunctions, options = {}) {\n            variantFunctions = [].concat(variantFunctions).map((variantFunction)=>{\n                if (typeof variantFunction !== \"string\") {\n                    // Safelist public API functions\n                    return (api)=>{\n                        let { args , modifySelectors , container , separator , wrap , format  } = api;\n                        let result = variantFunction(Object.assign({\n                            modifySelectors,\n                            container,\n                            separator\n                        }, variantFunction[MATCH_VARIANT] && {\n                            args,\n                            wrap,\n                            format\n                        }));\n                        if (typeof result === \"string\" && !isValidVariantFormatString(result)) {\n                            throw new Error(`Your custom variant \\`${variantName}\\` has an invalid format string. Make sure it's an at-rule or contains a \\`&\\` placeholder.`);\n                        }\n                        if (Array.isArray(result)) {\n                            return result.filter((variant)=>typeof variant === \"string\").map((variant)=>parseVariant(variant));\n                        }\n                        // result may be undefined with legacy variants that use APIs like `modifySelectors`\n                        // result may also be a postcss node if someone was returning the result from `modifySelectors`\n                        return result && typeof result === \"string\" && parseVariant(result)(api);\n                    };\n                }\n                if (!isValidVariantFormatString(variantFunction)) {\n                    throw new Error(`Your custom variant \\`${variantName}\\` has an invalid format string. Make sure it's an at-rule or contains a \\`&\\` placeholder.`);\n                }\n                return parseVariant(variantFunction);\n            });\n            insertInto(variantList, variantName, options);\n            variantMap.set(variantName, variantFunctions);\n        }\n    };\n    if ((0, _featureFlagsJs.flagEnabled)(tailwindConfig, \"matchVariant\")) {\n        api.matchVariant = function(variants, options) {\n            for(let variant in variants){\n                var ref;\n                for (let [k, v] of Object.entries((ref = options === null || options === void 0 ? void 0 : options.values) !== null && ref !== void 0 ? ref : {})){\n                    api.addVariant(`${variant}-${k}`, variants[variant](v));\n                }\n                api.addVariant(variant, Object.assign(({ args  })=>variants[variant](args), {\n                    [MATCH_VARIANT]: true\n                }), options);\n            }\n        };\n    }\n    return api;\n}\nlet fileModifiedMapCache = new WeakMap();\nfunction getFileModifiedMap(context) {\n    if (!fileModifiedMapCache.has(context)) {\n        fileModifiedMapCache.set(context, new Map());\n    }\n    return fileModifiedMapCache.get(context);\n}\nfunction trackModified(files, fileModifiedMap) {\n    let changed = false;\n    for (let file of files){\n        var ref;\n        if (!file) continue;\n        let parsed = _url.default.parse(file);\n        let pathname = parsed.hash ? parsed.href.replace(parsed.hash, \"\") : parsed.href;\n        pathname = parsed.search ? pathname.replace(parsed.search, \"\") : pathname;\n        let newModified = (ref = _fs.default.statSync(decodeURIComponent(pathname), {\n            throwIfNoEntry: false\n        })) === null || ref === void 0 ? void 0 : ref.mtimeMs;\n        if (!newModified) {\n            continue;\n        }\n        if (!fileModifiedMap.has(file) || newModified > fileModifiedMap.get(file)) {\n            changed = true;\n        }\n        fileModifiedMap.set(file, newModified);\n    }\n    return changed;\n}\nfunction extractVariantAtRules(node) {\n    node.walkAtRules((atRule)=>{\n        if ([\n            \"responsive\",\n            \"variants\"\n        ].includes(atRule.name)) {\n            extractVariantAtRules(atRule);\n            atRule.before(atRule.nodes);\n            atRule.remove();\n        }\n    });\n}\nfunction collectLayerPlugins(root) {\n    let layerPlugins = [];\n    root.each((node)=>{\n        if (node.type === \"atrule\" && [\n            \"responsive\",\n            \"variants\"\n        ].includes(node.name)) {\n            node.name = \"layer\";\n            node.params = \"utilities\";\n        }\n    });\n    // Walk @layer rules and treat them like plugins\n    root.walkAtRules(\"layer\", (layerRule)=>{\n        extractVariantAtRules(layerRule);\n        if (layerRule.params === \"base\") {\n            for (let node of layerRule.nodes){\n                layerPlugins.push(function({ addBase  }) {\n                    addBase(node, {\n                        respectPrefix: false\n                    });\n                });\n            }\n            layerRule.remove();\n        } else if (layerRule.params === \"components\") {\n            for (let node1 of layerRule.nodes){\n                layerPlugins.push(function({ addComponents  }) {\n                    addComponents(node1, {\n                        respectPrefix: false,\n                        preserveSource: true\n                    });\n                });\n            }\n            layerRule.remove();\n        } else if (layerRule.params === \"utilities\") {\n            for (let node2 of layerRule.nodes){\n                layerPlugins.push(function({ addUtilities  }) {\n                    addUtilities(node2, {\n                        respectPrefix: false,\n                        preserveSource: true\n                    });\n                });\n            }\n            layerRule.remove();\n        }\n    });\n    return layerPlugins;\n}\nfunction resolvePlugins(context, root) {\n    let corePluginList = Object.entries({\n        ..._corePlugins.variantPlugins,\n        ..._corePlugins.corePlugins\n    }).map(([name, plugin])=>{\n        if (!context.tailwindConfig.corePlugins.includes(name)) {\n            return null;\n        }\n        return plugin;\n    }).filter(Boolean);\n    let userPlugins = context.tailwindConfig.plugins.map((plugin)=>{\n        if (plugin.__isOptionsFunction) {\n            plugin = plugin();\n        }\n        return typeof plugin === \"function\" ? plugin : plugin.handler;\n    });\n    let layerPlugins = collectLayerPlugins(root);\n    // TODO: This is a workaround for backwards compatibility, since custom variants\n    // were historically sorted before screen/stackable variants.\n    let beforeVariants = [\n        _corePlugins.variantPlugins[\"pseudoElementVariants\"],\n        _corePlugins.variantPlugins[\"pseudoClassVariants\"], \n    ];\n    let afterVariants = [\n        _corePlugins.variantPlugins[\"directionVariants\"],\n        _corePlugins.variantPlugins[\"reducedMotionVariants\"],\n        _corePlugins.variantPlugins[\"prefersContrastVariants\"],\n        _corePlugins.variantPlugins[\"darkVariants\"],\n        _corePlugins.variantPlugins[\"printVariant\"],\n        _corePlugins.variantPlugins[\"screenVariants\"],\n        _corePlugins.variantPlugins[\"orientationVariants\"], \n    ];\n    return [\n        ...corePluginList,\n        ...beforeVariants,\n        ...userPlugins,\n        ...afterVariants,\n        ...layerPlugins\n    ];\n}\nfunction registerPlugins(plugins, context) {\n    let variantList = [];\n    let variantMap = new Map();\n    let offsets = {\n        defaults: 0n,\n        base: 0n,\n        components: 0n,\n        utilities: 0n,\n        user: 0n\n    };\n    let classList = new Set();\n    let pluginApi = buildPluginApi(context.tailwindConfig, context, {\n        variantList,\n        variantMap,\n        offsets,\n        classList\n    });\n    for (let plugin of plugins){\n        if (Array.isArray(plugin)) {\n            for (let pluginItem of plugin){\n                pluginItem(pluginApi);\n            }\n        } else {\n            plugin === null || plugin === void 0 ? void 0 : plugin(pluginApi);\n        }\n    }\n    let highestOffset = ((args)=>args.reduce((m, e)=>e > m ? e : m))([\n        offsets.base,\n        offsets.defaults,\n        offsets.components,\n        offsets.utilities,\n        offsets.user, \n    ]);\n    let reservedBits = BigInt(highestOffset.toString(2).length);\n    // A number one less than the top range of the highest offset area\n    // so arbitrary properties are always sorted at the end.\n    context.arbitraryPropertiesSort = (1n << reservedBits << 0n) - 1n;\n    context.layerOrder = {\n        defaults: 1n << reservedBits << 0n,\n        base: 1n << reservedBits << 1n,\n        components: 1n << reservedBits << 2n,\n        utilities: 1n << reservedBits << 3n,\n        user: 1n << reservedBits << 4n\n    };\n    reservedBits += 5n;\n    let offset = 0;\n    context.variantOrder = new Map(variantList.map((variant, i)=>{\n        let variantFunctions = variantMap.get(variant).length;\n        let bits = 1n << BigInt(i + offset) << reservedBits;\n        offset += variantFunctions - 1;\n        return [\n            variant,\n            bits\n        ];\n    }).sort(([, a], [, z])=>(0, _bigSign.default)(a - z)));\n    context.minimumScreen = [\n        ...context.variantOrder.values()\n    ].shift();\n    // Build variantMap\n    for (let [variantName, variantFunctions] of variantMap.entries()){\n        let sort = context.variantOrder.get(variantName);\n        context.variantMap.set(variantName, variantFunctions.map((variantFunction, idx)=>[\n                sort << BigInt(idx),\n                variantFunction\n            ]));\n    }\n    var _safelist;\n    let safelist = ((_safelist = context.tailwindConfig.safelist) !== null && _safelist !== void 0 ? _safelist : []).filter(Boolean);\n    if (safelist.length > 0) {\n        let checks = [];\n        for (let value of safelist){\n            if (typeof value === \"string\") {\n                context.changedContent.push({\n                    content: value,\n                    extension: \"html\"\n                });\n                continue;\n            }\n            if (value instanceof RegExp) {\n                _log.default.warn(\"root-regex\", [\n                    \"Regular expressions in `safelist` work differently in Tailwind CSS v3.0.\",\n                    \"Update your `safelist` configuration to eliminate this warning.\",\n                    \"https://tailwindcss.com/docs/content-configuration#safelisting-classes\", \n                ]);\n                continue;\n            }\n            checks.push(value);\n        }\n        if (checks.length > 0) {\n            let patternMatchingCount = new Map();\n            let prefixLength = context.tailwindConfig.prefix.length;\n            for (let util of classList){\n                let utils = Array.isArray(util) ? (()=>{\n                    let [utilName, options] = util;\n                    var ref;\n                    let values = Object.keys((ref = options === null || options === void 0 ? void 0 : options.values) !== null && ref !== void 0 ? ref : {});\n                    let classes = values.map((value)=>(0, _nameClass.formatClass)(utilName, value));\n                    if (options === null || options === void 0 ? void 0 : options.supportsNegativeValues) {\n                        // This is the normal negated version\n                        // e.g. `-inset-1` or `-tw-inset-1`\n                        classes = [\n                            ...classes,\n                            ...classes.map((cls)=>\"-\" + cls)\n                        ];\n                        // This is the negated version *after* the prefix\n                        // e.g. `tw--inset-1`\n                        // The prefix is already attached to util name\n                        // So we add the negative after the prefix\n                        classes = [\n                            ...classes,\n                            ...classes.map((cls)=>cls.slice(0, prefixLength) + \"-\" + cls.slice(prefixLength)), \n                        ];\n                    }\n                    if ([].concat(options === null || options === void 0 ? void 0 : options.type).includes(\"color\")) {\n                        classes = [\n                            ...classes,\n                            ...classes.flatMap((cls)=>Object.keys(context.tailwindConfig.theme.opacity).map((opacity)=>`${cls}/${opacity}`)), \n                        ];\n                    }\n                    return classes;\n                })() : [\n                    util\n                ];\n                for (let util1 of utils){\n                    for (let { pattern , variants =[]  } of checks){\n                        // RegExp with the /g flag are stateful, so let's reset the last\n                        // index pointer to reset the state.\n                        pattern.lastIndex = 0;\n                        if (!patternMatchingCount.has(pattern)) {\n                            patternMatchingCount.set(pattern, 0);\n                        }\n                        if (!pattern.test(util1)) continue;\n                        patternMatchingCount.set(pattern, patternMatchingCount.get(pattern) + 1);\n                        context.changedContent.push({\n                            content: util1,\n                            extension: \"html\"\n                        });\n                        for (let variant of variants){\n                            context.changedContent.push({\n                                content: variant + context.tailwindConfig.separator + util1,\n                                extension: \"html\"\n                            });\n                        }\n                    }\n                }\n            }\n            for (let [regex, count] of patternMatchingCount.entries()){\n                if (count !== 0) continue;\n                _log.default.warn([\n                    `The safelist pattern \\`${regex}\\` doesn't match any Tailwind CSS classes.`,\n                    \"Fix this pattern or remove it from your `safelist` configuration.\",\n                    \"https://tailwindcss.com/docs/content-configuration#safelisting-classes\", \n                ]);\n            }\n        }\n    }\n    // A list of utilities that are used by certain Tailwind CSS utilities but\n    // that don't exist on their own. This will result in them \"not existing\" and\n    // sorting could be weird since you still require them in order to make the\n    // host utitlies work properly. (Thanks Biology)\n    let parasiteUtilities = new Set([\n        prefix(context, \"group\"),\n        prefix(context, \"peer\")\n    ]);\n    context.getClassOrder = function getClassOrder(classes) {\n        let sortedClassNames = new Map();\n        for (let [sort, rule] of (0, _generateRules.generateRules)(new Set(classes), context)){\n            if (sortedClassNames.has(rule.raws.tailwind.candidate)) continue;\n            sortedClassNames.set(rule.raws.tailwind.candidate, sort);\n        }\n        return classes.map((className)=>{\n            var ref;\n            let order = (ref = sortedClassNames.get(className)) !== null && ref !== void 0 ? ref : null;\n            if (order === null && parasiteUtilities.has(className)) {\n                // This will make sure that it is at the very beginning of the\n                // `components` layer which technically means 'before any\n                // components'.\n                order = context.layerOrder.components;\n            }\n            return [\n                className,\n                order\n            ];\n        });\n    };\n    // Generate a list of strings for autocompletion purposes, e.g.\n    // ['uppercase', 'lowercase', ...]\n    context.getClassList = function getClassList() {\n        let output = [];\n        for (let util of classList){\n            if (Array.isArray(util)) {\n                let [utilName, options] = util;\n                let negativeClasses = [];\n                var ref;\n                for (let [key, value] of Object.entries((ref = options === null || options === void 0 ? void 0 : options.values) !== null && ref !== void 0 ? ref : {})){\n                    output.push((0, _nameClass.formatClass)(utilName, key));\n                    if ((options === null || options === void 0 ? void 0 : options.supportsNegativeValues) && (0, _negateValue.default)(value)) {\n                        negativeClasses.push((0, _nameClass.formatClass)(utilName, `-${key}`));\n                    }\n                }\n                output.push(...negativeClasses);\n            } else {\n                output.push(util);\n            }\n        }\n        return output;\n    };\n}\nfunction createContext(tailwindConfig, changedContent = [], root = _postcss.default.root()) {\n    let context = {\n        disposables: [],\n        ruleCache: new Set(),\n        classCache: new Map(),\n        applyClassCache: new Map(),\n        notClassCache: new Set(),\n        postCssNodeCache: new Map(),\n        candidateRuleMap: new Map(),\n        tailwindConfig,\n        changedContent: changedContent,\n        variantMap: new Map(),\n        stylesheetCache: null\n    };\n    let resolvedPlugins = resolvePlugins(context, root);\n    registerPlugins(resolvedPlugins, context);\n    return context;\n}\nlet contextMap = _sharedState.contextMap;\nlet configContextMap = _sharedState.configContextMap;\nlet contextSourcesMap = _sharedState.contextSourcesMap;\nfunction getContext(root, result, tailwindConfig, userConfigPath, tailwindConfigHash, contextDependencies) {\n    let sourcePath = result.opts.from;\n    let isConfigFile = userConfigPath !== null;\n    _sharedState.env.DEBUG && console.log(\"Source path:\", sourcePath);\n    let existingContext;\n    if (isConfigFile && contextMap.has(sourcePath)) {\n        existingContext = contextMap.get(sourcePath);\n    } else if (configContextMap.has(tailwindConfigHash)) {\n        let context = configContextMap.get(tailwindConfigHash);\n        contextSourcesMap.get(context).add(sourcePath);\n        contextMap.set(sourcePath, context);\n        existingContext = context;\n    }\n    let cssDidChange = (0, _cacheInvalidationJs.hasContentChanged)(sourcePath, root);\n    // If there's already a context in the cache and we don't need to\n    // reset the context, return the cached context.\n    if (existingContext) {\n        let contextDependenciesChanged = trackModified([\n            ...contextDependencies\n        ], getFileModifiedMap(existingContext));\n        if (!contextDependenciesChanged && !cssDidChange) {\n            return [\n                existingContext,\n                false\n            ];\n        }\n    }\n    // If this source is in the context map, get the old context.\n    // Remove this source from the context sources for the old context,\n    // and clean up that context if no one else is using it. This can be\n    // called by many processes in rapid succession, so we check for presence\n    // first because the first process to run this code will wipe it out first.\n    if (contextMap.has(sourcePath)) {\n        let oldContext = contextMap.get(sourcePath);\n        if (contextSourcesMap.has(oldContext)) {\n            contextSourcesMap.get(oldContext).delete(sourcePath);\n            if (contextSourcesMap.get(oldContext).size === 0) {\n                contextSourcesMap.delete(oldContext);\n                for (let [tailwindConfigHash1, context1] of configContextMap){\n                    if (context1 === oldContext) {\n                        configContextMap.delete(tailwindConfigHash1);\n                    }\n                }\n                for (let disposable of oldContext.disposables.splice(0)){\n                    disposable(oldContext);\n                }\n            }\n        }\n    }\n    _sharedState.env.DEBUG && console.log(\"Setting up new context...\");\n    let context2 = createContext(tailwindConfig, [], root);\n    trackModified([\n        ...contextDependencies\n    ], getFileModifiedMap(context2));\n    // ---\n    // Update all context tracking state\n    configContextMap.set(tailwindConfigHash, context2);\n    contextMap.set(sourcePath, context2);\n    if (!contextSourcesMap.has(context2)) {\n        contextSourcesMap.set(context2, new Set());\n    }\n    contextSourcesMap.get(context2).add(sourcePath);\n    return [\n        context2,\n        true\n    ];\n}\n\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/tailwindcss/lib/lib/setupContextUtils.js?");

/***/ }),

/***/ "./node_modules/tailwindcss/lib/lib/setupTrackingContext.js":
/*!******************************************************************!*\
  !*** ./node_modules/tailwindcss/lib/lib/setupTrackingContext.js ***!
  \******************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"default\", ({\n    enumerable: true,\n    get: ()=>setupTrackingContext\n}));\nconst _fs = /*#__PURE__*/ _interopRequireDefault(__webpack_require__(Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'fs'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }())));\nconst _path = /*#__PURE__*/ _interopRequireDefault(__webpack_require__(Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'path'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }())));\nconst _fastGlob = /*#__PURE__*/ _interopRequireDefault(__webpack_require__(/*! fast-glob */ \"./node_modules/fast-glob/out/index.js\"));\nconst _quickLru = /*#__PURE__*/ _interopRequireDefault(__webpack_require__(/*! quick-lru */ \"./node_modules/quick-lru/index.js\"));\nconst _normalizePath = /*#__PURE__*/ _interopRequireDefault(__webpack_require__(/*! normalize-path */ \"./node_modules/normalize-path/index.js\"));\nconst _hashConfig = /*#__PURE__*/ _interopRequireDefault(__webpack_require__(/*! ../util/hashConfig */ \"./node_modules/tailwindcss/lib/util/hashConfig.js\"));\nconst _getModuleDependencies = /*#__PURE__*/ _interopRequireDefault(__webpack_require__(/*! ../lib/getModuleDependencies */ \"./node_modules/tailwindcss/lib/lib/getModuleDependencies.js\"));\nconst _resolveConfig = /*#__PURE__*/ _interopRequireDefault(__webpack_require__(/*! ../public/resolve-config */ \"./node_modules/tailwindcss/lib/public/resolve-config.js\"));\nconst _resolveConfigPath = /*#__PURE__*/ _interopRequireDefault(__webpack_require__(/*! ../util/resolveConfigPath */ \"./node_modules/tailwindcss/lib/util/resolveConfigPath.js\"));\nconst _sharedState = __webpack_require__(/*! ./sharedState */ \"./node_modules/tailwindcss/lib/lib/sharedState.js\");\nconst _setupContextUtils = __webpack_require__(/*! ./setupContextUtils */ \"./node_modules/tailwindcss/lib/lib/setupContextUtils.js\");\nconst _parseDependency = /*#__PURE__*/ _interopRequireDefault(__webpack_require__(/*! ../util/parseDependency */ \"./node_modules/tailwindcss/lib/util/parseDependency.js\"));\nconst _validateConfigJs = __webpack_require__(/*! ../util/validateConfig.js */ \"./node_modules/tailwindcss/lib/util/validateConfig.js\");\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        default: obj\n    };\n}\nlet configPathCache = new _quickLru.default({\n    maxSize: 100\n});\nlet candidateFilesCache = new WeakMap();\nfunction getCandidateFiles(context, tailwindConfig) {\n    if (candidateFilesCache.has(context)) {\n        return candidateFilesCache.get(context);\n    }\n    let candidateFiles = tailwindConfig.content.files.filter((item)=>typeof item === \"string\").map((contentPath)=>(0, _normalizePath.default)(contentPath));\n    return candidateFilesCache.set(context, candidateFiles).get(context);\n}\n// Get the config object based on a path\nfunction getTailwindConfig(configOrPath) {\n    let userConfigPath = (0, _resolveConfigPath.default)(configOrPath);\n    if (userConfigPath !== null) {\n        let [prevConfig, prevConfigHash, prevDeps, prevModified] = configPathCache.get(userConfigPath) || [];\n        let newDeps = (0, _getModuleDependencies.default)(userConfigPath).map((dep)=>dep.file);\n        let modified = false;\n        let newModified = new Map();\n        for (let file of newDeps){\n            let time = _fs.default.statSync(file).mtimeMs;\n            newModified.set(file, time);\n            if (!prevModified || !prevModified.has(file) || time > prevModified.get(file)) {\n                modified = true;\n            }\n        }\n        // It hasn't changed (based on timestamps)\n        if (!modified) {\n            return [\n                prevConfig,\n                userConfigPath,\n                prevConfigHash,\n                prevDeps\n            ];\n        }\n        // It has changed (based on timestamps), or first run\n        for (let file1 of newDeps){\n            delete __webpack_require__.c[file1];\n        }\n        let newConfig = (0, _resolveConfig.default)(__webpack_require__(\"./node_modules/tailwindcss/lib/lib sync recursive\")(userConfigPath));\n        newConfig = (0, _validateConfigJs.validateConfig)(newConfig);\n        let newHash = (0, _hashConfig.default)(newConfig);\n        configPathCache.set(userConfigPath, [\n            newConfig,\n            newHash,\n            newDeps,\n            newModified\n        ]);\n        return [\n            newConfig,\n            userConfigPath,\n            newHash,\n            newDeps\n        ];\n    }\n    // It's a plain object, not a path\n    let newConfig1 = (0, _resolveConfig.default)(configOrPath.config === undefined ? configOrPath : configOrPath.config);\n    newConfig1 = (0, _validateConfigJs.validateConfig)(newConfig1);\n    return [\n        newConfig1,\n        null,\n        (0, _hashConfig.default)(newConfig1),\n        []\n    ];\n}\nfunction resolvedChangedContent(context, candidateFiles, fileModifiedMap) {\n    let changedContent = context.tailwindConfig.content.files.filter((item)=>typeof item.raw === \"string\").map(({ raw , extension =\"html\"  })=>({\n            content: raw,\n            extension\n        }));\n    for (let changedFile of resolveChangedFiles(candidateFiles, fileModifiedMap)){\n        let content = _fs.default.readFileSync(changedFile, \"utf8\");\n        let extension = _path.default.extname(changedFile).slice(1);\n        changedContent.push({\n            content,\n            extension\n        });\n    }\n    return changedContent;\n}\nfunction resolveChangedFiles(candidateFiles, fileModifiedMap) {\n    let changedFiles = new Set();\n    _sharedState.env.DEBUG && console.time(\"Finding changed files\");\n    let files = _fastGlob.default.sync(candidateFiles);\n    for (let file of files){\n        let prevModified = fileModifiedMap.has(file) ? fileModifiedMap.get(file) : -Infinity;\n        let modified = _fs.default.statSync(file).mtimeMs;\n        if (modified > prevModified) {\n            changedFiles.add(file);\n            fileModifiedMap.set(file, modified);\n        }\n    }\n    _sharedState.env.DEBUG && console.timeEnd(\"Finding changed files\");\n    return changedFiles;\n}\nfunction setupTrackingContext(configOrPath) {\n    return ({ tailwindDirectives , registerDependency  })=>{\n        return (root, result)=>{\n            let [tailwindConfig, userConfigPath, tailwindConfigHash, configDependencies] = getTailwindConfig(configOrPath);\n            let contextDependencies = new Set(configDependencies);\n            // If there are no @tailwind or @apply rules, we don't consider this CSS\n            // file or its dependencies to be dependencies of the context. Can reuse\n            // the context even if they change. We may want to think about `@layer`\n            // being part of this trigger too, but it's tough because it's impossible\n            // for a layer in one file to end up in the actual @tailwind rule in\n            // another file since independent sources are effectively isolated.\n            if (tailwindDirectives.size > 0) {\n                // Add current css file as a context dependencies.\n                contextDependencies.add(result.opts.from);\n                // Add all css @import dependencies as context dependencies.\n                for (let message of result.messages){\n                    if (message.type === \"dependency\") {\n                        contextDependencies.add(message.file);\n                    }\n                }\n            }\n            let [context] = (0, _setupContextUtils.getContext)(root, result, tailwindConfig, userConfigPath, tailwindConfigHash, contextDependencies);\n            let candidateFiles = getCandidateFiles(context, tailwindConfig);\n            // If there are no @tailwind or @apply rules, we don't consider this CSS file or it's\n            // dependencies to be dependencies of the context. Can reuse the context even if they change.\n            // We may want to think about `@layer` being part of this trigger too, but it's tough\n            // because it's impossible for a layer in one file to end up in the actual @tailwind rule\n            // in another file since independent sources are effectively isolated.\n            if (tailwindDirectives.size > 0) {\n                let fileModifiedMap = (0, _setupContextUtils.getFileModifiedMap)(context);\n                // Add template paths as postcss dependencies.\n                for (let fileOrGlob of candidateFiles){\n                    let dependency = (0, _parseDependency.default)(fileOrGlob);\n                    if (dependency) {\n                        registerDependency(dependency);\n                    }\n                }\n                for (let changedContent of resolvedChangedContent(context, candidateFiles, fileModifiedMap)){\n                    context.changedContent.push(changedContent);\n                }\n            }\n            for (let file of configDependencies){\n                registerDependency({\n                    type: \"dependency\",\n                    file\n                });\n            }\n            return context;\n        };\n    };\n}\n\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/tailwindcss/lib/lib/setupTrackingContext.js?");

/***/ }),

/***/ "./node_modules/tailwindcss/lib/lib/sharedState.js":
/*!*********************************************************!*\
  !*** ./node_modules/tailwindcss/lib/lib/sharedState.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    env: ()=>env,\n    contextMap: ()=>contextMap,\n    configContextMap: ()=>configContextMap,\n    contextSourcesMap: ()=>contextSourcesMap,\n    sourceHashMap: ()=>sourceHashMap,\n    NOT_ON_DEMAND: ()=>NOT_ON_DEMAND,\n    resolveDebug: ()=>resolveDebug\n});\nconst env = {\n    NODE_ENV: \"development\",\n    DEBUG: resolveDebug(process.env.DEBUG)\n};\nconst contextMap = new Map();\nconst configContextMap = new Map();\nconst contextSourcesMap = new Map();\nconst sourceHashMap = new Map();\nconst NOT_ON_DEMAND = new String(\"*\");\nfunction resolveDebug(debug) {\n    if (debug === undefined) {\n        return false;\n    }\n    // Environment variables are strings, so convert to boolean\n    if (debug === \"true\" || debug === \"1\") {\n        return true;\n    }\n    if (debug === \"false\" || debug === \"0\") {\n        return false;\n    }\n    // Keep the debug convention into account:\n    // DEBUG=* -> This enables all debug modes\n    // DEBUG=projectA,projectB,projectC -> This enables debug for projectA, projectB and projectC\n    // DEBUG=projectA:* -> This enables all debug modes for projectA (if you have sub-types)\n    // DEBUG=projectA,-projectB -> This enables debug for projectA and explicitly disables it for projectB\n    if (debug === \"*\") {\n        return true;\n    }\n    let debuggers = debug.split(\",\").map((d)=>d.split(\":\")[0]);\n    // Ignoring tailwindcss\n    if (debuggers.includes(\"-tailwindcss\")) {\n        return false;\n    }\n    // Including tailwindcss\n    if (debuggers.includes(\"tailwindcss\")) {\n        return true;\n    }\n    return false;\n}\n\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/tailwindcss/lib/lib/sharedState.js?");

/***/ }),

/***/ "./node_modules/tailwindcss/lib/lib/substituteScreenAtRules.js":
/*!*********************************************************************!*\
  !*** ./node_modules/tailwindcss/lib/lib/substituteScreenAtRules.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"default\", ({\n    enumerable: true,\n    get: ()=>_default\n}));\nconst _normalizeScreens = __webpack_require__(/*! ../util/normalizeScreens */ \"./node_modules/tailwindcss/lib/util/normalizeScreens.js\");\nconst _buildMediaQuery = /*#__PURE__*/ _interopRequireDefault(__webpack_require__(/*! ../util/buildMediaQuery */ \"./node_modules/tailwindcss/lib/util/buildMediaQuery.js\"));\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        default: obj\n    };\n}\nfunction _default({ tailwindConfig: { theme  }  }) {\n    return function(css) {\n        css.walkAtRules(\"screen\", (atRule)=>{\n            let screen = atRule.params;\n            let screens = (0, _normalizeScreens.normalizeScreens)(theme.screens);\n            let screenDefinition = screens.find(({ name  })=>name === screen);\n            if (!screenDefinition) {\n                throw atRule.error(`No \\`${screen}\\` screen found.`);\n            }\n            atRule.name = \"media\";\n            atRule.params = (0, _buildMediaQuery.default)(screenDefinition);\n        });\n    };\n}\n\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/tailwindcss/lib/lib/substituteScreenAtRules.js?");

/***/ }),

/***/ "./node_modules/tailwindcss/lib/lib sync recursive":
/*!************************************************!*\
  !*** ./node_modules/tailwindcss/lib/lib/ sync ***!
  \************************************************/
/***/ ((module) => {

eval("function webpackEmptyContext(req) {\n\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\te.code = 'MODULE_NOT_FOUND';\n\tthrow e;\n}\nwebpackEmptyContext.keys = () => ([]);\nwebpackEmptyContext.resolve = webpackEmptyContext;\nwebpackEmptyContext.id = \"./node_modules/tailwindcss/lib/lib sync recursive\";\nmodule.exports = webpackEmptyContext;\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/tailwindcss/lib/lib/_sync?");

/***/ }),

/***/ "./node_modules/tailwindcss/lib/processTailwindFeatures.js":
/*!*****************************************************************!*\
  !*** ./node_modules/tailwindcss/lib/processTailwindFeatures.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"default\", ({\n    enumerable: true,\n    get: ()=>processTailwindFeatures\n}));\nconst _normalizeTailwindDirectives = /*#__PURE__*/ _interopRequireDefault(__webpack_require__(/*! ./lib/normalizeTailwindDirectives */ \"./node_modules/tailwindcss/lib/lib/normalizeTailwindDirectives.js\"));\nconst _expandTailwindAtRules = /*#__PURE__*/ _interopRequireDefault(__webpack_require__(/*! ./lib/expandTailwindAtRules */ \"./node_modules/tailwindcss/lib/lib/expandTailwindAtRules.js\"));\nconst _expandApplyAtRules = /*#__PURE__*/ _interopRequireDefault(__webpack_require__(/*! ./lib/expandApplyAtRules */ \"./node_modules/tailwindcss/lib/lib/expandApplyAtRules.js\"));\nconst _evaluateTailwindFunctions = /*#__PURE__*/ _interopRequireDefault(__webpack_require__(/*! ./lib/evaluateTailwindFunctions */ \"./node_modules/tailwindcss/lib/lib/evaluateTailwindFunctions.js\"));\nconst _substituteScreenAtRules = /*#__PURE__*/ _interopRequireDefault(__webpack_require__(/*! ./lib/substituteScreenAtRules */ \"./node_modules/tailwindcss/lib/lib/substituteScreenAtRules.js\"));\nconst _resolveDefaultsAtRules = /*#__PURE__*/ _interopRequireDefault(__webpack_require__(/*! ./lib/resolveDefaultsAtRules */ \"./node_modules/tailwindcss/lib/lib/resolveDefaultsAtRules.js\"));\nconst _collapseAdjacentRules = /*#__PURE__*/ _interopRequireDefault(__webpack_require__(/*! ./lib/collapseAdjacentRules */ \"./node_modules/tailwindcss/lib/lib/collapseAdjacentRules.js\"));\nconst _collapseDuplicateDeclarations = /*#__PURE__*/ _interopRequireDefault(__webpack_require__(/*! ./lib/collapseDuplicateDeclarations */ \"./node_modules/tailwindcss/lib/lib/collapseDuplicateDeclarations.js\"));\nconst _partitionApplyAtRules = /*#__PURE__*/ _interopRequireDefault(__webpack_require__(/*! ./lib/partitionApplyAtRules */ \"./node_modules/tailwindcss/lib/lib/partitionApplyAtRules.js\"));\nconst _detectNesting = /*#__PURE__*/ _interopRequireDefault(__webpack_require__(/*! ./lib/detectNesting */ \"./node_modules/tailwindcss/lib/lib/detectNesting.js\"));\nconst _setupContextUtils = __webpack_require__(/*! ./lib/setupContextUtils */ \"./node_modules/tailwindcss/lib/lib/setupContextUtils.js\");\nconst _featureFlags = __webpack_require__(/*! ./featureFlags */ \"./node_modules/tailwindcss/lib/featureFlags.js\");\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        default: obj\n    };\n}\nfunction processTailwindFeatures(setupContext) {\n    return function(root, result) {\n        let { tailwindDirectives , applyDirectives  } = (0, _normalizeTailwindDirectives.default)(root);\n        (0, _detectNesting.default)()(root, result);\n        // Partition apply rules that are found in the css\n        // itself.\n        (0, _partitionApplyAtRules.default)()(root, result);\n        let context = setupContext({\n            tailwindDirectives,\n            applyDirectives,\n            registerDependency (dependency) {\n                result.messages.push({\n                    plugin: \"tailwindcss\",\n                    parent: result.opts.from,\n                    ...dependency\n                });\n            },\n            createContext (tailwindConfig, changedContent) {\n                return (0, _setupContextUtils.createContext)(tailwindConfig, changedContent, root);\n            }\n        })(root, result);\n        if (context.tailwindConfig.separator === \"-\") {\n            throw new Error(\"The '-' character cannot be used as a custom separator in JIT mode due to parsing ambiguity. Please use another character like '_' instead.\");\n        }\n        (0, _featureFlags.issueFlagNotices)(context.tailwindConfig);\n        (0, _expandTailwindAtRules.default)(context)(root, result);\n        // Partition apply rules that are generated by\n        // addComponents, addUtilities and so on.\n        (0, _partitionApplyAtRules.default)()(root, result);\n        (0, _expandApplyAtRules.default)(context)(root, result);\n        (0, _evaluateTailwindFunctions.default)(context)(root, result);\n        (0, _substituteScreenAtRules.default)(context)(root, result);\n        (0, _resolveDefaultsAtRules.default)(context)(root, result);\n        (0, _collapseAdjacentRules.default)(context)(root, result);\n        (0, _collapseDuplicateDeclarations.default)(context)(root, result);\n    };\n}\n\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/tailwindcss/lib/processTailwindFeatures.js?");

/***/ }),

/***/ "./node_modules/tailwindcss/lib/public/colors.js":
/*!*******************************************************!*\
  !*** ./node_modules/tailwindcss/lib/public/colors.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"default\", ({\n    enumerable: true,\n    get: ()=>_default\n}));\nconst _log = /*#__PURE__*/ _interopRequireDefault(__webpack_require__(/*! ../util/log */ \"./node_modules/tailwindcss/lib/util/log.js\"));\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        default: obj\n    };\n}\nfunction warn({ version , from , to  }) {\n    _log.default.warn(`${from}-color-renamed`, [\n        `As of Tailwind CSS ${version}, \\`${from}\\` has been renamed to \\`${to}\\`.`,\n        \"Update your configuration file to silence this warning.\", \n    ]);\n}\nconst _default = {\n    inherit: \"inherit\",\n    current: \"currentColor\",\n    transparent: \"transparent\",\n    black: \"#000\",\n    white: \"#fff\",\n    slate: {\n        50: \"#f8fafc\",\n        100: \"#f1f5f9\",\n        200: \"#e2e8f0\",\n        300: \"#cbd5e1\",\n        400: \"#94a3b8\",\n        500: \"#64748b\",\n        600: \"#475569\",\n        700: \"#334155\",\n        800: \"#1e293b\",\n        900: \"#0f172a\"\n    },\n    gray: {\n        50: \"#f9fafb\",\n        100: \"#f3f4f6\",\n        200: \"#e5e7eb\",\n        300: \"#d1d5db\",\n        400: \"#9ca3af\",\n        500: \"#6b7280\",\n        600: \"#4b5563\",\n        700: \"#374151\",\n        800: \"#1f2937\",\n        900: \"#111827\"\n    },\n    zinc: {\n        50: \"#fafafa\",\n        100: \"#f4f4f5\",\n        200: \"#e4e4e7\",\n        300: \"#d4d4d8\",\n        400: \"#a1a1aa\",\n        500: \"#71717a\",\n        600: \"#52525b\",\n        700: \"#3f3f46\",\n        800: \"#27272a\",\n        900: \"#18181b\"\n    },\n    neutral: {\n        50: \"#fafafa\",\n        100: \"#f5f5f5\",\n        200: \"#e5e5e5\",\n        300: \"#d4d4d4\",\n        400: \"#a3a3a3\",\n        500: \"#737373\",\n        600: \"#525252\",\n        700: \"#404040\",\n        800: \"#262626\",\n        900: \"#171717\"\n    },\n    stone: {\n        50: \"#fafaf9\",\n        100: \"#f5f5f4\",\n        200: \"#e7e5e4\",\n        300: \"#d6d3d1\",\n        400: \"#a8a29e\",\n        500: \"#78716c\",\n        600: \"#57534e\",\n        700: \"#44403c\",\n        800: \"#292524\",\n        900: \"#1c1917\"\n    },\n    red: {\n        50: \"#fef2f2\",\n        100: \"#fee2e2\",\n        200: \"#fecaca\",\n        300: \"#fca5a5\",\n        400: \"#f87171\",\n        500: \"#ef4444\",\n        600: \"#dc2626\",\n        700: \"#b91c1c\",\n        800: \"#991b1b\",\n        900: \"#7f1d1d\"\n    },\n    orange: {\n        50: \"#fff7ed\",\n        100: \"#ffedd5\",\n        200: \"#fed7aa\",\n        300: \"#fdba74\",\n        400: \"#fb923c\",\n        500: \"#f97316\",\n        600: \"#ea580c\",\n        700: \"#c2410c\",\n        800: \"#9a3412\",\n        900: \"#7c2d12\"\n    },\n    amber: {\n        50: \"#fffbeb\",\n        100: \"#fef3c7\",\n        200: \"#fde68a\",\n        300: \"#fcd34d\",\n        400: \"#fbbf24\",\n        500: \"#f59e0b\",\n        600: \"#d97706\",\n        700: \"#b45309\",\n        800: \"#92400e\",\n        900: \"#78350f\"\n    },\n    yellow: {\n        50: \"#fefce8\",\n        100: \"#fef9c3\",\n        200: \"#fef08a\",\n        300: \"#fde047\",\n        400: \"#facc15\",\n        500: \"#eab308\",\n        600: \"#ca8a04\",\n        700: \"#a16207\",\n        800: \"#854d0e\",\n        900: \"#713f12\"\n    },\n    lime: {\n        50: \"#f7fee7\",\n        100: \"#ecfccb\",\n        200: \"#d9f99d\",\n        300: \"#bef264\",\n        400: \"#a3e635\",\n        500: \"#84cc16\",\n        600: \"#65a30d\",\n        700: \"#4d7c0f\",\n        800: \"#3f6212\",\n        900: \"#365314\"\n    },\n    green: {\n        50: \"#f0fdf4\",\n        100: \"#dcfce7\",\n        200: \"#bbf7d0\",\n        300: \"#86efac\",\n        400: \"#4ade80\",\n        500: \"#22c55e\",\n        600: \"#16a34a\",\n        700: \"#15803d\",\n        800: \"#166534\",\n        900: \"#14532d\"\n    },\n    emerald: {\n        50: \"#ecfdf5\",\n        100: \"#d1fae5\",\n        200: \"#a7f3d0\",\n        300: \"#6ee7b7\",\n        400: \"#34d399\",\n        500: \"#10b981\",\n        600: \"#059669\",\n        700: \"#047857\",\n        800: \"#065f46\",\n        900: \"#064e3b\"\n    },\n    teal: {\n        50: \"#f0fdfa\",\n        100: \"#ccfbf1\",\n        200: \"#99f6e4\",\n        300: \"#5eead4\",\n        400: \"#2dd4bf\",\n        500: \"#14b8a6\",\n        600: \"#0d9488\",\n        700: \"#0f766e\",\n        800: \"#115e59\",\n        900: \"#134e4a\"\n    },\n    cyan: {\n        50: \"#ecfeff\",\n        100: \"#cffafe\",\n        200: \"#a5f3fc\",\n        300: \"#67e8f9\",\n        400: \"#22d3ee\",\n        500: \"#06b6d4\",\n        600: \"#0891b2\",\n        700: \"#0e7490\",\n        800: \"#155e75\",\n        900: \"#164e63\"\n    },\n    sky: {\n        50: \"#f0f9ff\",\n        100: \"#e0f2fe\",\n        200: \"#bae6fd\",\n        300: \"#7dd3fc\",\n        400: \"#38bdf8\",\n        500: \"#0ea5e9\",\n        600: \"#0284c7\",\n        700: \"#0369a1\",\n        800: \"#075985\",\n        900: \"#0c4a6e\"\n    },\n    blue: {\n        50: \"#eff6ff\",\n        100: \"#dbeafe\",\n        200: \"#bfdbfe\",\n        300: \"#93c5fd\",\n        400: \"#60a5fa\",\n        500: \"#3b82f6\",\n        600: \"#2563eb\",\n        700: \"#1d4ed8\",\n        800: \"#1e40af\",\n        900: \"#1e3a8a\"\n    },\n    indigo: {\n        50: \"#eef2ff\",\n        100: \"#e0e7ff\",\n        200: \"#c7d2fe\",\n        300: \"#a5b4fc\",\n        400: \"#818cf8\",\n        500: \"#6366f1\",\n        600: \"#4f46e5\",\n        700: \"#4338ca\",\n        800: \"#3730a3\",\n        900: \"#312e81\"\n    },\n    violet: {\n        50: \"#f5f3ff\",\n        100: \"#ede9fe\",\n        200: \"#ddd6fe\",\n        300: \"#c4b5fd\",\n        400: \"#a78bfa\",\n        500: \"#8b5cf6\",\n        600: \"#7c3aed\",\n        700: \"#6d28d9\",\n        800: \"#5b21b6\",\n        900: \"#4c1d95\"\n    },\n    purple: {\n        50: \"#faf5ff\",\n        100: \"#f3e8ff\",\n        200: \"#e9d5ff\",\n        300: \"#d8b4fe\",\n        400: \"#c084fc\",\n        500: \"#a855f7\",\n        600: \"#9333ea\",\n        700: \"#7e22ce\",\n        800: \"#6b21a8\",\n        900: \"#581c87\"\n    },\n    fuchsia: {\n        50: \"#fdf4ff\",\n        100: \"#fae8ff\",\n        200: \"#f5d0fe\",\n        300: \"#f0abfc\",\n        400: \"#e879f9\",\n        500: \"#d946ef\",\n        600: \"#c026d3\",\n        700: \"#a21caf\",\n        800: \"#86198f\",\n        900: \"#701a75\"\n    },\n    pink: {\n        50: \"#fdf2f8\",\n        100: \"#fce7f3\",\n        200: \"#fbcfe8\",\n        300: \"#f9a8d4\",\n        400: \"#f472b6\",\n        500: \"#ec4899\",\n        600: \"#db2777\",\n        700: \"#be185d\",\n        800: \"#9d174d\",\n        900: \"#831843\"\n    },\n    rose: {\n        50: \"#fff1f2\",\n        100: \"#ffe4e6\",\n        200: \"#fecdd3\",\n        300: \"#fda4af\",\n        400: \"#fb7185\",\n        500: \"#f43f5e\",\n        600: \"#e11d48\",\n        700: \"#be123c\",\n        800: \"#9f1239\",\n        900: \"#881337\"\n    },\n    get lightBlue () {\n        warn({\n            version: \"v2.2\",\n            from: \"lightBlue\",\n            to: \"sky\"\n        });\n        return this.sky;\n    },\n    get warmGray () {\n        warn({\n            version: \"v3.0\",\n            from: \"warmGray\",\n            to: \"stone\"\n        });\n        return this.stone;\n    },\n    get trueGray () {\n        warn({\n            version: \"v3.0\",\n            from: \"trueGray\",\n            to: \"neutral\"\n        });\n        return this.neutral;\n    },\n    get coolGray () {\n        warn({\n            version: \"v3.0\",\n            from: \"coolGray\",\n            to: \"gray\"\n        });\n        return this.gray;\n    },\n    get blueGray () {\n        warn({\n            version: \"v3.0\",\n            from: \"blueGray\",\n            to: \"slate\"\n        });\n        return this.slate;\n    }\n};\n\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/tailwindcss/lib/public/colors.js?");

/***/ }),

/***/ "./node_modules/tailwindcss/lib/public/resolve-config.js":
/*!***************************************************************!*\
  !*** ./node_modules/tailwindcss/lib/public/resolve-config.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"default\", ({\n    enumerable: true,\n    get: ()=>resolveConfig\n}));\nconst _resolveConfig = /*#__PURE__*/ _interopRequireDefault(__webpack_require__(/*! ../util/resolveConfig */ \"./node_modules/tailwindcss/lib/util/resolveConfig.js\"));\nconst _getAllConfigs = /*#__PURE__*/ _interopRequireDefault(__webpack_require__(/*! ../util/getAllConfigs */ \"./node_modules/tailwindcss/lib/util/getAllConfigs.js\"));\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        default: obj\n    };\n}\nfunction resolveConfig(...configs) {\n    let [, ...defaultConfigs] = (0, _getAllConfigs.default)(configs[0]);\n    return (0, _resolveConfig.default)([\n        ...configs,\n        ...defaultConfigs\n    ]);\n}\n\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/tailwindcss/lib/public/resolve-config.js?");

/***/ }),

/***/ "./node_modules/tailwindcss/lib/util/bigSign.js":
/*!******************************************************!*\
  !*** ./node_modules/tailwindcss/lib/util/bigSign.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"default\", ({\n    enumerable: true,\n    get: ()=>bigSign\n}));\nfunction bigSign(bigIntValue) {\n    return (bigIntValue > 0n) - (bigIntValue < 0n);\n}\n\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/tailwindcss/lib/util/bigSign.js?");

/***/ }),

/***/ "./node_modules/tailwindcss/lib/util/buildMediaQuery.js":
/*!**************************************************************!*\
  !*** ./node_modules/tailwindcss/lib/util/buildMediaQuery.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"default\", ({\n    enumerable: true,\n    get: ()=>buildMediaQuery\n}));\nfunction buildMediaQuery(screens) {\n    screens = Array.isArray(screens) ? screens : [\n        screens\n    ];\n    return screens.map((screen)=>screen.values.map((screen)=>{\n            if (screen.raw !== undefined) {\n                return screen.raw;\n            }\n            return [\n                screen.min && `(min-width: ${screen.min})`,\n                screen.max && `(max-width: ${screen.max})`, \n            ].filter(Boolean).join(\" and \");\n        })).join(\", \");\n}\n\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/tailwindcss/lib/util/buildMediaQuery.js?");

/***/ }),

/***/ "./node_modules/tailwindcss/lib/util/cloneDeep.js":
/*!********************************************************!*\
  !*** ./node_modules/tailwindcss/lib/util/cloneDeep.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"cloneDeep\", ({\n    enumerable: true,\n    get: ()=>cloneDeep\n}));\nfunction cloneDeep(value) {\n    if (Array.isArray(value)) {\n        return value.map((child)=>cloneDeep(child));\n    }\n    if (typeof value === \"object\" && value !== null) {\n        return Object.fromEntries(Object.entries(value).map(([k, v])=>[\n                k,\n                cloneDeep(v)\n            ]));\n    }\n    return value;\n}\n\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/tailwindcss/lib/util/cloneDeep.js?");

/***/ }),

/***/ "./node_modules/tailwindcss/lib/util/cloneNodes.js":
/*!*********************************************************!*\
  !*** ./node_modules/tailwindcss/lib/util/cloneNodes.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"default\", ({\n    enumerable: true,\n    get: ()=>cloneNodes\n}));\nfunction cloneNodes(nodes, source = undefined, raws = undefined) {\n    return nodes.map((node)=>{\n        var ref;\n        let cloned = node.clone();\n        // We always want override the source map\n        // except when explicitly told not to\n        let shouldOverwriteSource = ((ref = node.raws.tailwind) === null || ref === void 0 ? void 0 : ref.preserveSource) !== true || !cloned.source;\n        if (source !== undefined && shouldOverwriteSource) {\n            cloned.source = source;\n            if (\"walk\" in cloned) {\n                cloned.walk((child)=>{\n                    child.source = source;\n                });\n            }\n        }\n        if (raws !== undefined) {\n            cloned.raws.tailwind = {\n                ...cloned.raws.tailwind,\n                ...raws\n            };\n        }\n        return cloned;\n    });\n}\n\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/tailwindcss/lib/util/cloneNodes.js?");

/***/ }),

/***/ "./node_modules/tailwindcss/lib/util/color.js":
/*!****************************************************!*\
  !*** ./node_modules/tailwindcss/lib/util/color.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    parseColor: ()=>parseColor,\n    formatColor: ()=>formatColor\n});\nconst _colorName = /*#__PURE__*/ _interopRequireDefault(__webpack_require__(/*! color-name */ \"./node_modules/color-name/index.js\"));\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        default: obj\n    };\n}\nlet HEX = /^#([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})?$/i;\nlet SHORT_HEX = /^#([a-f\\d])([a-f\\d])([a-f\\d])([a-f\\d])?$/i;\nlet VALUE = /(?:\\d+|\\d*\\.\\d+)%?/;\nlet SEP = /(?:\\s*,\\s*|\\s+)/;\nlet ALPHA_SEP = /\\s*[,/]\\s*/;\nlet CUSTOM_PROPERTY = /var\\(--(?:[^ )]*?)\\)/;\nlet RGB = new RegExp(`^(rgb)a?\\\\(\\\\s*(${VALUE.source}|${CUSTOM_PROPERTY.source})(?:${SEP.source}(${VALUE.source}|${CUSTOM_PROPERTY.source}))?(?:${SEP.source}(${VALUE.source}|${CUSTOM_PROPERTY.source}))?(?:${ALPHA_SEP.source}(${VALUE.source}|${CUSTOM_PROPERTY.source}))?\\\\s*\\\\)$`);\nlet HSL = new RegExp(`^(hsl)a?\\\\(\\\\s*((?:${VALUE.source})(?:deg|rad|grad|turn)?|${CUSTOM_PROPERTY.source})(?:${SEP.source}(${VALUE.source}|${CUSTOM_PROPERTY.source}))?(?:${SEP.source}(${VALUE.source}|${CUSTOM_PROPERTY.source}))?(?:${ALPHA_SEP.source}(${VALUE.source}|${CUSTOM_PROPERTY.source}))?\\\\s*\\\\)$`);\nfunction parseColor(value, { loose =false  } = {}) {\n    var ref, ref1;\n    if (typeof value !== \"string\") {\n        return null;\n    }\n    value = value.trim();\n    if (value === \"transparent\") {\n        return {\n            mode: \"rgb\",\n            color: [\n                \"0\",\n                \"0\",\n                \"0\"\n            ],\n            alpha: \"0\"\n        };\n    }\n    if (value in _colorName.default) {\n        return {\n            mode: \"rgb\",\n            color: _colorName.default[value].map((v)=>v.toString())\n        };\n    }\n    let hex = value.replace(SHORT_HEX, (_, r, g, b, a)=>[\n            \"#\",\n            r,\n            r,\n            g,\n            g,\n            b,\n            b,\n            a ? a + a : \"\"\n        ].join(\"\")).match(HEX);\n    if (hex !== null) {\n        return {\n            mode: \"rgb\",\n            color: [\n                parseInt(hex[1], 16),\n                parseInt(hex[2], 16),\n                parseInt(hex[3], 16)\n            ].map((v)=>v.toString()),\n            alpha: hex[4] ? (parseInt(hex[4], 16) / 255).toString() : undefined\n        };\n    }\n    var ref2;\n    let match = (ref2 = value.match(RGB)) !== null && ref2 !== void 0 ? ref2 : value.match(HSL);\n    if (match === null) {\n        return null;\n    }\n    let color = [\n        match[2],\n        match[3],\n        match[4]\n    ].filter(Boolean).map((v)=>v.toString());\n    if (!loose && color.length !== 3) {\n        return null;\n    }\n    if (color.length < 3 && !color.some((part)=>/^var\\(.*?\\)$/.test(part))) {\n        return null;\n    }\n    return {\n        mode: match[1],\n        color,\n        alpha: (ref = match[5]) === null || ref === void 0 ? void 0 : (ref1 = ref.toString) === null || ref1 === void 0 ? void 0 : ref1.call(ref)\n    };\n}\nfunction formatColor({ mode , color , alpha  }) {\n    let hasAlpha = alpha !== undefined;\n    return `${mode}(${color.join(\" \")}${hasAlpha ? ` / ${alpha}` : \"\"})`;\n}\n\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/tailwindcss/lib/util/color.js?");

/***/ }),

/***/ "./node_modules/tailwindcss/lib/util/configurePlugins.js":
/*!***************************************************************!*\
  !*** ./node_modules/tailwindcss/lib/util/configurePlugins.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"default\", ({\n    enumerable: true,\n    get: ()=>_default\n}));\nfunction _default(pluginConfig, plugins) {\n    if (pluginConfig === undefined) {\n        return plugins;\n    }\n    const pluginNames = Array.isArray(pluginConfig) ? pluginConfig : [\n        ...new Set(plugins.filter((pluginName)=>{\n            return pluginConfig !== false && pluginConfig[pluginName] !== false;\n        }).concat(Object.keys(pluginConfig).filter((pluginName)=>{\n            return pluginConfig[pluginName] !== false;\n        }))), \n    ];\n    return pluginNames;\n}\n\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/tailwindcss/lib/util/configurePlugins.js?");

/***/ }),

/***/ "./node_modules/tailwindcss/lib/util/createUtilityPlugin.js":
/*!******************************************************************!*\
  !*** ./node_modules/tailwindcss/lib/util/createUtilityPlugin.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"default\", ({\n    enumerable: true,\n    get: ()=>createUtilityPlugin\n}));\nconst _transformThemeValue = /*#__PURE__*/ _interopRequireDefault(__webpack_require__(/*! ./transformThemeValue */ \"./node_modules/tailwindcss/lib/util/transformThemeValue.js\"));\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        default: obj\n    };\n}\nfunction createUtilityPlugin(themeKey, utilityVariations = [\n    [\n        themeKey,\n        [\n            themeKey\n        ]\n    ]\n], { filterDefault =false , ...options } = {}) {\n    let transformValue = (0, _transformThemeValue.default)(themeKey);\n    return function({ matchUtilities , theme  }) {\n        for (let utilityVariation of utilityVariations){\n            let group = Array.isArray(utilityVariation[0]) ? utilityVariation : [\n                utilityVariation\n            ];\n            var ref;\n            matchUtilities(group.reduce((obj, [classPrefix, properties])=>{\n                return Object.assign(obj, {\n                    [classPrefix]: (value)=>{\n                        return properties.reduce((obj, name)=>{\n                            if (Array.isArray(name)) {\n                                return Object.assign(obj, {\n                                    [name[0]]: name[1]\n                                });\n                            }\n                            return Object.assign(obj, {\n                                [name]: transformValue(value)\n                            });\n                        }, {});\n                    }\n                });\n            }, {}), {\n                ...options,\n                values: filterDefault ? Object.fromEntries(Object.entries((ref = theme(themeKey)) !== null && ref !== void 0 ? ref : {}).filter(([modifier])=>modifier !== \"DEFAULT\")) : theme(themeKey)\n            });\n        }\n    };\n}\n\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/tailwindcss/lib/util/createUtilityPlugin.js?");

/***/ }),

/***/ "./node_modules/tailwindcss/lib/util/dataTypes.js":
/*!********************************************************!*\
  !*** ./node_modules/tailwindcss/lib/util/dataTypes.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    normalize: ()=>normalize,\n    url: ()=>url,\n    number: ()=>number,\n    percentage: ()=>percentage,\n    length: ()=>length,\n    lineWidth: ()=>lineWidth,\n    shadow: ()=>shadow,\n    color: ()=>color,\n    image: ()=>image,\n    gradient: ()=>gradient,\n    position: ()=>position,\n    familyName: ()=>familyName,\n    genericName: ()=>genericName,\n    absoluteSize: ()=>absoluteSize,\n    relativeSize: ()=>relativeSize\n});\nconst _color = __webpack_require__(/*! ./color */ \"./node_modules/tailwindcss/lib/util/color.js\");\nconst _parseBoxShadowValue = __webpack_require__(/*! ./parseBoxShadowValue */ \"./node_modules/tailwindcss/lib/util/parseBoxShadowValue.js\");\nlet cssFunctions = [\n    \"min\",\n    \"max\",\n    \"clamp\",\n    \"calc\"\n];\n// Ref: https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Types\nlet COMMA = /,(?![^(]*\\))/g // Comma separator that is not located between brackets. E.g.: `cubiz-bezier(a, b, c)` these don't count.\n;\nlet UNDERSCORE = /_(?![^(]*\\))/g // Underscore separator that is not located between brackets. E.g.: `rgba(255,_255,_255)_black` these don't count.\n;\nfunction normalize(value, isRoot = true) {\n    // Keep raw strings if it starts with `url(`\n    if (value.includes(\"url(\")) {\n        return value.split(/(url\\(.*?\\))/g).filter(Boolean).map((part)=>{\n            if (/^url\\(.*?\\)$/.test(part)) {\n                return part;\n            }\n            return normalize(part, false);\n        }).join(\"\");\n    }\n    // Convert `_` to ` `, except for escaped underscores `\\_`\n    value = value.replace(/([^\\\\])_+/g, (fullMatch, characterBefore)=>characterBefore + \" \".repeat(fullMatch.length - 1)).replace(/^_/g, \" \").replace(/\\\\_/g, \"_\");\n    // Remove leftover whitespace\n    if (isRoot) {\n        value = value.trim();\n    }\n    // Add spaces around operators inside math functions like calc() that do not follow an operator\n    // or '('.\n    value = value.replace(/(calc|min|max|clamp)\\(.+\\)/g, (match)=>{\n        return match.replace(/(-?\\d*\\.?\\d(?!\\b-.+[,)](?![^+\\-/*])\\D)(?:%|[a-z]+)?|\\))([+\\-/*])/g, \"$1 $2 \");\n    });\n    return value;\n}\nfunction url(value) {\n    return value.startsWith(\"url(\");\n}\nfunction number(value) {\n    return !isNaN(Number(value)) || cssFunctions.some((fn)=>new RegExp(`^${fn}\\\\(.+?`).test(value));\n}\nfunction percentage(value) {\n    return value.split(UNDERSCORE).every((part)=>{\n        return /%$/g.test(part) || cssFunctions.some((fn)=>new RegExp(`^${fn}\\\\(.+?%`).test(part));\n    });\n}\nlet lengthUnits = [\n    \"cm\",\n    \"mm\",\n    \"Q\",\n    \"in\",\n    \"pc\",\n    \"pt\",\n    \"px\",\n    \"em\",\n    \"ex\",\n    \"ch\",\n    \"rem\",\n    \"lh\",\n    \"vw\",\n    \"vh\",\n    \"vmin\",\n    \"vmax\", \n];\nlet lengthUnitsPattern = `(?:${lengthUnits.join(\"|\")})`;\nfunction length(value) {\n    return value.split(UNDERSCORE).every((part)=>{\n        return part === \"0\" || new RegExp(`${lengthUnitsPattern}$`).test(part) || cssFunctions.some((fn)=>new RegExp(`^${fn}\\\\(.+?${lengthUnitsPattern}`).test(part));\n    });\n}\nlet lineWidths = new Set([\n    \"thin\",\n    \"medium\",\n    \"thick\"\n]);\nfunction lineWidth(value) {\n    return lineWidths.has(value);\n}\nfunction shadow(value) {\n    let parsedShadows = (0, _parseBoxShadowValue.parseBoxShadowValue)(normalize(value));\n    for (let parsedShadow of parsedShadows){\n        if (!parsedShadow.valid) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction color(value) {\n    let colors = 0;\n    let result = value.split(UNDERSCORE).every((part)=>{\n        part = normalize(part);\n        if (part.startsWith(\"var(\")) return true;\n        if ((0, _color.parseColor)(part, {\n            loose: true\n        }) !== null) return colors++, true;\n        return false;\n    });\n    if (!result) return false;\n    return colors > 0;\n}\nfunction image(value) {\n    let images = 0;\n    let result = value.split(COMMA).every((part)=>{\n        part = normalize(part);\n        if (part.startsWith(\"var(\")) return true;\n        if (url(part) || gradient(part) || [\n            \"element(\",\n            \"image(\",\n            \"cross-fade(\",\n            \"image-set(\"\n        ].some((fn)=>part.startsWith(fn))) {\n            images++;\n            return true;\n        }\n        return false;\n    });\n    if (!result) return false;\n    return images > 0;\n}\nlet gradientTypes = new Set([\n    \"linear-gradient\",\n    \"radial-gradient\",\n    \"repeating-linear-gradient\",\n    \"repeating-radial-gradient\",\n    \"conic-gradient\", \n]);\nfunction gradient(value) {\n    value = normalize(value);\n    for (let type of gradientTypes){\n        if (value.startsWith(`${type}(`)) {\n            return true;\n        }\n    }\n    return false;\n}\nlet validPositions = new Set([\n    \"center\",\n    \"top\",\n    \"right\",\n    \"bottom\",\n    \"left\"\n]);\nfunction position(value) {\n    let positions = 0;\n    let result = value.split(UNDERSCORE).every((part)=>{\n        part = normalize(part);\n        if (part.startsWith(\"var(\")) return true;\n        if (validPositions.has(part) || length(part) || percentage(part)) {\n            positions++;\n            return true;\n        }\n        return false;\n    });\n    if (!result) return false;\n    return positions > 0;\n}\nfunction familyName(value) {\n    let fonts = 0;\n    let result = value.split(COMMA).every((part)=>{\n        part = normalize(part);\n        if (part.startsWith(\"var(\")) return true;\n        // If it contains spaces, then it should be quoted\n        if (part.includes(\" \")) {\n            if (!/(['\"])([^\"']+)\\1/g.test(part)) {\n                return false;\n            }\n        }\n        // If it starts with a number, it's invalid\n        if (/^\\d/g.test(part)) {\n            return false;\n        }\n        fonts++;\n        return true;\n    });\n    if (!result) return false;\n    return fonts > 0;\n}\nlet genericNames = new Set([\n    \"serif\",\n    \"sans-serif\",\n    \"monospace\",\n    \"cursive\",\n    \"fantasy\",\n    \"system-ui\",\n    \"ui-serif\",\n    \"ui-sans-serif\",\n    \"ui-monospace\",\n    \"ui-rounded\",\n    \"math\",\n    \"emoji\",\n    \"fangsong\", \n]);\nfunction genericName(value) {\n    return genericNames.has(value);\n}\nlet absoluteSizes = new Set([\n    \"xx-small\",\n    \"x-small\",\n    \"small\",\n    \"medium\",\n    \"large\",\n    \"x-large\",\n    \"x-large\",\n    \"xxx-large\", \n]);\nfunction absoluteSize(value) {\n    return absoluteSizes.has(value);\n}\nlet relativeSizes = new Set([\n    \"larger\",\n    \"smaller\"\n]);\nfunction relativeSize(value) {\n    return relativeSizes.has(value);\n}\n\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/tailwindcss/lib/util/dataTypes.js?");

/***/ }),

/***/ "./node_modules/tailwindcss/lib/util/defaults.js":
/*!*******************************************************!*\
  !*** ./node_modules/tailwindcss/lib/util/defaults.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"defaults\", ({\n    enumerable: true,\n    get: ()=>defaults\n}));\nfunction defaults(target, ...sources) {\n    for (let source of sources){\n        for(let k in source){\n            var ref;\n            if (!(target === null || target === void 0 ? void 0 : (ref = target.hasOwnProperty) === null || ref === void 0 ? void 0 : ref.call(target, k))) {\n                target[k] = source[k];\n            }\n        }\n        for (let k1 of Object.getOwnPropertySymbols(source)){\n            var ref1;\n            if (!(target === null || target === void 0 ? void 0 : (ref1 = target.hasOwnProperty) === null || ref1 === void 0 ? void 0 : ref1.call(target, k1))) {\n                target[k1] = source[k1];\n            }\n        }\n    }\n    return target;\n}\n\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/tailwindcss/lib/util/defaults.js?");

/***/ }),

/***/ "./node_modules/tailwindcss/lib/util/escapeClassName.js":
/*!**************************************************************!*\
  !*** ./node_modules/tailwindcss/lib/util/escapeClassName.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"default\", ({\n    enumerable: true,\n    get: ()=>escapeClassName\n}));\nconst _postcssSelectorParser = /*#__PURE__*/ _interopRequireDefault(__webpack_require__(/*! postcss-selector-parser */ \"./node_modules/postcss-selector-parser/dist/index.js\"));\nconst _escapeCommas = /*#__PURE__*/ _interopRequireDefault(__webpack_require__(/*! ./escapeCommas */ \"./node_modules/tailwindcss/lib/util/escapeCommas.js\"));\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        default: obj\n    };\n}\nfunction escapeClassName(className) {\n    var ref;\n    let node = _postcssSelectorParser.default.className();\n    node.value = className;\n    var ref1;\n    return (0, _escapeCommas.default)((ref1 = node === null || node === void 0 ? void 0 : (ref = node.raws) === null || ref === void 0 ? void 0 : ref.value) !== null && ref1 !== void 0 ? ref1 : node.value);\n}\n\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/tailwindcss/lib/util/escapeClassName.js?");

/***/ }),

/***/ "./node_modules/tailwindcss/lib/util/escapeCommas.js":
/*!***********************************************************!*\
  !*** ./node_modules/tailwindcss/lib/util/escapeCommas.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"default\", ({\n    enumerable: true,\n    get: ()=>escapeCommas\n}));\nfunction escapeCommas(className) {\n    return className.replace(/\\\\,/g, \"\\\\2c \");\n}\n\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/tailwindcss/lib/util/escapeCommas.js?");

/***/ }),

/***/ "./node_modules/tailwindcss/lib/util/flattenColorPalette.js":
/*!******************************************************************!*\
  !*** ./node_modules/tailwindcss/lib/util/flattenColorPalette.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"default\", ({\n    enumerable: true,\n    get: ()=>_default\n}));\nconst flattenColorPalette = (colors)=>Object.assign({}, ...Object.entries(colors !== null && colors !== void 0 ? colors : {}).flatMap(([color, values])=>typeof values == \"object\" ? Object.entries(flattenColorPalette(values)).map(([number, hex])=>({\n                [color + (number === \"DEFAULT\" ? \"\" : `-${number}`)]: hex\n            })) : [\n            {\n                [`${color}`]: values\n            }\n        ]));\nconst _default = flattenColorPalette;\n\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/tailwindcss/lib/util/flattenColorPalette.js?");

/***/ }),

/***/ "./node_modules/tailwindcss/lib/util/formatVariantSelector.js":
/*!********************************************************************!*\
  !*** ./node_modules/tailwindcss/lib/util/formatVariantSelector.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    selectorFunctions: ()=>selectorFunctions,\n    formatVariantSelector: ()=>formatVariantSelector,\n    finalizeSelector: ()=>finalizeSelector\n});\nconst _postcssSelectorParser = /*#__PURE__*/ _interopRequireDefault(__webpack_require__(/*! postcss-selector-parser */ \"./node_modules/postcss-selector-parser/dist/index.js\"));\nconst _unesc = /*#__PURE__*/ _interopRequireDefault(__webpack_require__(/*! postcss-selector-parser/dist/util/unesc */ \"./node_modules/postcss-selector-parser/dist/util/unesc.js\"));\nconst _escapeClassName = /*#__PURE__*/ _interopRequireDefault(__webpack_require__(/*! ../util/escapeClassName */ \"./node_modules/tailwindcss/lib/util/escapeClassName.js\"));\nconst _prefixSelector = /*#__PURE__*/ _interopRequireDefault(__webpack_require__(/*! ../util/prefixSelector */ \"./node_modules/tailwindcss/lib/util/prefixSelector.js\"));\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        default: obj\n    };\n}\nvar ref;\nlet MERGE = \":merge\";\nlet PARENT = \"&\";\nlet selectorFunctions = new Set([\n    MERGE\n]);\nfunction formatVariantSelector(current, ...others) {\n    for (let other of others){\n        let incomingValue = resolveFunctionArgument(other, MERGE);\n        if (incomingValue !== null) {\n            let existingValue = resolveFunctionArgument(current, MERGE, incomingValue);\n            if (existingValue !== null) {\n                let existingTarget = `${MERGE}(${incomingValue})`;\n                let splitIdx = other.indexOf(existingTarget);\n                let addition = other.slice(splitIdx + existingTarget.length).split(\" \")[0];\n                current = current.replace(existingTarget, existingTarget + addition);\n                continue;\n            }\n        }\n        current = other.replace(PARENT, current);\n    }\n    return current;\n}\nvar ref1;\nfunction finalizeSelector(format, { selector , candidate , context , isArbitraryVariant , // Split by the separator, but ignore the separator inside square brackets:\n//\n// E.g.: dark:lg:hover:[paint-order:markers]\n//           ┬  ┬     ┬            ┬\n//           │  │     │            ╰── We will not split here\n//           ╰──┴─────┴─────────────── We will split here\n//\nbase =candidate.split(new RegExp(`\\\\${(ref1 = context === null || context === void 0 ? void 0 : (ref = context.tailwindConfig) === null || ref === void 0 ? void 0 : ref.separator) !== null && ref1 !== void 0 ? ref1 : \":\"}(?![^[]*\\\\])`)).pop() ,  }) {\n    var ref2;\n    let ast = (0, _postcssSelectorParser.default)().astSync(selector);\n    // We explicitly DO NOT prefix classes in arbitrary variants\n    if ((context === null || context === void 0 ? void 0 : (ref2 = context.tailwindConfig) === null || ref2 === void 0 ? void 0 : ref2.prefix) && !isArbitraryVariant) {\n        format = (0, _prefixSelector.default)(context.tailwindConfig.prefix, format);\n    }\n    format = format.replace(PARENT, `.${(0, _escapeClassName.default)(candidate)}`);\n    let formatAst = (0, _postcssSelectorParser.default)().astSync(format);\n    // Remove extraneous selectors that do not include the base class/candidate being matched against\n    // For example if we have a utility defined `.a, .b { color: red}`\n    // And the formatted variant is sm:b then we want the final selector to be `.sm\\:b` and not `.a, .sm\\:b`\n    ast.each((node)=>{\n        let hasClassesMatchingCandidate = node.some((n)=>n.type === \"class\" && n.value === base);\n        if (!hasClassesMatchingCandidate) {\n            node.remove();\n        }\n    });\n    // Normalize escaped classes, e.g.:\n    //\n    // The idea would be to replace the escaped `base` in the selector with the\n    // `format`. However, in css you can escape the same selector in a few\n    // different ways. This would result in different strings and therefore we\n    // can't replace it properly.\n    //\n    //               base: bg-[rgb(255,0,0)]\n    //   base in selector: bg-\\\\[rgb\\\\(255\\\\,0\\\\,0\\\\)\\\\]\n    //       escaped base: bg-\\\\[rgb\\\\(255\\\\2c 0\\\\2c 0\\\\)\\\\]\n    //\n    ast.walkClasses((node)=>{\n        if (node.raws && node.value.includes(base)) {\n            node.raws.value = (0, _escapeClassName.default)((0, _unesc.default)(node.raws.value));\n        }\n    });\n    // We can safely replace the escaped base now, since the `base` section is\n    // now in a normalized escaped value.\n    ast.walkClasses((node)=>{\n        if (node.value === base) {\n            node.replaceWith(...formatAst.nodes);\n        }\n    });\n    // This will make sure to move pseudo's to the correct spot (the end for\n    // pseudo elements) because otherwise the selector will never work\n    // anyway.\n    //\n    // E.g.:\n    //  - `before:hover:text-center` would result in `.before\\:hover\\:text-center:hover::before`\n    //  - `hover:before:text-center` would result in `.hover\\:before\\:text-center:hover::before`\n    //\n    // `::before:hover` doesn't work, which means that we can make it work for you by flipping the order.\n    function collectPseudoElements(selector) {\n        let nodes = [];\n        for (let node of selector.nodes){\n            if (isPseudoElement(node)) {\n                nodes.push(node);\n                selector.removeChild(node);\n            }\n            if (node === null || node === void 0 ? void 0 : node.nodes) {\n                nodes.push(...collectPseudoElements(node));\n            }\n        }\n        return nodes;\n    }\n    // Remove unnecessary pseudo selectors that we used as placeholders\n    ast.each((selector)=>{\n        selector.walkPseudos((p)=>{\n            if (selectorFunctions.has(p.value)) {\n                p.replaceWith(p.nodes);\n            }\n        });\n        let pseudoElements = collectPseudoElements(selector);\n        if (pseudoElements.length > 0) {\n            selector.nodes.push(pseudoElements.sort(sortSelector));\n        }\n    });\n    return ast.toString();\n}\n// Note: As a rule, double colons (::) should be used instead of a single colon\n// (:). This distinguishes pseudo-classes from pseudo-elements. However, since\n// this distinction was not present in older versions of the W3C spec, most\n// browsers support both syntaxes for the original pseudo-elements.\nlet pseudoElementsBC = [\n    \":before\",\n    \":after\",\n    \":first-line\",\n    \":first-letter\"\n];\n// These pseudo-elements _can_ be combined with other pseudo selectors AND the order does matter.\nlet pseudoElementExceptions = [\n    \"::file-selector-button\"\n];\n// This will make sure to move pseudo's to the correct spot (the end for\n// pseudo elements) because otherwise the selector will never work\n// anyway.\n//\n// E.g.:\n//  - `before:hover:text-center` would result in `.before\\:hover\\:text-center:hover::before`\n//  - `hover:before:text-center` would result in `.hover\\:before\\:text-center:hover::before`\n//\n// `::before:hover` doesn't work, which means that we can make it work\n// for you by flipping the order.\nfunction sortSelector(a, z) {\n    // Both nodes are non-pseudo's so we can safely ignore them and keep\n    // them in the same order.\n    if (a.type !== \"pseudo\" && z.type !== \"pseudo\") {\n        return 0;\n    }\n    // If one of them is a combinator, we need to keep it in the same order\n    // because that means it will start a new \"section\" in the selector.\n    if (a.type === \"combinator\" ^ z.type === \"combinator\") {\n        return 0;\n    }\n    // One of the items is a pseudo and the other one isn't. Let's move\n    // the pseudo to the right.\n    if (a.type === \"pseudo\" ^ z.type === \"pseudo\") {\n        return (a.type === \"pseudo\") - (z.type === \"pseudo\");\n    }\n    // Both are pseudo's, move the pseudo elements (except for\n    // ::file-selector-button) to the right.\n    return isPseudoElement(a) - isPseudoElement(z);\n}\nfunction isPseudoElement(node) {\n    if (node.type !== \"pseudo\") return false;\n    if (pseudoElementExceptions.includes(node.value)) return false;\n    return node.value.startsWith(\"::\") || pseudoElementsBC.includes(node.value);\n}\nfunction resolveFunctionArgument(haystack, needle, arg) {\n    let startIdx = haystack.indexOf(arg ? `${needle}(${arg})` : needle);\n    if (startIdx === -1) return null;\n    // Start inside the `(`\n    startIdx += needle.length + 1;\n    let target = \"\";\n    let count = 0;\n    for (let char of haystack.slice(startIdx)){\n        if (char !== \"(\" && char !== \")\") {\n            target += char;\n        } else if (char === \"(\") {\n            target += char;\n            count++;\n        } else if (char === \")\") {\n            if (--count < 0) break; // unbalanced\n            target += char;\n        }\n    }\n    return target;\n}\n\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/tailwindcss/lib/util/formatVariantSelector.js?");

/***/ }),

/***/ "./node_modules/tailwindcss/lib/util/getAllConfigs.js":
/*!************************************************************!*\
  !*** ./node_modules/tailwindcss/lib/util/getAllConfigs.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"default\", ({\n    enumerable: true,\n    get: ()=>getAllConfigs\n}));\nconst _defaultConfigStubJs = /*#__PURE__*/ _interopRequireDefault(__webpack_require__(/*! ../../stubs/defaultConfig.stub.js */ \"./node_modules/tailwindcss/stubs/defaultConfig.stub.js\"));\nconst _featureFlags = __webpack_require__(/*! ../featureFlags */ \"./node_modules/tailwindcss/lib/featureFlags.js\");\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        default: obj\n    };\n}\nfunction getAllConfigs(config) {\n    var ref;\n    const configs = ((ref = config === null || config === void 0 ? void 0 : config.presets) !== null && ref !== void 0 ? ref : [\n        _defaultConfigStubJs.default\n    ]).slice().reverse().flatMap((preset)=>getAllConfigs(preset instanceof Function ? preset() : preset));\n    const features = {\n        // Add experimental configs here...\n        respectDefaultRingColorOpacity: {\n            theme: {\n                ringColor: {\n                    DEFAULT: \"#3b82f67f\"\n                }\n            }\n        }\n    };\n    const experimentals = Object.keys(features).filter((feature)=>(0, _featureFlags.flagEnabled)(config, feature)).map((feature)=>features[feature]);\n    return [\n        config,\n        ...experimentals,\n        ...configs\n    ];\n}\n\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/tailwindcss/lib/util/getAllConfigs.js?");

/***/ }),

/***/ "./node_modules/tailwindcss/lib/util/hashConfig.js":
/*!*********************************************************!*\
  !*** ./node_modules/tailwindcss/lib/util/hashConfig.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"default\", ({\n    enumerable: true,\n    get: ()=>hashConfig\n}));\nconst _objectHash = /*#__PURE__*/ _interopRequireDefault(__webpack_require__(/*! object-hash */ \"./node_modules/object-hash/dist/object_hash.js\"));\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        default: obj\n    };\n}\nfunction hashConfig(config) {\n    return (0, _objectHash.default)(config, {\n        ignoreUnknown: true\n    });\n}\n\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/tailwindcss/lib/util/hashConfig.js?");

/***/ }),

/***/ "./node_modules/tailwindcss/lib/util/isPlainObject.js":
/*!************************************************************!*\
  !*** ./node_modules/tailwindcss/lib/util/isPlainObject.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"default\", ({\n    enumerable: true,\n    get: ()=>isPlainObject\n}));\nfunction isPlainObject(value) {\n    if (Object.prototype.toString.call(value) !== \"[object Object]\") {\n        return false;\n    }\n    const prototype = Object.getPrototypeOf(value);\n    return prototype === null || prototype === Object.prototype;\n}\n\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/tailwindcss/lib/util/isPlainObject.js?");

/***/ }),

/***/ "./node_modules/tailwindcss/lib/util/isValidArbitraryValue.js":
/*!********************************************************************!*\
  !*** ./node_modules/tailwindcss/lib/util/isValidArbitraryValue.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"default\", ({\n    enumerable: true,\n    get: ()=>isValidArbitraryValue\n}));\nlet matchingBrackets = new Map([\n    [\n        \"{\",\n        \"}\"\n    ],\n    [\n        \"[\",\n        \"]\"\n    ],\n    [\n        \"(\",\n        \")\"\n    ], \n]);\nlet inverseMatchingBrackets = new Map(Array.from(matchingBrackets.entries()).map(([k, v])=>[\n        v,\n        k\n    ]));\nlet quotes = new Set([\n    '\"',\n    \"'\",\n    \"`\"\n]);\nfunction isValidArbitraryValue(value) {\n    let stack = [];\n    let inQuotes = false;\n    for(let i = 0; i < value.length; i++){\n        let char = value[i];\n        if (char === \":\" && !inQuotes && stack.length === 0) {\n            return false;\n        }\n        // Non-escaped quotes allow us to \"allow\" anything in between\n        if (quotes.has(char) && value[i - 1] !== \"\\\\\") {\n            inQuotes = !inQuotes;\n        }\n        if (inQuotes) continue;\n        if (value[i - 1] === \"\\\\\") continue; // Escaped\n        if (matchingBrackets.has(char)) {\n            stack.push(char);\n        } else if (inverseMatchingBrackets.has(char)) {\n            let inverse = inverseMatchingBrackets.get(char);\n            // Nothing to pop from, therefore it is unbalanced\n            if (stack.length <= 0) {\n                return false;\n            }\n            // Popped value must match the inverse value, otherwise it is unbalanced\n            if (stack.pop() !== inverse) {\n                return false;\n            }\n        }\n    }\n    // If there is still something on the stack, it is also unbalanced\n    if (stack.length > 0) {\n        return false;\n    }\n    // All good, totally balanced!\n    return true;\n}\n\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/tailwindcss/lib/util/isValidArbitraryValue.js?");

/***/ }),

/***/ "./node_modules/tailwindcss/lib/util/log.js":
/*!**************************************************!*\
  !*** ./node_modules/tailwindcss/lib/util/log.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    dim: ()=>dim,\n    default: ()=>_default\n});\nconst _picocolors = /*#__PURE__*/ _interopRequireDefault(__webpack_require__(/*! picocolors */ \"./node_modules/picocolors/picocolors.browser.js\"));\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        default: obj\n    };\n}\nlet alreadyShown = new Set();\nfunction log(type, messages, key) {\n    if (typeof process !== \"undefined\" && process.env.JEST_WORKER_ID) return;\n    if (key && alreadyShown.has(key)) return;\n    if (key) alreadyShown.add(key);\n    console.warn(\"\");\n    messages.forEach((message)=>console.warn(type, \"-\", message));\n}\nfunction dim(input) {\n    return _picocolors.default.dim(input);\n}\nconst _default = {\n    info (key, messages) {\n        log(_picocolors.default.bold(_picocolors.default.cyan(\"info\")), ...Array.isArray(key) ? [\n            key\n        ] : [\n            messages,\n            key\n        ]);\n    },\n    warn (key, messages) {\n        log(_picocolors.default.bold(_picocolors.default.yellow(\"warn\")), ...Array.isArray(key) ? [\n            key\n        ] : [\n            messages,\n            key\n        ]);\n    },\n    risk (key, messages) {\n        log(_picocolors.default.bold(_picocolors.default.magenta(\"risk\")), ...Array.isArray(key) ? [\n            key\n        ] : [\n            messages,\n            key\n        ]);\n    }\n};\n\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/tailwindcss/lib/util/log.js?");

/***/ }),

/***/ "./node_modules/tailwindcss/lib/util/nameClass.js":
/*!********************************************************!*\
  !*** ./node_modules/tailwindcss/lib/util/nameClass.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    asClass: ()=>asClass,\n    default: ()=>nameClass,\n    formatClass: ()=>formatClass\n});\nconst _escapeClassName = /*#__PURE__*/ _interopRequireDefault(__webpack_require__(/*! ./escapeClassName */ \"./node_modules/tailwindcss/lib/util/escapeClassName.js\"));\nconst _escapeCommas = /*#__PURE__*/ _interopRequireDefault(__webpack_require__(/*! ./escapeCommas */ \"./node_modules/tailwindcss/lib/util/escapeCommas.js\"));\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        default: obj\n    };\n}\nfunction asClass(name) {\n    return (0, _escapeCommas.default)(`.${(0, _escapeClassName.default)(name)}`);\n}\nfunction nameClass(classPrefix, key) {\n    return asClass(formatClass(classPrefix, key));\n}\nfunction formatClass(classPrefix, key) {\n    if (key === \"DEFAULT\") {\n        return classPrefix;\n    }\n    if (key === \"-\" || key === \"-DEFAULT\") {\n        return `-${classPrefix}`;\n    }\n    if (key.startsWith(\"-\")) {\n        return `-${classPrefix}${key}`;\n    }\n    return `${classPrefix}-${key}`;\n}\n\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/tailwindcss/lib/util/nameClass.js?");

/***/ }),

/***/ "./node_modules/tailwindcss/lib/util/negateValue.js":
/*!**********************************************************!*\
  !*** ./node_modules/tailwindcss/lib/util/negateValue.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"default\", ({\n    enumerable: true,\n    get: ()=>_default\n}));\nfunction _default(value) {\n    value = `${value}`;\n    if (value === \"0\") {\n        return \"0\";\n    }\n    // Flip sign of numbers\n    if (/^[+-]?(\\d+|\\d*\\.\\d+)(e[+-]?\\d+)?(%|\\w+)?$/.test(value)) {\n        return value.replace(/^[+-]?/, (sign)=>sign === \"-\" ? \"\" : \"-\");\n    }\n    if (value.includes(\"var(\") || value.includes(\"calc(\")) {\n        return `calc(${value} * -1)`;\n    }\n}\n\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/tailwindcss/lib/util/negateValue.js?");

/***/ }),

/***/ "./node_modules/tailwindcss/lib/util/normalizeConfig.js":
/*!**************************************************************!*\
  !*** ./node_modules/tailwindcss/lib/util/normalizeConfig.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"normalizeConfig\", ({\n    enumerable: true,\n    get: ()=>normalizeConfig\n}));\nconst _log = /*#__PURE__*/ _interopRequireWildcard(__webpack_require__(/*! ./log */ \"./node_modules/tailwindcss/lib/util/log.js\"));\nfunction _getRequireWildcardCache(nodeInterop) {\n    if (typeof WeakMap !== \"function\") return null;\n    var cacheBabelInterop = new WeakMap();\n    var cacheNodeInterop = new WeakMap();\n    return (_getRequireWildcardCache = function(nodeInterop) {\n        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;\n    })(nodeInterop);\n}\nfunction _interopRequireWildcard(obj, nodeInterop) {\n    if (!nodeInterop && obj && obj.__esModule) {\n        return obj;\n    }\n    if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n        return {\n            default: obj\n        };\n    }\n    var cache = _getRequireWildcardCache(nodeInterop);\n    if (cache && cache.has(obj)) {\n        return cache.get(obj);\n    }\n    var newObj = {};\n    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n    for(var key in obj){\n        if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) {\n            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n            if (desc && (desc.get || desc.set)) {\n                Object.defineProperty(newObj, key, desc);\n            } else {\n                newObj[key] = obj[key];\n            }\n        }\n    }\n    newObj.default = obj;\n    if (cache) {\n        cache.set(obj, newObj);\n    }\n    return newObj;\n}\nfunction normalizeConfig(config) {\n    // Quick structure validation\n    /**\n   * type FilePath = string\n   * type RawFile = { raw: string, extension?: string }\n   * type ExtractorFn = (content: string) => Array<string>\n   * type TransformerFn = (content: string) => string\n   *\n   * type Content =\n   *   | Array<FilePath | RawFile>\n   *   | {\n   *       files: Array<FilePath | RawFile>,\n   *       extract?: ExtractorFn | { [extension: string]: ExtractorFn }\n   *       transform?: TransformerFn | { [extension: string]: TransformerFn }\n   *   }\n   */ let valid = (()=>{\n        // `config.purge` should not exist anymore\n        if (config.purge) {\n            return false;\n        }\n        // `config.content` should exist\n        if (!config.content) {\n            return false;\n        }\n        // `config.content` should be an object or an array\n        if (!Array.isArray(config.content) && !(typeof config.content === \"object\" && config.content !== null)) {\n            return false;\n        }\n        // When `config.content` is an array, it should consist of FilePaths or RawFiles\n        if (Array.isArray(config.content)) {\n            return config.content.every((path)=>{\n                // `path` can be a string\n                if (typeof path === \"string\") return true;\n                // `path` can be an object { raw: string, extension?: string }\n                // `raw` must be a string\n                if (typeof (path === null || path === void 0 ? void 0 : path.raw) !== \"string\") return false;\n                // `extension` (if provided) should also be a string\n                if ((path === null || path === void 0 ? void 0 : path.extension) && typeof (path === null || path === void 0 ? void 0 : path.extension) !== \"string\") {\n                    return false;\n                }\n                return true;\n            });\n        }\n        // When `config.content` is an object\n        if (typeof config.content === \"object\" && config.content !== null) {\n            // Only `files`, `extract` and `transform` can exist in `config.content`\n            if (Object.keys(config.content).some((key)=>![\n                    \"files\",\n                    \"extract\",\n                    \"transform\"\n                ].includes(key))) {\n                return false;\n            }\n            // `config.content.files` should exist of FilePaths or RawFiles\n            if (Array.isArray(config.content.files)) {\n                if (!config.content.files.every((path)=>{\n                    // `path` can be a string\n                    if (typeof path === \"string\") return true;\n                    // `path` can be an object { raw: string, extension?: string }\n                    // `raw` must be a string\n                    if (typeof (path === null || path === void 0 ? void 0 : path.raw) !== \"string\") return false;\n                    // `extension` (if provided) should also be a string\n                    if ((path === null || path === void 0 ? void 0 : path.extension) && typeof (path === null || path === void 0 ? void 0 : path.extension) !== \"string\") {\n                        return false;\n                    }\n                    return true;\n                })) {\n                    return false;\n                }\n                // `config.content.extract` is optional, and can be a Function or a Record<String, Function>\n                if (typeof config.content.extract === \"object\") {\n                    for (let value of Object.values(config.content.extract)){\n                        if (typeof value !== \"function\") {\n                            return false;\n                        }\n                    }\n                } else if (!(config.content.extract === undefined || typeof config.content.extract === \"function\")) {\n                    return false;\n                }\n                // `config.content.transform` is optional, and can be a Function or a Record<String, Function>\n                if (typeof config.content.transform === \"object\") {\n                    for (let value1 of Object.values(config.content.transform)){\n                        if (typeof value1 !== \"function\") {\n                            return false;\n                        }\n                    }\n                } else if (!(config.content.transform === undefined || typeof config.content.transform === \"function\")) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        return false;\n    })();\n    if (!valid) {\n        _log.default.warn(\"purge-deprecation\", [\n            \"The `purge`/`content` options have changed in Tailwind CSS v3.0.\",\n            \"Update your configuration file to eliminate this warning.\",\n            \"https://tailwindcss.com/docs/upgrade-guide#configure-content-sources\", \n        ]);\n    }\n    // Normalize the `safelist`\n    config.safelist = (()=>{\n        var ref;\n        let { content , purge , safelist  } = config;\n        if (Array.isArray(safelist)) return safelist;\n        if (Array.isArray(content === null || content === void 0 ? void 0 : content.safelist)) return content.safelist;\n        if (Array.isArray(purge === null || purge === void 0 ? void 0 : purge.safelist)) return purge.safelist;\n        if (Array.isArray(purge === null || purge === void 0 ? void 0 : (ref = purge.options) === null || ref === void 0 ? void 0 : ref.safelist)) return purge.options.safelist;\n        return [];\n    })();\n    // Normalize prefix option\n    if (typeof config.prefix === \"function\") {\n        _log.default.warn(\"prefix-function\", [\n            \"As of Tailwind CSS v3.0, `prefix` cannot be a function.\",\n            \"Update `prefix` in your configuration to be a string to eliminate this warning.\",\n            \"https://tailwindcss.com/docs/upgrade-guide#prefix-cannot-be-a-function\", \n        ]);\n        config.prefix = \"\";\n    } else {\n        var _prefix;\n        config.prefix = (_prefix = config.prefix) !== null && _prefix !== void 0 ? _prefix : \"\";\n    }\n    // Normalize the `content`\n    config.content = {\n        files: (()=>{\n            let { content , purge  } = config;\n            if (Array.isArray(purge)) return purge;\n            if (Array.isArray(purge === null || purge === void 0 ? void 0 : purge.content)) return purge.content;\n            if (Array.isArray(content)) return content;\n            if (Array.isArray(content === null || content === void 0 ? void 0 : content.content)) return content.content;\n            if (Array.isArray(content === null || content === void 0 ? void 0 : content.files)) return content.files;\n            return [];\n        })(),\n        extract: (()=>{\n            let extract = (()=>{\n                var ref, ref1, ref2, ref3, ref4, ref5, ref6, ref7, ref8, ref9;\n                if ((ref = config.purge) === null || ref === void 0 ? void 0 : ref.extract) return config.purge.extract;\n                if ((ref1 = config.content) === null || ref1 === void 0 ? void 0 : ref1.extract) return config.content.extract;\n                if ((ref2 = config.purge) === null || ref2 === void 0 ? void 0 : (ref3 = ref2.extract) === null || ref3 === void 0 ? void 0 : ref3.DEFAULT) return config.purge.extract.DEFAULT;\n                if ((ref4 = config.content) === null || ref4 === void 0 ? void 0 : (ref5 = ref4.extract) === null || ref5 === void 0 ? void 0 : ref5.DEFAULT) return config.content.extract.DEFAULT;\n                if ((ref6 = config.purge) === null || ref6 === void 0 ? void 0 : (ref7 = ref6.options) === null || ref7 === void 0 ? void 0 : ref7.extractors) return config.purge.options.extractors;\n                if ((ref8 = config.content) === null || ref8 === void 0 ? void 0 : (ref9 = ref8.options) === null || ref9 === void 0 ? void 0 : ref9.extractors) return config.content.options.extractors;\n                return {};\n            })();\n            let extractors = {};\n            let defaultExtractor = (()=>{\n                var ref, ref1, ref2, ref3;\n                if ((ref = config.purge) === null || ref === void 0 ? void 0 : (ref1 = ref.options) === null || ref1 === void 0 ? void 0 : ref1.defaultExtractor) {\n                    return config.purge.options.defaultExtractor;\n                }\n                if ((ref2 = config.content) === null || ref2 === void 0 ? void 0 : (ref3 = ref2.options) === null || ref3 === void 0 ? void 0 : ref3.defaultExtractor) {\n                    return config.content.options.defaultExtractor;\n                }\n                return undefined;\n            })();\n            if (defaultExtractor !== undefined) {\n                extractors.DEFAULT = defaultExtractor;\n            }\n            // Functions\n            if (typeof extract === \"function\") {\n                extractors.DEFAULT = extract;\n            } else if (Array.isArray(extract)) {\n                for (let { extensions , extractor  } of extract !== null && extract !== void 0 ? extract : []){\n                    for (let extension of extensions){\n                        extractors[extension] = extractor;\n                    }\n                }\n            } else if (typeof extract === \"object\" && extract !== null) {\n                Object.assign(extractors, extract);\n            }\n            return extractors;\n        })(),\n        transform: (()=>{\n            let transform = (()=>{\n                var ref, ref1, ref2, ref3, ref4, ref5;\n                if ((ref = config.purge) === null || ref === void 0 ? void 0 : ref.transform) return config.purge.transform;\n                if ((ref1 = config.content) === null || ref1 === void 0 ? void 0 : ref1.transform) return config.content.transform;\n                if ((ref2 = config.purge) === null || ref2 === void 0 ? void 0 : (ref3 = ref2.transform) === null || ref3 === void 0 ? void 0 : ref3.DEFAULT) return config.purge.transform.DEFAULT;\n                if ((ref4 = config.content) === null || ref4 === void 0 ? void 0 : (ref5 = ref4.transform) === null || ref5 === void 0 ? void 0 : ref5.DEFAULT) return config.content.transform.DEFAULT;\n                return {};\n            })();\n            let transformers = {};\n            if (typeof transform === \"function\") {\n                transformers.DEFAULT = transform;\n            }\n            if (typeof transform === \"object\" && transform !== null) {\n                Object.assign(transformers, transform);\n            }\n            return transformers;\n        })()\n    };\n    // Validate globs to prevent bogus globs.\n    // E.g.: `./src/*.{html}` is invalid, the `{html}` should just be `html`\n    for (let file of config.content.files){\n        if (typeof file === \"string\" && /{([^,]*?)}/g.test(file)) {\n            _log.default.warn(\"invalid-glob-braces\", [\n                `The glob pattern ${(0, _log.dim)(file)} in your Tailwind CSS configuration is invalid.`,\n                `Update it to ${(0, _log.dim)(file.replace(/{([^,]*?)}/g, \"$1\"))} to silence this warning.`\n            ]);\n            break;\n        }\n    }\n    return config;\n}\n\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/tailwindcss/lib/util/normalizeConfig.js?");

/***/ }),

/***/ "./node_modules/tailwindcss/lib/util/normalizeScreens.js":
/*!***************************************************************!*\
  !*** ./node_modules/tailwindcss/lib/util/normalizeScreens.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("/**\n * A function that normalizes the various forms that the screens object can be\n * provided in.\n *\n * Input(s):\n *   - ['100px', '200px'] // Raw strings\n *   - { sm: '100px', md: '200px' } // Object with string values\n *   - { sm: { min: '100px' }, md: { max: '100px' } } // Object with object values\n *   - { sm: [{ min: '100px' }, { max: '200px' }] } // Object with object array (multiple values)\n *\n * Output(s):\n *   - [{ name: 'sm', values: [{ min: '100px', max: '200px' }] }] // List of objects, that contains multiple values\n */ \nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"normalizeScreens\", ({\n    enumerable: true,\n    get: ()=>normalizeScreens\n}));\nfunction normalizeScreens(screens, root = true) {\n    if (Array.isArray(screens)) {\n        return screens.map((screen)=>{\n            if (root && Array.isArray(screen)) {\n                throw new Error(\"The tuple syntax is not supported for `screens`.\");\n            }\n            if (typeof screen === \"string\") {\n                return {\n                    name: screen.toString(),\n                    values: [\n                        {\n                            min: screen,\n                            max: undefined\n                        }\n                    ]\n                };\n            }\n            let [name, options] = screen;\n            name = name.toString();\n            if (typeof options === \"string\") {\n                return {\n                    name,\n                    values: [\n                        {\n                            min: options,\n                            max: undefined\n                        }\n                    ]\n                };\n            }\n            if (Array.isArray(options)) {\n                return {\n                    name,\n                    values: options.map((option)=>resolveValue(option))\n                };\n            }\n            return {\n                name,\n                values: [\n                    resolveValue(options)\n                ]\n            };\n        });\n    }\n    return normalizeScreens(Object.entries(screens !== null && screens !== void 0 ? screens : {}), false);\n}\nfunction resolveValue({ \"min-width\": _minWidth , min =_minWidth , max , raw  } = {}) {\n    return {\n        min,\n        max,\n        raw\n    };\n}\n\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/tailwindcss/lib/util/normalizeScreens.js?");

/***/ }),

/***/ "./node_modules/tailwindcss/lib/util/parseAnimationValue.js":
/*!******************************************************************!*\
  !*** ./node_modules/tailwindcss/lib/util/parseAnimationValue.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"default\", ({\n    enumerable: true,\n    get: ()=>parseAnimationValue\n}));\nconst DIRECTIONS = new Set([\n    \"normal\",\n    \"reverse\",\n    \"alternate\",\n    \"alternate-reverse\"\n]);\nconst PLAY_STATES = new Set([\n    \"running\",\n    \"paused\"\n]);\nconst FILL_MODES = new Set([\n    \"none\",\n    \"forwards\",\n    \"backwards\",\n    \"both\"\n]);\nconst ITERATION_COUNTS = new Set([\n    \"infinite\"\n]);\nconst TIMINGS = new Set([\n    \"linear\",\n    \"ease\",\n    \"ease-in\",\n    \"ease-out\",\n    \"ease-in-out\",\n    \"step-start\",\n    \"step-end\", \n]);\nconst TIMING_FNS = [\n    \"cubic-bezier\",\n    \"steps\"\n];\nconst COMMA = /\\,(?![^(]*\\))/g // Comma separator that is not located between brackets. E.g.: `cubiz-bezier(a, b, c)` these don't count.\n;\nconst SPACE = /\\ +(?![^(]*\\))/g // Similar to the one above, but with spaces instead.\n;\nconst TIME = /^(-?[\\d.]+m?s)$/;\nconst DIGIT = /^(\\d+)$/;\nfunction parseAnimationValue(input) {\n    let animations = input.split(COMMA);\n    return animations.map((animation)=>{\n        let value = animation.trim();\n        let result = {\n            value\n        };\n        let parts = value.split(SPACE);\n        let seen = new Set();\n        for (let part of parts){\n            if (!seen.has(\"DIRECTIONS\") && DIRECTIONS.has(part)) {\n                result.direction = part;\n                seen.add(\"DIRECTIONS\");\n            } else if (!seen.has(\"PLAY_STATES\") && PLAY_STATES.has(part)) {\n                result.playState = part;\n                seen.add(\"PLAY_STATES\");\n            } else if (!seen.has(\"FILL_MODES\") && FILL_MODES.has(part)) {\n                result.fillMode = part;\n                seen.add(\"FILL_MODES\");\n            } else if (!seen.has(\"ITERATION_COUNTS\") && (ITERATION_COUNTS.has(part) || DIGIT.test(part))) {\n                result.iterationCount = part;\n                seen.add(\"ITERATION_COUNTS\");\n            } else if (!seen.has(\"TIMING_FUNCTION\") && TIMINGS.has(part)) {\n                result.timingFunction = part;\n                seen.add(\"TIMING_FUNCTION\");\n            } else if (!seen.has(\"TIMING_FUNCTION\") && TIMING_FNS.some((f)=>part.startsWith(`${f}(`))) {\n                result.timingFunction = part;\n                seen.add(\"TIMING_FUNCTION\");\n            } else if (!seen.has(\"DURATION\") && TIME.test(part)) {\n                result.duration = part;\n                seen.add(\"DURATION\");\n            } else if (!seen.has(\"DELAY\") && TIME.test(part)) {\n                result.delay = part;\n                seen.add(\"DELAY\");\n            } else if (!seen.has(\"NAME\")) {\n                result.name = part;\n                seen.add(\"NAME\");\n            } else {\n                if (!result.unknown) result.unknown = [];\n                result.unknown.push(part);\n            }\n        }\n        return result;\n    });\n}\n\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/tailwindcss/lib/util/parseAnimationValue.js?");

/***/ }),

/***/ "./node_modules/tailwindcss/lib/util/parseBoxShadowValue.js":
/*!******************************************************************!*\
  !*** ./node_modules/tailwindcss/lib/util/parseBoxShadowValue.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    parseBoxShadowValue: ()=>parseBoxShadowValue,\n    formatBoxShadowValue: ()=>formatBoxShadowValue\n});\nconst _splitAtTopLevelOnly = __webpack_require__(/*! ./splitAtTopLevelOnly */ \"./node_modules/tailwindcss/lib/util/splitAtTopLevelOnly.js\");\nlet KEYWORDS = new Set([\n    \"inset\",\n    \"inherit\",\n    \"initial\",\n    \"revert\",\n    \"unset\"\n]);\nlet SPACE = /\\ +(?![^(]*\\))/g // Similar to the one above, but with spaces instead.\n;\nlet LENGTH = /^-?(\\d+|\\.\\d+)(.*?)$/g;\nfunction parseBoxShadowValue(input) {\n    let shadows = Array.from((0, _splitAtTopLevelOnly.splitAtTopLevelOnly)(input, \",\"));\n    return shadows.map((shadow)=>{\n        let value = shadow.trim();\n        let result = {\n            raw: value\n        };\n        let parts = value.split(SPACE);\n        let seen = new Set();\n        for (let part of parts){\n            // Reset index, since the regex is stateful.\n            LENGTH.lastIndex = 0;\n            // Keyword\n            if (!seen.has(\"KEYWORD\") && KEYWORDS.has(part)) {\n                result.keyword = part;\n                seen.add(\"KEYWORD\");\n            } else if (LENGTH.test(part)) {\n                if (!seen.has(\"X\")) {\n                    result.x = part;\n                    seen.add(\"X\");\n                } else if (!seen.has(\"Y\")) {\n                    result.y = part;\n                    seen.add(\"Y\");\n                } else if (!seen.has(\"BLUR\")) {\n                    result.blur = part;\n                    seen.add(\"BLUR\");\n                } else if (!seen.has(\"SPREAD\")) {\n                    result.spread = part;\n                    seen.add(\"SPREAD\");\n                }\n            } else {\n                if (!result.color) {\n                    result.color = part;\n                } else {\n                    if (!result.unknown) result.unknown = [];\n                    result.unknown.push(part);\n                }\n            }\n        }\n        // Check if valid\n        result.valid = result.x !== undefined && result.y !== undefined;\n        return result;\n    });\n}\nfunction formatBoxShadowValue(shadows) {\n    return shadows.map((shadow)=>{\n        if (!shadow.valid) {\n            return shadow.raw;\n        }\n        return [\n            shadow.keyword,\n            shadow.x,\n            shadow.y,\n            shadow.blur,\n            shadow.spread,\n            shadow.color\n        ].filter(Boolean).join(\" \");\n    }).join(\", \");\n}\n\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/tailwindcss/lib/util/parseBoxShadowValue.js?");

/***/ }),

/***/ "./node_modules/tailwindcss/lib/util/parseDependency.js":
/*!**************************************************************!*\
  !*** ./node_modules/tailwindcss/lib/util/parseDependency.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"default\", ({\n    enumerable: true,\n    get: ()=>parseDependency\n}));\nconst _isGlob = /*#__PURE__*/ _interopRequireDefault(__webpack_require__(/*! is-glob */ \"./node_modules/is-glob/index.js\"));\nconst _globParent = /*#__PURE__*/ _interopRequireDefault(__webpack_require__(/*! glob-parent */ \"./node_modules/glob-parent/index.js\"));\nconst _path = /*#__PURE__*/ _interopRequireDefault(__webpack_require__(Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'path'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }())));\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        default: obj\n    };\n}\n// Based on `glob-base`\n// https://github.com/micromatch/glob-base/blob/master/index.js\nfunction parseGlob(pattern) {\n    let glob = pattern;\n    let base = (0, _globParent.default)(pattern);\n    if (base !== \".\") {\n        glob = pattern.substr(base.length);\n        if (glob.charAt(0) === \"/\") {\n            glob = glob.substr(1);\n        }\n    }\n    if (glob.substr(0, 2) === \"./\") {\n        glob = glob.substr(2);\n    }\n    if (glob.charAt(0) === \"/\") {\n        glob = glob.substr(1);\n    }\n    return {\n        base,\n        glob\n    };\n}\nfunction parseDependency(normalizedFileOrGlob) {\n    if (normalizedFileOrGlob.startsWith(\"!\")) {\n        return null;\n    }\n    let message;\n    if ((0, _isGlob.default)(normalizedFileOrGlob)) {\n        let { base , glob  } = parseGlob(normalizedFileOrGlob);\n        message = {\n            type: \"dir-dependency\",\n            dir: _path.default.resolve(base),\n            glob\n        };\n    } else {\n        message = {\n            type: \"dependency\",\n            file: _path.default.resolve(normalizedFileOrGlob)\n        };\n    }\n    // rollup-plugin-postcss does not support dir-dependency messages\n    // but directories can be watched in the same way as files\n    if (message.type === \"dir-dependency\" && process.env.ROLLUP_WATCH === \"true\") {\n        message = {\n            type: \"dependency\",\n            file: message.dir\n        };\n    }\n    return message;\n}\n\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/tailwindcss/lib/util/parseDependency.js?");

/***/ }),

/***/ "./node_modules/tailwindcss/lib/util/parseObjectStyles.js":
/*!****************************************************************!*\
  !*** ./node_modules/tailwindcss/lib/util/parseObjectStyles.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"default\", ({\n    enumerable: true,\n    get: ()=>parseObjectStyles\n}));\nconst _postcss = /*#__PURE__*/ _interopRequireDefault(__webpack_require__(/*! postcss */ \"./node_modules/postcss/lib/postcss.js\"));\nconst _postcssNested = /*#__PURE__*/ _interopRequireDefault(__webpack_require__(/*! postcss-nested */ \"./node_modules/postcss-nested/index.js\"));\nconst _postcssJs = /*#__PURE__*/ _interopRequireDefault(__webpack_require__(/*! postcss-js */ \"./node_modules/postcss-js/index.js\"));\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        default: obj\n    };\n}\nfunction parseObjectStyles(styles) {\n    if (!Array.isArray(styles)) {\n        return parseObjectStyles([\n            styles\n        ]);\n    }\n    return styles.flatMap((style)=>{\n        return (0, _postcss.default)([\n            (0, _postcssNested.default)({\n                bubble: [\n                    \"screen\"\n                ]\n            }), \n        ]).process(style, {\n            parser: _postcssJs.default\n        }).root.nodes;\n    });\n}\n\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/tailwindcss/lib/util/parseObjectStyles.js?");

/***/ }),

/***/ "./node_modules/tailwindcss/lib/util/pluginUtils.js":
/*!**********************************************************!*\
  !*** ./node_modules/tailwindcss/lib/util/pluginUtils.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    updateAllClasses: ()=>updateAllClasses,\n    asValue: ()=>asValue,\n    parseColorFormat: ()=>parseColorFormat,\n    asColor: ()=>asColor,\n    asLookupValue: ()=>asLookupValue,\n    coerceValue: ()=>coerceValue\n});\nconst _postcssSelectorParser = /*#__PURE__*/ _interopRequireDefault(__webpack_require__(/*! postcss-selector-parser */ \"./node_modules/postcss-selector-parser/dist/index.js\"));\nconst _escapeCommas = /*#__PURE__*/ _interopRequireDefault(__webpack_require__(/*! ./escapeCommas */ \"./node_modules/tailwindcss/lib/util/escapeCommas.js\"));\nconst _withAlphaVariable = __webpack_require__(/*! ./withAlphaVariable */ \"./node_modules/tailwindcss/lib/util/withAlphaVariable.js\");\nconst _dataTypes = __webpack_require__(/*! ./dataTypes */ \"./node_modules/tailwindcss/lib/util/dataTypes.js\");\nconst _negateValue = /*#__PURE__*/ _interopRequireDefault(__webpack_require__(/*! ./negateValue */ \"./node_modules/tailwindcss/lib/util/negateValue.js\"));\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        default: obj\n    };\n}\nfunction updateAllClasses(selectors, updateClass) {\n    let parser = (0, _postcssSelectorParser.default)((selectors)=>{\n        selectors.walkClasses((sel)=>{\n            let updatedClass = updateClass(sel.value);\n            sel.value = updatedClass;\n            if (sel.raws && sel.raws.value) {\n                sel.raws.value = (0, _escapeCommas.default)(sel.raws.value);\n            }\n        });\n    });\n    let result = parser.processSync(selectors);\n    return result;\n}\nfunction resolveArbitraryValue(modifier, validate) {\n    if (!isArbitraryValue(modifier)) {\n        return undefined;\n    }\n    let value = modifier.slice(1, -1);\n    if (!validate(value)) {\n        return undefined;\n    }\n    return (0, _dataTypes.normalize)(value);\n}\nfunction asNegativeValue(modifier, lookup = {}, validate) {\n    let positiveValue = lookup[modifier];\n    if (positiveValue !== undefined) {\n        return (0, _negateValue.default)(positiveValue);\n    }\n    if (isArbitraryValue(modifier)) {\n        let resolved = resolveArbitraryValue(modifier, validate);\n        if (resolved === undefined) {\n            return undefined;\n        }\n        return (0, _negateValue.default)(resolved);\n    }\n}\nfunction asValue(modifier, options = {}, { validate =()=>true  } = {}) {\n    var ref;\n    let value = (ref = options.values) === null || ref === void 0 ? void 0 : ref[modifier];\n    if (value !== undefined) {\n        return value;\n    }\n    if (options.supportsNegativeValues && modifier.startsWith(\"-\")) {\n        return asNegativeValue(modifier.slice(1), options.values, validate);\n    }\n    return resolveArbitraryValue(modifier, validate);\n}\nfunction isArbitraryValue(input) {\n    return input.startsWith(\"[\") && input.endsWith(\"]\");\n}\nfunction splitAlpha(modifier) {\n    let slashIdx = modifier.lastIndexOf(\"/\");\n    if (slashIdx === -1 || slashIdx === modifier.length - 1) {\n        return [\n            modifier\n        ];\n    }\n    return [\n        modifier.slice(0, slashIdx),\n        modifier.slice(slashIdx + 1)\n    ];\n}\nfunction parseColorFormat(value) {\n    if (typeof value === \"string\" && value.includes(\"<alpha-value>\")) {\n        let oldValue = value;\n        return ({ opacityValue =1  })=>oldValue.replace(\"<alpha-value>\", opacityValue);\n    }\n    return value;\n}\nfunction asColor(modifier, options = {}, { tailwindConfig ={}  } = {}) {\n    var ref;\n    if (((ref = options.values) === null || ref === void 0 ? void 0 : ref[modifier]) !== undefined) {\n        var ref1;\n        return parseColorFormat((ref1 = options.values) === null || ref1 === void 0 ? void 0 : ref1[modifier]);\n    }\n    let [color, alpha] = splitAlpha(modifier);\n    if (alpha !== undefined) {\n        var ref2, ref3, ref4;\n        var ref5;\n        let normalizedColor = (ref5 = (ref2 = options.values) === null || ref2 === void 0 ? void 0 : ref2[color]) !== null && ref5 !== void 0 ? ref5 : isArbitraryValue(color) ? color.slice(1, -1) : undefined;\n        if (normalizedColor === undefined) {\n            return undefined;\n        }\n        normalizedColor = parseColorFormat(normalizedColor);\n        if (isArbitraryValue(alpha)) {\n            return (0, _withAlphaVariable.withAlphaValue)(normalizedColor, alpha.slice(1, -1));\n        }\n        if (((ref3 = tailwindConfig.theme) === null || ref3 === void 0 ? void 0 : (ref4 = ref3.opacity) === null || ref4 === void 0 ? void 0 : ref4[alpha]) === undefined) {\n            return undefined;\n        }\n        return (0, _withAlphaVariable.withAlphaValue)(normalizedColor, tailwindConfig.theme.opacity[alpha]);\n    }\n    return asValue(modifier, options, {\n        validate: _dataTypes.color\n    });\n}\nfunction asLookupValue(modifier, options = {}) {\n    var ref;\n    return (ref = options.values) === null || ref === void 0 ? void 0 : ref[modifier];\n}\nfunction guess(validate) {\n    return (modifier, options)=>{\n        return asValue(modifier, options, {\n            validate\n        });\n    };\n}\nlet typeMap = {\n    any: asValue,\n    color: asColor,\n    url: guess(_dataTypes.url),\n    image: guess(_dataTypes.image),\n    length: guess(_dataTypes.length),\n    percentage: guess(_dataTypes.percentage),\n    position: guess(_dataTypes.position),\n    lookup: asLookupValue,\n    \"generic-name\": guess(_dataTypes.genericName),\n    \"family-name\": guess(_dataTypes.familyName),\n    number: guess(_dataTypes.number),\n    \"line-width\": guess(_dataTypes.lineWidth),\n    \"absolute-size\": guess(_dataTypes.absoluteSize),\n    \"relative-size\": guess(_dataTypes.relativeSize),\n    shadow: guess(_dataTypes.shadow)\n};\nlet supportedTypes = Object.keys(typeMap);\nfunction splitAtFirst(input, delim) {\n    let idx = input.indexOf(delim);\n    if (idx === -1) return [\n        undefined,\n        input\n    ];\n    return [\n        input.slice(0, idx),\n        input.slice(idx + 1)\n    ];\n}\nfunction coerceValue(types, modifier, options, tailwindConfig) {\n    if (isArbitraryValue(modifier)) {\n        let arbitraryValue = modifier.slice(1, -1);\n        let [explicitType, value] = splitAtFirst(arbitraryValue, \":\");\n        // It could be that this resolves to `url(https` which is not a valid\n        // identifier. We currently only support \"simple\" words with dashes or\n        // underscores. E.g.: family-name\n        if (!/^[\\w-_]+$/g.test(explicitType)) {\n            value = arbitraryValue;\n        } else if (explicitType !== undefined && !supportedTypes.includes(explicitType)) {\n            return [];\n        }\n        if (value.length > 0 && supportedTypes.includes(explicitType)) {\n            return [\n                asValue(`[${value}]`, options),\n                explicitType\n            ];\n        }\n    }\n    // Find first matching type\n    for (let type of [].concat(types)){\n        let result = typeMap[type](modifier, options, {\n            tailwindConfig\n        });\n        if (result !== undefined) return [\n            result,\n            type\n        ];\n    }\n    return [];\n}\n\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/tailwindcss/lib/util/pluginUtils.js?");

/***/ }),

/***/ "./node_modules/tailwindcss/lib/util/prefixSelector.js":
/*!*************************************************************!*\
  !*** ./node_modules/tailwindcss/lib/util/prefixSelector.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"default\", ({\n    enumerable: true,\n    get: ()=>_default\n}));\nconst _postcssSelectorParser = /*#__PURE__*/ _interopRequireDefault(__webpack_require__(/*! postcss-selector-parser */ \"./node_modules/postcss-selector-parser/dist/index.js\"));\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        default: obj\n    };\n}\nfunction _default(prefix, selector, prependNegative = false) {\n    return (0, _postcssSelectorParser.default)((selectors)=>{\n        selectors.walkClasses((classSelector)=>{\n            let baseClass = classSelector.value;\n            let shouldPlaceNegativeBeforePrefix = prependNegative && baseClass.startsWith(\"-\");\n            classSelector.value = shouldPlaceNegativeBeforePrefix ? `-${prefix}${baseClass.slice(1)}` : `${prefix}${baseClass}`;\n        });\n    }).processSync(selector);\n}\n\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/tailwindcss/lib/util/prefixSelector.js?");

/***/ }),

/***/ "./node_modules/tailwindcss/lib/util/removeAlphaVariables.js":
/*!*******************************************************************!*\
  !*** ./node_modules/tailwindcss/lib/util/removeAlphaVariables.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("/**\n * This function removes any uses of CSS variables used as an alpha channel\n *\n * This is required for selectors like `:visited` which do not allow\n * changes in opacity or external control using CSS variables.\n *\n * @param {import('postcss').Container} container\n * @param {string[]} toRemove\n */ \nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"removeAlphaVariables\", ({\n    enumerable: true,\n    get: ()=>removeAlphaVariables\n}));\nfunction removeAlphaVariables(container, toRemove) {\n    container.walkDecls((decl)=>{\n        if (toRemove.includes(decl.prop)) {\n            decl.remove();\n            return;\n        }\n        for (let varName of toRemove){\n            if (decl.value.includes(`/ var(${varName})`)) {\n                decl.value = decl.value.replace(`/ var(${varName})`, \"\");\n            }\n        }\n    });\n}\n\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/tailwindcss/lib/util/removeAlphaVariables.js?");

/***/ }),

/***/ "./node_modules/tailwindcss/lib/util/resolveConfig.js":
/*!************************************************************!*\
  !*** ./node_modules/tailwindcss/lib/util/resolveConfig.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"default\", ({\n    enumerable: true,\n    get: ()=>resolveConfig\n}));\nconst _negateValue = /*#__PURE__*/ _interopRequireDefault(__webpack_require__(/*! ./negateValue */ \"./node_modules/tailwindcss/lib/util/negateValue.js\"));\nconst _corePluginList = /*#__PURE__*/ _interopRequireDefault(__webpack_require__(/*! ../corePluginList */ \"./node_modules/tailwindcss/lib/corePluginList.js\"));\nconst _configurePlugins = /*#__PURE__*/ _interopRequireDefault(__webpack_require__(/*! ./configurePlugins */ \"./node_modules/tailwindcss/lib/util/configurePlugins.js\"));\nconst _defaultConfigStub = /*#__PURE__*/ _interopRequireDefault(__webpack_require__(/*! ../../stubs/defaultConfig.stub */ \"./node_modules/tailwindcss/stubs/defaultConfig.stub.js\"));\nconst _colors = /*#__PURE__*/ _interopRequireDefault(__webpack_require__(/*! ../public/colors */ \"./node_modules/tailwindcss/lib/public/colors.js\"));\nconst _defaults = __webpack_require__(/*! ./defaults */ \"./node_modules/tailwindcss/lib/util/defaults.js\");\nconst _toPath = __webpack_require__(/*! ./toPath */ \"./node_modules/tailwindcss/lib/util/toPath.js\");\nconst _normalizeConfig = __webpack_require__(/*! ./normalizeConfig */ \"./node_modules/tailwindcss/lib/util/normalizeConfig.js\");\nconst _isPlainObject = /*#__PURE__*/ _interopRequireDefault(__webpack_require__(/*! ./isPlainObject */ \"./node_modules/tailwindcss/lib/util/isPlainObject.js\"));\nconst _cloneDeep = __webpack_require__(/*! ./cloneDeep */ \"./node_modules/tailwindcss/lib/util/cloneDeep.js\");\nconst _pluginUtils = __webpack_require__(/*! ./pluginUtils */ \"./node_modules/tailwindcss/lib/util/pluginUtils.js\");\nconst _withAlphaVariable = __webpack_require__(/*! ./withAlphaVariable */ \"./node_modules/tailwindcss/lib/util/withAlphaVariable.js\");\nconst _toColorValue = /*#__PURE__*/ _interopRequireDefault(__webpack_require__(/*! ./toColorValue */ \"./node_modules/tailwindcss/lib/util/toColorValue.js\"));\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        default: obj\n    };\n}\nfunction isFunction(input) {\n    return typeof input === \"function\";\n}\nfunction isObject(input) {\n    return typeof input === \"object\" && input !== null;\n}\nfunction mergeWith(target, ...sources) {\n    let customizer = sources.pop();\n    for (let source of sources){\n        for(let k in source){\n            let merged = customizer(target[k], source[k]);\n            if (merged === undefined) {\n                if (isObject(target[k]) && isObject(source[k])) {\n                    target[k] = mergeWith(target[k], source[k], customizer);\n                } else {\n                    target[k] = source[k];\n                }\n            } else {\n                target[k] = merged;\n            }\n        }\n    }\n    return target;\n}\nconst configUtils = {\n    colors: _colors.default,\n    negative (scale) {\n        // TODO: Log that this function isn't really needed anymore?\n        return Object.keys(scale).filter((key)=>scale[key] !== \"0\").reduce((negativeScale, key)=>{\n            let negativeValue = (0, _negateValue.default)(scale[key]);\n            if (negativeValue !== undefined) {\n                negativeScale[`-${key}`] = negativeValue;\n            }\n            return negativeScale;\n        }, {});\n    },\n    breakpoints (screens) {\n        return Object.keys(screens).filter((key)=>typeof screens[key] === \"string\").reduce((breakpoints, key)=>({\n                ...breakpoints,\n                [`screen-${key}`]: screens[key]\n            }), {});\n    }\n};\nfunction value(valueToResolve, ...args) {\n    return isFunction(valueToResolve) ? valueToResolve(...args) : valueToResolve;\n}\nfunction collectExtends(items) {\n    return items.reduce((merged, { extend  })=>{\n        return mergeWith(merged, extend, (mergedValue, extendValue)=>{\n            if (mergedValue === undefined) {\n                return [\n                    extendValue\n                ];\n            }\n            if (Array.isArray(mergedValue)) {\n                return [\n                    extendValue,\n                    ...mergedValue\n                ];\n            }\n            return [\n                extendValue,\n                mergedValue\n            ];\n        });\n    }, {});\n}\nfunction mergeThemes(themes) {\n    return {\n        ...themes.reduce((merged, theme)=>(0, _defaults.defaults)(merged, theme), {}),\n        // In order to resolve n config objects, we combine all of their `extend` properties\n        // into arrays instead of objects so they aren't overridden.\n        extend: collectExtends(themes)\n    };\n}\nfunction mergeExtensionCustomizer(merged, value) {\n    // When we have an array of objects, we do want to merge it\n    if (Array.isArray(merged) && isObject(merged[0])) {\n        return merged.concat(value);\n    }\n    // When the incoming value is an array, and the existing config is an object, prepend the existing object\n    if (Array.isArray(value) && isObject(value[0]) && isObject(merged)) {\n        return [\n            merged,\n            ...value\n        ];\n    }\n    // Override arrays (for example for font-families, box-shadows, ...)\n    if (Array.isArray(value)) {\n        return value;\n    }\n    // Execute default behaviour\n    return undefined;\n}\nfunction mergeExtensions({ extend , ...theme }) {\n    return mergeWith(theme, extend, (themeValue, extensions)=>{\n        // The `extend` property is an array, so we need to check if it contains any functions\n        if (!isFunction(themeValue) && !extensions.some(isFunction)) {\n            return mergeWith({}, themeValue, ...extensions, mergeExtensionCustomizer);\n        }\n        return (resolveThemePath, utils)=>mergeWith({}, ...[\n                themeValue,\n                ...extensions\n            ].map((e)=>value(e, resolveThemePath, utils)), mergeExtensionCustomizer);\n    });\n}\n/**\n *\n * @param {string} key\n * @return {Iterable<string[] & {alpha: string | undefined}>}\n */ function* toPaths(key) {\n    let path = (0, _toPath.toPath)(key);\n    if (path.length === 0) {\n        return;\n    }\n    yield path;\n    if (Array.isArray(key)) {\n        return;\n    }\n    let pattern = /^(.*?)\\s*\\/\\s*([^/]+)$/;\n    let matches = key.match(pattern);\n    if (matches !== null) {\n        let [, prefix, alpha] = matches;\n        let newPath = (0, _toPath.toPath)(prefix);\n        newPath.alpha = alpha;\n        yield newPath;\n    }\n}\nfunction resolveFunctionKeys(object) {\n    // theme('colors.red.500 / 0.5') -> ['colors', 'red', '500 / 0', '5]\n    const resolvePath = (key, defaultValue)=>{\n        for (const path of toPaths(key)){\n            let index = 0;\n            let val = object;\n            while(val !== undefined && val !== null && index < path.length){\n                val = val[path[index++]];\n                let shouldResolveAsFn = isFunction(val) && (path.alpha === undefined || index <= path.length - 1);\n                val = shouldResolveAsFn ? val(resolvePath, configUtils) : val;\n            }\n            if (val !== undefined) {\n                if (path.alpha !== undefined) {\n                    let normalized = (0, _pluginUtils.parseColorFormat)(val);\n                    return (0, _withAlphaVariable.withAlphaValue)(normalized, path.alpha, (0, _toColorValue.default)(normalized));\n                }\n                if ((0, _isPlainObject.default)(val)) {\n                    return (0, _cloneDeep.cloneDeep)(val);\n                }\n                return val;\n            }\n        }\n        return defaultValue;\n    };\n    Object.assign(resolvePath, {\n        theme: resolvePath,\n        ...configUtils\n    });\n    return Object.keys(object).reduce((resolved, key)=>{\n        resolved[key] = isFunction(object[key]) ? object[key](resolvePath, configUtils) : object[key];\n        return resolved;\n    }, {});\n}\nfunction extractPluginConfigs(configs) {\n    let allConfigs = [];\n    configs.forEach((config)=>{\n        allConfigs = [\n            ...allConfigs,\n            config\n        ];\n        var ref;\n        const plugins = (ref = config === null || config === void 0 ? void 0 : config.plugins) !== null && ref !== void 0 ? ref : [];\n        if (plugins.length === 0) {\n            return;\n        }\n        plugins.forEach((plugin)=>{\n            if (plugin.__isOptionsFunction) {\n                plugin = plugin();\n            }\n            var ref;\n            allConfigs = [\n                ...allConfigs,\n                ...extractPluginConfigs([\n                    (ref = plugin === null || plugin === void 0 ? void 0 : plugin.config) !== null && ref !== void 0 ? ref : {}\n                ])\n            ];\n        });\n    });\n    return allConfigs;\n}\nfunction resolveCorePlugins(corePluginConfigs) {\n    const result = [\n        ...corePluginConfigs\n    ].reduceRight((resolved, corePluginConfig)=>{\n        if (isFunction(corePluginConfig)) {\n            return corePluginConfig({\n                corePlugins: resolved\n            });\n        }\n        return (0, _configurePlugins.default)(corePluginConfig, resolved);\n    }, _corePluginList.default);\n    return result;\n}\nfunction resolvePluginLists(pluginLists) {\n    const result = [\n        ...pluginLists\n    ].reduceRight((resolved, pluginList)=>{\n        return [\n            ...resolved,\n            ...pluginList\n        ];\n    }, []);\n    return result;\n}\nfunction resolveConfig(configs) {\n    let allConfigs = [\n        ...extractPluginConfigs(configs),\n        {\n            prefix: \"\",\n            important: false,\n            separator: \":\",\n            variantOrder: _defaultConfigStub.default.variantOrder\n        }, \n    ];\n    var ref, ref1;\n    return (0, _normalizeConfig.normalizeConfig)((0, _defaults.defaults)({\n        theme: resolveFunctionKeys(mergeExtensions(mergeThemes(allConfigs.map((t)=>{\n            return (ref = t === null || t === void 0 ? void 0 : t.theme) !== null && ref !== void 0 ? ref : {};\n        })))),\n        corePlugins: resolveCorePlugins(allConfigs.map((c)=>c.corePlugins)),\n        plugins: resolvePluginLists(configs.map((c)=>{\n            return (ref1 = c === null || c === void 0 ? void 0 : c.plugins) !== null && ref1 !== void 0 ? ref1 : [];\n        }))\n    }, ...allConfigs));\n}\n\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/tailwindcss/lib/util/resolveConfig.js?");

/***/ }),

/***/ "./node_modules/tailwindcss/lib/util/resolveConfigPath.js":
/*!****************************************************************!*\
  !*** ./node_modules/tailwindcss/lib/util/resolveConfigPath.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"default\", ({\n    enumerable: true,\n    get: ()=>resolveConfigPath\n}));\nconst _fs = /*#__PURE__*/ _interopRequireDefault(__webpack_require__(Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'fs'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }())));\nconst _path = /*#__PURE__*/ _interopRequireDefault(__webpack_require__(Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'path'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }())));\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        default: obj\n    };\n}\nfunction isObject(value) {\n    return typeof value === \"object\" && value !== null;\n}\nfunction isEmpty(obj) {\n    return Object.keys(obj).length === 0;\n}\nfunction isString(value) {\n    return typeof value === \"string\" || value instanceof String;\n}\nfunction resolveConfigPath(pathOrConfig) {\n    // require('tailwindcss')({ theme: ..., variants: ... })\n    if (isObject(pathOrConfig) && pathOrConfig.config === undefined && !isEmpty(pathOrConfig)) {\n        return null;\n    }\n    // require('tailwindcss')({ config: 'custom-config.js' })\n    if (isObject(pathOrConfig) && pathOrConfig.config !== undefined && isString(pathOrConfig.config)) {\n        return _path.default.resolve(pathOrConfig.config);\n    }\n    // require('tailwindcss')({ config: { theme: ..., variants: ... } })\n    if (isObject(pathOrConfig) && pathOrConfig.config !== undefined && isObject(pathOrConfig.config)) {\n        return null;\n    }\n    // require('tailwindcss')('custom-config.js')\n    if (isString(pathOrConfig)) {\n        return _path.default.resolve(pathOrConfig);\n    }\n    // require('tailwindcss')\n    for (const configFile of [\n        \"./tailwind.config.js\",\n        \"./tailwind.config.cjs\"\n    ]){\n        try {\n            const configPath = _path.default.resolve(configFile);\n            _fs.default.accessSync(configPath);\n            return configPath;\n        } catch (err) {}\n    }\n    return null;\n}\n\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/tailwindcss/lib/util/resolveConfigPath.js?");

/***/ }),

/***/ "./node_modules/tailwindcss/lib/util/splitAtTopLevelOnly.js":
/*!******************************************************************!*\
  !*** ./node_modules/tailwindcss/lib/util/splitAtTopLevelOnly.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"splitAtTopLevelOnly\", ({\n    enumerable: true,\n    get: ()=>splitAtTopLevelOnly\n}));\nconst _regex = /*#__PURE__*/ _interopRequireWildcard(__webpack_require__(/*! ../lib/regex */ \"./node_modules/tailwindcss/lib/lib/regex.js\"));\nfunction _getRequireWildcardCache(nodeInterop) {\n    if (typeof WeakMap !== \"function\") return null;\n    var cacheBabelInterop = new WeakMap();\n    var cacheNodeInterop = new WeakMap();\n    return (_getRequireWildcardCache = function(nodeInterop) {\n        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;\n    })(nodeInterop);\n}\nfunction _interopRequireWildcard(obj, nodeInterop) {\n    if (!nodeInterop && obj && obj.__esModule) {\n        return obj;\n    }\n    if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n        return {\n            default: obj\n        };\n    }\n    var cache = _getRequireWildcardCache(nodeInterop);\n    if (cache && cache.has(obj)) {\n        return cache.get(obj);\n    }\n    var newObj = {};\n    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n    for(var key in obj){\n        if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) {\n            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n            if (desc && (desc.get || desc.set)) {\n                Object.defineProperty(newObj, key, desc);\n            } else {\n                newObj[key] = obj[key];\n            }\n        }\n    }\n    newObj.default = obj;\n    if (cache) {\n        cache.set(obj, newObj);\n    }\n    return newObj;\n}\nfunction* splitAtTopLevelOnly(input, separator) {\n    let SPECIALS = new RegExp(`[(){}\\\\[\\\\]${_regex.escape(separator)}]`, \"g\");\n    let depth = 0;\n    let lastIndex = 0;\n    let found = false;\n    let separatorIndex = 0;\n    let separatorStart = 0;\n    let separatorLength = separator.length;\n    // Find all paren-like things & character\n    // And only split on commas if they're top-level\n    for (let match of input.matchAll(SPECIALS)){\n        let matchesSeparator = match[0] === separator[separatorIndex];\n        let atEndOfSeparator = separatorIndex === separatorLength - 1;\n        let matchesFullSeparator = matchesSeparator && atEndOfSeparator;\n        if (match[0] === \"(\") depth++;\n        if (match[0] === \")\") depth--;\n        if (match[0] === \"[\") depth++;\n        if (match[0] === \"]\") depth--;\n        if (match[0] === \"{\") depth++;\n        if (match[0] === \"}\") depth--;\n        if (matchesSeparator && depth === 0) {\n            if (separatorStart === 0) {\n                separatorStart = match.index;\n            }\n            separatorIndex++;\n        }\n        if (matchesFullSeparator && depth === 0) {\n            found = true;\n            yield input.substring(lastIndex, separatorStart);\n            lastIndex = separatorStart + separatorLength;\n        }\n        if (separatorIndex === separatorLength) {\n            separatorIndex = 0;\n            separatorStart = 0;\n        }\n    }\n    // Provide the last segment of the string if available\n    // Otherwise the whole string since no `char`s were found\n    // This mirrors the behavior of string.split()\n    if (found) {\n        yield input.substring(lastIndex);\n    } else {\n        yield input;\n    }\n}\n\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/tailwindcss/lib/util/splitAtTopLevelOnly.js?");

/***/ }),

/***/ "./node_modules/tailwindcss/lib/util/toColorValue.js":
/*!***********************************************************!*\
  !*** ./node_modules/tailwindcss/lib/util/toColorValue.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"default\", ({\n    enumerable: true,\n    get: ()=>toColorValue\n}));\nfunction toColorValue(maybeFunction) {\n    return typeof maybeFunction === \"function\" ? maybeFunction({}) : maybeFunction;\n}\n\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/tailwindcss/lib/util/toColorValue.js?");

/***/ }),

/***/ "./node_modules/tailwindcss/lib/util/toPath.js":
/*!*****************************************************!*\
  !*** ./node_modules/tailwindcss/lib/util/toPath.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("/**\n * Parse a path string into an array of path segments.\n *\n * Square bracket notation `a[b]` may be used to \"escape\" dots that would otherwise be interpreted as path separators.\n *\n * Example:\n * a -> ['a']\n * a.b.c -> ['a', 'b', 'c']\n * a[b].c -> ['a', 'b', 'c']\n * a[b.c].e.f -> ['a', 'b.c', 'e', 'f']\n * a[b][c][d] -> ['a', 'b', 'c', 'd']\n *\n * @param {string|string[]} path\n **/ \nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"toPath\", ({\n    enumerable: true,\n    get: ()=>toPath\n}));\nfunction toPath(path) {\n    if (Array.isArray(path)) return path;\n    let openBrackets = path.split(\"[\").length - 1;\n    let closedBrackets = path.split(\"]\").length - 1;\n    if (openBrackets !== closedBrackets) {\n        throw new Error(`Path is invalid. Has unbalanced brackets: ${path}`);\n    }\n    return path.split(/\\.(?![^\\[]*\\])|[\\[\\]]/g).filter(Boolean);\n}\n\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/tailwindcss/lib/util/toPath.js?");

/***/ }),

/***/ "./node_modules/tailwindcss/lib/util/transformThemeValue.js":
/*!******************************************************************!*\
  !*** ./node_modules/tailwindcss/lib/util/transformThemeValue.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"default\", ({\n    enumerable: true,\n    get: ()=>transformThemeValue\n}));\nconst _postcss = /*#__PURE__*/ _interopRequireDefault(__webpack_require__(/*! postcss */ \"./node_modules/postcss/lib/postcss.js\"));\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        default: obj\n    };\n}\nfunction transformThemeValue(themeSection) {\n    if ([\n        \"fontSize\",\n        \"outline\"\n    ].includes(themeSection)) {\n        return (value)=>{\n            if (typeof value === \"function\") value = value({});\n            if (Array.isArray(value)) value = value[0];\n            return value;\n        };\n    }\n    if ([\n        \"fontFamily\",\n        \"boxShadow\",\n        \"transitionProperty\",\n        \"transitionDuration\",\n        \"transitionDelay\",\n        \"transitionTimingFunction\",\n        \"backgroundImage\",\n        \"backgroundSize\",\n        \"backgroundColor\",\n        \"cursor\",\n        \"animation\", \n    ].includes(themeSection)) {\n        return (value)=>{\n            if (typeof value === \"function\") value = value({});\n            if (Array.isArray(value)) value = value.join(\", \");\n            return value;\n        };\n    }\n    // For backwards compatibility reasons, before we switched to underscores\n    // instead of commas for arbitrary values.\n    if ([\n        \"gridTemplateColumns\",\n        \"gridTemplateRows\",\n        \"objectPosition\"\n    ].includes(themeSection)) {\n        return (value)=>{\n            if (typeof value === \"function\") value = value({});\n            if (typeof value === \"string\") value = _postcss.default.list.comma(value).join(\" \");\n            return value;\n        };\n    }\n    return (value, opts = {})=>{\n        if (typeof value === \"function\") {\n            value = value(opts);\n        }\n        return value;\n    };\n}\n\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/tailwindcss/lib/util/transformThemeValue.js?");

/***/ }),

/***/ "./node_modules/tailwindcss/lib/util/validateConfig.js":
/*!*************************************************************!*\
  !*** ./node_modules/tailwindcss/lib/util/validateConfig.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"validateConfig\", ({\n    enumerable: true,\n    get: ()=>validateConfig\n}));\nconst _log = /*#__PURE__*/ _interopRequireDefault(__webpack_require__(/*! ./log */ \"./node_modules/tailwindcss/lib/util/log.js\"));\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        default: obj\n    };\n}\nfunction validateConfig(config) {\n    if (config.content.files.length === 0) {\n        _log.default.warn(\"content-problems\", [\n            \"The `content` option in your Tailwind CSS configuration is missing or empty.\",\n            \"Configure your content sources or your generated CSS will be missing styles.\",\n            \"https://tailwindcss.com/docs/content-configuration\", \n        ]);\n    }\n    return config;\n}\n\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/tailwindcss/lib/util/validateConfig.js?");

/***/ }),

/***/ "./node_modules/tailwindcss/lib/util/withAlphaVariable.js":
/*!****************************************************************!*\
  !*** ./node_modules/tailwindcss/lib/util/withAlphaVariable.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    withAlphaValue: ()=>withAlphaValue,\n    default: ()=>withAlphaVariable\n});\nconst _color = __webpack_require__(/*! ./color */ \"./node_modules/tailwindcss/lib/util/color.js\");\nfunction withAlphaValue(color, alphaValue, defaultValue) {\n    if (typeof color === \"function\") {\n        return color({\n            opacityValue: alphaValue\n        });\n    }\n    let parsed = (0, _color.parseColor)(color, {\n        loose: true\n    });\n    if (parsed === null) {\n        return defaultValue;\n    }\n    return (0, _color.formatColor)({\n        ...parsed,\n        alpha: alphaValue\n    });\n}\nfunction withAlphaVariable({ color , property , variable  }) {\n    let properties = [].concat(property);\n    if (typeof color === \"function\") {\n        return {\n            [variable]: \"1\",\n            ...Object.fromEntries(properties.map((p)=>{\n                return [\n                    p,\n                    color({\n                        opacityVariable: variable,\n                        opacityValue: `var(${variable})`\n                    })\n                ];\n            }))\n        };\n    }\n    const parsed = (0, _color.parseColor)(color);\n    if (parsed === null) {\n        return Object.fromEntries(properties.map((p)=>[\n                p,\n                color\n            ]));\n    }\n    if (parsed.alpha !== undefined) {\n        // Has an alpha value, return color as-is\n        return Object.fromEntries(properties.map((p)=>[\n                p,\n                color\n            ]));\n    }\n    return {\n        [variable]: \"1\",\n        ...Object.fromEntries(properties.map((p)=>{\n            return [\n                p,\n                (0, _color.formatColor)({\n                    ...parsed,\n                    alpha: `var(${variable})`\n                })\n            ];\n        }))\n    };\n}\n\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/tailwindcss/lib/util/withAlphaVariable.js?");

/***/ }),

/***/ "./node_modules/tailwindcss/stubs/defaultConfig.stub.js":
/*!**************************************************************!*\
  !*** ./node_modules/tailwindcss/stubs/defaultConfig.stub.js ***!
  \**************************************************************/
/***/ ((module) => {

eval("/** @type {import('tailwindcss').Config} */\nmodule.exports = {\n  content: [],\n  presets: [],\n  darkMode: 'media', // or 'class'\n  theme: {\n    screens: {\n      sm: '640px',\n      md: '768px',\n      lg: '1024px',\n      xl: '1280px',\n      '2xl': '1536px',\n    },\n    colors: ({ colors }) => ({\n      inherit: colors.inherit,\n      current: colors.current,\n      transparent: colors.transparent,\n      black: colors.black,\n      white: colors.white,\n      slate: colors.slate,\n      gray: colors.gray,\n      zinc: colors.zinc,\n      neutral: colors.neutral,\n      stone: colors.stone,\n      red: colors.red,\n      orange: colors.orange,\n      amber: colors.amber,\n      yellow: colors.yellow,\n      lime: colors.lime,\n      green: colors.green,\n      emerald: colors.emerald,\n      teal: colors.teal,\n      cyan: colors.cyan,\n      sky: colors.sky,\n      blue: colors.blue,\n      indigo: colors.indigo,\n      violet: colors.violet,\n      purple: colors.purple,\n      fuchsia: colors.fuchsia,\n      pink: colors.pink,\n      rose: colors.rose,\n    }),\n    columns: {\n      auto: 'auto',\n      1: '1',\n      2: '2',\n      3: '3',\n      4: '4',\n      5: '5',\n      6: '6',\n      7: '7',\n      8: '8',\n      9: '9',\n      10: '10',\n      11: '11',\n      12: '12',\n      '3xs': '16rem',\n      '2xs': '18rem',\n      xs: '20rem',\n      sm: '24rem',\n      md: '28rem',\n      lg: '32rem',\n      xl: '36rem',\n      '2xl': '42rem',\n      '3xl': '48rem',\n      '4xl': '56rem',\n      '5xl': '64rem',\n      '6xl': '72rem',\n      '7xl': '80rem',\n    },\n    spacing: {\n      px: '1px',\n      0: '0px',\n      0.5: '0.125rem',\n      1: '0.25rem',\n      1.5: '0.375rem',\n      2: '0.5rem',\n      2.5: '0.625rem',\n      3: '0.75rem',\n      3.5: '0.875rem',\n      4: '1rem',\n      5: '1.25rem',\n      6: '1.5rem',\n      7: '1.75rem',\n      8: '2rem',\n      9: '2.25rem',\n      10: '2.5rem',\n      11: '2.75rem',\n      12: '3rem',\n      14: '3.5rem',\n      16: '4rem',\n      20: '5rem',\n      24: '6rem',\n      28: '7rem',\n      32: '8rem',\n      36: '9rem',\n      40: '10rem',\n      44: '11rem',\n      48: '12rem',\n      52: '13rem',\n      56: '14rem',\n      60: '15rem',\n      64: '16rem',\n      72: '18rem',\n      80: '20rem',\n      96: '24rem',\n    },\n    animation: {\n      none: 'none',\n      spin: 'spin 1s linear infinite',\n      ping: 'ping 1s cubic-bezier(0, 0, 0.2, 1) infinite',\n      pulse: 'pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite',\n      bounce: 'bounce 1s infinite',\n    },\n    aspectRatio: {\n      auto: 'auto',\n      square: '1 / 1',\n      video: '16 / 9',\n    },\n    backdropBlur: ({ theme }) => theme('blur'),\n    backdropBrightness: ({ theme }) => theme('brightness'),\n    backdropContrast: ({ theme }) => theme('contrast'),\n    backdropGrayscale: ({ theme }) => theme('grayscale'),\n    backdropHueRotate: ({ theme }) => theme('hueRotate'),\n    backdropInvert: ({ theme }) => theme('invert'),\n    backdropOpacity: ({ theme }) => theme('opacity'),\n    backdropSaturate: ({ theme }) => theme('saturate'),\n    backdropSepia: ({ theme }) => theme('sepia'),\n    backgroundColor: ({ theme }) => theme('colors'),\n    backgroundImage: {\n      none: 'none',\n      'gradient-to-t': 'linear-gradient(to top, var(--tw-gradient-stops))',\n      'gradient-to-tr': 'linear-gradient(to top right, var(--tw-gradient-stops))',\n      'gradient-to-r': 'linear-gradient(to right, var(--tw-gradient-stops))',\n      'gradient-to-br': 'linear-gradient(to bottom right, var(--tw-gradient-stops))',\n      'gradient-to-b': 'linear-gradient(to bottom, var(--tw-gradient-stops))',\n      'gradient-to-bl': 'linear-gradient(to bottom left, var(--tw-gradient-stops))',\n      'gradient-to-l': 'linear-gradient(to left, var(--tw-gradient-stops))',\n      'gradient-to-tl': 'linear-gradient(to top left, var(--tw-gradient-stops))',\n    },\n    backgroundOpacity: ({ theme }) => theme('opacity'),\n    backgroundPosition: {\n      bottom: 'bottom',\n      center: 'center',\n      left: 'left',\n      'left-bottom': 'left bottom',\n      'left-top': 'left top',\n      right: 'right',\n      'right-bottom': 'right bottom',\n      'right-top': 'right top',\n      top: 'top',\n    },\n    backgroundSize: {\n      auto: 'auto',\n      cover: 'cover',\n      contain: 'contain',\n    },\n    blur: {\n      0: '0',\n      none: '0',\n      sm: '4px',\n      DEFAULT: '8px',\n      md: '12px',\n      lg: '16px',\n      xl: '24px',\n      '2xl': '40px',\n      '3xl': '64px',\n    },\n    brightness: {\n      0: '0',\n      50: '.5',\n      75: '.75',\n      90: '.9',\n      95: '.95',\n      100: '1',\n      105: '1.05',\n      110: '1.1',\n      125: '1.25',\n      150: '1.5',\n      200: '2',\n    },\n    borderColor: ({ theme }) => ({\n      ...theme('colors'),\n      DEFAULT: theme('colors.gray.200', 'currentColor'),\n    }),\n    borderOpacity: ({ theme }) => theme('opacity'),\n    borderRadius: {\n      none: '0px',\n      sm: '0.125rem',\n      DEFAULT: '0.25rem',\n      md: '0.375rem',\n      lg: '0.5rem',\n      xl: '0.75rem',\n      '2xl': '1rem',\n      '3xl': '1.5rem',\n      full: '9999px',\n    },\n    borderSpacing: ({ theme }) => ({\n      ...theme('spacing'),\n    }),\n    borderWidth: {\n      DEFAULT: '1px',\n      0: '0px',\n      2: '2px',\n      4: '4px',\n      8: '8px',\n    },\n    boxShadow: {\n      sm: '0 1px 2px 0 rgb(0 0 0 / 0.05)',\n      DEFAULT: '0 1px 3px 0 rgb(0 0 0 / 0.1), 0 1px 2px -1px rgb(0 0 0 / 0.1)',\n      md: '0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1)',\n      lg: '0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1)',\n      xl: '0 20px 25px -5px rgb(0 0 0 / 0.1), 0 8px 10px -6px rgb(0 0 0 / 0.1)',\n      '2xl': '0 25px 50px -12px rgb(0 0 0 / 0.25)',\n      inner: 'inset 0 2px 4px 0 rgb(0 0 0 / 0.05)',\n      none: 'none',\n    },\n    boxShadowColor: ({ theme }) => theme('colors'),\n    caretColor: ({ theme }) => theme('colors'),\n    accentColor: ({ theme }) => ({\n      ...theme('colors'),\n      auto: 'auto',\n    }),\n    contrast: {\n      0: '0',\n      50: '.5',\n      75: '.75',\n      100: '1',\n      125: '1.25',\n      150: '1.5',\n      200: '2',\n    },\n    container: {},\n    content: {\n      none: 'none',\n    },\n    cursor: {\n      auto: 'auto',\n      default: 'default',\n      pointer: 'pointer',\n      wait: 'wait',\n      text: 'text',\n      move: 'move',\n      help: 'help',\n      'not-allowed': 'not-allowed',\n      none: 'none',\n      'context-menu': 'context-menu',\n      progress: 'progress',\n      cell: 'cell',\n      crosshair: 'crosshair',\n      'vertical-text': 'vertical-text',\n      alias: 'alias',\n      copy: 'copy',\n      'no-drop': 'no-drop',\n      grab: 'grab',\n      grabbing: 'grabbing',\n      'all-scroll': 'all-scroll',\n      'col-resize': 'col-resize',\n      'row-resize': 'row-resize',\n      'n-resize': 'n-resize',\n      'e-resize': 'e-resize',\n      's-resize': 's-resize',\n      'w-resize': 'w-resize',\n      'ne-resize': 'ne-resize',\n      'nw-resize': 'nw-resize',\n      'se-resize': 'se-resize',\n      'sw-resize': 'sw-resize',\n      'ew-resize': 'ew-resize',\n      'ns-resize': 'ns-resize',\n      'nesw-resize': 'nesw-resize',\n      'nwse-resize': 'nwse-resize',\n      'zoom-in': 'zoom-in',\n      'zoom-out': 'zoom-out',\n    },\n    divideColor: ({ theme }) => theme('borderColor'),\n    divideOpacity: ({ theme }) => theme('borderOpacity'),\n    divideWidth: ({ theme }) => theme('borderWidth'),\n    dropShadow: {\n      sm: '0 1px 1px rgb(0 0 0 / 0.05)',\n      DEFAULT: ['0 1px 2px rgb(0 0 0 / 0.1)', '0 1px 1px rgb(0 0 0 / 0.06)'],\n      md: ['0 4px 3px rgb(0 0 0 / 0.07)', '0 2px 2px rgb(0 0 0 / 0.06)'],\n      lg: ['0 10px 8px rgb(0 0 0 / 0.04)', '0 4px 3px rgb(0 0 0 / 0.1)'],\n      xl: ['0 20px 13px rgb(0 0 0 / 0.03)', '0 8px 5px rgb(0 0 0 / 0.08)'],\n      '2xl': '0 25px 25px rgb(0 0 0 / 0.15)',\n      none: '0 0 #0000',\n    },\n    fill: ({ theme }) => theme('colors'),\n    grayscale: {\n      0: '0',\n      DEFAULT: '100%',\n    },\n    hueRotate: {\n      0: '0deg',\n      15: '15deg',\n      30: '30deg',\n      60: '60deg',\n      90: '90deg',\n      180: '180deg',\n    },\n    invert: {\n      0: '0',\n      DEFAULT: '100%',\n    },\n    flex: {\n      1: '1 1 0%',\n      auto: '1 1 auto',\n      initial: '0 1 auto',\n      none: 'none',\n    },\n    flexBasis: ({ theme }) => ({\n      auto: 'auto',\n      ...theme('spacing'),\n      '1/2': '50%',\n      '1/3': '33.333333%',\n      '2/3': '66.666667%',\n      '1/4': '25%',\n      '2/4': '50%',\n      '3/4': '75%',\n      '1/5': '20%',\n      '2/5': '40%',\n      '3/5': '60%',\n      '4/5': '80%',\n      '1/6': '16.666667%',\n      '2/6': '33.333333%',\n      '3/6': '50%',\n      '4/6': '66.666667%',\n      '5/6': '83.333333%',\n      '1/12': '8.333333%',\n      '2/12': '16.666667%',\n      '3/12': '25%',\n      '4/12': '33.333333%',\n      '5/12': '41.666667%',\n      '6/12': '50%',\n      '7/12': '58.333333%',\n      '8/12': '66.666667%',\n      '9/12': '75%',\n      '10/12': '83.333333%',\n      '11/12': '91.666667%',\n      full: '100%',\n    }),\n    flexGrow: {\n      0: '0',\n      DEFAULT: '1',\n    },\n    flexShrink: {\n      0: '0',\n      DEFAULT: '1',\n    },\n    fontFamily: {\n      sans: [\n        'ui-sans-serif',\n        'system-ui',\n        '-apple-system',\n        'BlinkMacSystemFont',\n        '\"Segoe UI\"',\n        'Roboto',\n        '\"Helvetica Neue\"',\n        'Arial',\n        '\"Noto Sans\"',\n        'sans-serif',\n        '\"Apple Color Emoji\"',\n        '\"Segoe UI Emoji\"',\n        '\"Segoe UI Symbol\"',\n        '\"Noto Color Emoji\"',\n      ],\n      serif: ['ui-serif', 'Georgia', 'Cambria', '\"Times New Roman\"', 'Times', 'serif'],\n      mono: [\n        'ui-monospace',\n        'SFMono-Regular',\n        'Menlo',\n        'Monaco',\n        'Consolas',\n        '\"Liberation Mono\"',\n        '\"Courier New\"',\n        'monospace',\n      ],\n    },\n    fontSize: {\n      xs: ['0.75rem', { lineHeight: '1rem' }],\n      sm: ['0.875rem', { lineHeight: '1.25rem' }],\n      base: ['1rem', { lineHeight: '1.5rem' }],\n      lg: ['1.125rem', { lineHeight: '1.75rem' }],\n      xl: ['1.25rem', { lineHeight: '1.75rem' }],\n      '2xl': ['1.5rem', { lineHeight: '2rem' }],\n      '3xl': ['1.875rem', { lineHeight: '2.25rem' }],\n      '4xl': ['2.25rem', { lineHeight: '2.5rem' }],\n      '5xl': ['3rem', { lineHeight: '1' }],\n      '6xl': ['3.75rem', { lineHeight: '1' }],\n      '7xl': ['4.5rem', { lineHeight: '1' }],\n      '8xl': ['6rem', { lineHeight: '1' }],\n      '9xl': ['8rem', { lineHeight: '1' }],\n    },\n    fontWeight: {\n      thin: '100',\n      extralight: '200',\n      light: '300',\n      normal: '400',\n      medium: '500',\n      semibold: '600',\n      bold: '700',\n      extrabold: '800',\n      black: '900',\n    },\n    gap: ({ theme }) => theme('spacing'),\n    gradientColorStops: ({ theme }) => theme('colors'),\n    gridAutoColumns: {\n      auto: 'auto',\n      min: 'min-content',\n      max: 'max-content',\n      fr: 'minmax(0, 1fr)',\n    },\n    gridAutoRows: {\n      auto: 'auto',\n      min: 'min-content',\n      max: 'max-content',\n      fr: 'minmax(0, 1fr)',\n    },\n    gridColumn: {\n      auto: 'auto',\n      'span-1': 'span 1 / span 1',\n      'span-2': 'span 2 / span 2',\n      'span-3': 'span 3 / span 3',\n      'span-4': 'span 4 / span 4',\n      'span-5': 'span 5 / span 5',\n      'span-6': 'span 6 / span 6',\n      'span-7': 'span 7 / span 7',\n      'span-8': 'span 8 / span 8',\n      'span-9': 'span 9 / span 9',\n      'span-10': 'span 10 / span 10',\n      'span-11': 'span 11 / span 11',\n      'span-12': 'span 12 / span 12',\n      'span-full': '1 / -1',\n    },\n    gridColumnEnd: {\n      auto: 'auto',\n      1: '1',\n      2: '2',\n      3: '3',\n      4: '4',\n      5: '5',\n      6: '6',\n      7: '7',\n      8: '8',\n      9: '9',\n      10: '10',\n      11: '11',\n      12: '12',\n      13: '13',\n    },\n    gridColumnStart: {\n      auto: 'auto',\n      1: '1',\n      2: '2',\n      3: '3',\n      4: '4',\n      5: '5',\n      6: '6',\n      7: '7',\n      8: '8',\n      9: '9',\n      10: '10',\n      11: '11',\n      12: '12',\n      13: '13',\n    },\n    gridRow: {\n      auto: 'auto',\n      'span-1': 'span 1 / span 1',\n      'span-2': 'span 2 / span 2',\n      'span-3': 'span 3 / span 3',\n      'span-4': 'span 4 / span 4',\n      'span-5': 'span 5 / span 5',\n      'span-6': 'span 6 / span 6',\n      'span-full': '1 / -1',\n    },\n    gridRowStart: {\n      auto: 'auto',\n      1: '1',\n      2: '2',\n      3: '3',\n      4: '4',\n      5: '5',\n      6: '6',\n      7: '7',\n    },\n    gridRowEnd: {\n      auto: 'auto',\n      1: '1',\n      2: '2',\n      3: '3',\n      4: '4',\n      5: '5',\n      6: '6',\n      7: '7',\n    },\n    gridTemplateColumns: {\n      none: 'none',\n      1: 'repeat(1, minmax(0, 1fr))',\n      2: 'repeat(2, minmax(0, 1fr))',\n      3: 'repeat(3, minmax(0, 1fr))',\n      4: 'repeat(4, minmax(0, 1fr))',\n      5: 'repeat(5, minmax(0, 1fr))',\n      6: 'repeat(6, minmax(0, 1fr))',\n      7: 'repeat(7, minmax(0, 1fr))',\n      8: 'repeat(8, minmax(0, 1fr))',\n      9: 'repeat(9, minmax(0, 1fr))',\n      10: 'repeat(10, minmax(0, 1fr))',\n      11: 'repeat(11, minmax(0, 1fr))',\n      12: 'repeat(12, minmax(0, 1fr))',\n    },\n    gridTemplateRows: {\n      none: 'none',\n      1: 'repeat(1, minmax(0, 1fr))',\n      2: 'repeat(2, minmax(0, 1fr))',\n      3: 'repeat(3, minmax(0, 1fr))',\n      4: 'repeat(4, minmax(0, 1fr))',\n      5: 'repeat(5, minmax(0, 1fr))',\n      6: 'repeat(6, minmax(0, 1fr))',\n    },\n    height: ({ theme }) => ({\n      auto: 'auto',\n      ...theme('spacing'),\n      '1/2': '50%',\n      '1/3': '33.333333%',\n      '2/3': '66.666667%',\n      '1/4': '25%',\n      '2/4': '50%',\n      '3/4': '75%',\n      '1/5': '20%',\n      '2/5': '40%',\n      '3/5': '60%',\n      '4/5': '80%',\n      '1/6': '16.666667%',\n      '2/6': '33.333333%',\n      '3/6': '50%',\n      '4/6': '66.666667%',\n      '5/6': '83.333333%',\n      full: '100%',\n      screen: '100vh',\n      min: 'min-content',\n      max: 'max-content',\n      fit: 'fit-content',\n    }),\n    inset: ({ theme }) => ({\n      auto: 'auto',\n      ...theme('spacing'),\n      '1/2': '50%',\n      '1/3': '33.333333%',\n      '2/3': '66.666667%',\n      '1/4': '25%',\n      '2/4': '50%',\n      '3/4': '75%',\n      full: '100%',\n    }),\n    keyframes: {\n      spin: {\n        to: {\n          transform: 'rotate(360deg)',\n        },\n      },\n      ping: {\n        '75%, 100%': {\n          transform: 'scale(2)',\n          opacity: '0',\n        },\n      },\n      pulse: {\n        '50%': {\n          opacity: '.5',\n        },\n      },\n      bounce: {\n        '0%, 100%': {\n          transform: 'translateY(-25%)',\n          animationTimingFunction: 'cubic-bezier(0.8,0,1,1)',\n        },\n        '50%': {\n          transform: 'none',\n          animationTimingFunction: 'cubic-bezier(0,0,0.2,1)',\n        },\n      },\n    },\n    letterSpacing: {\n      tighter: '-0.05em',\n      tight: '-0.025em',\n      normal: '0em',\n      wide: '0.025em',\n      wider: '0.05em',\n      widest: '0.1em',\n    },\n    lineHeight: {\n      none: '1',\n      tight: '1.25',\n      snug: '1.375',\n      normal: '1.5',\n      relaxed: '1.625',\n      loose: '2',\n      3: '.75rem',\n      4: '1rem',\n      5: '1.25rem',\n      6: '1.5rem',\n      7: '1.75rem',\n      8: '2rem',\n      9: '2.25rem',\n      10: '2.5rem',\n    },\n    listStyleType: {\n      none: 'none',\n      disc: 'disc',\n      decimal: 'decimal',\n    },\n    margin: ({ theme }) => ({\n      auto: 'auto',\n      ...theme('spacing'),\n    }),\n    maxHeight: ({ theme }) => ({\n      ...theme('spacing'),\n      full: '100%',\n      screen: '100vh',\n      min: 'min-content',\n      max: 'max-content',\n      fit: 'fit-content',\n    }),\n    maxWidth: ({ theme, breakpoints }) => ({\n      none: 'none',\n      0: '0rem',\n      xs: '20rem',\n      sm: '24rem',\n      md: '28rem',\n      lg: '32rem',\n      xl: '36rem',\n      '2xl': '42rem',\n      '3xl': '48rem',\n      '4xl': '56rem',\n      '5xl': '64rem',\n      '6xl': '72rem',\n      '7xl': '80rem',\n      full: '100%',\n      min: 'min-content',\n      max: 'max-content',\n      fit: 'fit-content',\n      prose: '65ch',\n      ...breakpoints(theme('screens')),\n    }),\n    minHeight: {\n      0: '0px',\n      full: '100%',\n      screen: '100vh',\n      min: 'min-content',\n      max: 'max-content',\n      fit: 'fit-content',\n    },\n    minWidth: {\n      0: '0px',\n      full: '100%',\n      min: 'min-content',\n      max: 'max-content',\n      fit: 'fit-content',\n    },\n    objectPosition: {\n      bottom: 'bottom',\n      center: 'center',\n      left: 'left',\n      'left-bottom': 'left bottom',\n      'left-top': 'left top',\n      right: 'right',\n      'right-bottom': 'right bottom',\n      'right-top': 'right top',\n      top: 'top',\n    },\n    opacity: {\n      0: '0',\n      5: '0.05',\n      10: '0.1',\n      20: '0.2',\n      25: '0.25',\n      30: '0.3',\n      40: '0.4',\n      50: '0.5',\n      60: '0.6',\n      70: '0.7',\n      75: '0.75',\n      80: '0.8',\n      90: '0.9',\n      95: '0.95',\n      100: '1',\n    },\n    order: {\n      first: '-9999',\n      last: '9999',\n      none: '0',\n      1: '1',\n      2: '2',\n      3: '3',\n      4: '4',\n      5: '5',\n      6: '6',\n      7: '7',\n      8: '8',\n      9: '9',\n      10: '10',\n      11: '11',\n      12: '12',\n    },\n    padding: ({ theme }) => theme('spacing'),\n    placeholderColor: ({ theme }) => theme('colors'),\n    placeholderOpacity: ({ theme }) => theme('opacity'),\n    outlineColor: ({ theme }) => theme('colors'),\n    outlineOffset: {\n      0: '0px',\n      1: '1px',\n      2: '2px',\n      4: '4px',\n      8: '8px',\n    },\n    outlineWidth: {\n      0: '0px',\n      1: '1px',\n      2: '2px',\n      4: '4px',\n      8: '8px',\n    },\n    ringColor: ({ theme }) => ({\n      DEFAULT: theme(`colors.blue.500`, '#3b82f6'),\n      ...theme('colors'),\n    }),\n    ringOffsetColor: ({ theme }) => theme('colors'),\n    ringOffsetWidth: {\n      0: '0px',\n      1: '1px',\n      2: '2px',\n      4: '4px',\n      8: '8px',\n    },\n    ringOpacity: ({ theme }) => ({\n      DEFAULT: '0.5',\n      ...theme('opacity'),\n    }),\n    ringWidth: {\n      DEFAULT: '3px',\n      0: '0px',\n      1: '1px',\n      2: '2px',\n      4: '4px',\n      8: '8px',\n    },\n    rotate: {\n      0: '0deg',\n      1: '1deg',\n      2: '2deg',\n      3: '3deg',\n      6: '6deg',\n      12: '12deg',\n      45: '45deg',\n      90: '90deg',\n      180: '180deg',\n    },\n    saturate: {\n      0: '0',\n      50: '.5',\n      100: '1',\n      150: '1.5',\n      200: '2',\n    },\n    scale: {\n      0: '0',\n      50: '.5',\n      75: '.75',\n      90: '.9',\n      95: '.95',\n      100: '1',\n      105: '1.05',\n      110: '1.1',\n      125: '1.25',\n      150: '1.5',\n    },\n    scrollMargin: ({ theme }) => ({\n      ...theme('spacing'),\n    }),\n    scrollPadding: ({ theme }) => theme('spacing'),\n    sepia: {\n      0: '0',\n      DEFAULT: '100%',\n    },\n    skew: {\n      0: '0deg',\n      1: '1deg',\n      2: '2deg',\n      3: '3deg',\n      6: '6deg',\n      12: '12deg',\n    },\n    space: ({ theme }) => ({\n      ...theme('spacing'),\n    }),\n    stroke: ({ theme }) => theme('colors'),\n    strokeWidth: {\n      0: '0',\n      1: '1',\n      2: '2',\n    },\n    textColor: ({ theme }) => theme('colors'),\n    textDecorationColor: ({ theme }) => theme('colors'),\n    textDecorationThickness: {\n      auto: 'auto',\n      'from-font': 'from-font',\n      0: '0px',\n      1: '1px',\n      2: '2px',\n      4: '4px',\n      8: '8px',\n    },\n    textUnderlineOffset: {\n      auto: 'auto',\n      0: '0px',\n      1: '1px',\n      2: '2px',\n      4: '4px',\n      8: '8px',\n    },\n    textIndent: ({ theme }) => ({\n      ...theme('spacing'),\n    }),\n    textOpacity: ({ theme }) => theme('opacity'),\n    transformOrigin: {\n      center: 'center',\n      top: 'top',\n      'top-right': 'top right',\n      right: 'right',\n      'bottom-right': 'bottom right',\n      bottom: 'bottom',\n      'bottom-left': 'bottom left',\n      left: 'left',\n      'top-left': 'top left',\n    },\n    transitionDelay: {\n      75: '75ms',\n      100: '100ms',\n      150: '150ms',\n      200: '200ms',\n      300: '300ms',\n      500: '500ms',\n      700: '700ms',\n      1000: '1000ms',\n    },\n    transitionDuration: {\n      DEFAULT: '150ms',\n      75: '75ms',\n      100: '100ms',\n      150: '150ms',\n      200: '200ms',\n      300: '300ms',\n      500: '500ms',\n      700: '700ms',\n      1000: '1000ms',\n    },\n    transitionProperty: {\n      none: 'none',\n      all: 'all',\n      DEFAULT:\n        'color, background-color, border-color, text-decoration-color, fill, stroke, opacity, box-shadow, transform, filter, backdrop-filter',\n      colors: 'color, background-color, border-color, text-decoration-color, fill, stroke',\n      opacity: 'opacity',\n      shadow: 'box-shadow',\n      transform: 'transform',\n    },\n    transitionTimingFunction: {\n      DEFAULT: 'cubic-bezier(0.4, 0, 0.2, 1)',\n      linear: 'linear',\n      in: 'cubic-bezier(0.4, 0, 1, 1)',\n      out: 'cubic-bezier(0, 0, 0.2, 1)',\n      'in-out': 'cubic-bezier(0.4, 0, 0.2, 1)',\n    },\n    translate: ({ theme }) => ({\n      ...theme('spacing'),\n      '1/2': '50%',\n      '1/3': '33.333333%',\n      '2/3': '66.666667%',\n      '1/4': '25%',\n      '2/4': '50%',\n      '3/4': '75%',\n      full: '100%',\n    }),\n    width: ({ theme }) => ({\n      auto: 'auto',\n      ...theme('spacing'),\n      '1/2': '50%',\n      '1/3': '33.333333%',\n      '2/3': '66.666667%',\n      '1/4': '25%',\n      '2/4': '50%',\n      '3/4': '75%',\n      '1/5': '20%',\n      '2/5': '40%',\n      '3/5': '60%',\n      '4/5': '80%',\n      '1/6': '16.666667%',\n      '2/6': '33.333333%',\n      '3/6': '50%',\n      '4/6': '66.666667%',\n      '5/6': '83.333333%',\n      '1/12': '8.333333%',\n      '2/12': '16.666667%',\n      '3/12': '25%',\n      '4/12': '33.333333%',\n      '5/12': '41.666667%',\n      '6/12': '50%',\n      '7/12': '58.333333%',\n      '8/12': '66.666667%',\n      '9/12': '75%',\n      '10/12': '83.333333%',\n      '11/12': '91.666667%',\n      full: '100%',\n      screen: '100vw',\n      min: 'min-content',\n      max: 'max-content',\n      fit: 'fit-content',\n    }),\n    willChange: {\n      auto: 'auto',\n      scroll: 'scroll-position',\n      contents: 'contents',\n      transform: 'transform',\n    },\n    zIndex: {\n      auto: 'auto',\n      0: '0',\n      10: '10',\n      20: '20',\n      30: '30',\n      40: '40',\n      50: '50',\n    },\n  },\n  variantOrder: [\n    'first',\n    'last',\n    'odd',\n    'even',\n    'visited',\n    'checked',\n    'empty',\n    'read-only',\n    'group-hover',\n    'group-focus',\n    'focus-within',\n    'hover',\n    'focus',\n    'focus-visible',\n    'active',\n    'disabled',\n  ],\n  plugins: [],\n}\n\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/tailwindcss/stubs/defaultConfig.stub.js?");

/***/ }),

/***/ "./node_modules/to-regex-range/index.js":
/*!**********************************************!*\
  !*** ./node_modules/to-regex-range/index.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*!\n * to-regex-range <https://github.com/micromatch/to-regex-range>\n *\n * Copyright (c) 2015-present, Jon Schlinkert.\n * Released under the MIT License.\n */\n\n\n\nconst isNumber = __webpack_require__(/*! is-number */ \"./node_modules/is-number/index.js\");\n\nconst toRegexRange = (min, max, options) => {\n  if (isNumber(min) === false) {\n    throw new TypeError('toRegexRange: expected the first argument to be a number');\n  }\n\n  if (max === void 0 || min === max) {\n    return String(min);\n  }\n\n  if (isNumber(max) === false) {\n    throw new TypeError('toRegexRange: expected the second argument to be a number.');\n  }\n\n  let opts = { relaxZeros: true, ...options };\n  if (typeof opts.strictZeros === 'boolean') {\n    opts.relaxZeros = opts.strictZeros === false;\n  }\n\n  let relax = String(opts.relaxZeros);\n  let shorthand = String(opts.shorthand);\n  let capture = String(opts.capture);\n  let wrap = String(opts.wrap);\n  let cacheKey = min + ':' + max + '=' + relax + shorthand + capture + wrap;\n\n  if (toRegexRange.cache.hasOwnProperty(cacheKey)) {\n    return toRegexRange.cache[cacheKey].result;\n  }\n\n  let a = Math.min(min, max);\n  let b = Math.max(min, max);\n\n  if (Math.abs(a - b) === 1) {\n    let result = min + '|' + max;\n    if (opts.capture) {\n      return `(${result})`;\n    }\n    if (opts.wrap === false) {\n      return result;\n    }\n    return `(?:${result})`;\n  }\n\n  let isPadded = hasPadding(min) || hasPadding(max);\n  let state = { min, max, a, b };\n  let positives = [];\n  let negatives = [];\n\n  if (isPadded) {\n    state.isPadded = isPadded;\n    state.maxLen = String(state.max).length;\n  }\n\n  if (a < 0) {\n    let newMin = b < 0 ? Math.abs(b) : 1;\n    negatives = splitToPatterns(newMin, Math.abs(a), state, opts);\n    a = state.a = 0;\n  }\n\n  if (b >= 0) {\n    positives = splitToPatterns(a, b, state, opts);\n  }\n\n  state.negatives = negatives;\n  state.positives = positives;\n  state.result = collatePatterns(negatives, positives, opts);\n\n  if (opts.capture === true) {\n    state.result = `(${state.result})`;\n  } else if (opts.wrap !== false && (positives.length + negatives.length) > 1) {\n    state.result = `(?:${state.result})`;\n  }\n\n  toRegexRange.cache[cacheKey] = state;\n  return state.result;\n};\n\nfunction collatePatterns(neg, pos, options) {\n  let onlyNegative = filterPatterns(neg, pos, '-', false, options) || [];\n  let onlyPositive = filterPatterns(pos, neg, '', false, options) || [];\n  let intersected = filterPatterns(neg, pos, '-?', true, options) || [];\n  let subpatterns = onlyNegative.concat(intersected).concat(onlyPositive);\n  return subpatterns.join('|');\n}\n\nfunction splitToRanges(min, max) {\n  let nines = 1;\n  let zeros = 1;\n\n  let stop = countNines(min, nines);\n  let stops = new Set([max]);\n\n  while (min <= stop && stop <= max) {\n    stops.add(stop);\n    nines += 1;\n    stop = countNines(min, nines);\n  }\n\n  stop = countZeros(max + 1, zeros) - 1;\n\n  while (min < stop && stop <= max) {\n    stops.add(stop);\n    zeros += 1;\n    stop = countZeros(max + 1, zeros) - 1;\n  }\n\n  stops = [...stops];\n  stops.sort(compare);\n  return stops;\n}\n\n/**\n * Convert a range to a regex pattern\n * @param {Number} `start`\n * @param {Number} `stop`\n * @return {String}\n */\n\nfunction rangeToPattern(start, stop, options) {\n  if (start === stop) {\n    return { pattern: start, count: [], digits: 0 };\n  }\n\n  let zipped = zip(start, stop);\n  let digits = zipped.length;\n  let pattern = '';\n  let count = 0;\n\n  for (let i = 0; i < digits; i++) {\n    let [startDigit, stopDigit] = zipped[i];\n\n    if (startDigit === stopDigit) {\n      pattern += startDigit;\n\n    } else if (startDigit !== '0' || stopDigit !== '9') {\n      pattern += toCharacterClass(startDigit, stopDigit, options);\n\n    } else {\n      count++;\n    }\n  }\n\n  if (count) {\n    pattern += options.shorthand === true ? '\\\\d' : '[0-9]';\n  }\n\n  return { pattern, count: [count], digits };\n}\n\nfunction splitToPatterns(min, max, tok, options) {\n  let ranges = splitToRanges(min, max);\n  let tokens = [];\n  let start = min;\n  let prev;\n\n  for (let i = 0; i < ranges.length; i++) {\n    let max = ranges[i];\n    let obj = rangeToPattern(String(start), String(max), options);\n    let zeros = '';\n\n    if (!tok.isPadded && prev && prev.pattern === obj.pattern) {\n      if (prev.count.length > 1) {\n        prev.count.pop();\n      }\n\n      prev.count.push(obj.count[0]);\n      prev.string = prev.pattern + toQuantifier(prev.count);\n      start = max + 1;\n      continue;\n    }\n\n    if (tok.isPadded) {\n      zeros = padZeros(max, tok, options);\n    }\n\n    obj.string = zeros + obj.pattern + toQuantifier(obj.count);\n    tokens.push(obj);\n    start = max + 1;\n    prev = obj;\n  }\n\n  return tokens;\n}\n\nfunction filterPatterns(arr, comparison, prefix, intersection, options) {\n  let result = [];\n\n  for (let ele of arr) {\n    let { string } = ele;\n\n    // only push if _both_ are negative...\n    if (!intersection && !contains(comparison, 'string', string)) {\n      result.push(prefix + string);\n    }\n\n    // or _both_ are positive\n    if (intersection && contains(comparison, 'string', string)) {\n      result.push(prefix + string);\n    }\n  }\n  return result;\n}\n\n/**\n * Zip strings\n */\n\nfunction zip(a, b) {\n  let arr = [];\n  for (let i = 0; i < a.length; i++) arr.push([a[i], b[i]]);\n  return arr;\n}\n\nfunction compare(a, b) {\n  return a > b ? 1 : b > a ? -1 : 0;\n}\n\nfunction contains(arr, key, val) {\n  return arr.some(ele => ele[key] === val);\n}\n\nfunction countNines(min, len) {\n  return Number(String(min).slice(0, -len) + '9'.repeat(len));\n}\n\nfunction countZeros(integer, zeros) {\n  return integer - (integer % Math.pow(10, zeros));\n}\n\nfunction toQuantifier(digits) {\n  let [start = 0, stop = ''] = digits;\n  if (stop || start > 1) {\n    return `{${start + (stop ? ',' + stop : '')}}`;\n  }\n  return '';\n}\n\nfunction toCharacterClass(a, b, options) {\n  return `[${a}${(b - a === 1) ? '' : '-'}${b}]`;\n}\n\nfunction hasPadding(str) {\n  return /^-?(0+)\\d/.test(str);\n}\n\nfunction padZeros(value, tok, options) {\n  if (!tok.isPadded) {\n    return value;\n  }\n\n  let diff = Math.abs(tok.maxLen - String(value).length);\n  let relax = options.relaxZeros !== false;\n\n  switch (diff) {\n    case 0:\n      return '';\n    case 1:\n      return relax ? '0?' : '0';\n    case 2:\n      return relax ? '0{0,2}' : '00';\n    default: {\n      return relax ? `0{0,${diff}}` : `0{${diff}}`;\n    }\n  }\n}\n\n/**\n * Cache\n */\n\ntoRegexRange.cache = {};\ntoRegexRange.clearCache = () => (toRegexRange.cache = {});\n\n/**\n * Expose `toRegexRange`\n */\n\nmodule.exports = toRegexRange;\n\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/to-regex-range/index.js?");

/***/ }),

/***/ "./node_modules/util-deprecate/browser.js":
/*!************************************************!*\
  !*** ./node_modules/util-deprecate/browser.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n/**\n * Module exports.\n */\n\nmodule.exports = deprecate;\n\n/**\n * Mark that a method should not be used.\n * Returns a modified function which warns once by default.\n *\n * If `localStorage.noDeprecation = true` is set, then it is a no-op.\n *\n * If `localStorage.throwDeprecation = true` is set, then deprecated functions\n * will throw an Error when invoked.\n *\n * If `localStorage.traceDeprecation = true` is set, then deprecated functions\n * will invoke `console.trace()` instead of `console.error()`.\n *\n * @param {Function} fn - the function to deprecate\n * @param {String} msg - the string to print to the console when `fn` is invoked\n * @returns {Function} a new \"deprecated\" version of `fn`\n * @api public\n */\n\nfunction deprecate (fn, msg) {\n  if (config('noDeprecation')) {\n    return fn;\n  }\n\n  var warned = false;\n  function deprecated() {\n    if (!warned) {\n      if (config('throwDeprecation')) {\n        throw new Error(msg);\n      } else if (config('traceDeprecation')) {\n        console.trace(msg);\n      } else {\n        console.warn(msg);\n      }\n      warned = true;\n    }\n    return fn.apply(this, arguments);\n  }\n\n  return deprecated;\n}\n\n/**\n * Checks `localStorage` for boolean values for the given `name`.\n *\n * @param {String} name\n * @returns {Boolean}\n * @api private\n */\n\nfunction config (name) {\n  // accessing global.localStorage can trigger a DOMException in sandboxed iframes\n  try {\n    if (!__webpack_require__.g.localStorage) return false;\n  } catch (_) {\n    return false;\n  }\n  var val = __webpack_require__.g.localStorage[name];\n  if (null == val) return false;\n  return String(val).toLowerCase() === 'true';\n}\n\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/util-deprecate/browser.js?");

/***/ }),

/***/ "./node_modules/xtend/immutable.js":
/*!*****************************************!*\
  !*** ./node_modules/xtend/immutable.js ***!
  \*****************************************/
/***/ ((module) => {

eval("module.exports = extend\n\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\nfunction extend() {\n    var target = {}\n\n    for (var i = 0; i < arguments.length; i++) {\n        var source = arguments[i]\n\n        for (var key in source) {\n            if (hasOwnProperty.call(source, key)) {\n                target[key] = source[key]\n            }\n        }\n    }\n\n    return target\n}\n\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/xtend/immutable.js?");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var tailwindcss__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tailwindcss */ \"./node_modules/tailwindcss/lib/index.js\");\n/* harmony import */ var tailwindcss__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(tailwindcss__WEBPACK_IMPORTED_MODULE_0__);\n\r\nconst todoTitle = document.getElementById(\"todoTitle\");\r\nconst todoDesc = document.getElementById(\"desc\");\r\nconst submitButton = document.getElementById(\"submitbtn\");\r\nconst mainListItem = document.getElementById(\"mainListItem\");\r\nconst toastifyElement = document.getElementById(\"alert\");\r\nconst toastify = (msg, options) => {\r\n  toastifyElement.style.right = \"0\";\r\n  switch (options.type) {\r\n    case \"warn\":\r\n      toastifyElement.style.backgroundColor = \"tomato\";\r\n\r\n      break;\r\n    case \"error\":\r\n      toastifyElement.style.backgroundColor = \"orange\";\r\n\r\n    default:\r\n      toastifyElement.style.backgroundColor = \"gainsbro\";\r\n\r\n      break;\r\n  }\r\n  toastifyElement.children[0].innerHTML = msg;\r\n  toastifyElement.children[1].addEventListener(\"click\", () => {\r\n    toastifyElement.style.right = \"-100%\";\r\n  });\r\n  setTimeout(function () {\r\n    toastifyElement.style.right = \"-100%\";\r\n  }, options.time || 3000);\r\n};\r\n\r\nconst savedLCTodos = localStorage.getItem(\"todoItem\");\r\nconst parseSavedLCTodos = JSON.parse(savedLCTodos) || [];\r\nlet saveTodos = [...parseSavedLCTodos];\r\nconst creatNewTodo = (title, desc, id, checked) => {\r\n  const listItem = document.createElement(\"li\");\r\n  listItem.className = \"list\";\r\n  listItem.id = id;\r\n  const titleListItem = document.createElement(\"h3\");\r\n  const todoTitleInput = document.createElement(\"input\");\r\n  titleListItem.appendChild(todoTitleInput);\r\n  todoTitleInput.defaultValue = title;\r\n  todoTitleInput.classList = \"title-input\";\r\n  todoTitleInput.disabled = \"true\";\r\n  titleListItem.style.backgroundColor = \"orange\";\r\n  if (checked) {\r\n    titleListItem.style.backgroundColor = \"green\";\r\n  }\r\n  const descListItem = document.createElement(\"p\");\r\n  descListItem.style.backgroundColor = \"\";\r\n  descListItem.innerHTML = desc;\r\n  const todoController = document.createElement(\"div\");\r\n  const delButton = document.createElement(\"button\");\r\n  delButton.className = \"btn-2\";\r\n  delButton.innerHTML = \"Del\";\r\n  const editButton = document.createElement(\"button\");\r\n  editButton.className = \"btn-2\";\r\n  editButton.innerHTML = \"Edite\";\r\n  const updateButton = document.createElement(\"button\");\r\n  updateButton.className = \"btn-2\";\r\n  updateButton.innerHTML = \"check\";\r\n  // append my Element in parent tag\r\n\r\n  todoController.appendChild(delButton);\r\n  todoController.appendChild(editButton);\r\n  todoController.appendChild(updateButton);\r\n  listItem.appendChild(titleListItem);\r\n  listItem.appendChild(descListItem);\r\n  listItem.appendChild(todoController);\r\n  mainListItem.appendChild(listItem);\r\n};\r\n\r\nconst handeCreatTodo = (event) => {\r\n  event.preventDefault();\r\n  if (!todoTitle.value)\r\n    return toastify(\"please type somthing ...\", {\r\n      time: 2000,\r\n      type: \"error\",\r\n    });\r\n  const newTodo = {\r\n    title: todoTitle.value,\r\n    desc: todoDesc.value,\r\n    id: Date.now(),\r\n    checked: false,\r\n  };\r\n  saveTodos.push(newTodo);\r\n  localStorage.setItem(\"todoItem\", JSON.stringify(saveTodos));\r\n  creatNewTodo(newTodo.title, newTodo.desc, newTodo.id);\r\n};\r\n\r\nmainListItem.addEventListener(\"click\", (e) => {\r\n  if (e.target.innerText === \"Del\") {\r\n    const todoEl = e.target.parentElement.parentElement;\r\n    const filteredTodo = saveTodos.filter(\r\n      (item) => item.id !== Number(todoEl.id)\r\n    );\r\n    localStorage.setItem(\"todoItem\", JSON.stringify(filteredTodo));\r\n    location.reload();\r\n  } else if (e.target.innerText === \"check\") {\r\n    const todoEl = e.target.parentElement.parentElement;\r\n    const filteredTodo = saveTodos.filter(\r\n      (item) => item.id === Number(todoEl.id)\r\n    );\r\n    const updateFilteredTodo = {\r\n      ...filteredTodo[0],\r\n      checked: true,\r\n    };\r\n    const filteredTodosUpdate = saveTodos.filter(\r\n      (item) => item.id !== Number(todoEl.id)\r\n    );\r\n    const updateSavedTodos = [...filteredTodosUpdate, updateFilteredTodo];\r\n    localStorage.setItem(\"todoItem\", JSON.stringify(updateSavedTodos));\r\n    location.reload();\r\n  } else if (e.target.innerText === \"Edite\") {\r\n    const todoEl = e.target.parentElement.parentElement;\r\n    todoEl.children[0].children[0].disabled = false;\r\n    todoEl.children[0].children[0].style.backgroundColor = \"blue\";\r\n    todoEl.children[0].children[0].select();\r\n    e.target.innerText = \"save\";\r\n    e.target.addEventListener(\"click\", () => {\r\n      const filteredTodo = saveTodos.filter(\r\n        (item) => item.id === Number(todoEl.id)\r\n      );\r\n      const updateFilteredTodo = {\r\n        ...filteredTodo[0],\r\n        title: todoEl.children[0].children[0].value,\r\n      };\r\n\r\n      const filteredTodosUpdate = saveTodos.filter(\r\n        (item) => item.id !== Number(todoEl.id)\r\n      );\r\n      // console.log(filteredTodosUpdate);\r\n      const updateSavedTodos = [...filteredTodosUpdate, updateFilteredTodo];\r\n      // console.log(updateSavedTodos);\r\n      localStorage.setItem(\"todoItem\", JSON.stringify(updateSavedTodos));\r\n      location.reload();\r\n    });\r\n  }\r\n});\r\nsaveTodos.forEach((todo) => {\r\n  creatNewTodo(todo.title, todo.desc, todo.id, todo.checked);\r\n});\r\nsubmitButton.addEventListener(\"click\", handeCreatTodo);\r\n\r\n\r\n\r\n\r\n\n\n//# sourceURL=webpack://webpack-tailwind/./src/index.js?");

/***/ }),

/***/ "?5580":
/*!**************************************!*\
  !*** ./terminal-highlight (ignored) ***!
  \**************************************/
/***/ (() => {

eval("/* (ignored) */\n\n//# sourceURL=webpack://webpack-tailwind/./terminal-highlight_(ignored)?");

/***/ }),

/***/ "?03fb":
/*!********************!*\
  !*** fs (ignored) ***!
  \********************/
/***/ (() => {

eval("/* (ignored) */\n\n//# sourceURL=webpack://webpack-tailwind/fs_(ignored)?");

/***/ }),

/***/ "?6197":
/*!**********************!*\
  !*** path (ignored) ***!
  \**********************/
/***/ (() => {

eval("/* (ignored) */\n\n//# sourceURL=webpack://webpack-tailwind/path_(ignored)?");

/***/ }),

/***/ "?b8cb":
/*!*******************************!*\
  !*** source-map-js (ignored) ***!
  \*******************************/
/***/ (() => {

eval("/* (ignored) */\n\n//# sourceURL=webpack://webpack-tailwind/source-map-js_(ignored)?");

/***/ }),

/***/ "?c717":
/*!*********************!*\
  !*** url (ignored) ***!
  \*********************/
/***/ (() => {

eval("/* (ignored) */\n\n//# sourceURL=webpack://webpack-tailwind/url_(ignored)?");

/***/ }),

/***/ "./node_modules/nanoid/non-secure/index.cjs":
/*!**************************************************!*\
  !*** ./node_modules/nanoid/non-secure/index.cjs ***!
  \**************************************************/
/***/ ((module) => {

eval("let urlAlphabet =\n  'useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict'\nlet customAlphabet = (alphabet, defaultSize = 21) => {\n  return (size = defaultSize) => {\n    let id = ''\n    let i = size\n    while (i--) {\n      id += alphabet[(Math.random() * alphabet.length) | 0]\n    }\n    return id\n  }\n}\nlet nanoid = (size = 21) => {\n  let id = ''\n  let i = size\n  while (i--) {\n    id += urlAlphabet[(Math.random() * 64) | 0]\n  }\n  return id\n}\nmodule.exports = { nanoid, customAlphabet }\n\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/nanoid/non-secure/index.cjs?");

/***/ }),

/***/ "./node_modules/acorn-walk/dist/walk.mjs":
/*!***********************************************!*\
  !*** ./node_modules/acorn-walk/dist/walk.mjs ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ancestor\": () => (/* binding */ ancestor),\n/* harmony export */   \"base\": () => (/* binding */ base),\n/* harmony export */   \"findNodeAfter\": () => (/* binding */ findNodeAfter),\n/* harmony export */   \"findNodeAround\": () => (/* binding */ findNodeAround),\n/* harmony export */   \"findNodeAt\": () => (/* binding */ findNodeAt),\n/* harmony export */   \"findNodeBefore\": () => (/* binding */ findNodeBefore),\n/* harmony export */   \"full\": () => (/* binding */ full),\n/* harmony export */   \"fullAncestor\": () => (/* binding */ fullAncestor),\n/* harmony export */   \"make\": () => (/* binding */ make),\n/* harmony export */   \"recursive\": () => (/* binding */ recursive),\n/* harmony export */   \"simple\": () => (/* binding */ simple)\n/* harmony export */ });\n// AST walker module for Mozilla Parser API compatible trees\n\n// A simple walk is one where you simply specify callbacks to be\n// called on specific nodes. The last two arguments are optional. A\n// simple use would be\n//\n//     walk.simple(myTree, {\n//         Expression: function(node) { ... }\n//     });\n//\n// to do something with all expressions. All Parser API node types\n// can be used to identify node types, as well as Expression and\n// Statement, which denote categories of nodes.\n//\n// The base argument can be used to pass a custom (recursive)\n// walker, and state can be used to give this walked an initial\n// state.\n\nfunction simple(node, visitors, baseVisitor, state, override) {\n  if (!baseVisitor) { baseVisitor = base\n  ; }(function c(node, st, override) {\n    var type = override || node.type, found = visitors[type];\n    baseVisitor[type](node, st, c);\n    if (found) { found(node, st); }\n  })(node, state, override);\n}\n\n// An ancestor walk keeps an array of ancestor nodes (including the\n// current node) and passes them to the callback as third parameter\n// (and also as state parameter when no other state is present).\nfunction ancestor(node, visitors, baseVisitor, state, override) {\n  var ancestors = [];\n  if (!baseVisitor) { baseVisitor = base\n  ; }(function c(node, st, override) {\n    var type = override || node.type, found = visitors[type];\n    var isNew = node !== ancestors[ancestors.length - 1];\n    if (isNew) { ancestors.push(node); }\n    baseVisitor[type](node, st, c);\n    if (found) { found(node, st || ancestors, ancestors); }\n    if (isNew) { ancestors.pop(); }\n  })(node, state, override);\n}\n\n// A recursive walk is one where your functions override the default\n// walkers. They can modify and replace the state parameter that's\n// threaded through the walk, and can opt how and whether to walk\n// their child nodes (by calling their third argument on these\n// nodes).\nfunction recursive(node, state, funcs, baseVisitor, override) {\n  var visitor = funcs ? make(funcs, baseVisitor || undefined) : baseVisitor\n  ;(function c(node, st, override) {\n    visitor[override || node.type](node, st, c);\n  })(node, state, override);\n}\n\nfunction makeTest(test) {\n  if (typeof test === \"string\")\n    { return function (type) { return type === test; } }\n  else if (!test)\n    { return function () { return true; } }\n  else\n    { return test }\n}\n\nvar Found = function Found(node, state) { this.node = node; this.state = state; };\n\n// A full walk triggers the callback on each node\nfunction full(node, callback, baseVisitor, state, override) {\n  if (!baseVisitor) { baseVisitor = base\n  ; }(function c(node, st, override) {\n    var type = override || node.type;\n    baseVisitor[type](node, st, c);\n    if (!override) { callback(node, st, type); }\n  })(node, state, override);\n}\n\n// An fullAncestor walk is like an ancestor walk, but triggers\n// the callback on each node\nfunction fullAncestor(node, callback, baseVisitor, state) {\n  if (!baseVisitor) { baseVisitor = base; }\n  var ancestors = []\n  ;(function c(node, st, override) {\n    var type = override || node.type;\n    var isNew = node !== ancestors[ancestors.length - 1];\n    if (isNew) { ancestors.push(node); }\n    baseVisitor[type](node, st, c);\n    if (!override) { callback(node, st || ancestors, ancestors, type); }\n    if (isNew) { ancestors.pop(); }\n  })(node, state);\n}\n\n// Find a node with a given start, end, and type (all are optional,\n// null can be used as wildcard). Returns a {node, state} object, or\n// undefined when it doesn't find a matching node.\nfunction findNodeAt(node, start, end, test, baseVisitor, state) {\n  if (!baseVisitor) { baseVisitor = base; }\n  test = makeTest(test);\n  try {\n    (function c(node, st, override) {\n      var type = override || node.type;\n      if ((start == null || node.start <= start) &&\n          (end == null || node.end >= end))\n        { baseVisitor[type](node, st, c); }\n      if ((start == null || node.start === start) &&\n          (end == null || node.end === end) &&\n          test(type, node))\n        { throw new Found(node, st) }\n    })(node, state);\n  } catch (e) {\n    if (e instanceof Found) { return e }\n    throw e\n  }\n}\n\n// Find the innermost node of a given type that contains the given\n// position. Interface similar to findNodeAt.\nfunction findNodeAround(node, pos, test, baseVisitor, state) {\n  test = makeTest(test);\n  if (!baseVisitor) { baseVisitor = base; }\n  try {\n    (function c(node, st, override) {\n      var type = override || node.type;\n      if (node.start > pos || node.end < pos) { return }\n      baseVisitor[type](node, st, c);\n      if (test(type, node)) { throw new Found(node, st) }\n    })(node, state);\n  } catch (e) {\n    if (e instanceof Found) { return e }\n    throw e\n  }\n}\n\n// Find the outermost matching node after a given position.\nfunction findNodeAfter(node, pos, test, baseVisitor, state) {\n  test = makeTest(test);\n  if (!baseVisitor) { baseVisitor = base; }\n  try {\n    (function c(node, st, override) {\n      if (node.end < pos) { return }\n      var type = override || node.type;\n      if (node.start >= pos && test(type, node)) { throw new Found(node, st) }\n      baseVisitor[type](node, st, c);\n    })(node, state);\n  } catch (e) {\n    if (e instanceof Found) { return e }\n    throw e\n  }\n}\n\n// Find the outermost matching node before a given position.\nfunction findNodeBefore(node, pos, test, baseVisitor, state) {\n  test = makeTest(test);\n  if (!baseVisitor) { baseVisitor = base; }\n  var max\n  ;(function c(node, st, override) {\n    if (node.start > pos) { return }\n    var type = override || node.type;\n    if (node.end <= pos && (!max || max.node.end < node.end) && test(type, node))\n      { max = new Found(node, st); }\n    baseVisitor[type](node, st, c);\n  })(node, state);\n  return max\n}\n\n// Fallback to an Object.create polyfill for older environments.\nvar create = Object.create || function(proto) {\n  function Ctor() {}\n  Ctor.prototype = proto;\n  return new Ctor\n};\n\n// Used to create a custom walker. Will fill in all missing node\n// type properties with the defaults.\nfunction make(funcs, baseVisitor) {\n  var visitor = create(baseVisitor || base);\n  for (var type in funcs) { visitor[type] = funcs[type]; }\n  return visitor\n}\n\nfunction skipThrough(node, st, c) { c(node, st); }\nfunction ignore(_node, _st, _c) {}\n\n// Node walkers.\n\nvar base = {};\n\nbase.Program = base.BlockStatement = function (node, st, c) {\n  for (var i = 0, list = node.body; i < list.length; i += 1)\n    {\n    var stmt = list[i];\n\n    c(stmt, st, \"Statement\");\n  }\n};\nbase.Statement = skipThrough;\nbase.EmptyStatement = ignore;\nbase.ExpressionStatement = base.ParenthesizedExpression = base.ChainExpression =\n  function (node, st, c) { return c(node.expression, st, \"Expression\"); };\nbase.IfStatement = function (node, st, c) {\n  c(node.test, st, \"Expression\");\n  c(node.consequent, st, \"Statement\");\n  if (node.alternate) { c(node.alternate, st, \"Statement\"); }\n};\nbase.LabeledStatement = function (node, st, c) { return c(node.body, st, \"Statement\"); };\nbase.BreakStatement = base.ContinueStatement = ignore;\nbase.WithStatement = function (node, st, c) {\n  c(node.object, st, \"Expression\");\n  c(node.body, st, \"Statement\");\n};\nbase.SwitchStatement = function (node, st, c) {\n  c(node.discriminant, st, \"Expression\");\n  for (var i$1 = 0, list$1 = node.cases; i$1 < list$1.length; i$1 += 1) {\n    var cs = list$1[i$1];\n\n    if (cs.test) { c(cs.test, st, \"Expression\"); }\n    for (var i = 0, list = cs.consequent; i < list.length; i += 1)\n      {\n      var cons = list[i];\n\n      c(cons, st, \"Statement\");\n    }\n  }\n};\nbase.SwitchCase = function (node, st, c) {\n  if (node.test) { c(node.test, st, \"Expression\"); }\n  for (var i = 0, list = node.consequent; i < list.length; i += 1)\n    {\n    var cons = list[i];\n\n    c(cons, st, \"Statement\");\n  }\n};\nbase.ReturnStatement = base.YieldExpression = base.AwaitExpression = function (node, st, c) {\n  if (node.argument) { c(node.argument, st, \"Expression\"); }\n};\nbase.ThrowStatement = base.SpreadElement =\n  function (node, st, c) { return c(node.argument, st, \"Expression\"); };\nbase.TryStatement = function (node, st, c) {\n  c(node.block, st, \"Statement\");\n  if (node.handler) { c(node.handler, st); }\n  if (node.finalizer) { c(node.finalizer, st, \"Statement\"); }\n};\nbase.CatchClause = function (node, st, c) {\n  if (node.param) { c(node.param, st, \"Pattern\"); }\n  c(node.body, st, \"Statement\");\n};\nbase.WhileStatement = base.DoWhileStatement = function (node, st, c) {\n  c(node.test, st, \"Expression\");\n  c(node.body, st, \"Statement\");\n};\nbase.ForStatement = function (node, st, c) {\n  if (node.init) { c(node.init, st, \"ForInit\"); }\n  if (node.test) { c(node.test, st, \"Expression\"); }\n  if (node.update) { c(node.update, st, \"Expression\"); }\n  c(node.body, st, \"Statement\");\n};\nbase.ForInStatement = base.ForOfStatement = function (node, st, c) {\n  c(node.left, st, \"ForInit\");\n  c(node.right, st, \"Expression\");\n  c(node.body, st, \"Statement\");\n};\nbase.ForInit = function (node, st, c) {\n  if (node.type === \"VariableDeclaration\") { c(node, st); }\n  else { c(node, st, \"Expression\"); }\n};\nbase.DebuggerStatement = ignore;\n\nbase.FunctionDeclaration = function (node, st, c) { return c(node, st, \"Function\"); };\nbase.VariableDeclaration = function (node, st, c) {\n  for (var i = 0, list = node.declarations; i < list.length; i += 1)\n    {\n    var decl = list[i];\n\n    c(decl, st);\n  }\n};\nbase.VariableDeclarator = function (node, st, c) {\n  c(node.id, st, \"Pattern\");\n  if (node.init) { c(node.init, st, \"Expression\"); }\n};\n\nbase.Function = function (node, st, c) {\n  if (node.id) { c(node.id, st, \"Pattern\"); }\n  for (var i = 0, list = node.params; i < list.length; i += 1)\n    {\n    var param = list[i];\n\n    c(param, st, \"Pattern\");\n  }\n  c(node.body, st, node.expression ? \"Expression\" : \"Statement\");\n};\n\nbase.Pattern = function (node, st, c) {\n  if (node.type === \"Identifier\")\n    { c(node, st, \"VariablePattern\"); }\n  else if (node.type === \"MemberExpression\")\n    { c(node, st, \"MemberPattern\"); }\n  else\n    { c(node, st); }\n};\nbase.VariablePattern = ignore;\nbase.MemberPattern = skipThrough;\nbase.RestElement = function (node, st, c) { return c(node.argument, st, \"Pattern\"); };\nbase.ArrayPattern = function (node, st, c) {\n  for (var i = 0, list = node.elements; i < list.length; i += 1) {\n    var elt = list[i];\n\n    if (elt) { c(elt, st, \"Pattern\"); }\n  }\n};\nbase.ObjectPattern = function (node, st, c) {\n  for (var i = 0, list = node.properties; i < list.length; i += 1) {\n    var prop = list[i];\n\n    if (prop.type === \"Property\") {\n      if (prop.computed) { c(prop.key, st, \"Expression\"); }\n      c(prop.value, st, \"Pattern\");\n    } else if (prop.type === \"RestElement\") {\n      c(prop.argument, st, \"Pattern\");\n    }\n  }\n};\n\nbase.Expression = skipThrough;\nbase.ThisExpression = base.Super = base.MetaProperty = ignore;\nbase.ArrayExpression = function (node, st, c) {\n  for (var i = 0, list = node.elements; i < list.length; i += 1) {\n    var elt = list[i];\n\n    if (elt) { c(elt, st, \"Expression\"); }\n  }\n};\nbase.ObjectExpression = function (node, st, c) {\n  for (var i = 0, list = node.properties; i < list.length; i += 1)\n    {\n    var prop = list[i];\n\n    c(prop, st);\n  }\n};\nbase.FunctionExpression = base.ArrowFunctionExpression = base.FunctionDeclaration;\nbase.SequenceExpression = function (node, st, c) {\n  for (var i = 0, list = node.expressions; i < list.length; i += 1)\n    {\n    var expr = list[i];\n\n    c(expr, st, \"Expression\");\n  }\n};\nbase.TemplateLiteral = function (node, st, c) {\n  for (var i = 0, list = node.quasis; i < list.length; i += 1)\n    {\n    var quasi = list[i];\n\n    c(quasi, st);\n  }\n\n  for (var i$1 = 0, list$1 = node.expressions; i$1 < list$1.length; i$1 += 1)\n    {\n    var expr = list$1[i$1];\n\n    c(expr, st, \"Expression\");\n  }\n};\nbase.TemplateElement = ignore;\nbase.UnaryExpression = base.UpdateExpression = function (node, st, c) {\n  c(node.argument, st, \"Expression\");\n};\nbase.BinaryExpression = base.LogicalExpression = function (node, st, c) {\n  c(node.left, st, \"Expression\");\n  c(node.right, st, \"Expression\");\n};\nbase.AssignmentExpression = base.AssignmentPattern = function (node, st, c) {\n  c(node.left, st, \"Pattern\");\n  c(node.right, st, \"Expression\");\n};\nbase.ConditionalExpression = function (node, st, c) {\n  c(node.test, st, \"Expression\");\n  c(node.consequent, st, \"Expression\");\n  c(node.alternate, st, \"Expression\");\n};\nbase.NewExpression = base.CallExpression = function (node, st, c) {\n  c(node.callee, st, \"Expression\");\n  if (node.arguments)\n    { for (var i = 0, list = node.arguments; i < list.length; i += 1)\n      {\n        var arg = list[i];\n\n        c(arg, st, \"Expression\");\n      } }\n};\nbase.MemberExpression = function (node, st, c) {\n  c(node.object, st, \"Expression\");\n  if (node.computed) { c(node.property, st, \"Expression\"); }\n};\nbase.ExportNamedDeclaration = base.ExportDefaultDeclaration = function (node, st, c) {\n  if (node.declaration)\n    { c(node.declaration, st, node.type === \"ExportNamedDeclaration\" || node.declaration.id ? \"Statement\" : \"Expression\"); }\n  if (node.source) { c(node.source, st, \"Expression\"); }\n};\nbase.ExportAllDeclaration = function (node, st, c) {\n  if (node.exported)\n    { c(node.exported, st); }\n  c(node.source, st, \"Expression\");\n};\nbase.ImportDeclaration = function (node, st, c) {\n  for (var i = 0, list = node.specifiers; i < list.length; i += 1)\n    {\n    var spec = list[i];\n\n    c(spec, st);\n  }\n  c(node.source, st, \"Expression\");\n};\nbase.ImportExpression = function (node, st, c) {\n  c(node.source, st, \"Expression\");\n};\nbase.ImportSpecifier = base.ImportDefaultSpecifier = base.ImportNamespaceSpecifier = base.Identifier = base.Literal = ignore;\n\nbase.TaggedTemplateExpression = function (node, st, c) {\n  c(node.tag, st, \"Expression\");\n  c(node.quasi, st, \"Expression\");\n};\nbase.ClassDeclaration = base.ClassExpression = function (node, st, c) { return c(node, st, \"Class\"); };\nbase.Class = function (node, st, c) {\n  if (node.id) { c(node.id, st, \"Pattern\"); }\n  if (node.superClass) { c(node.superClass, st, \"Expression\"); }\n  c(node.body, st);\n};\nbase.ClassBody = function (node, st, c) {\n  for (var i = 0, list = node.body; i < list.length; i += 1)\n    {\n    var elt = list[i];\n\n    c(elt, st);\n  }\n};\nbase.MethodDefinition = base.Property = function (node, st, c) {\n  if (node.computed) { c(node.key, st, \"Expression\"); }\n  c(node.value, st, \"Expression\");\n};\n\n\n\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/acorn-walk/dist/walk.mjs?");

/***/ }),

/***/ "./node_modules/acorn/dist/acorn.mjs":
/*!*******************************************!*\
  !*** ./node_modules/acorn/dist/acorn.mjs ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Node\": () => (/* binding */ Node),\n/* harmony export */   \"Parser\": () => (/* binding */ Parser),\n/* harmony export */   \"Position\": () => (/* binding */ Position),\n/* harmony export */   \"SourceLocation\": () => (/* binding */ SourceLocation),\n/* harmony export */   \"TokContext\": () => (/* binding */ TokContext),\n/* harmony export */   \"Token\": () => (/* binding */ Token),\n/* harmony export */   \"TokenType\": () => (/* binding */ TokenType),\n/* harmony export */   \"defaultOptions\": () => (/* binding */ defaultOptions),\n/* harmony export */   \"getLineInfo\": () => (/* binding */ getLineInfo),\n/* harmony export */   \"isIdentifierChar\": () => (/* binding */ isIdentifierChar),\n/* harmony export */   \"isIdentifierStart\": () => (/* binding */ isIdentifierStart),\n/* harmony export */   \"isNewLine\": () => (/* binding */ isNewLine),\n/* harmony export */   \"keywordTypes\": () => (/* binding */ keywords$1),\n/* harmony export */   \"lineBreak\": () => (/* binding */ lineBreak),\n/* harmony export */   \"lineBreakG\": () => (/* binding */ lineBreakG),\n/* harmony export */   \"nonASCIIwhitespace\": () => (/* binding */ nonASCIIwhitespace),\n/* harmony export */   \"parse\": () => (/* binding */ parse),\n/* harmony export */   \"parseExpressionAt\": () => (/* binding */ parseExpressionAt),\n/* harmony export */   \"tokContexts\": () => (/* binding */ types$1),\n/* harmony export */   \"tokTypes\": () => (/* binding */ types),\n/* harmony export */   \"tokenizer\": () => (/* binding */ tokenizer),\n/* harmony export */   \"version\": () => (/* binding */ version)\n/* harmony export */ });\n// Reserved word lists for various dialects of the language\n\nvar reservedWords = {\n  3: \"abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile\",\n  5: \"class enum extends super const export import\",\n  6: \"enum\",\n  strict: \"implements interface let package private protected public static yield\",\n  strictBind: \"eval arguments\"\n};\n\n// And the keywords\n\nvar ecma5AndLessKeywords = \"break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this\";\n\nvar keywords = {\n  5: ecma5AndLessKeywords,\n  \"5module\": ecma5AndLessKeywords + \" export import\",\n  6: ecma5AndLessKeywords + \" const class extends export import super\"\n};\n\nvar keywordRelationalOperator = /^in(stanceof)?$/;\n\n// ## Character categories\n\n// Big ugly regular expressions that match characters in the\n// whitespace, identifier, and identifier-start categories. These\n// are only applied when a character is found to actually have a\n// code point above 128.\n// Generated by `bin/generate-identifier-regex.js`.\nvar nonASCIIidentifierStartChars = \"\\xaa\\xb5\\xba\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u02c1\\u02c6-\\u02d1\\u02e0-\\u02e4\\u02ec\\u02ee\\u0370-\\u0374\\u0376\\u0377\\u037a-\\u037d\\u037f\\u0386\\u0388-\\u038a\\u038c\\u038e-\\u03a1\\u03a3-\\u03f5\\u03f7-\\u0481\\u048a-\\u052f\\u0531-\\u0556\\u0559\\u0560-\\u0588\\u05d0-\\u05ea\\u05ef-\\u05f2\\u0620-\\u064a\\u066e\\u066f\\u0671-\\u06d3\\u06d5\\u06e5\\u06e6\\u06ee\\u06ef\\u06fa-\\u06fc\\u06ff\\u0710\\u0712-\\u072f\\u074d-\\u07a5\\u07b1\\u07ca-\\u07ea\\u07f4\\u07f5\\u07fa\\u0800-\\u0815\\u081a\\u0824\\u0828\\u0840-\\u0858\\u0860-\\u086a\\u08a0-\\u08b4\\u08b6-\\u08c7\\u0904-\\u0939\\u093d\\u0950\\u0958-\\u0961\\u0971-\\u0980\\u0985-\\u098c\\u098f\\u0990\\u0993-\\u09a8\\u09aa-\\u09b0\\u09b2\\u09b6-\\u09b9\\u09bd\\u09ce\\u09dc\\u09dd\\u09df-\\u09e1\\u09f0\\u09f1\\u09fc\\u0a05-\\u0a0a\\u0a0f\\u0a10\\u0a13-\\u0a28\\u0a2a-\\u0a30\\u0a32\\u0a33\\u0a35\\u0a36\\u0a38\\u0a39\\u0a59-\\u0a5c\\u0a5e\\u0a72-\\u0a74\\u0a85-\\u0a8d\\u0a8f-\\u0a91\\u0a93-\\u0aa8\\u0aaa-\\u0ab0\\u0ab2\\u0ab3\\u0ab5-\\u0ab9\\u0abd\\u0ad0\\u0ae0\\u0ae1\\u0af9\\u0b05-\\u0b0c\\u0b0f\\u0b10\\u0b13-\\u0b28\\u0b2a-\\u0b30\\u0b32\\u0b33\\u0b35-\\u0b39\\u0b3d\\u0b5c\\u0b5d\\u0b5f-\\u0b61\\u0b71\\u0b83\\u0b85-\\u0b8a\\u0b8e-\\u0b90\\u0b92-\\u0b95\\u0b99\\u0b9a\\u0b9c\\u0b9e\\u0b9f\\u0ba3\\u0ba4\\u0ba8-\\u0baa\\u0bae-\\u0bb9\\u0bd0\\u0c05-\\u0c0c\\u0c0e-\\u0c10\\u0c12-\\u0c28\\u0c2a-\\u0c39\\u0c3d\\u0c58-\\u0c5a\\u0c60\\u0c61\\u0c80\\u0c85-\\u0c8c\\u0c8e-\\u0c90\\u0c92-\\u0ca8\\u0caa-\\u0cb3\\u0cb5-\\u0cb9\\u0cbd\\u0cde\\u0ce0\\u0ce1\\u0cf1\\u0cf2\\u0d04-\\u0d0c\\u0d0e-\\u0d10\\u0d12-\\u0d3a\\u0d3d\\u0d4e\\u0d54-\\u0d56\\u0d5f-\\u0d61\\u0d7a-\\u0d7f\\u0d85-\\u0d96\\u0d9a-\\u0db1\\u0db3-\\u0dbb\\u0dbd\\u0dc0-\\u0dc6\\u0e01-\\u0e30\\u0e32\\u0e33\\u0e40-\\u0e46\\u0e81\\u0e82\\u0e84\\u0e86-\\u0e8a\\u0e8c-\\u0ea3\\u0ea5\\u0ea7-\\u0eb0\\u0eb2\\u0eb3\\u0ebd\\u0ec0-\\u0ec4\\u0ec6\\u0edc-\\u0edf\\u0f00\\u0f40-\\u0f47\\u0f49-\\u0f6c\\u0f88-\\u0f8c\\u1000-\\u102a\\u103f\\u1050-\\u1055\\u105a-\\u105d\\u1061\\u1065\\u1066\\u106e-\\u1070\\u1075-\\u1081\\u108e\\u10a0-\\u10c5\\u10c7\\u10cd\\u10d0-\\u10fa\\u10fc-\\u1248\\u124a-\\u124d\\u1250-\\u1256\\u1258\\u125a-\\u125d\\u1260-\\u1288\\u128a-\\u128d\\u1290-\\u12b0\\u12b2-\\u12b5\\u12b8-\\u12be\\u12c0\\u12c2-\\u12c5\\u12c8-\\u12d6\\u12d8-\\u1310\\u1312-\\u1315\\u1318-\\u135a\\u1380-\\u138f\\u13a0-\\u13f5\\u13f8-\\u13fd\\u1401-\\u166c\\u166f-\\u167f\\u1681-\\u169a\\u16a0-\\u16ea\\u16ee-\\u16f8\\u1700-\\u170c\\u170e-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176c\\u176e-\\u1770\\u1780-\\u17b3\\u17d7\\u17dc\\u1820-\\u1878\\u1880-\\u18a8\\u18aa\\u18b0-\\u18f5\\u1900-\\u191e\\u1950-\\u196d\\u1970-\\u1974\\u1980-\\u19ab\\u19b0-\\u19c9\\u1a00-\\u1a16\\u1a20-\\u1a54\\u1aa7\\u1b05-\\u1b33\\u1b45-\\u1b4b\\u1b83-\\u1ba0\\u1bae\\u1baf\\u1bba-\\u1be5\\u1c00-\\u1c23\\u1c4d-\\u1c4f\\u1c5a-\\u1c7d\\u1c80-\\u1c88\\u1c90-\\u1cba\\u1cbd-\\u1cbf\\u1ce9-\\u1cec\\u1cee-\\u1cf3\\u1cf5\\u1cf6\\u1cfa\\u1d00-\\u1dbf\\u1e00-\\u1f15\\u1f18-\\u1f1d\\u1f20-\\u1f45\\u1f48-\\u1f4d\\u1f50-\\u1f57\\u1f59\\u1f5b\\u1f5d\\u1f5f-\\u1f7d\\u1f80-\\u1fb4\\u1fb6-\\u1fbc\\u1fbe\\u1fc2-\\u1fc4\\u1fc6-\\u1fcc\\u1fd0-\\u1fd3\\u1fd6-\\u1fdb\\u1fe0-\\u1fec\\u1ff2-\\u1ff4\\u1ff6-\\u1ffc\\u2071\\u207f\\u2090-\\u209c\\u2102\\u2107\\u210a-\\u2113\\u2115\\u2118-\\u211d\\u2124\\u2126\\u2128\\u212a-\\u2139\\u213c-\\u213f\\u2145-\\u2149\\u214e\\u2160-\\u2188\\u2c00-\\u2c2e\\u2c30-\\u2c5e\\u2c60-\\u2ce4\\u2ceb-\\u2cee\\u2cf2\\u2cf3\\u2d00-\\u2d25\\u2d27\\u2d2d\\u2d30-\\u2d67\\u2d6f\\u2d80-\\u2d96\\u2da0-\\u2da6\\u2da8-\\u2dae\\u2db0-\\u2db6\\u2db8-\\u2dbe\\u2dc0-\\u2dc6\\u2dc8-\\u2dce\\u2dd0-\\u2dd6\\u2dd8-\\u2dde\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303c\\u3041-\\u3096\\u309b-\\u309f\\u30a1-\\u30fa\\u30fc-\\u30ff\\u3105-\\u312f\\u3131-\\u318e\\u31a0-\\u31bf\\u31f0-\\u31ff\\u3400-\\u4dbf\\u4e00-\\u9ffc\\ua000-\\ua48c\\ua4d0-\\ua4fd\\ua500-\\ua60c\\ua610-\\ua61f\\ua62a\\ua62b\\ua640-\\ua66e\\ua67f-\\ua69d\\ua6a0-\\ua6ef\\ua717-\\ua71f\\ua722-\\ua788\\ua78b-\\ua7bf\\ua7c2-\\ua7ca\\ua7f5-\\ua801\\ua803-\\ua805\\ua807-\\ua80a\\ua80c-\\ua822\\ua840-\\ua873\\ua882-\\ua8b3\\ua8f2-\\ua8f7\\ua8fb\\ua8fd\\ua8fe\\ua90a-\\ua925\\ua930-\\ua946\\ua960-\\ua97c\\ua984-\\ua9b2\\ua9cf\\ua9e0-\\ua9e4\\ua9e6-\\ua9ef\\ua9fa-\\ua9fe\\uaa00-\\uaa28\\uaa40-\\uaa42\\uaa44-\\uaa4b\\uaa60-\\uaa76\\uaa7a\\uaa7e-\\uaaaf\\uaab1\\uaab5\\uaab6\\uaab9-\\uaabd\\uaac0\\uaac2\\uaadb-\\uaadd\\uaae0-\\uaaea\\uaaf2-\\uaaf4\\uab01-\\uab06\\uab09-\\uab0e\\uab11-\\uab16\\uab20-\\uab26\\uab28-\\uab2e\\uab30-\\uab5a\\uab5c-\\uab69\\uab70-\\uabe2\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\uf900-\\ufa6d\\ufa70-\\ufad9\\ufb00-\\ufb06\\ufb13-\\ufb17\\ufb1d\\ufb1f-\\ufb28\\ufb2a-\\ufb36\\ufb38-\\ufb3c\\ufb3e\\ufb40\\ufb41\\ufb43\\ufb44\\ufb46-\\ufbb1\\ufbd3-\\ufd3d\\ufd50-\\ufd8f\\ufd92-\\ufdc7\\ufdf0-\\ufdfb\\ufe70-\\ufe74\\ufe76-\\ufefc\\uff21-\\uff3a\\uff41-\\uff5a\\uff66-\\uffbe\\uffc2-\\uffc7\\uffca-\\uffcf\\uffd2-\\uffd7\\uffda-\\uffdc\";\nvar nonASCIIidentifierChars = \"\\u200c\\u200d\\xb7\\u0300-\\u036f\\u0387\\u0483-\\u0487\\u0591-\\u05bd\\u05bf\\u05c1\\u05c2\\u05c4\\u05c5\\u05c7\\u0610-\\u061a\\u064b-\\u0669\\u0670\\u06d6-\\u06dc\\u06df-\\u06e4\\u06e7\\u06e8\\u06ea-\\u06ed\\u06f0-\\u06f9\\u0711\\u0730-\\u074a\\u07a6-\\u07b0\\u07c0-\\u07c9\\u07eb-\\u07f3\\u07fd\\u0816-\\u0819\\u081b-\\u0823\\u0825-\\u0827\\u0829-\\u082d\\u0859-\\u085b\\u08d3-\\u08e1\\u08e3-\\u0903\\u093a-\\u093c\\u093e-\\u094f\\u0951-\\u0957\\u0962\\u0963\\u0966-\\u096f\\u0981-\\u0983\\u09bc\\u09be-\\u09c4\\u09c7\\u09c8\\u09cb-\\u09cd\\u09d7\\u09e2\\u09e3\\u09e6-\\u09ef\\u09fe\\u0a01-\\u0a03\\u0a3c\\u0a3e-\\u0a42\\u0a47\\u0a48\\u0a4b-\\u0a4d\\u0a51\\u0a66-\\u0a71\\u0a75\\u0a81-\\u0a83\\u0abc\\u0abe-\\u0ac5\\u0ac7-\\u0ac9\\u0acb-\\u0acd\\u0ae2\\u0ae3\\u0ae6-\\u0aef\\u0afa-\\u0aff\\u0b01-\\u0b03\\u0b3c\\u0b3e-\\u0b44\\u0b47\\u0b48\\u0b4b-\\u0b4d\\u0b55-\\u0b57\\u0b62\\u0b63\\u0b66-\\u0b6f\\u0b82\\u0bbe-\\u0bc2\\u0bc6-\\u0bc8\\u0bca-\\u0bcd\\u0bd7\\u0be6-\\u0bef\\u0c00-\\u0c04\\u0c3e-\\u0c44\\u0c46-\\u0c48\\u0c4a-\\u0c4d\\u0c55\\u0c56\\u0c62\\u0c63\\u0c66-\\u0c6f\\u0c81-\\u0c83\\u0cbc\\u0cbe-\\u0cc4\\u0cc6-\\u0cc8\\u0cca-\\u0ccd\\u0cd5\\u0cd6\\u0ce2\\u0ce3\\u0ce6-\\u0cef\\u0d00-\\u0d03\\u0d3b\\u0d3c\\u0d3e-\\u0d44\\u0d46-\\u0d48\\u0d4a-\\u0d4d\\u0d57\\u0d62\\u0d63\\u0d66-\\u0d6f\\u0d81-\\u0d83\\u0dca\\u0dcf-\\u0dd4\\u0dd6\\u0dd8-\\u0ddf\\u0de6-\\u0def\\u0df2\\u0df3\\u0e31\\u0e34-\\u0e3a\\u0e47-\\u0e4e\\u0e50-\\u0e59\\u0eb1\\u0eb4-\\u0ebc\\u0ec8-\\u0ecd\\u0ed0-\\u0ed9\\u0f18\\u0f19\\u0f20-\\u0f29\\u0f35\\u0f37\\u0f39\\u0f3e\\u0f3f\\u0f71-\\u0f84\\u0f86\\u0f87\\u0f8d-\\u0f97\\u0f99-\\u0fbc\\u0fc6\\u102b-\\u103e\\u1040-\\u1049\\u1056-\\u1059\\u105e-\\u1060\\u1062-\\u1064\\u1067-\\u106d\\u1071-\\u1074\\u1082-\\u108d\\u108f-\\u109d\\u135d-\\u135f\\u1369-\\u1371\\u1712-\\u1714\\u1732-\\u1734\\u1752\\u1753\\u1772\\u1773\\u17b4-\\u17d3\\u17dd\\u17e0-\\u17e9\\u180b-\\u180d\\u1810-\\u1819\\u18a9\\u1920-\\u192b\\u1930-\\u193b\\u1946-\\u194f\\u19d0-\\u19da\\u1a17-\\u1a1b\\u1a55-\\u1a5e\\u1a60-\\u1a7c\\u1a7f-\\u1a89\\u1a90-\\u1a99\\u1ab0-\\u1abd\\u1abf\\u1ac0\\u1b00-\\u1b04\\u1b34-\\u1b44\\u1b50-\\u1b59\\u1b6b-\\u1b73\\u1b80-\\u1b82\\u1ba1-\\u1bad\\u1bb0-\\u1bb9\\u1be6-\\u1bf3\\u1c24-\\u1c37\\u1c40-\\u1c49\\u1c50-\\u1c59\\u1cd0-\\u1cd2\\u1cd4-\\u1ce8\\u1ced\\u1cf4\\u1cf7-\\u1cf9\\u1dc0-\\u1df9\\u1dfb-\\u1dff\\u203f\\u2040\\u2054\\u20d0-\\u20dc\\u20e1\\u20e5-\\u20f0\\u2cef-\\u2cf1\\u2d7f\\u2de0-\\u2dff\\u302a-\\u302f\\u3099\\u309a\\ua620-\\ua629\\ua66f\\ua674-\\ua67d\\ua69e\\ua69f\\ua6f0\\ua6f1\\ua802\\ua806\\ua80b\\ua823-\\ua827\\ua82c\\ua880\\ua881\\ua8b4-\\ua8c5\\ua8d0-\\ua8d9\\ua8e0-\\ua8f1\\ua8ff-\\ua909\\ua926-\\ua92d\\ua947-\\ua953\\ua980-\\ua983\\ua9b3-\\ua9c0\\ua9d0-\\ua9d9\\ua9e5\\ua9f0-\\ua9f9\\uaa29-\\uaa36\\uaa43\\uaa4c\\uaa4d\\uaa50-\\uaa59\\uaa7b-\\uaa7d\\uaab0\\uaab2-\\uaab4\\uaab7\\uaab8\\uaabe\\uaabf\\uaac1\\uaaeb-\\uaaef\\uaaf5\\uaaf6\\uabe3-\\uabea\\uabec\\uabed\\uabf0-\\uabf9\\ufb1e\\ufe00-\\ufe0f\\ufe20-\\ufe2f\\ufe33\\ufe34\\ufe4d-\\ufe4f\\uff10-\\uff19\\uff3f\";\n\nvar nonASCIIidentifierStart = new RegExp(\"[\" + nonASCIIidentifierStartChars + \"]\");\nvar nonASCIIidentifier = new RegExp(\"[\" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + \"]\");\n\nnonASCIIidentifierStartChars = nonASCIIidentifierChars = null;\n\n// These are a run-length and offset encoded representation of the\n// >0xffff code points that are a valid part of identifiers. The\n// offset starts at 0x10000, and each pair of numbers represents an\n// offset to the next range, and then a size of the range. They were\n// generated by bin/generate-identifier-regex.js\n\n// eslint-disable-next-line comma-spacing\nvar astralIdentifierStartCodes = [0,11,2,25,2,18,2,1,2,14,3,13,35,122,70,52,268,28,4,48,48,31,14,29,6,37,11,29,3,35,5,7,2,4,43,157,19,35,5,35,5,39,9,51,157,310,10,21,11,7,153,5,3,0,2,43,2,1,4,0,3,22,11,22,10,30,66,18,2,1,11,21,11,25,71,55,7,1,65,0,16,3,2,2,2,28,43,28,4,28,36,7,2,27,28,53,11,21,11,18,14,17,111,72,56,50,14,50,14,35,349,41,7,1,79,28,11,0,9,21,107,20,28,22,13,52,76,44,33,24,27,35,30,0,3,0,9,34,4,0,13,47,15,3,22,0,2,0,36,17,2,24,85,6,2,0,2,3,2,14,2,9,8,46,39,7,3,1,3,21,2,6,2,1,2,4,4,0,19,0,13,4,159,52,19,3,21,2,31,47,21,1,2,0,185,46,42,3,37,47,21,0,60,42,14,0,72,26,230,43,117,63,32,7,3,0,3,7,2,1,2,23,16,0,2,0,95,7,3,38,17,0,2,0,29,0,11,39,8,0,22,0,12,45,20,0,35,56,264,8,2,36,18,0,50,29,113,6,2,1,2,37,22,0,26,5,2,1,2,31,15,0,328,18,190,0,80,921,103,110,18,195,2749,1070,4050,582,8634,568,8,30,114,29,19,47,17,3,32,20,6,18,689,63,129,74,6,0,67,12,65,1,2,0,29,6135,9,1237,43,8,8952,286,50,2,18,3,9,395,2309,106,6,12,4,8,8,9,5991,84,2,70,2,1,3,0,3,1,3,3,2,11,2,0,2,6,2,64,2,3,3,7,2,6,2,27,2,3,2,4,2,0,4,6,2,339,3,24,2,24,2,30,2,24,2,30,2,24,2,30,2,24,2,30,2,24,2,7,2357,44,11,6,17,0,370,43,1301,196,60,67,8,0,1205,3,2,26,2,1,2,0,3,0,2,9,2,3,2,0,2,0,7,0,5,0,2,0,2,0,2,2,2,1,2,0,3,0,2,0,2,0,2,0,2,0,2,1,2,0,3,3,2,6,2,3,2,3,2,0,2,9,2,16,6,2,2,4,2,16,4421,42717,35,4148,12,221,3,5761,15,7472,3104,541,1507,4938];\n\n// eslint-disable-next-line comma-spacing\nvar astralIdentifierCodes = [509,0,227,0,150,4,294,9,1368,2,2,1,6,3,41,2,5,0,166,1,574,3,9,9,370,1,154,10,176,2,54,14,32,9,16,3,46,10,54,9,7,2,37,13,2,9,6,1,45,0,13,2,49,13,9,3,2,11,83,11,7,0,161,11,6,9,7,3,56,1,2,6,3,1,3,2,10,0,11,1,3,6,4,4,193,17,10,9,5,0,82,19,13,9,214,6,3,8,28,1,83,16,16,9,82,12,9,9,84,14,5,9,243,14,166,9,71,5,2,1,3,3,2,0,2,1,13,9,120,6,3,6,4,0,29,9,41,6,2,3,9,0,10,10,47,15,406,7,2,7,17,9,57,21,2,13,123,5,4,0,2,1,2,6,2,0,9,9,49,4,2,1,2,4,9,9,330,3,19306,9,135,4,60,6,26,9,1014,0,2,54,8,3,82,0,12,1,19628,1,5319,4,4,5,9,7,3,6,31,3,149,2,1418,49,513,54,5,49,9,0,15,0,23,4,2,14,1361,6,2,16,3,6,2,1,2,4,262,6,10,9,419,13,1495,6,110,6,6,9,4759,9,787719,239];\n\n// This has a complexity linear to the value of the code. The\n// assumption is that looking up astral identifier characters is\n// rare.\nfunction isInAstralSet(code, set) {\n  var pos = 0x10000;\n  for (var i = 0; i < set.length; i += 2) {\n    pos += set[i];\n    if (pos > code) { return false }\n    pos += set[i + 1];\n    if (pos >= code) { return true }\n  }\n}\n\n// Test whether a given character code starts an identifier.\n\nfunction isIdentifierStart(code, astral) {\n  if (code < 65) { return code === 36 }\n  if (code < 91) { return true }\n  if (code < 97) { return code === 95 }\n  if (code < 123) { return true }\n  if (code <= 0xffff) { return code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code)) }\n  if (astral === false) { return false }\n  return isInAstralSet(code, astralIdentifierStartCodes)\n}\n\n// Test whether a given character is part of an identifier.\n\nfunction isIdentifierChar(code, astral) {\n  if (code < 48) { return code === 36 }\n  if (code < 58) { return true }\n  if (code < 65) { return false }\n  if (code < 91) { return true }\n  if (code < 97) { return code === 95 }\n  if (code < 123) { return true }\n  if (code <= 0xffff) { return code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code)) }\n  if (astral === false) { return false }\n  return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes)\n}\n\n// ## Token types\n\n// The assignment of fine-grained, information-carrying type objects\n// allows the tokenizer to store the information it has about a\n// token in a way that is very cheap for the parser to look up.\n\n// All token type variables start with an underscore, to make them\n// easy to recognize.\n\n// The `beforeExpr` property is used to disambiguate between regular\n// expressions and divisions. It is set on all token types that can\n// be followed by an expression (thus, a slash after them would be a\n// regular expression).\n//\n// The `startsExpr` property is used to check if the token ends a\n// `yield` expression. It is set on all token types that either can\n// directly start an expression (like a quotation mark) or can\n// continue an expression (like the body of a string).\n//\n// `isLoop` marks a keyword as starting a loop, which is important\n// to know when parsing a label, in order to allow or disallow\n// continue jumps to that label.\n\nvar TokenType = function TokenType(label, conf) {\n  if ( conf === void 0 ) conf = {};\n\n  this.label = label;\n  this.keyword = conf.keyword;\n  this.beforeExpr = !!conf.beforeExpr;\n  this.startsExpr = !!conf.startsExpr;\n  this.isLoop = !!conf.isLoop;\n  this.isAssign = !!conf.isAssign;\n  this.prefix = !!conf.prefix;\n  this.postfix = !!conf.postfix;\n  this.binop = conf.binop || null;\n  this.updateContext = null;\n};\n\nfunction binop(name, prec) {\n  return new TokenType(name, {beforeExpr: true, binop: prec})\n}\nvar beforeExpr = {beforeExpr: true}, startsExpr = {startsExpr: true};\n\n// Map keyword names to token types.\n\nvar keywords$1 = {};\n\n// Succinct definitions of keyword token types\nfunction kw(name, options) {\n  if ( options === void 0 ) options = {};\n\n  options.keyword = name;\n  return keywords$1[name] = new TokenType(name, options)\n}\n\nvar types = {\n  num: new TokenType(\"num\", startsExpr),\n  regexp: new TokenType(\"regexp\", startsExpr),\n  string: new TokenType(\"string\", startsExpr),\n  name: new TokenType(\"name\", startsExpr),\n  eof: new TokenType(\"eof\"),\n\n  // Punctuation token types.\n  bracketL: new TokenType(\"[\", {beforeExpr: true, startsExpr: true}),\n  bracketR: new TokenType(\"]\"),\n  braceL: new TokenType(\"{\", {beforeExpr: true, startsExpr: true}),\n  braceR: new TokenType(\"}\"),\n  parenL: new TokenType(\"(\", {beforeExpr: true, startsExpr: true}),\n  parenR: new TokenType(\")\"),\n  comma: new TokenType(\",\", beforeExpr),\n  semi: new TokenType(\";\", beforeExpr),\n  colon: new TokenType(\":\", beforeExpr),\n  dot: new TokenType(\".\"),\n  question: new TokenType(\"?\", beforeExpr),\n  questionDot: new TokenType(\"?.\"),\n  arrow: new TokenType(\"=>\", beforeExpr),\n  template: new TokenType(\"template\"),\n  invalidTemplate: new TokenType(\"invalidTemplate\"),\n  ellipsis: new TokenType(\"...\", beforeExpr),\n  backQuote: new TokenType(\"`\", startsExpr),\n  dollarBraceL: new TokenType(\"${\", {beforeExpr: true, startsExpr: true}),\n\n  // Operators. These carry several kinds of properties to help the\n  // parser use them properly (the presence of these properties is\n  // what categorizes them as operators).\n  //\n  // `binop`, when present, specifies that this operator is a binary\n  // operator, and will refer to its precedence.\n  //\n  // `prefix` and `postfix` mark the operator as a prefix or postfix\n  // unary operator.\n  //\n  // `isAssign` marks all of `=`, `+=`, `-=` etcetera, which act as\n  // binary operators with a very low precedence, that should result\n  // in AssignmentExpression nodes.\n\n  eq: new TokenType(\"=\", {beforeExpr: true, isAssign: true}),\n  assign: new TokenType(\"_=\", {beforeExpr: true, isAssign: true}),\n  incDec: new TokenType(\"++/--\", {prefix: true, postfix: true, startsExpr: true}),\n  prefix: new TokenType(\"!/~\", {beforeExpr: true, prefix: true, startsExpr: true}),\n  logicalOR: binop(\"||\", 1),\n  logicalAND: binop(\"&&\", 2),\n  bitwiseOR: binop(\"|\", 3),\n  bitwiseXOR: binop(\"^\", 4),\n  bitwiseAND: binop(\"&\", 5),\n  equality: binop(\"==/!=/===/!==\", 6),\n  relational: binop(\"</>/<=/>=\", 7),\n  bitShift: binop(\"<</>>/>>>\", 8),\n  plusMin: new TokenType(\"+/-\", {beforeExpr: true, binop: 9, prefix: true, startsExpr: true}),\n  modulo: binop(\"%\", 10),\n  star: binop(\"*\", 10),\n  slash: binop(\"/\", 10),\n  starstar: new TokenType(\"**\", {beforeExpr: true}),\n  coalesce: binop(\"??\", 1),\n\n  // Keyword token types.\n  _break: kw(\"break\"),\n  _case: kw(\"case\", beforeExpr),\n  _catch: kw(\"catch\"),\n  _continue: kw(\"continue\"),\n  _debugger: kw(\"debugger\"),\n  _default: kw(\"default\", beforeExpr),\n  _do: kw(\"do\", {isLoop: true, beforeExpr: true}),\n  _else: kw(\"else\", beforeExpr),\n  _finally: kw(\"finally\"),\n  _for: kw(\"for\", {isLoop: true}),\n  _function: kw(\"function\", startsExpr),\n  _if: kw(\"if\"),\n  _return: kw(\"return\", beforeExpr),\n  _switch: kw(\"switch\"),\n  _throw: kw(\"throw\", beforeExpr),\n  _try: kw(\"try\"),\n  _var: kw(\"var\"),\n  _const: kw(\"const\"),\n  _while: kw(\"while\", {isLoop: true}),\n  _with: kw(\"with\"),\n  _new: kw(\"new\", {beforeExpr: true, startsExpr: true}),\n  _this: kw(\"this\", startsExpr),\n  _super: kw(\"super\", startsExpr),\n  _class: kw(\"class\", startsExpr),\n  _extends: kw(\"extends\", beforeExpr),\n  _export: kw(\"export\"),\n  _import: kw(\"import\", startsExpr),\n  _null: kw(\"null\", startsExpr),\n  _true: kw(\"true\", startsExpr),\n  _false: kw(\"false\", startsExpr),\n  _in: kw(\"in\", {beforeExpr: true, binop: 7}),\n  _instanceof: kw(\"instanceof\", {beforeExpr: true, binop: 7}),\n  _typeof: kw(\"typeof\", {beforeExpr: true, prefix: true, startsExpr: true}),\n  _void: kw(\"void\", {beforeExpr: true, prefix: true, startsExpr: true}),\n  _delete: kw(\"delete\", {beforeExpr: true, prefix: true, startsExpr: true})\n};\n\n// Matches a whole line break (where CRLF is considered a single\n// line break). Used to count lines.\n\nvar lineBreak = /\\r\\n?|\\n|\\u2028|\\u2029/;\nvar lineBreakG = new RegExp(lineBreak.source, \"g\");\n\nfunction isNewLine(code, ecma2019String) {\n  return code === 10 || code === 13 || (!ecma2019String && (code === 0x2028 || code === 0x2029))\n}\n\nvar nonASCIIwhitespace = /[\\u1680\\u2000-\\u200a\\u202f\\u205f\\u3000\\ufeff]/;\n\nvar skipWhiteSpace = /(?:\\s|\\/\\/.*|\\/\\*[^]*?\\*\\/)*/g;\n\nvar ref = Object.prototype;\nvar hasOwnProperty = ref.hasOwnProperty;\nvar toString = ref.toString;\n\n// Checks if an object has a property.\n\nfunction has(obj, propName) {\n  return hasOwnProperty.call(obj, propName)\n}\n\nvar isArray = Array.isArray || (function (obj) { return (\n  toString.call(obj) === \"[object Array]\"\n); });\n\nfunction wordsRegexp(words) {\n  return new RegExp(\"^(?:\" + words.replace(/ /g, \"|\") + \")$\")\n}\n\n// These are used when `options.locations` is on, for the\n// `startLoc` and `endLoc` properties.\n\nvar Position = function Position(line, col) {\n  this.line = line;\n  this.column = col;\n};\n\nPosition.prototype.offset = function offset (n) {\n  return new Position(this.line, this.column + n)\n};\n\nvar SourceLocation = function SourceLocation(p, start, end) {\n  this.start = start;\n  this.end = end;\n  if (p.sourceFile !== null) { this.source = p.sourceFile; }\n};\n\n// The `getLineInfo` function is mostly useful when the\n// `locations` option is off (for performance reasons) and you\n// want to find the line/column position for a given character\n// offset. `input` should be the code string that the offset refers\n// into.\n\nfunction getLineInfo(input, offset) {\n  for (var line = 1, cur = 0;;) {\n    lineBreakG.lastIndex = cur;\n    var match = lineBreakG.exec(input);\n    if (match && match.index < offset) {\n      ++line;\n      cur = match.index + match[0].length;\n    } else {\n      return new Position(line, offset - cur)\n    }\n  }\n}\n\n// A second optional argument can be given to further configure\n// the parser process. These options are recognized:\n\nvar defaultOptions = {\n  // `ecmaVersion` indicates the ECMAScript version to parse. Must be\n  // either 3, 5, 6 (2015), 7 (2016), 8 (2017), 9 (2018), or 10\n  // (2019). This influences support for strict mode, the set of\n  // reserved words, and support for new syntax features. The default\n  // is 10.\n  ecmaVersion: 10,\n  // `sourceType` indicates the mode the code should be parsed in.\n  // Can be either `\"script\"` or `\"module\"`. This influences global\n  // strict mode and parsing of `import` and `export` declarations.\n  sourceType: \"script\",\n  // `onInsertedSemicolon` can be a callback that will be called\n  // when a semicolon is automatically inserted. It will be passed\n  // the position of the comma as an offset, and if `locations` is\n  // enabled, it is given the location as a `{line, column}` object\n  // as second argument.\n  onInsertedSemicolon: null,\n  // `onTrailingComma` is similar to `onInsertedSemicolon`, but for\n  // trailing commas.\n  onTrailingComma: null,\n  // By default, reserved words are only enforced if ecmaVersion >= 5.\n  // Set `allowReserved` to a boolean value to explicitly turn this on\n  // an off. When this option has the value \"never\", reserved words\n  // and keywords can also not be used as property names.\n  allowReserved: null,\n  // When enabled, a return at the top level is not considered an\n  // error.\n  allowReturnOutsideFunction: false,\n  // When enabled, import/export statements are not constrained to\n  // appearing at the top of the program.\n  allowImportExportEverywhere: false,\n  // When enabled, await identifiers are allowed to appear at the top-level scope,\n  // but they are still not allowed in non-async functions.\n  allowAwaitOutsideFunction: false,\n  // When enabled, hashbang directive in the beginning of file\n  // is allowed and treated as a line comment.\n  allowHashBang: false,\n  // When `locations` is on, `loc` properties holding objects with\n  // `start` and `end` properties in `{line, column}` form (with\n  // line being 1-based and column 0-based) will be attached to the\n  // nodes.\n  locations: false,\n  // A function can be passed as `onToken` option, which will\n  // cause Acorn to call that function with object in the same\n  // format as tokens returned from `tokenizer().getToken()`. Note\n  // that you are not allowed to call the parser from the\n  // callback—that will corrupt its internal state.\n  onToken: null,\n  // A function can be passed as `onComment` option, which will\n  // cause Acorn to call that function with `(block, text, start,\n  // end)` parameters whenever a comment is skipped. `block` is a\n  // boolean indicating whether this is a block (`/* */`) comment,\n  // `text` is the content of the comment, and `start` and `end` are\n  // character offsets that denote the start and end of the comment.\n  // When the `locations` option is on, two more parameters are\n  // passed, the full `{line, column}` locations of the start and\n  // end of the comments. Note that you are not allowed to call the\n  // parser from the callback—that will corrupt its internal state.\n  onComment: null,\n  // Nodes have their start and end characters offsets recorded in\n  // `start` and `end` properties (directly on the node, rather than\n  // the `loc` object, which holds line/column data. To also add a\n  // [semi-standardized][range] `range` property holding a `[start,\n  // end]` array with the same numbers, set the `ranges` option to\n  // `true`.\n  //\n  // [range]: https://bugzilla.mozilla.org/show_bug.cgi?id=745678\n  ranges: false,\n  // It is possible to parse multiple files into a single AST by\n  // passing the tree produced by parsing the first file as\n  // `program` option in subsequent parses. This will add the\n  // toplevel forms of the parsed file to the `Program` (top) node\n  // of an existing parse tree.\n  program: null,\n  // When `locations` is on, you can pass this to record the source\n  // file in every node's `loc` object.\n  sourceFile: null,\n  // This value, if given, is stored in every node, whether\n  // `locations` is on or off.\n  directSourceFile: null,\n  // When enabled, parenthesized expressions are represented by\n  // (non-standard) ParenthesizedExpression nodes\n  preserveParens: false\n};\n\n// Interpret and default an options object\n\nfunction getOptions(opts) {\n  var options = {};\n\n  for (var opt in defaultOptions)\n    { options[opt] = opts && has(opts, opt) ? opts[opt] : defaultOptions[opt]; }\n\n  if (options.ecmaVersion >= 2015)\n    { options.ecmaVersion -= 2009; }\n\n  if (options.allowReserved == null)\n    { options.allowReserved = options.ecmaVersion < 5; }\n\n  if (isArray(options.onToken)) {\n    var tokens = options.onToken;\n    options.onToken = function (token) { return tokens.push(token); };\n  }\n  if (isArray(options.onComment))\n    { options.onComment = pushComment(options, options.onComment); }\n\n  return options\n}\n\nfunction pushComment(options, array) {\n  return function(block, text, start, end, startLoc, endLoc) {\n    var comment = {\n      type: block ? \"Block\" : \"Line\",\n      value: text,\n      start: start,\n      end: end\n    };\n    if (options.locations)\n      { comment.loc = new SourceLocation(this, startLoc, endLoc); }\n    if (options.ranges)\n      { comment.range = [start, end]; }\n    array.push(comment);\n  }\n}\n\n// Each scope gets a bitset that may contain these flags\nvar\n    SCOPE_TOP = 1,\n    SCOPE_FUNCTION = 2,\n    SCOPE_VAR = SCOPE_TOP | SCOPE_FUNCTION,\n    SCOPE_ASYNC = 4,\n    SCOPE_GENERATOR = 8,\n    SCOPE_ARROW = 16,\n    SCOPE_SIMPLE_CATCH = 32,\n    SCOPE_SUPER = 64,\n    SCOPE_DIRECT_SUPER = 128;\n\nfunction functionFlags(async, generator) {\n  return SCOPE_FUNCTION | (async ? SCOPE_ASYNC : 0) | (generator ? SCOPE_GENERATOR : 0)\n}\n\n// Used in checkLVal and declareName to determine the type of a binding\nvar\n    BIND_NONE = 0, // Not a binding\n    BIND_VAR = 1, // Var-style binding\n    BIND_LEXICAL = 2, // Let- or const-style binding\n    BIND_FUNCTION = 3, // Function declaration\n    BIND_SIMPLE_CATCH = 4, // Simple (identifier pattern) catch binding\n    BIND_OUTSIDE = 5; // Special case for function names as bound inside the function\n\nvar Parser = function Parser(options, input, startPos) {\n  this.options = options = getOptions(options);\n  this.sourceFile = options.sourceFile;\n  this.keywords = wordsRegexp(keywords[options.ecmaVersion >= 6 ? 6 : options.sourceType === \"module\" ? \"5module\" : 5]);\n  var reserved = \"\";\n  if (options.allowReserved !== true) {\n    for (var v = options.ecmaVersion;; v--)\n      { if (reserved = reservedWords[v]) { break } }\n    if (options.sourceType === \"module\") { reserved += \" await\"; }\n  }\n  this.reservedWords = wordsRegexp(reserved);\n  var reservedStrict = (reserved ? reserved + \" \" : \"\") + reservedWords.strict;\n  this.reservedWordsStrict = wordsRegexp(reservedStrict);\n  this.reservedWordsStrictBind = wordsRegexp(reservedStrict + \" \" + reservedWords.strictBind);\n  this.input = String(input);\n\n  // Used to signal to callers of `readWord1` whether the word\n  // contained any escape sequences. This is needed because words with\n  // escape sequences must not be interpreted as keywords.\n  this.containsEsc = false;\n\n  // Set up token state\n\n  // The current position of the tokenizer in the input.\n  if (startPos) {\n    this.pos = startPos;\n    this.lineStart = this.input.lastIndexOf(\"\\n\", startPos - 1) + 1;\n    this.curLine = this.input.slice(0, this.lineStart).split(lineBreak).length;\n  } else {\n    this.pos = this.lineStart = 0;\n    this.curLine = 1;\n  }\n\n  // Properties of the current token:\n  // Its type\n  this.type = types.eof;\n  // For tokens that include more information than their type, the value\n  this.value = null;\n  // Its start and end offset\n  this.start = this.end = this.pos;\n  // And, if locations are used, the {line, column} object\n  // corresponding to those offsets\n  this.startLoc = this.endLoc = this.curPosition();\n\n  // Position information for the previous token\n  this.lastTokEndLoc = this.lastTokStartLoc = null;\n  this.lastTokStart = this.lastTokEnd = this.pos;\n\n  // The context stack is used to superficially track syntactic\n  // context to predict whether a regular expression is allowed in a\n  // given position.\n  this.context = this.initialContext();\n  this.exprAllowed = true;\n\n  // Figure out if it's a module code.\n  this.inModule = options.sourceType === \"module\";\n  this.strict = this.inModule || this.strictDirective(this.pos);\n\n  // Used to signify the start of a potential arrow function\n  this.potentialArrowAt = -1;\n\n  // Positions to delayed-check that yield/await does not exist in default parameters.\n  this.yieldPos = this.awaitPos = this.awaitIdentPos = 0;\n  // Labels in scope.\n  this.labels = [];\n  // Thus-far undefined exports.\n  this.undefinedExports = {};\n\n  // If enabled, skip leading hashbang line.\n  if (this.pos === 0 && options.allowHashBang && this.input.slice(0, 2) === \"#!\")\n    { this.skipLineComment(2); }\n\n  // Scope tracking for duplicate variable names (see scope.js)\n  this.scopeStack = [];\n  this.enterScope(SCOPE_TOP);\n\n  // For RegExp validation\n  this.regexpState = null;\n};\n\nvar prototypeAccessors = { inFunction: { configurable: true },inGenerator: { configurable: true },inAsync: { configurable: true },allowSuper: { configurable: true },allowDirectSuper: { configurable: true },treatFunctionsAsVar: { configurable: true } };\n\nParser.prototype.parse = function parse () {\n  var node = this.options.program || this.startNode();\n  this.nextToken();\n  return this.parseTopLevel(node)\n};\n\nprototypeAccessors.inFunction.get = function () { return (this.currentVarScope().flags & SCOPE_FUNCTION) > 0 };\nprototypeAccessors.inGenerator.get = function () { return (this.currentVarScope().flags & SCOPE_GENERATOR) > 0 };\nprototypeAccessors.inAsync.get = function () { return (this.currentVarScope().flags & SCOPE_ASYNC) > 0 };\nprototypeAccessors.allowSuper.get = function () { return (this.currentThisScope().flags & SCOPE_SUPER) > 0 };\nprototypeAccessors.allowDirectSuper.get = function () { return (this.currentThisScope().flags & SCOPE_DIRECT_SUPER) > 0 };\nprototypeAccessors.treatFunctionsAsVar.get = function () { return this.treatFunctionsAsVarInScope(this.currentScope()) };\n\n// Switch to a getter for 7.0.0.\nParser.prototype.inNonArrowFunction = function inNonArrowFunction () { return (this.currentThisScope().flags & SCOPE_FUNCTION) > 0 };\n\nParser.extend = function extend () {\n    var plugins = [], len = arguments.length;\n    while ( len-- ) plugins[ len ] = arguments[ len ];\n\n  var cls = this;\n  for (var i = 0; i < plugins.length; i++) { cls = plugins[i](cls); }\n  return cls\n};\n\nParser.parse = function parse (input, options) {\n  return new this(options, input).parse()\n};\n\nParser.parseExpressionAt = function parseExpressionAt (input, pos, options) {\n  var parser = new this(options, input, pos);\n  parser.nextToken();\n  return parser.parseExpression()\n};\n\nParser.tokenizer = function tokenizer (input, options) {\n  return new this(options, input)\n};\n\nObject.defineProperties( Parser.prototype, prototypeAccessors );\n\nvar pp = Parser.prototype;\n\n// ## Parser utilities\n\nvar literal = /^(?:'((?:\\\\.|[^'\\\\])*?)'|\"((?:\\\\.|[^\"\\\\])*?)\")/;\npp.strictDirective = function(start) {\n  for (;;) {\n    // Try to find string literal.\n    skipWhiteSpace.lastIndex = start;\n    start += skipWhiteSpace.exec(this.input)[0].length;\n    var match = literal.exec(this.input.slice(start));\n    if (!match) { return false }\n    if ((match[1] || match[2]) === \"use strict\") {\n      skipWhiteSpace.lastIndex = start + match[0].length;\n      var spaceAfter = skipWhiteSpace.exec(this.input), end = spaceAfter.index + spaceAfter[0].length;\n      var next = this.input.charAt(end);\n      return next === \";\" || next === \"}\" ||\n        (lineBreak.test(spaceAfter[0]) &&\n         !(/[(`.[+\\-/*%<>=,?^&]/.test(next) || next === \"!\" && this.input.charAt(end + 1) === \"=\"))\n    }\n    start += match[0].length;\n\n    // Skip semicolon, if any.\n    skipWhiteSpace.lastIndex = start;\n    start += skipWhiteSpace.exec(this.input)[0].length;\n    if (this.input[start] === \";\")\n      { start++; }\n  }\n};\n\n// Predicate that tests whether the next token is of the given\n// type, and if yes, consumes it as a side effect.\n\npp.eat = function(type) {\n  if (this.type === type) {\n    this.next();\n    return true\n  } else {\n    return false\n  }\n};\n\n// Tests whether parsed token is a contextual keyword.\n\npp.isContextual = function(name) {\n  return this.type === types.name && this.value === name && !this.containsEsc\n};\n\n// Consumes contextual keyword if possible.\n\npp.eatContextual = function(name) {\n  if (!this.isContextual(name)) { return false }\n  this.next();\n  return true\n};\n\n// Asserts that following token is given contextual keyword.\n\npp.expectContextual = function(name) {\n  if (!this.eatContextual(name)) { this.unexpected(); }\n};\n\n// Test whether a semicolon can be inserted at the current position.\n\npp.canInsertSemicolon = function() {\n  return this.type === types.eof ||\n    this.type === types.braceR ||\n    lineBreak.test(this.input.slice(this.lastTokEnd, this.start))\n};\n\npp.insertSemicolon = function() {\n  if (this.canInsertSemicolon()) {\n    if (this.options.onInsertedSemicolon)\n      { this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc); }\n    return true\n  }\n};\n\n// Consume a semicolon, or, failing that, see if we are allowed to\n// pretend that there is a semicolon at this position.\n\npp.semicolon = function() {\n  if (!this.eat(types.semi) && !this.insertSemicolon()) { this.unexpected(); }\n};\n\npp.afterTrailingComma = function(tokType, notNext) {\n  if (this.type === tokType) {\n    if (this.options.onTrailingComma)\n      { this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc); }\n    if (!notNext)\n      { this.next(); }\n    return true\n  }\n};\n\n// Expect a token of a given type. If found, consume it, otherwise,\n// raise an unexpected token error.\n\npp.expect = function(type) {\n  this.eat(type) || this.unexpected();\n};\n\n// Raise an unexpected token error.\n\npp.unexpected = function(pos) {\n  this.raise(pos != null ? pos : this.start, \"Unexpected token\");\n};\n\nfunction DestructuringErrors() {\n  this.shorthandAssign =\n  this.trailingComma =\n  this.parenthesizedAssign =\n  this.parenthesizedBind =\n  this.doubleProto =\n    -1;\n}\n\npp.checkPatternErrors = function(refDestructuringErrors, isAssign) {\n  if (!refDestructuringErrors) { return }\n  if (refDestructuringErrors.trailingComma > -1)\n    { this.raiseRecoverable(refDestructuringErrors.trailingComma, \"Comma is not permitted after the rest element\"); }\n  var parens = isAssign ? refDestructuringErrors.parenthesizedAssign : refDestructuringErrors.parenthesizedBind;\n  if (parens > -1) { this.raiseRecoverable(parens, \"Parenthesized pattern\"); }\n};\n\npp.checkExpressionErrors = function(refDestructuringErrors, andThrow) {\n  if (!refDestructuringErrors) { return false }\n  var shorthandAssign = refDestructuringErrors.shorthandAssign;\n  var doubleProto = refDestructuringErrors.doubleProto;\n  if (!andThrow) { return shorthandAssign >= 0 || doubleProto >= 0 }\n  if (shorthandAssign >= 0)\n    { this.raise(shorthandAssign, \"Shorthand property assignments are valid only in destructuring patterns\"); }\n  if (doubleProto >= 0)\n    { this.raiseRecoverable(doubleProto, \"Redefinition of __proto__ property\"); }\n};\n\npp.checkYieldAwaitInDefaultParams = function() {\n  if (this.yieldPos && (!this.awaitPos || this.yieldPos < this.awaitPos))\n    { this.raise(this.yieldPos, \"Yield expression cannot be a default value\"); }\n  if (this.awaitPos)\n    { this.raise(this.awaitPos, \"Await expression cannot be a default value\"); }\n};\n\npp.isSimpleAssignTarget = function(expr) {\n  if (expr.type === \"ParenthesizedExpression\")\n    { return this.isSimpleAssignTarget(expr.expression) }\n  return expr.type === \"Identifier\" || expr.type === \"MemberExpression\"\n};\n\nvar pp$1 = Parser.prototype;\n\n// ### Statement parsing\n\n// Parse a program. Initializes the parser, reads any number of\n// statements, and wraps them in a Program node.  Optionally takes a\n// `program` argument.  If present, the statements will be appended\n// to its body instead of creating a new node.\n\npp$1.parseTopLevel = function(node) {\n  var exports = {};\n  if (!node.body) { node.body = []; }\n  while (this.type !== types.eof) {\n    var stmt = this.parseStatement(null, true, exports);\n    node.body.push(stmt);\n  }\n  if (this.inModule)\n    { for (var i = 0, list = Object.keys(this.undefinedExports); i < list.length; i += 1)\n      {\n        var name = list[i];\n\n        this.raiseRecoverable(this.undefinedExports[name].start, (\"Export '\" + name + \"' is not defined\"));\n      } }\n  this.adaptDirectivePrologue(node.body);\n  this.next();\n  node.sourceType = this.options.sourceType;\n  return this.finishNode(node, \"Program\")\n};\n\nvar loopLabel = {kind: \"loop\"}, switchLabel = {kind: \"switch\"};\n\npp$1.isLet = function(context) {\n  if (this.options.ecmaVersion < 6 || !this.isContextual(\"let\")) { return false }\n  skipWhiteSpace.lastIndex = this.pos;\n  var skip = skipWhiteSpace.exec(this.input);\n  var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);\n  // For ambiguous cases, determine if a LexicalDeclaration (or only a\n  // Statement) is allowed here. If context is not empty then only a Statement\n  // is allowed. However, `let [` is an explicit negative lookahead for\n  // ExpressionStatement, so special-case it first.\n  if (nextCh === 91) { return true } // '['\n  if (context) { return false }\n\n  if (nextCh === 123) { return true } // '{'\n  if (isIdentifierStart(nextCh, true)) {\n    var pos = next + 1;\n    while (isIdentifierChar(this.input.charCodeAt(pos), true)) { ++pos; }\n    var ident = this.input.slice(next, pos);\n    if (!keywordRelationalOperator.test(ident)) { return true }\n  }\n  return false\n};\n\n// check 'async [no LineTerminator here] function'\n// - 'async /*foo*/ function' is OK.\n// - 'async /*\\n*/ function' is invalid.\npp$1.isAsyncFunction = function() {\n  if (this.options.ecmaVersion < 8 || !this.isContextual(\"async\"))\n    { return false }\n\n  skipWhiteSpace.lastIndex = this.pos;\n  var skip = skipWhiteSpace.exec(this.input);\n  var next = this.pos + skip[0].length;\n  return !lineBreak.test(this.input.slice(this.pos, next)) &&\n    this.input.slice(next, next + 8) === \"function\" &&\n    (next + 8 === this.input.length || !isIdentifierChar(this.input.charAt(next + 8)))\n};\n\n// Parse a single statement.\n//\n// If expecting a statement and finding a slash operator, parse a\n// regular expression literal. This is to handle cases like\n// `if (foo) /blah/.exec(foo)`, where looking at the previous token\n// does not help.\n\npp$1.parseStatement = function(context, topLevel, exports) {\n  var starttype = this.type, node = this.startNode(), kind;\n\n  if (this.isLet(context)) {\n    starttype = types._var;\n    kind = \"let\";\n  }\n\n  // Most types of statements are recognized by the keyword they\n  // start with. Many are trivial to parse, some require a bit of\n  // complexity.\n\n  switch (starttype) {\n  case types._break: case types._continue: return this.parseBreakContinueStatement(node, starttype.keyword)\n  case types._debugger: return this.parseDebuggerStatement(node)\n  case types._do: return this.parseDoStatement(node)\n  case types._for: return this.parseForStatement(node)\n  case types._function:\n    // Function as sole body of either an if statement or a labeled statement\n    // works, but not when it is part of a labeled statement that is the sole\n    // body of an if statement.\n    if ((context && (this.strict || context !== \"if\" && context !== \"label\")) && this.options.ecmaVersion >= 6) { this.unexpected(); }\n    return this.parseFunctionStatement(node, false, !context)\n  case types._class:\n    if (context) { this.unexpected(); }\n    return this.parseClass(node, true)\n  case types._if: return this.parseIfStatement(node)\n  case types._return: return this.parseReturnStatement(node)\n  case types._switch: return this.parseSwitchStatement(node)\n  case types._throw: return this.parseThrowStatement(node)\n  case types._try: return this.parseTryStatement(node)\n  case types._const: case types._var:\n    kind = kind || this.value;\n    if (context && kind !== \"var\") { this.unexpected(); }\n    return this.parseVarStatement(node, kind)\n  case types._while: return this.parseWhileStatement(node)\n  case types._with: return this.parseWithStatement(node)\n  case types.braceL: return this.parseBlock(true, node)\n  case types.semi: return this.parseEmptyStatement(node)\n  case types._export:\n  case types._import:\n    if (this.options.ecmaVersion > 10 && starttype === types._import) {\n      skipWhiteSpace.lastIndex = this.pos;\n      var skip = skipWhiteSpace.exec(this.input);\n      var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);\n      if (nextCh === 40 || nextCh === 46) // '(' or '.'\n        { return this.parseExpressionStatement(node, this.parseExpression()) }\n    }\n\n    if (!this.options.allowImportExportEverywhere) {\n      if (!topLevel)\n        { this.raise(this.start, \"'import' and 'export' may only appear at the top level\"); }\n      if (!this.inModule)\n        { this.raise(this.start, \"'import' and 'export' may appear only with 'sourceType: module'\"); }\n    }\n    return starttype === types._import ? this.parseImport(node) : this.parseExport(node, exports)\n\n    // If the statement does not start with a statement keyword or a\n    // brace, it's an ExpressionStatement or LabeledStatement. We\n    // simply start parsing an expression, and afterwards, if the\n    // next token is a colon and the expression was a simple\n    // Identifier node, we switch to interpreting it as a label.\n  default:\n    if (this.isAsyncFunction()) {\n      if (context) { this.unexpected(); }\n      this.next();\n      return this.parseFunctionStatement(node, true, !context)\n    }\n\n    var maybeName = this.value, expr = this.parseExpression();\n    if (starttype === types.name && expr.type === \"Identifier\" && this.eat(types.colon))\n      { return this.parseLabeledStatement(node, maybeName, expr, context) }\n    else { return this.parseExpressionStatement(node, expr) }\n  }\n};\n\npp$1.parseBreakContinueStatement = function(node, keyword) {\n  var isBreak = keyword === \"break\";\n  this.next();\n  if (this.eat(types.semi) || this.insertSemicolon()) { node.label = null; }\n  else if (this.type !== types.name) { this.unexpected(); }\n  else {\n    node.label = this.parseIdent();\n    this.semicolon();\n  }\n\n  // Verify that there is an actual destination to break or\n  // continue to.\n  var i = 0;\n  for (; i < this.labels.length; ++i) {\n    var lab = this.labels[i];\n    if (node.label == null || lab.name === node.label.name) {\n      if (lab.kind != null && (isBreak || lab.kind === \"loop\")) { break }\n      if (node.label && isBreak) { break }\n    }\n  }\n  if (i === this.labels.length) { this.raise(node.start, \"Unsyntactic \" + keyword); }\n  return this.finishNode(node, isBreak ? \"BreakStatement\" : \"ContinueStatement\")\n};\n\npp$1.parseDebuggerStatement = function(node) {\n  this.next();\n  this.semicolon();\n  return this.finishNode(node, \"DebuggerStatement\")\n};\n\npp$1.parseDoStatement = function(node) {\n  this.next();\n  this.labels.push(loopLabel);\n  node.body = this.parseStatement(\"do\");\n  this.labels.pop();\n  this.expect(types._while);\n  node.test = this.parseParenExpression();\n  if (this.options.ecmaVersion >= 6)\n    { this.eat(types.semi); }\n  else\n    { this.semicolon(); }\n  return this.finishNode(node, \"DoWhileStatement\")\n};\n\n// Disambiguating between a `for` and a `for`/`in` or `for`/`of`\n// loop is non-trivial. Basically, we have to parse the init `var`\n// statement or expression, disallowing the `in` operator (see\n// the second parameter to `parseExpression`), and then check\n// whether the next token is `in` or `of`. When there is no init\n// part (semicolon immediately after the opening parenthesis), it\n// is a regular `for` loop.\n\npp$1.parseForStatement = function(node) {\n  this.next();\n  var awaitAt = (this.options.ecmaVersion >= 9 && (this.inAsync || (!this.inFunction && this.options.allowAwaitOutsideFunction)) && this.eatContextual(\"await\")) ? this.lastTokStart : -1;\n  this.labels.push(loopLabel);\n  this.enterScope(0);\n  this.expect(types.parenL);\n  if (this.type === types.semi) {\n    if (awaitAt > -1) { this.unexpected(awaitAt); }\n    return this.parseFor(node, null)\n  }\n  var isLet = this.isLet();\n  if (this.type === types._var || this.type === types._const || isLet) {\n    var init$1 = this.startNode(), kind = isLet ? \"let\" : this.value;\n    this.next();\n    this.parseVar(init$1, true, kind);\n    this.finishNode(init$1, \"VariableDeclaration\");\n    if ((this.type === types._in || (this.options.ecmaVersion >= 6 && this.isContextual(\"of\"))) && init$1.declarations.length === 1) {\n      if (this.options.ecmaVersion >= 9) {\n        if (this.type === types._in) {\n          if (awaitAt > -1) { this.unexpected(awaitAt); }\n        } else { node.await = awaitAt > -1; }\n      }\n      return this.parseForIn(node, init$1)\n    }\n    if (awaitAt > -1) { this.unexpected(awaitAt); }\n    return this.parseFor(node, init$1)\n  }\n  var refDestructuringErrors = new DestructuringErrors;\n  var init = this.parseExpression(true, refDestructuringErrors);\n  if (this.type === types._in || (this.options.ecmaVersion >= 6 && this.isContextual(\"of\"))) {\n    if (this.options.ecmaVersion >= 9) {\n      if (this.type === types._in) {\n        if (awaitAt > -1) { this.unexpected(awaitAt); }\n      } else { node.await = awaitAt > -1; }\n    }\n    this.toAssignable(init, false, refDestructuringErrors);\n    this.checkLVal(init);\n    return this.parseForIn(node, init)\n  } else {\n    this.checkExpressionErrors(refDestructuringErrors, true);\n  }\n  if (awaitAt > -1) { this.unexpected(awaitAt); }\n  return this.parseFor(node, init)\n};\n\npp$1.parseFunctionStatement = function(node, isAsync, declarationPosition) {\n  this.next();\n  return this.parseFunction(node, FUNC_STATEMENT | (declarationPosition ? 0 : FUNC_HANGING_STATEMENT), false, isAsync)\n};\n\npp$1.parseIfStatement = function(node) {\n  this.next();\n  node.test = this.parseParenExpression();\n  // allow function declarations in branches, but only in non-strict mode\n  node.consequent = this.parseStatement(\"if\");\n  node.alternate = this.eat(types._else) ? this.parseStatement(\"if\") : null;\n  return this.finishNode(node, \"IfStatement\")\n};\n\npp$1.parseReturnStatement = function(node) {\n  if (!this.inFunction && !this.options.allowReturnOutsideFunction)\n    { this.raise(this.start, \"'return' outside of function\"); }\n  this.next();\n\n  // In `return` (and `break`/`continue`), the keywords with\n  // optional arguments, we eagerly look for a semicolon or the\n  // possibility to insert one.\n\n  if (this.eat(types.semi) || this.insertSemicolon()) { node.argument = null; }\n  else { node.argument = this.parseExpression(); this.semicolon(); }\n  return this.finishNode(node, \"ReturnStatement\")\n};\n\npp$1.parseSwitchStatement = function(node) {\n  this.next();\n  node.discriminant = this.parseParenExpression();\n  node.cases = [];\n  this.expect(types.braceL);\n  this.labels.push(switchLabel);\n  this.enterScope(0);\n\n  // Statements under must be grouped (by label) in SwitchCase\n  // nodes. `cur` is used to keep the node that we are currently\n  // adding statements to.\n\n  var cur;\n  for (var sawDefault = false; this.type !== types.braceR;) {\n    if (this.type === types._case || this.type === types._default) {\n      var isCase = this.type === types._case;\n      if (cur) { this.finishNode(cur, \"SwitchCase\"); }\n      node.cases.push(cur = this.startNode());\n      cur.consequent = [];\n      this.next();\n      if (isCase) {\n        cur.test = this.parseExpression();\n      } else {\n        if (sawDefault) { this.raiseRecoverable(this.lastTokStart, \"Multiple default clauses\"); }\n        sawDefault = true;\n        cur.test = null;\n      }\n      this.expect(types.colon);\n    } else {\n      if (!cur) { this.unexpected(); }\n      cur.consequent.push(this.parseStatement(null));\n    }\n  }\n  this.exitScope();\n  if (cur) { this.finishNode(cur, \"SwitchCase\"); }\n  this.next(); // Closing brace\n  this.labels.pop();\n  return this.finishNode(node, \"SwitchStatement\")\n};\n\npp$1.parseThrowStatement = function(node) {\n  this.next();\n  if (lineBreak.test(this.input.slice(this.lastTokEnd, this.start)))\n    { this.raise(this.lastTokEnd, \"Illegal newline after throw\"); }\n  node.argument = this.parseExpression();\n  this.semicolon();\n  return this.finishNode(node, \"ThrowStatement\")\n};\n\n// Reused empty array added for node fields that are always empty.\n\nvar empty = [];\n\npp$1.parseTryStatement = function(node) {\n  this.next();\n  node.block = this.parseBlock();\n  node.handler = null;\n  if (this.type === types._catch) {\n    var clause = this.startNode();\n    this.next();\n    if (this.eat(types.parenL)) {\n      clause.param = this.parseBindingAtom();\n      var simple = clause.param.type === \"Identifier\";\n      this.enterScope(simple ? SCOPE_SIMPLE_CATCH : 0);\n      this.checkLVal(clause.param, simple ? BIND_SIMPLE_CATCH : BIND_LEXICAL);\n      this.expect(types.parenR);\n    } else {\n      if (this.options.ecmaVersion < 10) { this.unexpected(); }\n      clause.param = null;\n      this.enterScope(0);\n    }\n    clause.body = this.parseBlock(false);\n    this.exitScope();\n    node.handler = this.finishNode(clause, \"CatchClause\");\n  }\n  node.finalizer = this.eat(types._finally) ? this.parseBlock() : null;\n  if (!node.handler && !node.finalizer)\n    { this.raise(node.start, \"Missing catch or finally clause\"); }\n  return this.finishNode(node, \"TryStatement\")\n};\n\npp$1.parseVarStatement = function(node, kind) {\n  this.next();\n  this.parseVar(node, false, kind);\n  this.semicolon();\n  return this.finishNode(node, \"VariableDeclaration\")\n};\n\npp$1.parseWhileStatement = function(node) {\n  this.next();\n  node.test = this.parseParenExpression();\n  this.labels.push(loopLabel);\n  node.body = this.parseStatement(\"while\");\n  this.labels.pop();\n  return this.finishNode(node, \"WhileStatement\")\n};\n\npp$1.parseWithStatement = function(node) {\n  if (this.strict) { this.raise(this.start, \"'with' in strict mode\"); }\n  this.next();\n  node.object = this.parseParenExpression();\n  node.body = this.parseStatement(\"with\");\n  return this.finishNode(node, \"WithStatement\")\n};\n\npp$1.parseEmptyStatement = function(node) {\n  this.next();\n  return this.finishNode(node, \"EmptyStatement\")\n};\n\npp$1.parseLabeledStatement = function(node, maybeName, expr, context) {\n  for (var i$1 = 0, list = this.labels; i$1 < list.length; i$1 += 1)\n    {\n    var label = list[i$1];\n\n    if (label.name === maybeName)\n      { this.raise(expr.start, \"Label '\" + maybeName + \"' is already declared\");\n  } }\n  var kind = this.type.isLoop ? \"loop\" : this.type === types._switch ? \"switch\" : null;\n  for (var i = this.labels.length - 1; i >= 0; i--) {\n    var label$1 = this.labels[i];\n    if (label$1.statementStart === node.start) {\n      // Update information about previous labels on this node\n      label$1.statementStart = this.start;\n      label$1.kind = kind;\n    } else { break }\n  }\n  this.labels.push({name: maybeName, kind: kind, statementStart: this.start});\n  node.body = this.parseStatement(context ? context.indexOf(\"label\") === -1 ? context + \"label\" : context : \"label\");\n  this.labels.pop();\n  node.label = expr;\n  return this.finishNode(node, \"LabeledStatement\")\n};\n\npp$1.parseExpressionStatement = function(node, expr) {\n  node.expression = expr;\n  this.semicolon();\n  return this.finishNode(node, \"ExpressionStatement\")\n};\n\n// Parse a semicolon-enclosed block of statements, handling `\"use\n// strict\"` declarations when `allowStrict` is true (used for\n// function bodies).\n\npp$1.parseBlock = function(createNewLexicalScope, node, exitStrict) {\n  if ( createNewLexicalScope === void 0 ) createNewLexicalScope = true;\n  if ( node === void 0 ) node = this.startNode();\n\n  node.body = [];\n  this.expect(types.braceL);\n  if (createNewLexicalScope) { this.enterScope(0); }\n  while (this.type !== types.braceR) {\n    var stmt = this.parseStatement(null);\n    node.body.push(stmt);\n  }\n  if (exitStrict) { this.strict = false; }\n  this.next();\n  if (createNewLexicalScope) { this.exitScope(); }\n  return this.finishNode(node, \"BlockStatement\")\n};\n\n// Parse a regular `for` loop. The disambiguation code in\n// `parseStatement` will already have parsed the init statement or\n// expression.\n\npp$1.parseFor = function(node, init) {\n  node.init = init;\n  this.expect(types.semi);\n  node.test = this.type === types.semi ? null : this.parseExpression();\n  this.expect(types.semi);\n  node.update = this.type === types.parenR ? null : this.parseExpression();\n  this.expect(types.parenR);\n  node.body = this.parseStatement(\"for\");\n  this.exitScope();\n  this.labels.pop();\n  return this.finishNode(node, \"ForStatement\")\n};\n\n// Parse a `for`/`in` and `for`/`of` loop, which are almost\n// same from parser's perspective.\n\npp$1.parseForIn = function(node, init) {\n  var isForIn = this.type === types._in;\n  this.next();\n\n  if (\n    init.type === \"VariableDeclaration\" &&\n    init.declarations[0].init != null &&\n    (\n      !isForIn ||\n      this.options.ecmaVersion < 8 ||\n      this.strict ||\n      init.kind !== \"var\" ||\n      init.declarations[0].id.type !== \"Identifier\"\n    )\n  ) {\n    this.raise(\n      init.start,\n      ((isForIn ? \"for-in\" : \"for-of\") + \" loop variable declaration may not have an initializer\")\n    );\n  } else if (init.type === \"AssignmentPattern\") {\n    this.raise(init.start, \"Invalid left-hand side in for-loop\");\n  }\n  node.left = init;\n  node.right = isForIn ? this.parseExpression() : this.parseMaybeAssign();\n  this.expect(types.parenR);\n  node.body = this.parseStatement(\"for\");\n  this.exitScope();\n  this.labels.pop();\n  return this.finishNode(node, isForIn ? \"ForInStatement\" : \"ForOfStatement\")\n};\n\n// Parse a list of variable declarations.\n\npp$1.parseVar = function(node, isFor, kind) {\n  node.declarations = [];\n  node.kind = kind;\n  for (;;) {\n    var decl = this.startNode();\n    this.parseVarId(decl, kind);\n    if (this.eat(types.eq)) {\n      decl.init = this.parseMaybeAssign(isFor);\n    } else if (kind === \"const\" && !(this.type === types._in || (this.options.ecmaVersion >= 6 && this.isContextual(\"of\")))) {\n      this.unexpected();\n    } else if (decl.id.type !== \"Identifier\" && !(isFor && (this.type === types._in || this.isContextual(\"of\")))) {\n      this.raise(this.lastTokEnd, \"Complex binding patterns require an initialization value\");\n    } else {\n      decl.init = null;\n    }\n    node.declarations.push(this.finishNode(decl, \"VariableDeclarator\"));\n    if (!this.eat(types.comma)) { break }\n  }\n  return node\n};\n\npp$1.parseVarId = function(decl, kind) {\n  decl.id = this.parseBindingAtom();\n  this.checkLVal(decl.id, kind === \"var\" ? BIND_VAR : BIND_LEXICAL, false);\n};\n\nvar FUNC_STATEMENT = 1, FUNC_HANGING_STATEMENT = 2, FUNC_NULLABLE_ID = 4;\n\n// Parse a function declaration or literal (depending on the\n// `statement & FUNC_STATEMENT`).\n\n// Remove `allowExpressionBody` for 7.0.0, as it is only called with false\npp$1.parseFunction = function(node, statement, allowExpressionBody, isAsync) {\n  this.initFunction(node);\n  if (this.options.ecmaVersion >= 9 || this.options.ecmaVersion >= 6 && !isAsync) {\n    if (this.type === types.star && (statement & FUNC_HANGING_STATEMENT))\n      { this.unexpected(); }\n    node.generator = this.eat(types.star);\n  }\n  if (this.options.ecmaVersion >= 8)\n    { node.async = !!isAsync; }\n\n  if (statement & FUNC_STATEMENT) {\n    node.id = (statement & FUNC_NULLABLE_ID) && this.type !== types.name ? null : this.parseIdent();\n    if (node.id && !(statement & FUNC_HANGING_STATEMENT))\n      // If it is a regular function declaration in sloppy mode, then it is\n      // subject to Annex B semantics (BIND_FUNCTION). Otherwise, the binding\n      // mode depends on properties of the current scope (see\n      // treatFunctionsAsVar).\n      { this.checkLVal(node.id, (this.strict || node.generator || node.async) ? this.treatFunctionsAsVar ? BIND_VAR : BIND_LEXICAL : BIND_FUNCTION); }\n  }\n\n  var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;\n  this.yieldPos = 0;\n  this.awaitPos = 0;\n  this.awaitIdentPos = 0;\n  this.enterScope(functionFlags(node.async, node.generator));\n\n  if (!(statement & FUNC_STATEMENT))\n    { node.id = this.type === types.name ? this.parseIdent() : null; }\n\n  this.parseFunctionParams(node);\n  this.parseFunctionBody(node, allowExpressionBody, false);\n\n  this.yieldPos = oldYieldPos;\n  this.awaitPos = oldAwaitPos;\n  this.awaitIdentPos = oldAwaitIdentPos;\n  return this.finishNode(node, (statement & FUNC_STATEMENT) ? \"FunctionDeclaration\" : \"FunctionExpression\")\n};\n\npp$1.parseFunctionParams = function(node) {\n  this.expect(types.parenL);\n  node.params = this.parseBindingList(types.parenR, false, this.options.ecmaVersion >= 8);\n  this.checkYieldAwaitInDefaultParams();\n};\n\n// Parse a class declaration or literal (depending on the\n// `isStatement` parameter).\n\npp$1.parseClass = function(node, isStatement) {\n  this.next();\n\n  // ecma-262 14.6 Class Definitions\n  // A class definition is always strict mode code.\n  var oldStrict = this.strict;\n  this.strict = true;\n\n  this.parseClassId(node, isStatement);\n  this.parseClassSuper(node);\n  var classBody = this.startNode();\n  var hadConstructor = false;\n  classBody.body = [];\n  this.expect(types.braceL);\n  while (this.type !== types.braceR) {\n    var element = this.parseClassElement(node.superClass !== null);\n    if (element) {\n      classBody.body.push(element);\n      if (element.type === \"MethodDefinition\" && element.kind === \"constructor\") {\n        if (hadConstructor) { this.raise(element.start, \"Duplicate constructor in the same class\"); }\n        hadConstructor = true;\n      }\n    }\n  }\n  this.strict = oldStrict;\n  this.next();\n  node.body = this.finishNode(classBody, \"ClassBody\");\n  return this.finishNode(node, isStatement ? \"ClassDeclaration\" : \"ClassExpression\")\n};\n\npp$1.parseClassElement = function(constructorAllowsSuper) {\n  var this$1 = this;\n\n  if (this.eat(types.semi)) { return null }\n\n  var method = this.startNode();\n  var tryContextual = function (k, noLineBreak) {\n    if ( noLineBreak === void 0 ) noLineBreak = false;\n\n    var start = this$1.start, startLoc = this$1.startLoc;\n    if (!this$1.eatContextual(k)) { return false }\n    if (this$1.type !== types.parenL && (!noLineBreak || !this$1.canInsertSemicolon())) { return true }\n    if (method.key) { this$1.unexpected(); }\n    method.computed = false;\n    method.key = this$1.startNodeAt(start, startLoc);\n    method.key.name = k;\n    this$1.finishNode(method.key, \"Identifier\");\n    return false\n  };\n\n  method.kind = \"method\";\n  method.static = tryContextual(\"static\");\n  var isGenerator = this.eat(types.star);\n  var isAsync = false;\n  if (!isGenerator) {\n    if (this.options.ecmaVersion >= 8 && tryContextual(\"async\", true)) {\n      isAsync = true;\n      isGenerator = this.options.ecmaVersion >= 9 && this.eat(types.star);\n    } else if (tryContextual(\"get\")) {\n      method.kind = \"get\";\n    } else if (tryContextual(\"set\")) {\n      method.kind = \"set\";\n    }\n  }\n  if (!method.key) { this.parsePropertyName(method); }\n  var key = method.key;\n  var allowsDirectSuper = false;\n  if (!method.computed && !method.static && (key.type === \"Identifier\" && key.name === \"constructor\" ||\n      key.type === \"Literal\" && key.value === \"constructor\")) {\n    if (method.kind !== \"method\") { this.raise(key.start, \"Constructor can't have get/set modifier\"); }\n    if (isGenerator) { this.raise(key.start, \"Constructor can't be a generator\"); }\n    if (isAsync) { this.raise(key.start, \"Constructor can't be an async method\"); }\n    method.kind = \"constructor\";\n    allowsDirectSuper = constructorAllowsSuper;\n  } else if (method.static && key.type === \"Identifier\" && key.name === \"prototype\") {\n    this.raise(key.start, \"Classes may not have a static property named prototype\");\n  }\n  this.parseClassMethod(method, isGenerator, isAsync, allowsDirectSuper);\n  if (method.kind === \"get\" && method.value.params.length !== 0)\n    { this.raiseRecoverable(method.value.start, \"getter should have no params\"); }\n  if (method.kind === \"set\" && method.value.params.length !== 1)\n    { this.raiseRecoverable(method.value.start, \"setter should have exactly one param\"); }\n  if (method.kind === \"set\" && method.value.params[0].type === \"RestElement\")\n    { this.raiseRecoverable(method.value.params[0].start, \"Setter cannot use rest params\"); }\n  return method\n};\n\npp$1.parseClassMethod = function(method, isGenerator, isAsync, allowsDirectSuper) {\n  method.value = this.parseMethod(isGenerator, isAsync, allowsDirectSuper);\n  return this.finishNode(method, \"MethodDefinition\")\n};\n\npp$1.parseClassId = function(node, isStatement) {\n  if (this.type === types.name) {\n    node.id = this.parseIdent();\n    if (isStatement)\n      { this.checkLVal(node.id, BIND_LEXICAL, false); }\n  } else {\n    if (isStatement === true)\n      { this.unexpected(); }\n    node.id = null;\n  }\n};\n\npp$1.parseClassSuper = function(node) {\n  node.superClass = this.eat(types._extends) ? this.parseExprSubscripts() : null;\n};\n\n// Parses module export declaration.\n\npp$1.parseExport = function(node, exports) {\n  this.next();\n  // export * from '...'\n  if (this.eat(types.star)) {\n    if (this.options.ecmaVersion >= 11) {\n      if (this.eatContextual(\"as\")) {\n        node.exported = this.parseIdent(true);\n        this.checkExport(exports, node.exported.name, this.lastTokStart);\n      } else {\n        node.exported = null;\n      }\n    }\n    this.expectContextual(\"from\");\n    if (this.type !== types.string) { this.unexpected(); }\n    node.source = this.parseExprAtom();\n    this.semicolon();\n    return this.finishNode(node, \"ExportAllDeclaration\")\n  }\n  if (this.eat(types._default)) { // export default ...\n    this.checkExport(exports, \"default\", this.lastTokStart);\n    var isAsync;\n    if (this.type === types._function || (isAsync = this.isAsyncFunction())) {\n      var fNode = this.startNode();\n      this.next();\n      if (isAsync) { this.next(); }\n      node.declaration = this.parseFunction(fNode, FUNC_STATEMENT | FUNC_NULLABLE_ID, false, isAsync);\n    } else if (this.type === types._class) {\n      var cNode = this.startNode();\n      node.declaration = this.parseClass(cNode, \"nullableID\");\n    } else {\n      node.declaration = this.parseMaybeAssign();\n      this.semicolon();\n    }\n    return this.finishNode(node, \"ExportDefaultDeclaration\")\n  }\n  // export var|const|let|function|class ...\n  if (this.shouldParseExportStatement()) {\n    node.declaration = this.parseStatement(null);\n    if (node.declaration.type === \"VariableDeclaration\")\n      { this.checkVariableExport(exports, node.declaration.declarations); }\n    else\n      { this.checkExport(exports, node.declaration.id.name, node.declaration.id.start); }\n    node.specifiers = [];\n    node.source = null;\n  } else { // export { x, y as z } [from '...']\n    node.declaration = null;\n    node.specifiers = this.parseExportSpecifiers(exports);\n    if (this.eatContextual(\"from\")) {\n      if (this.type !== types.string) { this.unexpected(); }\n      node.source = this.parseExprAtom();\n    } else {\n      for (var i = 0, list = node.specifiers; i < list.length; i += 1) {\n        // check for keywords used as local names\n        var spec = list[i];\n\n        this.checkUnreserved(spec.local);\n        // check if export is defined\n        this.checkLocalExport(spec.local);\n      }\n\n      node.source = null;\n    }\n    this.semicolon();\n  }\n  return this.finishNode(node, \"ExportNamedDeclaration\")\n};\n\npp$1.checkExport = function(exports, name, pos) {\n  if (!exports) { return }\n  if (has(exports, name))\n    { this.raiseRecoverable(pos, \"Duplicate export '\" + name + \"'\"); }\n  exports[name] = true;\n};\n\npp$1.checkPatternExport = function(exports, pat) {\n  var type = pat.type;\n  if (type === \"Identifier\")\n    { this.checkExport(exports, pat.name, pat.start); }\n  else if (type === \"ObjectPattern\")\n    { for (var i = 0, list = pat.properties; i < list.length; i += 1)\n      {\n        var prop = list[i];\n\n        this.checkPatternExport(exports, prop);\n      } }\n  else if (type === \"ArrayPattern\")\n    { for (var i$1 = 0, list$1 = pat.elements; i$1 < list$1.length; i$1 += 1) {\n      var elt = list$1[i$1];\n\n        if (elt) { this.checkPatternExport(exports, elt); }\n    } }\n  else if (type === \"Property\")\n    { this.checkPatternExport(exports, pat.value); }\n  else if (type === \"AssignmentPattern\")\n    { this.checkPatternExport(exports, pat.left); }\n  else if (type === \"RestElement\")\n    { this.checkPatternExport(exports, pat.argument); }\n  else if (type === \"ParenthesizedExpression\")\n    { this.checkPatternExport(exports, pat.expression); }\n};\n\npp$1.checkVariableExport = function(exports, decls) {\n  if (!exports) { return }\n  for (var i = 0, list = decls; i < list.length; i += 1)\n    {\n    var decl = list[i];\n\n    this.checkPatternExport(exports, decl.id);\n  }\n};\n\npp$1.shouldParseExportStatement = function() {\n  return this.type.keyword === \"var\" ||\n    this.type.keyword === \"const\" ||\n    this.type.keyword === \"class\" ||\n    this.type.keyword === \"function\" ||\n    this.isLet() ||\n    this.isAsyncFunction()\n};\n\n// Parses a comma-separated list of module exports.\n\npp$1.parseExportSpecifiers = function(exports) {\n  var nodes = [], first = true;\n  // export { x, y as z } [from '...']\n  this.expect(types.braceL);\n  while (!this.eat(types.braceR)) {\n    if (!first) {\n      this.expect(types.comma);\n      if (this.afterTrailingComma(types.braceR)) { break }\n    } else { first = false; }\n\n    var node = this.startNode();\n    node.local = this.parseIdent(true);\n    node.exported = this.eatContextual(\"as\") ? this.parseIdent(true) : node.local;\n    this.checkExport(exports, node.exported.name, node.exported.start);\n    nodes.push(this.finishNode(node, \"ExportSpecifier\"));\n  }\n  return nodes\n};\n\n// Parses import declaration.\n\npp$1.parseImport = function(node) {\n  this.next();\n  // import '...'\n  if (this.type === types.string) {\n    node.specifiers = empty;\n    node.source = this.parseExprAtom();\n  } else {\n    node.specifiers = this.parseImportSpecifiers();\n    this.expectContextual(\"from\");\n    node.source = this.type === types.string ? this.parseExprAtom() : this.unexpected();\n  }\n  this.semicolon();\n  return this.finishNode(node, \"ImportDeclaration\")\n};\n\n// Parses a comma-separated list of module imports.\n\npp$1.parseImportSpecifiers = function() {\n  var nodes = [], first = true;\n  if (this.type === types.name) {\n    // import defaultObj, { x, y as z } from '...'\n    var node = this.startNode();\n    node.local = this.parseIdent();\n    this.checkLVal(node.local, BIND_LEXICAL);\n    nodes.push(this.finishNode(node, \"ImportDefaultSpecifier\"));\n    if (!this.eat(types.comma)) { return nodes }\n  }\n  if (this.type === types.star) {\n    var node$1 = this.startNode();\n    this.next();\n    this.expectContextual(\"as\");\n    node$1.local = this.parseIdent();\n    this.checkLVal(node$1.local, BIND_LEXICAL);\n    nodes.push(this.finishNode(node$1, \"ImportNamespaceSpecifier\"));\n    return nodes\n  }\n  this.expect(types.braceL);\n  while (!this.eat(types.braceR)) {\n    if (!first) {\n      this.expect(types.comma);\n      if (this.afterTrailingComma(types.braceR)) { break }\n    } else { first = false; }\n\n    var node$2 = this.startNode();\n    node$2.imported = this.parseIdent(true);\n    if (this.eatContextual(\"as\")) {\n      node$2.local = this.parseIdent();\n    } else {\n      this.checkUnreserved(node$2.imported);\n      node$2.local = node$2.imported;\n    }\n    this.checkLVal(node$2.local, BIND_LEXICAL);\n    nodes.push(this.finishNode(node$2, \"ImportSpecifier\"));\n  }\n  return nodes\n};\n\n// Set `ExpressionStatement#directive` property for directive prologues.\npp$1.adaptDirectivePrologue = function(statements) {\n  for (var i = 0; i < statements.length && this.isDirectiveCandidate(statements[i]); ++i) {\n    statements[i].directive = statements[i].expression.raw.slice(1, -1);\n  }\n};\npp$1.isDirectiveCandidate = function(statement) {\n  return (\n    statement.type === \"ExpressionStatement\" &&\n    statement.expression.type === \"Literal\" &&\n    typeof statement.expression.value === \"string\" &&\n    // Reject parenthesized strings.\n    (this.input[statement.start] === \"\\\"\" || this.input[statement.start] === \"'\")\n  )\n};\n\nvar pp$2 = Parser.prototype;\n\n// Convert existing expression atom to assignable pattern\n// if possible.\n\npp$2.toAssignable = function(node, isBinding, refDestructuringErrors) {\n  if (this.options.ecmaVersion >= 6 && node) {\n    switch (node.type) {\n    case \"Identifier\":\n      if (this.inAsync && node.name === \"await\")\n        { this.raise(node.start, \"Cannot use 'await' as identifier inside an async function\"); }\n      break\n\n    case \"ObjectPattern\":\n    case \"ArrayPattern\":\n    case \"RestElement\":\n      break\n\n    case \"ObjectExpression\":\n      node.type = \"ObjectPattern\";\n      if (refDestructuringErrors) { this.checkPatternErrors(refDestructuringErrors, true); }\n      for (var i = 0, list = node.properties; i < list.length; i += 1) {\n        var prop = list[i];\n\n      this.toAssignable(prop, isBinding);\n        // Early error:\n        //   AssignmentRestProperty[Yield, Await] :\n        //     `...` DestructuringAssignmentTarget[Yield, Await]\n        //\n        //   It is a Syntax Error if |DestructuringAssignmentTarget| is an |ArrayLiteral| or an |ObjectLiteral|.\n        if (\n          prop.type === \"RestElement\" &&\n          (prop.argument.type === \"ArrayPattern\" || prop.argument.type === \"ObjectPattern\")\n        ) {\n          this.raise(prop.argument.start, \"Unexpected token\");\n        }\n      }\n      break\n\n    case \"Property\":\n      // AssignmentProperty has type === \"Property\"\n      if (node.kind !== \"init\") { this.raise(node.key.start, \"Object pattern can't contain getter or setter\"); }\n      this.toAssignable(node.value, isBinding);\n      break\n\n    case \"ArrayExpression\":\n      node.type = \"ArrayPattern\";\n      if (refDestructuringErrors) { this.checkPatternErrors(refDestructuringErrors, true); }\n      this.toAssignableList(node.elements, isBinding);\n      break\n\n    case \"SpreadElement\":\n      node.type = \"RestElement\";\n      this.toAssignable(node.argument, isBinding);\n      if (node.argument.type === \"AssignmentPattern\")\n        { this.raise(node.argument.start, \"Rest elements cannot have a default value\"); }\n      break\n\n    case \"AssignmentExpression\":\n      if (node.operator !== \"=\") { this.raise(node.left.end, \"Only '=' operator can be used for specifying default value.\"); }\n      node.type = \"AssignmentPattern\";\n      delete node.operator;\n      this.toAssignable(node.left, isBinding);\n      // falls through to AssignmentPattern\n\n    case \"AssignmentPattern\":\n      break\n\n    case \"ParenthesizedExpression\":\n      this.toAssignable(node.expression, isBinding, refDestructuringErrors);\n      break\n\n    case \"ChainExpression\":\n      this.raiseRecoverable(node.start, \"Optional chaining cannot appear in left-hand side\");\n      break\n\n    case \"MemberExpression\":\n      if (!isBinding) { break }\n\n    default:\n      this.raise(node.start, \"Assigning to rvalue\");\n    }\n  } else if (refDestructuringErrors) { this.checkPatternErrors(refDestructuringErrors, true); }\n  return node\n};\n\n// Convert list of expression atoms to binding list.\n\npp$2.toAssignableList = function(exprList, isBinding) {\n  var end = exprList.length;\n  for (var i = 0; i < end; i++) {\n    var elt = exprList[i];\n    if (elt) { this.toAssignable(elt, isBinding); }\n  }\n  if (end) {\n    var last = exprList[end - 1];\n    if (this.options.ecmaVersion === 6 && isBinding && last && last.type === \"RestElement\" && last.argument.type !== \"Identifier\")\n      { this.unexpected(last.argument.start); }\n  }\n  return exprList\n};\n\n// Parses spread element.\n\npp$2.parseSpread = function(refDestructuringErrors) {\n  var node = this.startNode();\n  this.next();\n  node.argument = this.parseMaybeAssign(false, refDestructuringErrors);\n  return this.finishNode(node, \"SpreadElement\")\n};\n\npp$2.parseRestBinding = function() {\n  var node = this.startNode();\n  this.next();\n\n  // RestElement inside of a function parameter must be an identifier\n  if (this.options.ecmaVersion === 6 && this.type !== types.name)\n    { this.unexpected(); }\n\n  node.argument = this.parseBindingAtom();\n\n  return this.finishNode(node, \"RestElement\")\n};\n\n// Parses lvalue (assignable) atom.\n\npp$2.parseBindingAtom = function() {\n  if (this.options.ecmaVersion >= 6) {\n    switch (this.type) {\n    case types.bracketL:\n      var node = this.startNode();\n      this.next();\n      node.elements = this.parseBindingList(types.bracketR, true, true);\n      return this.finishNode(node, \"ArrayPattern\")\n\n    case types.braceL:\n      return this.parseObj(true)\n    }\n  }\n  return this.parseIdent()\n};\n\npp$2.parseBindingList = function(close, allowEmpty, allowTrailingComma) {\n  var elts = [], first = true;\n  while (!this.eat(close)) {\n    if (first) { first = false; }\n    else { this.expect(types.comma); }\n    if (allowEmpty && this.type === types.comma) {\n      elts.push(null);\n    } else if (allowTrailingComma && this.afterTrailingComma(close)) {\n      break\n    } else if (this.type === types.ellipsis) {\n      var rest = this.parseRestBinding();\n      this.parseBindingListItem(rest);\n      elts.push(rest);\n      if (this.type === types.comma) { this.raise(this.start, \"Comma is not permitted after the rest element\"); }\n      this.expect(close);\n      break\n    } else {\n      var elem = this.parseMaybeDefault(this.start, this.startLoc);\n      this.parseBindingListItem(elem);\n      elts.push(elem);\n    }\n  }\n  return elts\n};\n\npp$2.parseBindingListItem = function(param) {\n  return param\n};\n\n// Parses assignment pattern around given atom if possible.\n\npp$2.parseMaybeDefault = function(startPos, startLoc, left) {\n  left = left || this.parseBindingAtom();\n  if (this.options.ecmaVersion < 6 || !this.eat(types.eq)) { return left }\n  var node = this.startNodeAt(startPos, startLoc);\n  node.left = left;\n  node.right = this.parseMaybeAssign();\n  return this.finishNode(node, \"AssignmentPattern\")\n};\n\n// Verify that a node is an lval — something that can be assigned\n// to.\n// bindingType can be either:\n// 'var' indicating that the lval creates a 'var' binding\n// 'let' indicating that the lval creates a lexical ('let' or 'const') binding\n// 'none' indicating that the binding should be checked for illegal identifiers, but not for duplicate references\n\npp$2.checkLVal = function(expr, bindingType, checkClashes) {\n  if ( bindingType === void 0 ) bindingType = BIND_NONE;\n\n  switch (expr.type) {\n  case \"Identifier\":\n    if (bindingType === BIND_LEXICAL && expr.name === \"let\")\n      { this.raiseRecoverable(expr.start, \"let is disallowed as a lexically bound name\"); }\n    if (this.strict && this.reservedWordsStrictBind.test(expr.name))\n      { this.raiseRecoverable(expr.start, (bindingType ? \"Binding \" : \"Assigning to \") + expr.name + \" in strict mode\"); }\n    if (checkClashes) {\n      if (has(checkClashes, expr.name))\n        { this.raiseRecoverable(expr.start, \"Argument name clash\"); }\n      checkClashes[expr.name] = true;\n    }\n    if (bindingType !== BIND_NONE && bindingType !== BIND_OUTSIDE) { this.declareName(expr.name, bindingType, expr.start); }\n    break\n\n  case \"ChainExpression\":\n    this.raiseRecoverable(expr.start, \"Optional chaining cannot appear in left-hand side\");\n    break\n\n  case \"MemberExpression\":\n    if (bindingType) { this.raiseRecoverable(expr.start, \"Binding member expression\"); }\n    break\n\n  case \"ObjectPattern\":\n    for (var i = 0, list = expr.properties; i < list.length; i += 1)\n      {\n    var prop = list[i];\n\n    this.checkLVal(prop, bindingType, checkClashes);\n  }\n    break\n\n  case \"Property\":\n    // AssignmentProperty has type === \"Property\"\n    this.checkLVal(expr.value, bindingType, checkClashes);\n    break\n\n  case \"ArrayPattern\":\n    for (var i$1 = 0, list$1 = expr.elements; i$1 < list$1.length; i$1 += 1) {\n      var elem = list$1[i$1];\n\n    if (elem) { this.checkLVal(elem, bindingType, checkClashes); }\n    }\n    break\n\n  case \"AssignmentPattern\":\n    this.checkLVal(expr.left, bindingType, checkClashes);\n    break\n\n  case \"RestElement\":\n    this.checkLVal(expr.argument, bindingType, checkClashes);\n    break\n\n  case \"ParenthesizedExpression\":\n    this.checkLVal(expr.expression, bindingType, checkClashes);\n    break\n\n  default:\n    this.raise(expr.start, (bindingType ? \"Binding\" : \"Assigning to\") + \" rvalue\");\n  }\n};\n\n// A recursive descent parser operates by defining functions for all\n\nvar pp$3 = Parser.prototype;\n\n// Check if property name clashes with already added.\n// Object/class getters and setters are not allowed to clash —\n// either with each other or with an init property — and in\n// strict mode, init properties are also not allowed to be repeated.\n\npp$3.checkPropClash = function(prop, propHash, refDestructuringErrors) {\n  if (this.options.ecmaVersion >= 9 && prop.type === \"SpreadElement\")\n    { return }\n  if (this.options.ecmaVersion >= 6 && (prop.computed || prop.method || prop.shorthand))\n    { return }\n  var key = prop.key;\n  var name;\n  switch (key.type) {\n  case \"Identifier\": name = key.name; break\n  case \"Literal\": name = String(key.value); break\n  default: return\n  }\n  var kind = prop.kind;\n  if (this.options.ecmaVersion >= 6) {\n    if (name === \"__proto__\" && kind === \"init\") {\n      if (propHash.proto) {\n        if (refDestructuringErrors) {\n          if (refDestructuringErrors.doubleProto < 0)\n            { refDestructuringErrors.doubleProto = key.start; }\n          // Backwards-compat kludge. Can be removed in version 6.0\n        } else { this.raiseRecoverable(key.start, \"Redefinition of __proto__ property\"); }\n      }\n      propHash.proto = true;\n    }\n    return\n  }\n  name = \"$\" + name;\n  var other = propHash[name];\n  if (other) {\n    var redefinition;\n    if (kind === \"init\") {\n      redefinition = this.strict && other.init || other.get || other.set;\n    } else {\n      redefinition = other.init || other[kind];\n    }\n    if (redefinition)\n      { this.raiseRecoverable(key.start, \"Redefinition of property\"); }\n  } else {\n    other = propHash[name] = {\n      init: false,\n      get: false,\n      set: false\n    };\n  }\n  other[kind] = true;\n};\n\n// ### Expression parsing\n\n// These nest, from the most general expression type at the top to\n// 'atomic', nondivisible expression types at the bottom. Most of\n// the functions will simply let the function(s) below them parse,\n// and, *if* the syntactic construct they handle is present, wrap\n// the AST node that the inner parser gave them in another node.\n\n// Parse a full expression. The optional arguments are used to\n// forbid the `in` operator (in for loops initalization expressions)\n// and provide reference for storing '=' operator inside shorthand\n// property assignment in contexts where both object expression\n// and object pattern might appear (so it's possible to raise\n// delayed syntax error at correct position).\n\npp$3.parseExpression = function(noIn, refDestructuringErrors) {\n  var startPos = this.start, startLoc = this.startLoc;\n  var expr = this.parseMaybeAssign(noIn, refDestructuringErrors);\n  if (this.type === types.comma) {\n    var node = this.startNodeAt(startPos, startLoc);\n    node.expressions = [expr];\n    while (this.eat(types.comma)) { node.expressions.push(this.parseMaybeAssign(noIn, refDestructuringErrors)); }\n    return this.finishNode(node, \"SequenceExpression\")\n  }\n  return expr\n};\n\n// Parse an assignment expression. This includes applications of\n// operators like `+=`.\n\npp$3.parseMaybeAssign = function(noIn, refDestructuringErrors, afterLeftParse) {\n  if (this.isContextual(\"yield\")) {\n    if (this.inGenerator) { return this.parseYield(noIn) }\n    // The tokenizer will assume an expression is allowed after\n    // `yield`, but this isn't that kind of yield\n    else { this.exprAllowed = false; }\n  }\n\n  var ownDestructuringErrors = false, oldParenAssign = -1, oldTrailingComma = -1;\n  if (refDestructuringErrors) {\n    oldParenAssign = refDestructuringErrors.parenthesizedAssign;\n    oldTrailingComma = refDestructuringErrors.trailingComma;\n    refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = -1;\n  } else {\n    refDestructuringErrors = new DestructuringErrors;\n    ownDestructuringErrors = true;\n  }\n\n  var startPos = this.start, startLoc = this.startLoc;\n  if (this.type === types.parenL || this.type === types.name)\n    { this.potentialArrowAt = this.start; }\n  var left = this.parseMaybeConditional(noIn, refDestructuringErrors);\n  if (afterLeftParse) { left = afterLeftParse.call(this, left, startPos, startLoc); }\n  if (this.type.isAssign) {\n    var node = this.startNodeAt(startPos, startLoc);\n    node.operator = this.value;\n    node.left = this.type === types.eq ? this.toAssignable(left, false, refDestructuringErrors) : left;\n    if (!ownDestructuringErrors) {\n      refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = refDestructuringErrors.doubleProto = -1;\n    }\n    if (refDestructuringErrors.shorthandAssign >= node.left.start)\n      { refDestructuringErrors.shorthandAssign = -1; } // reset because shorthand default was used correctly\n    this.checkLVal(left);\n    this.next();\n    node.right = this.parseMaybeAssign(noIn);\n    return this.finishNode(node, \"AssignmentExpression\")\n  } else {\n    if (ownDestructuringErrors) { this.checkExpressionErrors(refDestructuringErrors, true); }\n  }\n  if (oldParenAssign > -1) { refDestructuringErrors.parenthesizedAssign = oldParenAssign; }\n  if (oldTrailingComma > -1) { refDestructuringErrors.trailingComma = oldTrailingComma; }\n  return left\n};\n\n// Parse a ternary conditional (`?:`) operator.\n\npp$3.parseMaybeConditional = function(noIn, refDestructuringErrors) {\n  var startPos = this.start, startLoc = this.startLoc;\n  var expr = this.parseExprOps(noIn, refDestructuringErrors);\n  if (this.checkExpressionErrors(refDestructuringErrors)) { return expr }\n  if (this.eat(types.question)) {\n    var node = this.startNodeAt(startPos, startLoc);\n    node.test = expr;\n    node.consequent = this.parseMaybeAssign();\n    this.expect(types.colon);\n    node.alternate = this.parseMaybeAssign(noIn);\n    return this.finishNode(node, \"ConditionalExpression\")\n  }\n  return expr\n};\n\n// Start the precedence parser.\n\npp$3.parseExprOps = function(noIn, refDestructuringErrors) {\n  var startPos = this.start, startLoc = this.startLoc;\n  var expr = this.parseMaybeUnary(refDestructuringErrors, false);\n  if (this.checkExpressionErrors(refDestructuringErrors)) { return expr }\n  return expr.start === startPos && expr.type === \"ArrowFunctionExpression\" ? expr : this.parseExprOp(expr, startPos, startLoc, -1, noIn)\n};\n\n// Parse binary operators with the operator precedence parsing\n// algorithm. `left` is the left-hand side of the operator.\n// `minPrec` provides context that allows the function to stop and\n// defer further parser to one of its callers when it encounters an\n// operator that has a lower precedence than the set it is parsing.\n\npp$3.parseExprOp = function(left, leftStartPos, leftStartLoc, minPrec, noIn) {\n  var prec = this.type.binop;\n  if (prec != null && (!noIn || this.type !== types._in)) {\n    if (prec > minPrec) {\n      var logical = this.type === types.logicalOR || this.type === types.logicalAND;\n      var coalesce = this.type === types.coalesce;\n      if (coalesce) {\n        // Handle the precedence of `tt.coalesce` as equal to the range of logical expressions.\n        // In other words, `node.right` shouldn't contain logical expressions in order to check the mixed error.\n        prec = types.logicalAND.binop;\n      }\n      var op = this.value;\n      this.next();\n      var startPos = this.start, startLoc = this.startLoc;\n      var right = this.parseExprOp(this.parseMaybeUnary(null, false), startPos, startLoc, prec, noIn);\n      var node = this.buildBinary(leftStartPos, leftStartLoc, left, right, op, logical || coalesce);\n      if ((logical && this.type === types.coalesce) || (coalesce && (this.type === types.logicalOR || this.type === types.logicalAND))) {\n        this.raiseRecoverable(this.start, \"Logical expressions and coalesce expressions cannot be mixed. Wrap either by parentheses\");\n      }\n      return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec, noIn)\n    }\n  }\n  return left\n};\n\npp$3.buildBinary = function(startPos, startLoc, left, right, op, logical) {\n  var node = this.startNodeAt(startPos, startLoc);\n  node.left = left;\n  node.operator = op;\n  node.right = right;\n  return this.finishNode(node, logical ? \"LogicalExpression\" : \"BinaryExpression\")\n};\n\n// Parse unary operators, both prefix and postfix.\n\npp$3.parseMaybeUnary = function(refDestructuringErrors, sawUnary) {\n  var startPos = this.start, startLoc = this.startLoc, expr;\n  if (this.isContextual(\"await\") && (this.inAsync || (!this.inFunction && this.options.allowAwaitOutsideFunction))) {\n    expr = this.parseAwait();\n    sawUnary = true;\n  } else if (this.type.prefix) {\n    var node = this.startNode(), update = this.type === types.incDec;\n    node.operator = this.value;\n    node.prefix = true;\n    this.next();\n    node.argument = this.parseMaybeUnary(null, true);\n    this.checkExpressionErrors(refDestructuringErrors, true);\n    if (update) { this.checkLVal(node.argument); }\n    else if (this.strict && node.operator === \"delete\" &&\n             node.argument.type === \"Identifier\")\n      { this.raiseRecoverable(node.start, \"Deleting local variable in strict mode\"); }\n    else { sawUnary = true; }\n    expr = this.finishNode(node, update ? \"UpdateExpression\" : \"UnaryExpression\");\n  } else {\n    expr = this.parseExprSubscripts(refDestructuringErrors);\n    if (this.checkExpressionErrors(refDestructuringErrors)) { return expr }\n    while (this.type.postfix && !this.canInsertSemicolon()) {\n      var node$1 = this.startNodeAt(startPos, startLoc);\n      node$1.operator = this.value;\n      node$1.prefix = false;\n      node$1.argument = expr;\n      this.checkLVal(expr);\n      this.next();\n      expr = this.finishNode(node$1, \"UpdateExpression\");\n    }\n  }\n\n  if (!sawUnary && this.eat(types.starstar))\n    { return this.buildBinary(startPos, startLoc, expr, this.parseMaybeUnary(null, false), \"**\", false) }\n  else\n    { return expr }\n};\n\n// Parse call, dot, and `[]`-subscript expressions.\n\npp$3.parseExprSubscripts = function(refDestructuringErrors) {\n  var startPos = this.start, startLoc = this.startLoc;\n  var expr = this.parseExprAtom(refDestructuringErrors);\n  if (expr.type === \"ArrowFunctionExpression\" && this.input.slice(this.lastTokStart, this.lastTokEnd) !== \")\")\n    { return expr }\n  var result = this.parseSubscripts(expr, startPos, startLoc);\n  if (refDestructuringErrors && result.type === \"MemberExpression\") {\n    if (refDestructuringErrors.parenthesizedAssign >= result.start) { refDestructuringErrors.parenthesizedAssign = -1; }\n    if (refDestructuringErrors.parenthesizedBind >= result.start) { refDestructuringErrors.parenthesizedBind = -1; }\n  }\n  return result\n};\n\npp$3.parseSubscripts = function(base, startPos, startLoc, noCalls) {\n  var maybeAsyncArrow = this.options.ecmaVersion >= 8 && base.type === \"Identifier\" && base.name === \"async\" &&\n      this.lastTokEnd === base.end && !this.canInsertSemicolon() && base.end - base.start === 5 &&\n      this.potentialArrowAt === base.start;\n  var optionalChained = false;\n\n  while (true) {\n    var element = this.parseSubscript(base, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained);\n\n    if (element.optional) { optionalChained = true; }\n    if (element === base || element.type === \"ArrowFunctionExpression\") {\n      if (optionalChained) {\n        var chainNode = this.startNodeAt(startPos, startLoc);\n        chainNode.expression = element;\n        element = this.finishNode(chainNode, \"ChainExpression\");\n      }\n      return element\n    }\n\n    base = element;\n  }\n};\n\npp$3.parseSubscript = function(base, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained) {\n  var optionalSupported = this.options.ecmaVersion >= 11;\n  var optional = optionalSupported && this.eat(types.questionDot);\n  if (noCalls && optional) { this.raise(this.lastTokStart, \"Optional chaining cannot appear in the callee of new expressions\"); }\n\n  var computed = this.eat(types.bracketL);\n  if (computed || (optional && this.type !== types.parenL && this.type !== types.backQuote) || this.eat(types.dot)) {\n    var node = this.startNodeAt(startPos, startLoc);\n    node.object = base;\n    node.property = computed ? this.parseExpression() : this.parseIdent(this.options.allowReserved !== \"never\");\n    node.computed = !!computed;\n    if (computed) { this.expect(types.bracketR); }\n    if (optionalSupported) {\n      node.optional = optional;\n    }\n    base = this.finishNode(node, \"MemberExpression\");\n  } else if (!noCalls && this.eat(types.parenL)) {\n    var refDestructuringErrors = new DestructuringErrors, oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;\n    this.yieldPos = 0;\n    this.awaitPos = 0;\n    this.awaitIdentPos = 0;\n    var exprList = this.parseExprList(types.parenR, this.options.ecmaVersion >= 8, false, refDestructuringErrors);\n    if (maybeAsyncArrow && !optional && !this.canInsertSemicolon() && this.eat(types.arrow)) {\n      this.checkPatternErrors(refDestructuringErrors, false);\n      this.checkYieldAwaitInDefaultParams();\n      if (this.awaitIdentPos > 0)\n        { this.raise(this.awaitIdentPos, \"Cannot use 'await' as identifier inside an async function\"); }\n      this.yieldPos = oldYieldPos;\n      this.awaitPos = oldAwaitPos;\n      this.awaitIdentPos = oldAwaitIdentPos;\n      return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, true)\n    }\n    this.checkExpressionErrors(refDestructuringErrors, true);\n    this.yieldPos = oldYieldPos || this.yieldPos;\n    this.awaitPos = oldAwaitPos || this.awaitPos;\n    this.awaitIdentPos = oldAwaitIdentPos || this.awaitIdentPos;\n    var node$1 = this.startNodeAt(startPos, startLoc);\n    node$1.callee = base;\n    node$1.arguments = exprList;\n    if (optionalSupported) {\n      node$1.optional = optional;\n    }\n    base = this.finishNode(node$1, \"CallExpression\");\n  } else if (this.type === types.backQuote) {\n    if (optional || optionalChained) {\n      this.raise(this.start, \"Optional chaining cannot appear in the tag of tagged template expressions\");\n    }\n    var node$2 = this.startNodeAt(startPos, startLoc);\n    node$2.tag = base;\n    node$2.quasi = this.parseTemplate({isTagged: true});\n    base = this.finishNode(node$2, \"TaggedTemplateExpression\");\n  }\n  return base\n};\n\n// Parse an atomic expression — either a single token that is an\n// expression, an expression started by a keyword like `function` or\n// `new`, or an expression wrapped in punctuation like `()`, `[]`,\n// or `{}`.\n\npp$3.parseExprAtom = function(refDestructuringErrors) {\n  // If a division operator appears in an expression position, the\n  // tokenizer got confused, and we force it to read a regexp instead.\n  if (this.type === types.slash) { this.readRegexp(); }\n\n  var node, canBeArrow = this.potentialArrowAt === this.start;\n  switch (this.type) {\n  case types._super:\n    if (!this.allowSuper)\n      { this.raise(this.start, \"'super' keyword outside a method\"); }\n    node = this.startNode();\n    this.next();\n    if (this.type === types.parenL && !this.allowDirectSuper)\n      { this.raise(node.start, \"super() call outside constructor of a subclass\"); }\n    // The `super` keyword can appear at below:\n    // SuperProperty:\n    //     super [ Expression ]\n    //     super . IdentifierName\n    // SuperCall:\n    //     super ( Arguments )\n    if (this.type !== types.dot && this.type !== types.bracketL && this.type !== types.parenL)\n      { this.unexpected(); }\n    return this.finishNode(node, \"Super\")\n\n  case types._this:\n    node = this.startNode();\n    this.next();\n    return this.finishNode(node, \"ThisExpression\")\n\n  case types.name:\n    var startPos = this.start, startLoc = this.startLoc, containsEsc = this.containsEsc;\n    var id = this.parseIdent(false);\n    if (this.options.ecmaVersion >= 8 && !containsEsc && id.name === \"async\" && !this.canInsertSemicolon() && this.eat(types._function))\n      { return this.parseFunction(this.startNodeAt(startPos, startLoc), 0, false, true) }\n    if (canBeArrow && !this.canInsertSemicolon()) {\n      if (this.eat(types.arrow))\n        { return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], false) }\n      if (this.options.ecmaVersion >= 8 && id.name === \"async\" && this.type === types.name && !containsEsc) {\n        id = this.parseIdent(false);\n        if (this.canInsertSemicolon() || !this.eat(types.arrow))\n          { this.unexpected(); }\n        return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], true)\n      }\n    }\n    return id\n\n  case types.regexp:\n    var value = this.value;\n    node = this.parseLiteral(value.value);\n    node.regex = {pattern: value.pattern, flags: value.flags};\n    return node\n\n  case types.num: case types.string:\n    return this.parseLiteral(this.value)\n\n  case types._null: case types._true: case types._false:\n    node = this.startNode();\n    node.value = this.type === types._null ? null : this.type === types._true;\n    node.raw = this.type.keyword;\n    this.next();\n    return this.finishNode(node, \"Literal\")\n\n  case types.parenL:\n    var start = this.start, expr = this.parseParenAndDistinguishExpression(canBeArrow);\n    if (refDestructuringErrors) {\n      if (refDestructuringErrors.parenthesizedAssign < 0 && !this.isSimpleAssignTarget(expr))\n        { refDestructuringErrors.parenthesizedAssign = start; }\n      if (refDestructuringErrors.parenthesizedBind < 0)\n        { refDestructuringErrors.parenthesizedBind = start; }\n    }\n    return expr\n\n  case types.bracketL:\n    node = this.startNode();\n    this.next();\n    node.elements = this.parseExprList(types.bracketR, true, true, refDestructuringErrors);\n    return this.finishNode(node, \"ArrayExpression\")\n\n  case types.braceL:\n    return this.parseObj(false, refDestructuringErrors)\n\n  case types._function:\n    node = this.startNode();\n    this.next();\n    return this.parseFunction(node, 0)\n\n  case types._class:\n    return this.parseClass(this.startNode(), false)\n\n  case types._new:\n    return this.parseNew()\n\n  case types.backQuote:\n    return this.parseTemplate()\n\n  case types._import:\n    if (this.options.ecmaVersion >= 11) {\n      return this.parseExprImport()\n    } else {\n      return this.unexpected()\n    }\n\n  default:\n    this.unexpected();\n  }\n};\n\npp$3.parseExprImport = function() {\n  var node = this.startNode();\n\n  // Consume `import` as an identifier for `import.meta`.\n  // Because `this.parseIdent(true)` doesn't check escape sequences, it needs the check of `this.containsEsc`.\n  if (this.containsEsc) { this.raiseRecoverable(this.start, \"Escape sequence in keyword import\"); }\n  var meta = this.parseIdent(true);\n\n  switch (this.type) {\n  case types.parenL:\n    return this.parseDynamicImport(node)\n  case types.dot:\n    node.meta = meta;\n    return this.parseImportMeta(node)\n  default:\n    this.unexpected();\n  }\n};\n\npp$3.parseDynamicImport = function(node) {\n  this.next(); // skip `(`\n\n  // Parse node.source.\n  node.source = this.parseMaybeAssign();\n\n  // Verify ending.\n  if (!this.eat(types.parenR)) {\n    var errorPos = this.start;\n    if (this.eat(types.comma) && this.eat(types.parenR)) {\n      this.raiseRecoverable(errorPos, \"Trailing comma is not allowed in import()\");\n    } else {\n      this.unexpected(errorPos);\n    }\n  }\n\n  return this.finishNode(node, \"ImportExpression\")\n};\n\npp$3.parseImportMeta = function(node) {\n  this.next(); // skip `.`\n\n  var containsEsc = this.containsEsc;\n  node.property = this.parseIdent(true);\n\n  if (node.property.name !== \"meta\")\n    { this.raiseRecoverable(node.property.start, \"The only valid meta property for import is 'import.meta'\"); }\n  if (containsEsc)\n    { this.raiseRecoverable(node.start, \"'import.meta' must not contain escaped characters\"); }\n  if (this.options.sourceType !== \"module\")\n    { this.raiseRecoverable(node.start, \"Cannot use 'import.meta' outside a module\"); }\n\n  return this.finishNode(node, \"MetaProperty\")\n};\n\npp$3.parseLiteral = function(value) {\n  var node = this.startNode();\n  node.value = value;\n  node.raw = this.input.slice(this.start, this.end);\n  if (node.raw.charCodeAt(node.raw.length - 1) === 110) { node.bigint = node.raw.slice(0, -1).replace(/_/g, \"\"); }\n  this.next();\n  return this.finishNode(node, \"Literal\")\n};\n\npp$3.parseParenExpression = function() {\n  this.expect(types.parenL);\n  var val = this.parseExpression();\n  this.expect(types.parenR);\n  return val\n};\n\npp$3.parseParenAndDistinguishExpression = function(canBeArrow) {\n  var startPos = this.start, startLoc = this.startLoc, val, allowTrailingComma = this.options.ecmaVersion >= 8;\n  if (this.options.ecmaVersion >= 6) {\n    this.next();\n\n    var innerStartPos = this.start, innerStartLoc = this.startLoc;\n    var exprList = [], first = true, lastIsComma = false;\n    var refDestructuringErrors = new DestructuringErrors, oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, spreadStart;\n    this.yieldPos = 0;\n    this.awaitPos = 0;\n    // Do not save awaitIdentPos to allow checking awaits nested in parameters\n    while (this.type !== types.parenR) {\n      first ? first = false : this.expect(types.comma);\n      if (allowTrailingComma && this.afterTrailingComma(types.parenR, true)) {\n        lastIsComma = true;\n        break\n      } else if (this.type === types.ellipsis) {\n        spreadStart = this.start;\n        exprList.push(this.parseParenItem(this.parseRestBinding()));\n        if (this.type === types.comma) { this.raise(this.start, \"Comma is not permitted after the rest element\"); }\n        break\n      } else {\n        exprList.push(this.parseMaybeAssign(false, refDestructuringErrors, this.parseParenItem));\n      }\n    }\n    var innerEndPos = this.start, innerEndLoc = this.startLoc;\n    this.expect(types.parenR);\n\n    if (canBeArrow && !this.canInsertSemicolon() && this.eat(types.arrow)) {\n      this.checkPatternErrors(refDestructuringErrors, false);\n      this.checkYieldAwaitInDefaultParams();\n      this.yieldPos = oldYieldPos;\n      this.awaitPos = oldAwaitPos;\n      return this.parseParenArrowList(startPos, startLoc, exprList)\n    }\n\n    if (!exprList.length || lastIsComma) { this.unexpected(this.lastTokStart); }\n    if (spreadStart) { this.unexpected(spreadStart); }\n    this.checkExpressionErrors(refDestructuringErrors, true);\n    this.yieldPos = oldYieldPos || this.yieldPos;\n    this.awaitPos = oldAwaitPos || this.awaitPos;\n\n    if (exprList.length > 1) {\n      val = this.startNodeAt(innerStartPos, innerStartLoc);\n      val.expressions = exprList;\n      this.finishNodeAt(val, \"SequenceExpression\", innerEndPos, innerEndLoc);\n    } else {\n      val = exprList[0];\n    }\n  } else {\n    val = this.parseParenExpression();\n  }\n\n  if (this.options.preserveParens) {\n    var par = this.startNodeAt(startPos, startLoc);\n    par.expression = val;\n    return this.finishNode(par, \"ParenthesizedExpression\")\n  } else {\n    return val\n  }\n};\n\npp$3.parseParenItem = function(item) {\n  return item\n};\n\npp$3.parseParenArrowList = function(startPos, startLoc, exprList) {\n  return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList)\n};\n\n// New's precedence is slightly tricky. It must allow its argument to\n// be a `[]` or dot subscript expression, but not a call — at least,\n// not without wrapping it in parentheses. Thus, it uses the noCalls\n// argument to parseSubscripts to prevent it from consuming the\n// argument list.\n\nvar empty$1 = [];\n\npp$3.parseNew = function() {\n  if (this.containsEsc) { this.raiseRecoverable(this.start, \"Escape sequence in keyword new\"); }\n  var node = this.startNode();\n  var meta = this.parseIdent(true);\n  if (this.options.ecmaVersion >= 6 && this.eat(types.dot)) {\n    node.meta = meta;\n    var containsEsc = this.containsEsc;\n    node.property = this.parseIdent(true);\n    if (node.property.name !== \"target\")\n      { this.raiseRecoverable(node.property.start, \"The only valid meta property for new is 'new.target'\"); }\n    if (containsEsc)\n      { this.raiseRecoverable(node.start, \"'new.target' must not contain escaped characters\"); }\n    if (!this.inNonArrowFunction())\n      { this.raiseRecoverable(node.start, \"'new.target' can only be used in functions\"); }\n    return this.finishNode(node, \"MetaProperty\")\n  }\n  var startPos = this.start, startLoc = this.startLoc, isImport = this.type === types._import;\n  node.callee = this.parseSubscripts(this.parseExprAtom(), startPos, startLoc, true);\n  if (isImport && node.callee.type === \"ImportExpression\") {\n    this.raise(startPos, \"Cannot use new with import()\");\n  }\n  if (this.eat(types.parenL)) { node.arguments = this.parseExprList(types.parenR, this.options.ecmaVersion >= 8, false); }\n  else { node.arguments = empty$1; }\n  return this.finishNode(node, \"NewExpression\")\n};\n\n// Parse template expression.\n\npp$3.parseTemplateElement = function(ref) {\n  var isTagged = ref.isTagged;\n\n  var elem = this.startNode();\n  if (this.type === types.invalidTemplate) {\n    if (!isTagged) {\n      this.raiseRecoverable(this.start, \"Bad escape sequence in untagged template literal\");\n    }\n    elem.value = {\n      raw: this.value,\n      cooked: null\n    };\n  } else {\n    elem.value = {\n      raw: this.input.slice(this.start, this.end).replace(/\\r\\n?/g, \"\\n\"),\n      cooked: this.value\n    };\n  }\n  this.next();\n  elem.tail = this.type === types.backQuote;\n  return this.finishNode(elem, \"TemplateElement\")\n};\n\npp$3.parseTemplate = function(ref) {\n  if ( ref === void 0 ) ref = {};\n  var isTagged = ref.isTagged; if ( isTagged === void 0 ) isTagged = false;\n\n  var node = this.startNode();\n  this.next();\n  node.expressions = [];\n  var curElt = this.parseTemplateElement({isTagged: isTagged});\n  node.quasis = [curElt];\n  while (!curElt.tail) {\n    if (this.type === types.eof) { this.raise(this.pos, \"Unterminated template literal\"); }\n    this.expect(types.dollarBraceL);\n    node.expressions.push(this.parseExpression());\n    this.expect(types.braceR);\n    node.quasis.push(curElt = this.parseTemplateElement({isTagged: isTagged}));\n  }\n  this.next();\n  return this.finishNode(node, \"TemplateLiteral\")\n};\n\npp$3.isAsyncProp = function(prop) {\n  return !prop.computed && prop.key.type === \"Identifier\" && prop.key.name === \"async\" &&\n    (this.type === types.name || this.type === types.num || this.type === types.string || this.type === types.bracketL || this.type.keyword || (this.options.ecmaVersion >= 9 && this.type === types.star)) &&\n    !lineBreak.test(this.input.slice(this.lastTokEnd, this.start))\n};\n\n// Parse an object literal or binding pattern.\n\npp$3.parseObj = function(isPattern, refDestructuringErrors) {\n  var node = this.startNode(), first = true, propHash = {};\n  node.properties = [];\n  this.next();\n  while (!this.eat(types.braceR)) {\n    if (!first) {\n      this.expect(types.comma);\n      if (this.options.ecmaVersion >= 5 && this.afterTrailingComma(types.braceR)) { break }\n    } else { first = false; }\n\n    var prop = this.parseProperty(isPattern, refDestructuringErrors);\n    if (!isPattern) { this.checkPropClash(prop, propHash, refDestructuringErrors); }\n    node.properties.push(prop);\n  }\n  return this.finishNode(node, isPattern ? \"ObjectPattern\" : \"ObjectExpression\")\n};\n\npp$3.parseProperty = function(isPattern, refDestructuringErrors) {\n  var prop = this.startNode(), isGenerator, isAsync, startPos, startLoc;\n  if (this.options.ecmaVersion >= 9 && this.eat(types.ellipsis)) {\n    if (isPattern) {\n      prop.argument = this.parseIdent(false);\n      if (this.type === types.comma) {\n        this.raise(this.start, \"Comma is not permitted after the rest element\");\n      }\n      return this.finishNode(prop, \"RestElement\")\n    }\n    // To disallow parenthesized identifier via `this.toAssignable()`.\n    if (this.type === types.parenL && refDestructuringErrors) {\n      if (refDestructuringErrors.parenthesizedAssign < 0) {\n        refDestructuringErrors.parenthesizedAssign = this.start;\n      }\n      if (refDestructuringErrors.parenthesizedBind < 0) {\n        refDestructuringErrors.parenthesizedBind = this.start;\n      }\n    }\n    // Parse argument.\n    prop.argument = this.parseMaybeAssign(false, refDestructuringErrors);\n    // To disallow trailing comma via `this.toAssignable()`.\n    if (this.type === types.comma && refDestructuringErrors && refDestructuringErrors.trailingComma < 0) {\n      refDestructuringErrors.trailingComma = this.start;\n    }\n    // Finish\n    return this.finishNode(prop, \"SpreadElement\")\n  }\n  if (this.options.ecmaVersion >= 6) {\n    prop.method = false;\n    prop.shorthand = false;\n    if (isPattern || refDestructuringErrors) {\n      startPos = this.start;\n      startLoc = this.startLoc;\n    }\n    if (!isPattern)\n      { isGenerator = this.eat(types.star); }\n  }\n  var containsEsc = this.containsEsc;\n  this.parsePropertyName(prop);\n  if (!isPattern && !containsEsc && this.options.ecmaVersion >= 8 && !isGenerator && this.isAsyncProp(prop)) {\n    isAsync = true;\n    isGenerator = this.options.ecmaVersion >= 9 && this.eat(types.star);\n    this.parsePropertyName(prop, refDestructuringErrors);\n  } else {\n    isAsync = false;\n  }\n  this.parsePropertyValue(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc);\n  return this.finishNode(prop, \"Property\")\n};\n\npp$3.parsePropertyValue = function(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc) {\n  if ((isGenerator || isAsync) && this.type === types.colon)\n    { this.unexpected(); }\n\n  if (this.eat(types.colon)) {\n    prop.value = isPattern ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(false, refDestructuringErrors);\n    prop.kind = \"init\";\n  } else if (this.options.ecmaVersion >= 6 && this.type === types.parenL) {\n    if (isPattern) { this.unexpected(); }\n    prop.kind = \"init\";\n    prop.method = true;\n    prop.value = this.parseMethod(isGenerator, isAsync);\n  } else if (!isPattern && !containsEsc &&\n             this.options.ecmaVersion >= 5 && !prop.computed && prop.key.type === \"Identifier\" &&\n             (prop.key.name === \"get\" || prop.key.name === \"set\") &&\n             (this.type !== types.comma && this.type !== types.braceR && this.type !== types.eq)) {\n    if (isGenerator || isAsync) { this.unexpected(); }\n    prop.kind = prop.key.name;\n    this.parsePropertyName(prop);\n    prop.value = this.parseMethod(false);\n    var paramCount = prop.kind === \"get\" ? 0 : 1;\n    if (prop.value.params.length !== paramCount) {\n      var start = prop.value.start;\n      if (prop.kind === \"get\")\n        { this.raiseRecoverable(start, \"getter should have no params\"); }\n      else\n        { this.raiseRecoverable(start, \"setter should have exactly one param\"); }\n    } else {\n      if (prop.kind === \"set\" && prop.value.params[0].type === \"RestElement\")\n        { this.raiseRecoverable(prop.value.params[0].start, \"Setter cannot use rest params\"); }\n    }\n  } else if (this.options.ecmaVersion >= 6 && !prop.computed && prop.key.type === \"Identifier\") {\n    if (isGenerator || isAsync) { this.unexpected(); }\n    this.checkUnreserved(prop.key);\n    if (prop.key.name === \"await\" && !this.awaitIdentPos)\n      { this.awaitIdentPos = startPos; }\n    prop.kind = \"init\";\n    if (isPattern) {\n      prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key);\n    } else if (this.type === types.eq && refDestructuringErrors) {\n      if (refDestructuringErrors.shorthandAssign < 0)\n        { refDestructuringErrors.shorthandAssign = this.start; }\n      prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key);\n    } else {\n      prop.value = prop.key;\n    }\n    prop.shorthand = true;\n  } else { this.unexpected(); }\n};\n\npp$3.parsePropertyName = function(prop) {\n  if (this.options.ecmaVersion >= 6) {\n    if (this.eat(types.bracketL)) {\n      prop.computed = true;\n      prop.key = this.parseMaybeAssign();\n      this.expect(types.bracketR);\n      return prop.key\n    } else {\n      prop.computed = false;\n    }\n  }\n  return prop.key = this.type === types.num || this.type === types.string ? this.parseExprAtom() : this.parseIdent(this.options.allowReserved !== \"never\")\n};\n\n// Initialize empty function node.\n\npp$3.initFunction = function(node) {\n  node.id = null;\n  if (this.options.ecmaVersion >= 6) { node.generator = node.expression = false; }\n  if (this.options.ecmaVersion >= 8) { node.async = false; }\n};\n\n// Parse object or class method.\n\npp$3.parseMethod = function(isGenerator, isAsync, allowDirectSuper) {\n  var node = this.startNode(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;\n\n  this.initFunction(node);\n  if (this.options.ecmaVersion >= 6)\n    { node.generator = isGenerator; }\n  if (this.options.ecmaVersion >= 8)\n    { node.async = !!isAsync; }\n\n  this.yieldPos = 0;\n  this.awaitPos = 0;\n  this.awaitIdentPos = 0;\n  this.enterScope(functionFlags(isAsync, node.generator) | SCOPE_SUPER | (allowDirectSuper ? SCOPE_DIRECT_SUPER : 0));\n\n  this.expect(types.parenL);\n  node.params = this.parseBindingList(types.parenR, false, this.options.ecmaVersion >= 8);\n  this.checkYieldAwaitInDefaultParams();\n  this.parseFunctionBody(node, false, true);\n\n  this.yieldPos = oldYieldPos;\n  this.awaitPos = oldAwaitPos;\n  this.awaitIdentPos = oldAwaitIdentPos;\n  return this.finishNode(node, \"FunctionExpression\")\n};\n\n// Parse arrow function expression with given parameters.\n\npp$3.parseArrowExpression = function(node, params, isAsync) {\n  var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;\n\n  this.enterScope(functionFlags(isAsync, false) | SCOPE_ARROW);\n  this.initFunction(node);\n  if (this.options.ecmaVersion >= 8) { node.async = !!isAsync; }\n\n  this.yieldPos = 0;\n  this.awaitPos = 0;\n  this.awaitIdentPos = 0;\n\n  node.params = this.toAssignableList(params, true);\n  this.parseFunctionBody(node, true, false);\n\n  this.yieldPos = oldYieldPos;\n  this.awaitPos = oldAwaitPos;\n  this.awaitIdentPos = oldAwaitIdentPos;\n  return this.finishNode(node, \"ArrowFunctionExpression\")\n};\n\n// Parse function body and check parameters.\n\npp$3.parseFunctionBody = function(node, isArrowFunction, isMethod) {\n  var isExpression = isArrowFunction && this.type !== types.braceL;\n  var oldStrict = this.strict, useStrict = false;\n\n  if (isExpression) {\n    node.body = this.parseMaybeAssign();\n    node.expression = true;\n    this.checkParams(node, false);\n  } else {\n    var nonSimple = this.options.ecmaVersion >= 7 && !this.isSimpleParamList(node.params);\n    if (!oldStrict || nonSimple) {\n      useStrict = this.strictDirective(this.end);\n      // If this is a strict mode function, verify that argument names\n      // are not repeated, and it does not try to bind the words `eval`\n      // or `arguments`.\n      if (useStrict && nonSimple)\n        { this.raiseRecoverable(node.start, \"Illegal 'use strict' directive in function with non-simple parameter list\"); }\n    }\n    // Start a new scope with regard to labels and the `inFunction`\n    // flag (restore them to their old value afterwards).\n    var oldLabels = this.labels;\n    this.labels = [];\n    if (useStrict) { this.strict = true; }\n\n    // Add the params to varDeclaredNames to ensure that an error is thrown\n    // if a let/const declaration in the function clashes with one of the params.\n    this.checkParams(node, !oldStrict && !useStrict && !isArrowFunction && !isMethod && this.isSimpleParamList(node.params));\n    // Ensure the function name isn't a forbidden identifier in strict mode, e.g. 'eval'\n    if (this.strict && node.id) { this.checkLVal(node.id, BIND_OUTSIDE); }\n    node.body = this.parseBlock(false, undefined, useStrict && !oldStrict);\n    node.expression = false;\n    this.adaptDirectivePrologue(node.body.body);\n    this.labels = oldLabels;\n  }\n  this.exitScope();\n};\n\npp$3.isSimpleParamList = function(params) {\n  for (var i = 0, list = params; i < list.length; i += 1)\n    {\n    var param = list[i];\n\n    if (param.type !== \"Identifier\") { return false\n  } }\n  return true\n};\n\n// Checks function params for various disallowed patterns such as using \"eval\"\n// or \"arguments\" and duplicate parameters.\n\npp$3.checkParams = function(node, allowDuplicates) {\n  var nameHash = {};\n  for (var i = 0, list = node.params; i < list.length; i += 1)\n    {\n    var param = list[i];\n\n    this.checkLVal(param, BIND_VAR, allowDuplicates ? null : nameHash);\n  }\n};\n\n// Parses a comma-separated list of expressions, and returns them as\n// an array. `close` is the token type that ends the list, and\n// `allowEmpty` can be turned on to allow subsequent commas with\n// nothing in between them to be parsed as `null` (which is needed\n// for array literals).\n\npp$3.parseExprList = function(close, allowTrailingComma, allowEmpty, refDestructuringErrors) {\n  var elts = [], first = true;\n  while (!this.eat(close)) {\n    if (!first) {\n      this.expect(types.comma);\n      if (allowTrailingComma && this.afterTrailingComma(close)) { break }\n    } else { first = false; }\n\n    var elt = (void 0);\n    if (allowEmpty && this.type === types.comma)\n      { elt = null; }\n    else if (this.type === types.ellipsis) {\n      elt = this.parseSpread(refDestructuringErrors);\n      if (refDestructuringErrors && this.type === types.comma && refDestructuringErrors.trailingComma < 0)\n        { refDestructuringErrors.trailingComma = this.start; }\n    } else {\n      elt = this.parseMaybeAssign(false, refDestructuringErrors);\n    }\n    elts.push(elt);\n  }\n  return elts\n};\n\npp$3.checkUnreserved = function(ref) {\n  var start = ref.start;\n  var end = ref.end;\n  var name = ref.name;\n\n  if (this.inGenerator && name === \"yield\")\n    { this.raiseRecoverable(start, \"Cannot use 'yield' as identifier inside a generator\"); }\n  if (this.inAsync && name === \"await\")\n    { this.raiseRecoverable(start, \"Cannot use 'await' as identifier inside an async function\"); }\n  if (this.keywords.test(name))\n    { this.raise(start, (\"Unexpected keyword '\" + name + \"'\")); }\n  if (this.options.ecmaVersion < 6 &&\n    this.input.slice(start, end).indexOf(\"\\\\\") !== -1) { return }\n  var re = this.strict ? this.reservedWordsStrict : this.reservedWords;\n  if (re.test(name)) {\n    if (!this.inAsync && name === \"await\")\n      { this.raiseRecoverable(start, \"Cannot use keyword 'await' outside an async function\"); }\n    this.raiseRecoverable(start, (\"The keyword '\" + name + \"' is reserved\"));\n  }\n};\n\n// Parse the next token as an identifier. If `liberal` is true (used\n// when parsing properties), it will also convert keywords into\n// identifiers.\n\npp$3.parseIdent = function(liberal, isBinding) {\n  var node = this.startNode();\n  if (this.type === types.name) {\n    node.name = this.value;\n  } else if (this.type.keyword) {\n    node.name = this.type.keyword;\n\n    // To fix https://github.com/acornjs/acorn/issues/575\n    // `class` and `function` keywords push new context into this.context.\n    // But there is no chance to pop the context if the keyword is consumed as an identifier such as a property name.\n    // If the previous token is a dot, this does not apply because the context-managing code already ignored the keyword\n    if ((node.name === \"class\" || node.name === \"function\") &&\n        (this.lastTokEnd !== this.lastTokStart + 1 || this.input.charCodeAt(this.lastTokStart) !== 46)) {\n      this.context.pop();\n    }\n  } else {\n    this.unexpected();\n  }\n  this.next(!!liberal);\n  this.finishNode(node, \"Identifier\");\n  if (!liberal) {\n    this.checkUnreserved(node);\n    if (node.name === \"await\" && !this.awaitIdentPos)\n      { this.awaitIdentPos = node.start; }\n  }\n  return node\n};\n\n// Parses yield expression inside generator.\n\npp$3.parseYield = function(noIn) {\n  if (!this.yieldPos) { this.yieldPos = this.start; }\n\n  var node = this.startNode();\n  this.next();\n  if (this.type === types.semi || this.canInsertSemicolon() || (this.type !== types.star && !this.type.startsExpr)) {\n    node.delegate = false;\n    node.argument = null;\n  } else {\n    node.delegate = this.eat(types.star);\n    node.argument = this.parseMaybeAssign(noIn);\n  }\n  return this.finishNode(node, \"YieldExpression\")\n};\n\npp$3.parseAwait = function() {\n  if (!this.awaitPos) { this.awaitPos = this.start; }\n\n  var node = this.startNode();\n  this.next();\n  node.argument = this.parseMaybeUnary(null, false);\n  return this.finishNode(node, \"AwaitExpression\")\n};\n\nvar pp$4 = Parser.prototype;\n\n// This function is used to raise exceptions on parse errors. It\n// takes an offset integer (into the current `input`) to indicate\n// the location of the error, attaches the position to the end\n// of the error message, and then raises a `SyntaxError` with that\n// message.\n\npp$4.raise = function(pos, message) {\n  var loc = getLineInfo(this.input, pos);\n  message += \" (\" + loc.line + \":\" + loc.column + \")\";\n  var err = new SyntaxError(message);\n  err.pos = pos; err.loc = loc; err.raisedAt = this.pos;\n  throw err\n};\n\npp$4.raiseRecoverable = pp$4.raise;\n\npp$4.curPosition = function() {\n  if (this.options.locations) {\n    return new Position(this.curLine, this.pos - this.lineStart)\n  }\n};\n\nvar pp$5 = Parser.prototype;\n\nvar Scope = function Scope(flags) {\n  this.flags = flags;\n  // A list of var-declared names in the current lexical scope\n  this.var = [];\n  // A list of lexically-declared names in the current lexical scope\n  this.lexical = [];\n  // A list of lexically-declared FunctionDeclaration names in the current lexical scope\n  this.functions = [];\n};\n\n// The functions in this module keep track of declared variables in the current scope in order to detect duplicate variable names.\n\npp$5.enterScope = function(flags) {\n  this.scopeStack.push(new Scope(flags));\n};\n\npp$5.exitScope = function() {\n  this.scopeStack.pop();\n};\n\n// The spec says:\n// > At the top level of a function, or script, function declarations are\n// > treated like var declarations rather than like lexical declarations.\npp$5.treatFunctionsAsVarInScope = function(scope) {\n  return (scope.flags & SCOPE_FUNCTION) || !this.inModule && (scope.flags & SCOPE_TOP)\n};\n\npp$5.declareName = function(name, bindingType, pos) {\n  var redeclared = false;\n  if (bindingType === BIND_LEXICAL) {\n    var scope = this.currentScope();\n    redeclared = scope.lexical.indexOf(name) > -1 || scope.functions.indexOf(name) > -1 || scope.var.indexOf(name) > -1;\n    scope.lexical.push(name);\n    if (this.inModule && (scope.flags & SCOPE_TOP))\n      { delete this.undefinedExports[name]; }\n  } else if (bindingType === BIND_SIMPLE_CATCH) {\n    var scope$1 = this.currentScope();\n    scope$1.lexical.push(name);\n  } else if (bindingType === BIND_FUNCTION) {\n    var scope$2 = this.currentScope();\n    if (this.treatFunctionsAsVar)\n      { redeclared = scope$2.lexical.indexOf(name) > -1; }\n    else\n      { redeclared = scope$2.lexical.indexOf(name) > -1 || scope$2.var.indexOf(name) > -1; }\n    scope$2.functions.push(name);\n  } else {\n    for (var i = this.scopeStack.length - 1; i >= 0; --i) {\n      var scope$3 = this.scopeStack[i];\n      if (scope$3.lexical.indexOf(name) > -1 && !((scope$3.flags & SCOPE_SIMPLE_CATCH) && scope$3.lexical[0] === name) ||\n          !this.treatFunctionsAsVarInScope(scope$3) && scope$3.functions.indexOf(name) > -1) {\n        redeclared = true;\n        break\n      }\n      scope$3.var.push(name);\n      if (this.inModule && (scope$3.flags & SCOPE_TOP))\n        { delete this.undefinedExports[name]; }\n      if (scope$3.flags & SCOPE_VAR) { break }\n    }\n  }\n  if (redeclared) { this.raiseRecoverable(pos, (\"Identifier '\" + name + \"' has already been declared\")); }\n};\n\npp$5.checkLocalExport = function(id) {\n  // scope.functions must be empty as Module code is always strict.\n  if (this.scopeStack[0].lexical.indexOf(id.name) === -1 &&\n      this.scopeStack[0].var.indexOf(id.name) === -1) {\n    this.undefinedExports[id.name] = id;\n  }\n};\n\npp$5.currentScope = function() {\n  return this.scopeStack[this.scopeStack.length - 1]\n};\n\npp$5.currentVarScope = function() {\n  for (var i = this.scopeStack.length - 1;; i--) {\n    var scope = this.scopeStack[i];\n    if (scope.flags & SCOPE_VAR) { return scope }\n  }\n};\n\n// Could be useful for `this`, `new.target`, `super()`, `super.property`, and `super[property]`.\npp$5.currentThisScope = function() {\n  for (var i = this.scopeStack.length - 1;; i--) {\n    var scope = this.scopeStack[i];\n    if (scope.flags & SCOPE_VAR && !(scope.flags & SCOPE_ARROW)) { return scope }\n  }\n};\n\nvar Node = function Node(parser, pos, loc) {\n  this.type = \"\";\n  this.start = pos;\n  this.end = 0;\n  if (parser.options.locations)\n    { this.loc = new SourceLocation(parser, loc); }\n  if (parser.options.directSourceFile)\n    { this.sourceFile = parser.options.directSourceFile; }\n  if (parser.options.ranges)\n    { this.range = [pos, 0]; }\n};\n\n// Start an AST node, attaching a start offset.\n\nvar pp$6 = Parser.prototype;\n\npp$6.startNode = function() {\n  return new Node(this, this.start, this.startLoc)\n};\n\npp$6.startNodeAt = function(pos, loc) {\n  return new Node(this, pos, loc)\n};\n\n// Finish an AST node, adding `type` and `end` properties.\n\nfunction finishNodeAt(node, type, pos, loc) {\n  node.type = type;\n  node.end = pos;\n  if (this.options.locations)\n    { node.loc.end = loc; }\n  if (this.options.ranges)\n    { node.range[1] = pos; }\n  return node\n}\n\npp$6.finishNode = function(node, type) {\n  return finishNodeAt.call(this, node, type, this.lastTokEnd, this.lastTokEndLoc)\n};\n\n// Finish node at given position\n\npp$6.finishNodeAt = function(node, type, pos, loc) {\n  return finishNodeAt.call(this, node, type, pos, loc)\n};\n\n// The algorithm used to determine whether a regexp can appear at a\n\nvar TokContext = function TokContext(token, isExpr, preserveSpace, override, generator) {\n  this.token = token;\n  this.isExpr = !!isExpr;\n  this.preserveSpace = !!preserveSpace;\n  this.override = override;\n  this.generator = !!generator;\n};\n\nvar types$1 = {\n  b_stat: new TokContext(\"{\", false),\n  b_expr: new TokContext(\"{\", true),\n  b_tmpl: new TokContext(\"${\", false),\n  p_stat: new TokContext(\"(\", false),\n  p_expr: new TokContext(\"(\", true),\n  q_tmpl: new TokContext(\"`\", true, true, function (p) { return p.tryReadTemplateToken(); }),\n  f_stat: new TokContext(\"function\", false),\n  f_expr: new TokContext(\"function\", true),\n  f_expr_gen: new TokContext(\"function\", true, false, null, true),\n  f_gen: new TokContext(\"function\", false, false, null, true)\n};\n\nvar pp$7 = Parser.prototype;\n\npp$7.initialContext = function() {\n  return [types$1.b_stat]\n};\n\npp$7.braceIsBlock = function(prevType) {\n  var parent = this.curContext();\n  if (parent === types$1.f_expr || parent === types$1.f_stat)\n    { return true }\n  if (prevType === types.colon && (parent === types$1.b_stat || parent === types$1.b_expr))\n    { return !parent.isExpr }\n\n  // The check for `tt.name && exprAllowed` detects whether we are\n  // after a `yield` or `of` construct. See the `updateContext` for\n  // `tt.name`.\n  if (prevType === types._return || prevType === types.name && this.exprAllowed)\n    { return lineBreak.test(this.input.slice(this.lastTokEnd, this.start)) }\n  if (prevType === types._else || prevType === types.semi || prevType === types.eof || prevType === types.parenR || prevType === types.arrow)\n    { return true }\n  if (prevType === types.braceL)\n    { return parent === types$1.b_stat }\n  if (prevType === types._var || prevType === types._const || prevType === types.name)\n    { return false }\n  return !this.exprAllowed\n};\n\npp$7.inGeneratorContext = function() {\n  for (var i = this.context.length - 1; i >= 1; i--) {\n    var context = this.context[i];\n    if (context.token === \"function\")\n      { return context.generator }\n  }\n  return false\n};\n\npp$7.updateContext = function(prevType) {\n  var update, type = this.type;\n  if (type.keyword && prevType === types.dot)\n    { this.exprAllowed = false; }\n  else if (update = type.updateContext)\n    { update.call(this, prevType); }\n  else\n    { this.exprAllowed = type.beforeExpr; }\n};\n\n// Token-specific context update code\n\ntypes.parenR.updateContext = types.braceR.updateContext = function() {\n  if (this.context.length === 1) {\n    this.exprAllowed = true;\n    return\n  }\n  var out = this.context.pop();\n  if (out === types$1.b_stat && this.curContext().token === \"function\") {\n    out = this.context.pop();\n  }\n  this.exprAllowed = !out.isExpr;\n};\n\ntypes.braceL.updateContext = function(prevType) {\n  this.context.push(this.braceIsBlock(prevType) ? types$1.b_stat : types$1.b_expr);\n  this.exprAllowed = true;\n};\n\ntypes.dollarBraceL.updateContext = function() {\n  this.context.push(types$1.b_tmpl);\n  this.exprAllowed = true;\n};\n\ntypes.parenL.updateContext = function(prevType) {\n  var statementParens = prevType === types._if || prevType === types._for || prevType === types._with || prevType === types._while;\n  this.context.push(statementParens ? types$1.p_stat : types$1.p_expr);\n  this.exprAllowed = true;\n};\n\ntypes.incDec.updateContext = function() {\n  // tokExprAllowed stays unchanged\n};\n\ntypes._function.updateContext = types._class.updateContext = function(prevType) {\n  if (prevType.beforeExpr && prevType !== types.semi && prevType !== types._else &&\n      !(prevType === types._return && lineBreak.test(this.input.slice(this.lastTokEnd, this.start))) &&\n      !((prevType === types.colon || prevType === types.braceL) && this.curContext() === types$1.b_stat))\n    { this.context.push(types$1.f_expr); }\n  else\n    { this.context.push(types$1.f_stat); }\n  this.exprAllowed = false;\n};\n\ntypes.backQuote.updateContext = function() {\n  if (this.curContext() === types$1.q_tmpl)\n    { this.context.pop(); }\n  else\n    { this.context.push(types$1.q_tmpl); }\n  this.exprAllowed = false;\n};\n\ntypes.star.updateContext = function(prevType) {\n  if (prevType === types._function) {\n    var index = this.context.length - 1;\n    if (this.context[index] === types$1.f_expr)\n      { this.context[index] = types$1.f_expr_gen; }\n    else\n      { this.context[index] = types$1.f_gen; }\n  }\n  this.exprAllowed = true;\n};\n\ntypes.name.updateContext = function(prevType) {\n  var allowed = false;\n  if (this.options.ecmaVersion >= 6 && prevType !== types.dot) {\n    if (this.value === \"of\" && !this.exprAllowed ||\n        this.value === \"yield\" && this.inGeneratorContext())\n      { allowed = true; }\n  }\n  this.exprAllowed = allowed;\n};\n\n// This file contains Unicode properties extracted from the ECMAScript\n// specification. The lists are extracted like so:\n// $$('#table-binary-unicode-properties > figure > table > tbody > tr > td:nth-child(1) code').map(el => el.innerText)\n\n// #table-binary-unicode-properties\nvar ecma9BinaryProperties = \"ASCII ASCII_Hex_Digit AHex Alphabetic Alpha Any Assigned Bidi_Control Bidi_C Bidi_Mirrored Bidi_M Case_Ignorable CI Cased Changes_When_Casefolded CWCF Changes_When_Casemapped CWCM Changes_When_Lowercased CWL Changes_When_NFKC_Casefolded CWKCF Changes_When_Titlecased CWT Changes_When_Uppercased CWU Dash Default_Ignorable_Code_Point DI Deprecated Dep Diacritic Dia Emoji Emoji_Component Emoji_Modifier Emoji_Modifier_Base Emoji_Presentation Extender Ext Grapheme_Base Gr_Base Grapheme_Extend Gr_Ext Hex_Digit Hex IDS_Binary_Operator IDSB IDS_Trinary_Operator IDST ID_Continue IDC ID_Start IDS Ideographic Ideo Join_Control Join_C Logical_Order_Exception LOE Lowercase Lower Math Noncharacter_Code_Point NChar Pattern_Syntax Pat_Syn Pattern_White_Space Pat_WS Quotation_Mark QMark Radical Regional_Indicator RI Sentence_Terminal STerm Soft_Dotted SD Terminal_Punctuation Term Unified_Ideograph UIdeo Uppercase Upper Variation_Selector VS White_Space space XID_Continue XIDC XID_Start XIDS\";\nvar ecma10BinaryProperties = ecma9BinaryProperties + \" Extended_Pictographic\";\nvar ecma11BinaryProperties = ecma10BinaryProperties;\nvar unicodeBinaryProperties = {\n  9: ecma9BinaryProperties,\n  10: ecma10BinaryProperties,\n  11: ecma11BinaryProperties\n};\n\n// #table-unicode-general-category-values\nvar unicodeGeneralCategoryValues = \"Cased_Letter LC Close_Punctuation Pe Connector_Punctuation Pc Control Cc cntrl Currency_Symbol Sc Dash_Punctuation Pd Decimal_Number Nd digit Enclosing_Mark Me Final_Punctuation Pf Format Cf Initial_Punctuation Pi Letter L Letter_Number Nl Line_Separator Zl Lowercase_Letter Ll Mark M Combining_Mark Math_Symbol Sm Modifier_Letter Lm Modifier_Symbol Sk Nonspacing_Mark Mn Number N Open_Punctuation Ps Other C Other_Letter Lo Other_Number No Other_Punctuation Po Other_Symbol So Paragraph_Separator Zp Private_Use Co Punctuation P punct Separator Z Space_Separator Zs Spacing_Mark Mc Surrogate Cs Symbol S Titlecase_Letter Lt Unassigned Cn Uppercase_Letter Lu\";\n\n// #table-unicode-script-values\nvar ecma9ScriptValues = \"Adlam Adlm Ahom Ahom Anatolian_Hieroglyphs Hluw Arabic Arab Armenian Armn Avestan Avst Balinese Bali Bamum Bamu Bassa_Vah Bass Batak Batk Bengali Beng Bhaiksuki Bhks Bopomofo Bopo Brahmi Brah Braille Brai Buginese Bugi Buhid Buhd Canadian_Aboriginal Cans Carian Cari Caucasian_Albanian Aghb Chakma Cakm Cham Cham Cherokee Cher Common Zyyy Coptic Copt Qaac Cuneiform Xsux Cypriot Cprt Cyrillic Cyrl Deseret Dsrt Devanagari Deva Duployan Dupl Egyptian_Hieroglyphs Egyp Elbasan Elba Ethiopic Ethi Georgian Geor Glagolitic Glag Gothic Goth Grantha Gran Greek Grek Gujarati Gujr Gurmukhi Guru Han Hani Hangul Hang Hanunoo Hano Hatran Hatr Hebrew Hebr Hiragana Hira Imperial_Aramaic Armi Inherited Zinh Qaai Inscriptional_Pahlavi Phli Inscriptional_Parthian Prti Javanese Java Kaithi Kthi Kannada Knda Katakana Kana Kayah_Li Kali Kharoshthi Khar Khmer Khmr Khojki Khoj Khudawadi Sind Lao Laoo Latin Latn Lepcha Lepc Limbu Limb Linear_A Lina Linear_B Linb Lisu Lisu Lycian Lyci Lydian Lydi Mahajani Mahj Malayalam Mlym Mandaic Mand Manichaean Mani Marchen Marc Masaram_Gondi Gonm Meetei_Mayek Mtei Mende_Kikakui Mend Meroitic_Cursive Merc Meroitic_Hieroglyphs Mero Miao Plrd Modi Modi Mongolian Mong Mro Mroo Multani Mult Myanmar Mymr Nabataean Nbat New_Tai_Lue Talu Newa Newa Nko Nkoo Nushu Nshu Ogham Ogam Ol_Chiki Olck Old_Hungarian Hung Old_Italic Ital Old_North_Arabian Narb Old_Permic Perm Old_Persian Xpeo Old_South_Arabian Sarb Old_Turkic Orkh Oriya Orya Osage Osge Osmanya Osma Pahawh_Hmong Hmng Palmyrene Palm Pau_Cin_Hau Pauc Phags_Pa Phag Phoenician Phnx Psalter_Pahlavi Phlp Rejang Rjng Runic Runr Samaritan Samr Saurashtra Saur Sharada Shrd Shavian Shaw Siddham Sidd SignWriting Sgnw Sinhala Sinh Sora_Sompeng Sora Soyombo Soyo Sundanese Sund Syloti_Nagri Sylo Syriac Syrc Tagalog Tglg Tagbanwa Tagb Tai_Le Tale Tai_Tham Lana Tai_Viet Tavt Takri Takr Tamil Taml Tangut Tang Telugu Telu Thaana Thaa Thai Thai Tibetan Tibt Tifinagh Tfng Tirhuta Tirh Ugaritic Ugar Vai Vaii Warang_Citi Wara Yi Yiii Zanabazar_Square Zanb\";\nvar ecma10ScriptValues = ecma9ScriptValues + \" Dogra Dogr Gunjala_Gondi Gong Hanifi_Rohingya Rohg Makasar Maka Medefaidrin Medf Old_Sogdian Sogo Sogdian Sogd\";\nvar ecma11ScriptValues = ecma10ScriptValues + \" Elymaic Elym Nandinagari Nand Nyiakeng_Puachue_Hmong Hmnp Wancho Wcho\";\nvar unicodeScriptValues = {\n  9: ecma9ScriptValues,\n  10: ecma10ScriptValues,\n  11: ecma11ScriptValues\n};\n\nvar data = {};\nfunction buildUnicodeData(ecmaVersion) {\n  var d = data[ecmaVersion] = {\n    binary: wordsRegexp(unicodeBinaryProperties[ecmaVersion] + \" \" + unicodeGeneralCategoryValues),\n    nonBinary: {\n      General_Category: wordsRegexp(unicodeGeneralCategoryValues),\n      Script: wordsRegexp(unicodeScriptValues[ecmaVersion])\n    }\n  };\n  d.nonBinary.Script_Extensions = d.nonBinary.Script;\n\n  d.nonBinary.gc = d.nonBinary.General_Category;\n  d.nonBinary.sc = d.nonBinary.Script;\n  d.nonBinary.scx = d.nonBinary.Script_Extensions;\n}\nbuildUnicodeData(9);\nbuildUnicodeData(10);\nbuildUnicodeData(11);\n\nvar pp$8 = Parser.prototype;\n\nvar RegExpValidationState = function RegExpValidationState(parser) {\n  this.parser = parser;\n  this.validFlags = \"gim\" + (parser.options.ecmaVersion >= 6 ? \"uy\" : \"\") + (parser.options.ecmaVersion >= 9 ? \"s\" : \"\");\n  this.unicodeProperties = data[parser.options.ecmaVersion >= 11 ? 11 : parser.options.ecmaVersion];\n  this.source = \"\";\n  this.flags = \"\";\n  this.start = 0;\n  this.switchU = false;\n  this.switchN = false;\n  this.pos = 0;\n  this.lastIntValue = 0;\n  this.lastStringValue = \"\";\n  this.lastAssertionIsQuantifiable = false;\n  this.numCapturingParens = 0;\n  this.maxBackReference = 0;\n  this.groupNames = [];\n  this.backReferenceNames = [];\n};\n\nRegExpValidationState.prototype.reset = function reset (start, pattern, flags) {\n  var unicode = flags.indexOf(\"u\") !== -1;\n  this.start = start | 0;\n  this.source = pattern + \"\";\n  this.flags = flags;\n  this.switchU = unicode && this.parser.options.ecmaVersion >= 6;\n  this.switchN = unicode && this.parser.options.ecmaVersion >= 9;\n};\n\nRegExpValidationState.prototype.raise = function raise (message) {\n  this.parser.raiseRecoverable(this.start, (\"Invalid regular expression: /\" + (this.source) + \"/: \" + message));\n};\n\n// If u flag is given, this returns the code point at the index (it combines a surrogate pair).\n// Otherwise, this returns the code unit of the index (can be a part of a surrogate pair).\nRegExpValidationState.prototype.at = function at (i, forceU) {\n    if ( forceU === void 0 ) forceU = false;\n\n  var s = this.source;\n  var l = s.length;\n  if (i >= l) {\n    return -1\n  }\n  var c = s.charCodeAt(i);\n  if (!(forceU || this.switchU) || c <= 0xD7FF || c >= 0xE000 || i + 1 >= l) {\n    return c\n  }\n  var next = s.charCodeAt(i + 1);\n  return next >= 0xDC00 && next <= 0xDFFF ? (c << 10) + next - 0x35FDC00 : c\n};\n\nRegExpValidationState.prototype.nextIndex = function nextIndex (i, forceU) {\n    if ( forceU === void 0 ) forceU = false;\n\n  var s = this.source;\n  var l = s.length;\n  if (i >= l) {\n    return l\n  }\n  var c = s.charCodeAt(i), next;\n  if (!(forceU || this.switchU) || c <= 0xD7FF || c >= 0xE000 || i + 1 >= l ||\n      (next = s.charCodeAt(i + 1)) < 0xDC00 || next > 0xDFFF) {\n    return i + 1\n  }\n  return i + 2\n};\n\nRegExpValidationState.prototype.current = function current (forceU) {\n    if ( forceU === void 0 ) forceU = false;\n\n  return this.at(this.pos, forceU)\n};\n\nRegExpValidationState.prototype.lookahead = function lookahead (forceU) {\n    if ( forceU === void 0 ) forceU = false;\n\n  return this.at(this.nextIndex(this.pos, forceU), forceU)\n};\n\nRegExpValidationState.prototype.advance = function advance (forceU) {\n    if ( forceU === void 0 ) forceU = false;\n\n  this.pos = this.nextIndex(this.pos, forceU);\n};\n\nRegExpValidationState.prototype.eat = function eat (ch, forceU) {\n    if ( forceU === void 0 ) forceU = false;\n\n  if (this.current(forceU) === ch) {\n    this.advance(forceU);\n    return true\n  }\n  return false\n};\n\nfunction codePointToString(ch) {\n  if (ch <= 0xFFFF) { return String.fromCharCode(ch) }\n  ch -= 0x10000;\n  return String.fromCharCode((ch >> 10) + 0xD800, (ch & 0x03FF) + 0xDC00)\n}\n\n/**\n * Validate the flags part of a given RegExpLiteral.\n *\n * @param {RegExpValidationState} state The state to validate RegExp.\n * @returns {void}\n */\npp$8.validateRegExpFlags = function(state) {\n  var validFlags = state.validFlags;\n  var flags = state.flags;\n\n  for (var i = 0; i < flags.length; i++) {\n    var flag = flags.charAt(i);\n    if (validFlags.indexOf(flag) === -1) {\n      this.raise(state.start, \"Invalid regular expression flag\");\n    }\n    if (flags.indexOf(flag, i + 1) > -1) {\n      this.raise(state.start, \"Duplicate regular expression flag\");\n    }\n  }\n};\n\n/**\n * Validate the pattern part of a given RegExpLiteral.\n *\n * @param {RegExpValidationState} state The state to validate RegExp.\n * @returns {void}\n */\npp$8.validateRegExpPattern = function(state) {\n  this.regexp_pattern(state);\n\n  // The goal symbol for the parse is |Pattern[~U, ~N]|. If the result of\n  // parsing contains a |GroupName|, reparse with the goal symbol\n  // |Pattern[~U, +N]| and use this result instead. Throw a *SyntaxError*\n  // exception if _P_ did not conform to the grammar, if any elements of _P_\n  // were not matched by the parse, or if any Early Error conditions exist.\n  if (!state.switchN && this.options.ecmaVersion >= 9 && state.groupNames.length > 0) {\n    state.switchN = true;\n    this.regexp_pattern(state);\n  }\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-Pattern\npp$8.regexp_pattern = function(state) {\n  state.pos = 0;\n  state.lastIntValue = 0;\n  state.lastStringValue = \"\";\n  state.lastAssertionIsQuantifiable = false;\n  state.numCapturingParens = 0;\n  state.maxBackReference = 0;\n  state.groupNames.length = 0;\n  state.backReferenceNames.length = 0;\n\n  this.regexp_disjunction(state);\n\n  if (state.pos !== state.source.length) {\n    // Make the same messages as V8.\n    if (state.eat(0x29 /* ) */)) {\n      state.raise(\"Unmatched ')'\");\n    }\n    if (state.eat(0x5D /* ] */) || state.eat(0x7D /* } */)) {\n      state.raise(\"Lone quantifier brackets\");\n    }\n  }\n  if (state.maxBackReference > state.numCapturingParens) {\n    state.raise(\"Invalid escape\");\n  }\n  for (var i = 0, list = state.backReferenceNames; i < list.length; i += 1) {\n    var name = list[i];\n\n    if (state.groupNames.indexOf(name) === -1) {\n      state.raise(\"Invalid named capture referenced\");\n    }\n  }\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-Disjunction\npp$8.regexp_disjunction = function(state) {\n  this.regexp_alternative(state);\n  while (state.eat(0x7C /* | */)) {\n    this.regexp_alternative(state);\n  }\n\n  // Make the same message as V8.\n  if (this.regexp_eatQuantifier(state, true)) {\n    state.raise(\"Nothing to repeat\");\n  }\n  if (state.eat(0x7B /* { */)) {\n    state.raise(\"Lone quantifier brackets\");\n  }\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-Alternative\npp$8.regexp_alternative = function(state) {\n  while (state.pos < state.source.length && this.regexp_eatTerm(state))\n    { }\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-Term\npp$8.regexp_eatTerm = function(state) {\n  if (this.regexp_eatAssertion(state)) {\n    // Handle `QuantifiableAssertion Quantifier` alternative.\n    // `state.lastAssertionIsQuantifiable` is true if the last eaten Assertion\n    // is a QuantifiableAssertion.\n    if (state.lastAssertionIsQuantifiable && this.regexp_eatQuantifier(state)) {\n      // Make the same message as V8.\n      if (state.switchU) {\n        state.raise(\"Invalid quantifier\");\n      }\n    }\n    return true\n  }\n\n  if (state.switchU ? this.regexp_eatAtom(state) : this.regexp_eatExtendedAtom(state)) {\n    this.regexp_eatQuantifier(state);\n    return true\n  }\n\n  return false\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-Assertion\npp$8.regexp_eatAssertion = function(state) {\n  var start = state.pos;\n  state.lastAssertionIsQuantifiable = false;\n\n  // ^, $\n  if (state.eat(0x5E /* ^ */) || state.eat(0x24 /* $ */)) {\n    return true\n  }\n\n  // \\b \\B\n  if (state.eat(0x5C /* \\ */)) {\n    if (state.eat(0x42 /* B */) || state.eat(0x62 /* b */)) {\n      return true\n    }\n    state.pos = start;\n  }\n\n  // Lookahead / Lookbehind\n  if (state.eat(0x28 /* ( */) && state.eat(0x3F /* ? */)) {\n    var lookbehind = false;\n    if (this.options.ecmaVersion >= 9) {\n      lookbehind = state.eat(0x3C /* < */);\n    }\n    if (state.eat(0x3D /* = */) || state.eat(0x21 /* ! */)) {\n      this.regexp_disjunction(state);\n      if (!state.eat(0x29 /* ) */)) {\n        state.raise(\"Unterminated group\");\n      }\n      state.lastAssertionIsQuantifiable = !lookbehind;\n      return true\n    }\n  }\n\n  state.pos = start;\n  return false\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-Quantifier\npp$8.regexp_eatQuantifier = function(state, noError) {\n  if ( noError === void 0 ) noError = false;\n\n  if (this.regexp_eatQuantifierPrefix(state, noError)) {\n    state.eat(0x3F /* ? */);\n    return true\n  }\n  return false\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-QuantifierPrefix\npp$8.regexp_eatQuantifierPrefix = function(state, noError) {\n  return (\n    state.eat(0x2A /* * */) ||\n    state.eat(0x2B /* + */) ||\n    state.eat(0x3F /* ? */) ||\n    this.regexp_eatBracedQuantifier(state, noError)\n  )\n};\npp$8.regexp_eatBracedQuantifier = function(state, noError) {\n  var start = state.pos;\n  if (state.eat(0x7B /* { */)) {\n    var min = 0, max = -1;\n    if (this.regexp_eatDecimalDigits(state)) {\n      min = state.lastIntValue;\n      if (state.eat(0x2C /* , */) && this.regexp_eatDecimalDigits(state)) {\n        max = state.lastIntValue;\n      }\n      if (state.eat(0x7D /* } */)) {\n        // SyntaxError in https://www.ecma-international.org/ecma-262/8.0/#sec-term\n        if (max !== -1 && max < min && !noError) {\n          state.raise(\"numbers out of order in {} quantifier\");\n        }\n        return true\n      }\n    }\n    if (state.switchU && !noError) {\n      state.raise(\"Incomplete quantifier\");\n    }\n    state.pos = start;\n  }\n  return false\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-Atom\npp$8.regexp_eatAtom = function(state) {\n  return (\n    this.regexp_eatPatternCharacters(state) ||\n    state.eat(0x2E /* . */) ||\n    this.regexp_eatReverseSolidusAtomEscape(state) ||\n    this.regexp_eatCharacterClass(state) ||\n    this.regexp_eatUncapturingGroup(state) ||\n    this.regexp_eatCapturingGroup(state)\n  )\n};\npp$8.regexp_eatReverseSolidusAtomEscape = function(state) {\n  var start = state.pos;\n  if (state.eat(0x5C /* \\ */)) {\n    if (this.regexp_eatAtomEscape(state)) {\n      return true\n    }\n    state.pos = start;\n  }\n  return false\n};\npp$8.regexp_eatUncapturingGroup = function(state) {\n  var start = state.pos;\n  if (state.eat(0x28 /* ( */)) {\n    if (state.eat(0x3F /* ? */) && state.eat(0x3A /* : */)) {\n      this.regexp_disjunction(state);\n      if (state.eat(0x29 /* ) */)) {\n        return true\n      }\n      state.raise(\"Unterminated group\");\n    }\n    state.pos = start;\n  }\n  return false\n};\npp$8.regexp_eatCapturingGroup = function(state) {\n  if (state.eat(0x28 /* ( */)) {\n    if (this.options.ecmaVersion >= 9) {\n      this.regexp_groupSpecifier(state);\n    } else if (state.current() === 0x3F /* ? */) {\n      state.raise(\"Invalid group\");\n    }\n    this.regexp_disjunction(state);\n    if (state.eat(0x29 /* ) */)) {\n      state.numCapturingParens += 1;\n      return true\n    }\n    state.raise(\"Unterminated group\");\n  }\n  return false\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ExtendedAtom\npp$8.regexp_eatExtendedAtom = function(state) {\n  return (\n    state.eat(0x2E /* . */) ||\n    this.regexp_eatReverseSolidusAtomEscape(state) ||\n    this.regexp_eatCharacterClass(state) ||\n    this.regexp_eatUncapturingGroup(state) ||\n    this.regexp_eatCapturingGroup(state) ||\n    this.regexp_eatInvalidBracedQuantifier(state) ||\n    this.regexp_eatExtendedPatternCharacter(state)\n  )\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-InvalidBracedQuantifier\npp$8.regexp_eatInvalidBracedQuantifier = function(state) {\n  if (this.regexp_eatBracedQuantifier(state, true)) {\n    state.raise(\"Nothing to repeat\");\n  }\n  return false\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-SyntaxCharacter\npp$8.regexp_eatSyntaxCharacter = function(state) {\n  var ch = state.current();\n  if (isSyntaxCharacter(ch)) {\n    state.lastIntValue = ch;\n    state.advance();\n    return true\n  }\n  return false\n};\nfunction isSyntaxCharacter(ch) {\n  return (\n    ch === 0x24 /* $ */ ||\n    ch >= 0x28 /* ( */ && ch <= 0x2B /* + */ ||\n    ch === 0x2E /* . */ ||\n    ch === 0x3F /* ? */ ||\n    ch >= 0x5B /* [ */ && ch <= 0x5E /* ^ */ ||\n    ch >= 0x7B /* { */ && ch <= 0x7D /* } */\n  )\n}\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-PatternCharacter\n// But eat eager.\npp$8.regexp_eatPatternCharacters = function(state) {\n  var start = state.pos;\n  var ch = 0;\n  while ((ch = state.current()) !== -1 && !isSyntaxCharacter(ch)) {\n    state.advance();\n  }\n  return state.pos !== start\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ExtendedPatternCharacter\npp$8.regexp_eatExtendedPatternCharacter = function(state) {\n  var ch = state.current();\n  if (\n    ch !== -1 &&\n    ch !== 0x24 /* $ */ &&\n    !(ch >= 0x28 /* ( */ && ch <= 0x2B /* + */) &&\n    ch !== 0x2E /* . */ &&\n    ch !== 0x3F /* ? */ &&\n    ch !== 0x5B /* [ */ &&\n    ch !== 0x5E /* ^ */ &&\n    ch !== 0x7C /* | */\n  ) {\n    state.advance();\n    return true\n  }\n  return false\n};\n\n// GroupSpecifier ::\n//   [empty]\n//   `?` GroupName\npp$8.regexp_groupSpecifier = function(state) {\n  if (state.eat(0x3F /* ? */)) {\n    if (this.regexp_eatGroupName(state)) {\n      if (state.groupNames.indexOf(state.lastStringValue) !== -1) {\n        state.raise(\"Duplicate capture group name\");\n      }\n      state.groupNames.push(state.lastStringValue);\n      return\n    }\n    state.raise(\"Invalid group\");\n  }\n};\n\n// GroupName ::\n//   `<` RegExpIdentifierName `>`\n// Note: this updates `state.lastStringValue` property with the eaten name.\npp$8.regexp_eatGroupName = function(state) {\n  state.lastStringValue = \"\";\n  if (state.eat(0x3C /* < */)) {\n    if (this.regexp_eatRegExpIdentifierName(state) && state.eat(0x3E /* > */)) {\n      return true\n    }\n    state.raise(\"Invalid capture group name\");\n  }\n  return false\n};\n\n// RegExpIdentifierName ::\n//   RegExpIdentifierStart\n//   RegExpIdentifierName RegExpIdentifierPart\n// Note: this updates `state.lastStringValue` property with the eaten name.\npp$8.regexp_eatRegExpIdentifierName = function(state) {\n  state.lastStringValue = \"\";\n  if (this.regexp_eatRegExpIdentifierStart(state)) {\n    state.lastStringValue += codePointToString(state.lastIntValue);\n    while (this.regexp_eatRegExpIdentifierPart(state)) {\n      state.lastStringValue += codePointToString(state.lastIntValue);\n    }\n    return true\n  }\n  return false\n};\n\n// RegExpIdentifierStart ::\n//   UnicodeIDStart\n//   `$`\n//   `_`\n//   `\\` RegExpUnicodeEscapeSequence[+U]\npp$8.regexp_eatRegExpIdentifierStart = function(state) {\n  var start = state.pos;\n  var forceU = this.options.ecmaVersion >= 11;\n  var ch = state.current(forceU);\n  state.advance(forceU);\n\n  if (ch === 0x5C /* \\ */ && this.regexp_eatRegExpUnicodeEscapeSequence(state, forceU)) {\n    ch = state.lastIntValue;\n  }\n  if (isRegExpIdentifierStart(ch)) {\n    state.lastIntValue = ch;\n    return true\n  }\n\n  state.pos = start;\n  return false\n};\nfunction isRegExpIdentifierStart(ch) {\n  return isIdentifierStart(ch, true) || ch === 0x24 /* $ */ || ch === 0x5F /* _ */\n}\n\n// RegExpIdentifierPart ::\n//   UnicodeIDContinue\n//   `$`\n//   `_`\n//   `\\` RegExpUnicodeEscapeSequence[+U]\n//   <ZWNJ>\n//   <ZWJ>\npp$8.regexp_eatRegExpIdentifierPart = function(state) {\n  var start = state.pos;\n  var forceU = this.options.ecmaVersion >= 11;\n  var ch = state.current(forceU);\n  state.advance(forceU);\n\n  if (ch === 0x5C /* \\ */ && this.regexp_eatRegExpUnicodeEscapeSequence(state, forceU)) {\n    ch = state.lastIntValue;\n  }\n  if (isRegExpIdentifierPart(ch)) {\n    state.lastIntValue = ch;\n    return true\n  }\n\n  state.pos = start;\n  return false\n};\nfunction isRegExpIdentifierPart(ch) {\n  return isIdentifierChar(ch, true) || ch === 0x24 /* $ */ || ch === 0x5F /* _ */ || ch === 0x200C /* <ZWNJ> */ || ch === 0x200D /* <ZWJ> */\n}\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-AtomEscape\npp$8.regexp_eatAtomEscape = function(state) {\n  if (\n    this.regexp_eatBackReference(state) ||\n    this.regexp_eatCharacterClassEscape(state) ||\n    this.regexp_eatCharacterEscape(state) ||\n    (state.switchN && this.regexp_eatKGroupName(state))\n  ) {\n    return true\n  }\n  if (state.switchU) {\n    // Make the same message as V8.\n    if (state.current() === 0x63 /* c */) {\n      state.raise(\"Invalid unicode escape\");\n    }\n    state.raise(\"Invalid escape\");\n  }\n  return false\n};\npp$8.regexp_eatBackReference = function(state) {\n  var start = state.pos;\n  if (this.regexp_eatDecimalEscape(state)) {\n    var n = state.lastIntValue;\n    if (state.switchU) {\n      // For SyntaxError in https://www.ecma-international.org/ecma-262/8.0/#sec-atomescape\n      if (n > state.maxBackReference) {\n        state.maxBackReference = n;\n      }\n      return true\n    }\n    if (n <= state.numCapturingParens) {\n      return true\n    }\n    state.pos = start;\n  }\n  return false\n};\npp$8.regexp_eatKGroupName = function(state) {\n  if (state.eat(0x6B /* k */)) {\n    if (this.regexp_eatGroupName(state)) {\n      state.backReferenceNames.push(state.lastStringValue);\n      return true\n    }\n    state.raise(\"Invalid named reference\");\n  }\n  return false\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-CharacterEscape\npp$8.regexp_eatCharacterEscape = function(state) {\n  return (\n    this.regexp_eatControlEscape(state) ||\n    this.regexp_eatCControlLetter(state) ||\n    this.regexp_eatZero(state) ||\n    this.regexp_eatHexEscapeSequence(state) ||\n    this.regexp_eatRegExpUnicodeEscapeSequence(state, false) ||\n    (!state.switchU && this.regexp_eatLegacyOctalEscapeSequence(state)) ||\n    this.regexp_eatIdentityEscape(state)\n  )\n};\npp$8.regexp_eatCControlLetter = function(state) {\n  var start = state.pos;\n  if (state.eat(0x63 /* c */)) {\n    if (this.regexp_eatControlLetter(state)) {\n      return true\n    }\n    state.pos = start;\n  }\n  return false\n};\npp$8.regexp_eatZero = function(state) {\n  if (state.current() === 0x30 /* 0 */ && !isDecimalDigit(state.lookahead())) {\n    state.lastIntValue = 0;\n    state.advance();\n    return true\n  }\n  return false\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-ControlEscape\npp$8.regexp_eatControlEscape = function(state) {\n  var ch = state.current();\n  if (ch === 0x74 /* t */) {\n    state.lastIntValue = 0x09; /* \\t */\n    state.advance();\n    return true\n  }\n  if (ch === 0x6E /* n */) {\n    state.lastIntValue = 0x0A; /* \\n */\n    state.advance();\n    return true\n  }\n  if (ch === 0x76 /* v */) {\n    state.lastIntValue = 0x0B; /* \\v */\n    state.advance();\n    return true\n  }\n  if (ch === 0x66 /* f */) {\n    state.lastIntValue = 0x0C; /* \\f */\n    state.advance();\n    return true\n  }\n  if (ch === 0x72 /* r */) {\n    state.lastIntValue = 0x0D; /* \\r */\n    state.advance();\n    return true\n  }\n  return false\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-ControlLetter\npp$8.regexp_eatControlLetter = function(state) {\n  var ch = state.current();\n  if (isControlLetter(ch)) {\n    state.lastIntValue = ch % 0x20;\n    state.advance();\n    return true\n  }\n  return false\n};\nfunction isControlLetter(ch) {\n  return (\n    (ch >= 0x41 /* A */ && ch <= 0x5A /* Z */) ||\n    (ch >= 0x61 /* a */ && ch <= 0x7A /* z */)\n  )\n}\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-RegExpUnicodeEscapeSequence\npp$8.regexp_eatRegExpUnicodeEscapeSequence = function(state, forceU) {\n  if ( forceU === void 0 ) forceU = false;\n\n  var start = state.pos;\n  var switchU = forceU || state.switchU;\n\n  if (state.eat(0x75 /* u */)) {\n    if (this.regexp_eatFixedHexDigits(state, 4)) {\n      var lead = state.lastIntValue;\n      if (switchU && lead >= 0xD800 && lead <= 0xDBFF) {\n        var leadSurrogateEnd = state.pos;\n        if (state.eat(0x5C /* \\ */) && state.eat(0x75 /* u */) && this.regexp_eatFixedHexDigits(state, 4)) {\n          var trail = state.lastIntValue;\n          if (trail >= 0xDC00 && trail <= 0xDFFF) {\n            state.lastIntValue = (lead - 0xD800) * 0x400 + (trail - 0xDC00) + 0x10000;\n            return true\n          }\n        }\n        state.pos = leadSurrogateEnd;\n        state.lastIntValue = lead;\n      }\n      return true\n    }\n    if (\n      switchU &&\n      state.eat(0x7B /* { */) &&\n      this.regexp_eatHexDigits(state) &&\n      state.eat(0x7D /* } */) &&\n      isValidUnicode(state.lastIntValue)\n    ) {\n      return true\n    }\n    if (switchU) {\n      state.raise(\"Invalid unicode escape\");\n    }\n    state.pos = start;\n  }\n\n  return false\n};\nfunction isValidUnicode(ch) {\n  return ch >= 0 && ch <= 0x10FFFF\n}\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-IdentityEscape\npp$8.regexp_eatIdentityEscape = function(state) {\n  if (state.switchU) {\n    if (this.regexp_eatSyntaxCharacter(state)) {\n      return true\n    }\n    if (state.eat(0x2F /* / */)) {\n      state.lastIntValue = 0x2F; /* / */\n      return true\n    }\n    return false\n  }\n\n  var ch = state.current();\n  if (ch !== 0x63 /* c */ && (!state.switchN || ch !== 0x6B /* k */)) {\n    state.lastIntValue = ch;\n    state.advance();\n    return true\n  }\n\n  return false\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-DecimalEscape\npp$8.regexp_eatDecimalEscape = function(state) {\n  state.lastIntValue = 0;\n  var ch = state.current();\n  if (ch >= 0x31 /* 1 */ && ch <= 0x39 /* 9 */) {\n    do {\n      state.lastIntValue = 10 * state.lastIntValue + (ch - 0x30 /* 0 */);\n      state.advance();\n    } while ((ch = state.current()) >= 0x30 /* 0 */ && ch <= 0x39 /* 9 */)\n    return true\n  }\n  return false\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-CharacterClassEscape\npp$8.regexp_eatCharacterClassEscape = function(state) {\n  var ch = state.current();\n\n  if (isCharacterClassEscape(ch)) {\n    state.lastIntValue = -1;\n    state.advance();\n    return true\n  }\n\n  if (\n    state.switchU &&\n    this.options.ecmaVersion >= 9 &&\n    (ch === 0x50 /* P */ || ch === 0x70 /* p */)\n  ) {\n    state.lastIntValue = -1;\n    state.advance();\n    if (\n      state.eat(0x7B /* { */) &&\n      this.regexp_eatUnicodePropertyValueExpression(state) &&\n      state.eat(0x7D /* } */)\n    ) {\n      return true\n    }\n    state.raise(\"Invalid property name\");\n  }\n\n  return false\n};\nfunction isCharacterClassEscape(ch) {\n  return (\n    ch === 0x64 /* d */ ||\n    ch === 0x44 /* D */ ||\n    ch === 0x73 /* s */ ||\n    ch === 0x53 /* S */ ||\n    ch === 0x77 /* w */ ||\n    ch === 0x57 /* W */\n  )\n}\n\n// UnicodePropertyValueExpression ::\n//   UnicodePropertyName `=` UnicodePropertyValue\n//   LoneUnicodePropertyNameOrValue\npp$8.regexp_eatUnicodePropertyValueExpression = function(state) {\n  var start = state.pos;\n\n  // UnicodePropertyName `=` UnicodePropertyValue\n  if (this.regexp_eatUnicodePropertyName(state) && state.eat(0x3D /* = */)) {\n    var name = state.lastStringValue;\n    if (this.regexp_eatUnicodePropertyValue(state)) {\n      var value = state.lastStringValue;\n      this.regexp_validateUnicodePropertyNameAndValue(state, name, value);\n      return true\n    }\n  }\n  state.pos = start;\n\n  // LoneUnicodePropertyNameOrValue\n  if (this.regexp_eatLoneUnicodePropertyNameOrValue(state)) {\n    var nameOrValue = state.lastStringValue;\n    this.regexp_validateUnicodePropertyNameOrValue(state, nameOrValue);\n    return true\n  }\n  return false\n};\npp$8.regexp_validateUnicodePropertyNameAndValue = function(state, name, value) {\n  if (!has(state.unicodeProperties.nonBinary, name))\n    { state.raise(\"Invalid property name\"); }\n  if (!state.unicodeProperties.nonBinary[name].test(value))\n    { state.raise(\"Invalid property value\"); }\n};\npp$8.regexp_validateUnicodePropertyNameOrValue = function(state, nameOrValue) {\n  if (!state.unicodeProperties.binary.test(nameOrValue))\n    { state.raise(\"Invalid property name\"); }\n};\n\n// UnicodePropertyName ::\n//   UnicodePropertyNameCharacters\npp$8.regexp_eatUnicodePropertyName = function(state) {\n  var ch = 0;\n  state.lastStringValue = \"\";\n  while (isUnicodePropertyNameCharacter(ch = state.current())) {\n    state.lastStringValue += codePointToString(ch);\n    state.advance();\n  }\n  return state.lastStringValue !== \"\"\n};\nfunction isUnicodePropertyNameCharacter(ch) {\n  return isControlLetter(ch) || ch === 0x5F /* _ */\n}\n\n// UnicodePropertyValue ::\n//   UnicodePropertyValueCharacters\npp$8.regexp_eatUnicodePropertyValue = function(state) {\n  var ch = 0;\n  state.lastStringValue = \"\";\n  while (isUnicodePropertyValueCharacter(ch = state.current())) {\n    state.lastStringValue += codePointToString(ch);\n    state.advance();\n  }\n  return state.lastStringValue !== \"\"\n};\nfunction isUnicodePropertyValueCharacter(ch) {\n  return isUnicodePropertyNameCharacter(ch) || isDecimalDigit(ch)\n}\n\n// LoneUnicodePropertyNameOrValue ::\n//   UnicodePropertyValueCharacters\npp$8.regexp_eatLoneUnicodePropertyNameOrValue = function(state) {\n  return this.regexp_eatUnicodePropertyValue(state)\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-CharacterClass\npp$8.regexp_eatCharacterClass = function(state) {\n  if (state.eat(0x5B /* [ */)) {\n    state.eat(0x5E /* ^ */);\n    this.regexp_classRanges(state);\n    if (state.eat(0x5D /* ] */)) {\n      return true\n    }\n    // Unreachable since it threw \"unterminated regular expression\" error before.\n    state.raise(\"Unterminated character class\");\n  }\n  return false\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-ClassRanges\n// https://www.ecma-international.org/ecma-262/8.0/#prod-NonemptyClassRanges\n// https://www.ecma-international.org/ecma-262/8.0/#prod-NonemptyClassRangesNoDash\npp$8.regexp_classRanges = function(state) {\n  while (this.regexp_eatClassAtom(state)) {\n    var left = state.lastIntValue;\n    if (state.eat(0x2D /* - */) && this.regexp_eatClassAtom(state)) {\n      var right = state.lastIntValue;\n      if (state.switchU && (left === -1 || right === -1)) {\n        state.raise(\"Invalid character class\");\n      }\n      if (left !== -1 && right !== -1 && left > right) {\n        state.raise(\"Range out of order in character class\");\n      }\n    }\n  }\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-ClassAtom\n// https://www.ecma-international.org/ecma-262/8.0/#prod-ClassAtomNoDash\npp$8.regexp_eatClassAtom = function(state) {\n  var start = state.pos;\n\n  if (state.eat(0x5C /* \\ */)) {\n    if (this.regexp_eatClassEscape(state)) {\n      return true\n    }\n    if (state.switchU) {\n      // Make the same message as V8.\n      var ch$1 = state.current();\n      if (ch$1 === 0x63 /* c */ || isOctalDigit(ch$1)) {\n        state.raise(\"Invalid class escape\");\n      }\n      state.raise(\"Invalid escape\");\n    }\n    state.pos = start;\n  }\n\n  var ch = state.current();\n  if (ch !== 0x5D /* ] */) {\n    state.lastIntValue = ch;\n    state.advance();\n    return true\n  }\n\n  return false\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ClassEscape\npp$8.regexp_eatClassEscape = function(state) {\n  var start = state.pos;\n\n  if (state.eat(0x62 /* b */)) {\n    state.lastIntValue = 0x08; /* <BS> */\n    return true\n  }\n\n  if (state.switchU && state.eat(0x2D /* - */)) {\n    state.lastIntValue = 0x2D; /* - */\n    return true\n  }\n\n  if (!state.switchU && state.eat(0x63 /* c */)) {\n    if (this.regexp_eatClassControlLetter(state)) {\n      return true\n    }\n    state.pos = start;\n  }\n\n  return (\n    this.regexp_eatCharacterClassEscape(state) ||\n    this.regexp_eatCharacterEscape(state)\n  )\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ClassControlLetter\npp$8.regexp_eatClassControlLetter = function(state) {\n  var ch = state.current();\n  if (isDecimalDigit(ch) || ch === 0x5F /* _ */) {\n    state.lastIntValue = ch % 0x20;\n    state.advance();\n    return true\n  }\n  return false\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-HexEscapeSequence\npp$8.regexp_eatHexEscapeSequence = function(state) {\n  var start = state.pos;\n  if (state.eat(0x78 /* x */)) {\n    if (this.regexp_eatFixedHexDigits(state, 2)) {\n      return true\n    }\n    if (state.switchU) {\n      state.raise(\"Invalid escape\");\n    }\n    state.pos = start;\n  }\n  return false\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-DecimalDigits\npp$8.regexp_eatDecimalDigits = function(state) {\n  var start = state.pos;\n  var ch = 0;\n  state.lastIntValue = 0;\n  while (isDecimalDigit(ch = state.current())) {\n    state.lastIntValue = 10 * state.lastIntValue + (ch - 0x30 /* 0 */);\n    state.advance();\n  }\n  return state.pos !== start\n};\nfunction isDecimalDigit(ch) {\n  return ch >= 0x30 /* 0 */ && ch <= 0x39 /* 9 */\n}\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-HexDigits\npp$8.regexp_eatHexDigits = function(state) {\n  var start = state.pos;\n  var ch = 0;\n  state.lastIntValue = 0;\n  while (isHexDigit(ch = state.current())) {\n    state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);\n    state.advance();\n  }\n  return state.pos !== start\n};\nfunction isHexDigit(ch) {\n  return (\n    (ch >= 0x30 /* 0 */ && ch <= 0x39 /* 9 */) ||\n    (ch >= 0x41 /* A */ && ch <= 0x46 /* F */) ||\n    (ch >= 0x61 /* a */ && ch <= 0x66 /* f */)\n  )\n}\nfunction hexToInt(ch) {\n  if (ch >= 0x41 /* A */ && ch <= 0x46 /* F */) {\n    return 10 + (ch - 0x41 /* A */)\n  }\n  if (ch >= 0x61 /* a */ && ch <= 0x66 /* f */) {\n    return 10 + (ch - 0x61 /* a */)\n  }\n  return ch - 0x30 /* 0 */\n}\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-LegacyOctalEscapeSequence\n// Allows only 0-377(octal) i.e. 0-255(decimal).\npp$8.regexp_eatLegacyOctalEscapeSequence = function(state) {\n  if (this.regexp_eatOctalDigit(state)) {\n    var n1 = state.lastIntValue;\n    if (this.regexp_eatOctalDigit(state)) {\n      var n2 = state.lastIntValue;\n      if (n1 <= 3 && this.regexp_eatOctalDigit(state)) {\n        state.lastIntValue = n1 * 64 + n2 * 8 + state.lastIntValue;\n      } else {\n        state.lastIntValue = n1 * 8 + n2;\n      }\n    } else {\n      state.lastIntValue = n1;\n    }\n    return true\n  }\n  return false\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-OctalDigit\npp$8.regexp_eatOctalDigit = function(state) {\n  var ch = state.current();\n  if (isOctalDigit(ch)) {\n    state.lastIntValue = ch - 0x30; /* 0 */\n    state.advance();\n    return true\n  }\n  state.lastIntValue = 0;\n  return false\n};\nfunction isOctalDigit(ch) {\n  return ch >= 0x30 /* 0 */ && ch <= 0x37 /* 7 */\n}\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-Hex4Digits\n// https://www.ecma-international.org/ecma-262/8.0/#prod-HexDigit\n// And HexDigit HexDigit in https://www.ecma-international.org/ecma-262/8.0/#prod-HexEscapeSequence\npp$8.regexp_eatFixedHexDigits = function(state, length) {\n  var start = state.pos;\n  state.lastIntValue = 0;\n  for (var i = 0; i < length; ++i) {\n    var ch = state.current();\n    if (!isHexDigit(ch)) {\n      state.pos = start;\n      return false\n    }\n    state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);\n    state.advance();\n  }\n  return true\n};\n\n// Object type used to represent tokens. Note that normally, tokens\n// simply exist as properties on the parser object. This is only\n// used for the onToken callback and the external tokenizer.\n\nvar Token = function Token(p) {\n  this.type = p.type;\n  this.value = p.value;\n  this.start = p.start;\n  this.end = p.end;\n  if (p.options.locations)\n    { this.loc = new SourceLocation(p, p.startLoc, p.endLoc); }\n  if (p.options.ranges)\n    { this.range = [p.start, p.end]; }\n};\n\n// ## Tokenizer\n\nvar pp$9 = Parser.prototype;\n\n// Move to the next token\n\npp$9.next = function(ignoreEscapeSequenceInKeyword) {\n  if (!ignoreEscapeSequenceInKeyword && this.type.keyword && this.containsEsc)\n    { this.raiseRecoverable(this.start, \"Escape sequence in keyword \" + this.type.keyword); }\n  if (this.options.onToken)\n    { this.options.onToken(new Token(this)); }\n\n  this.lastTokEnd = this.end;\n  this.lastTokStart = this.start;\n  this.lastTokEndLoc = this.endLoc;\n  this.lastTokStartLoc = this.startLoc;\n  this.nextToken();\n};\n\npp$9.getToken = function() {\n  this.next();\n  return new Token(this)\n};\n\n// If we're in an ES6 environment, make parsers iterable\nif (typeof Symbol !== \"undefined\")\n  { pp$9[Symbol.iterator] = function() {\n    var this$1 = this;\n\n    return {\n      next: function () {\n        var token = this$1.getToken();\n        return {\n          done: token.type === types.eof,\n          value: token\n        }\n      }\n    }\n  }; }\n\n// Toggle strict mode. Re-reads the next number or string to please\n// pedantic tests (`\"use strict\"; 010;` should fail).\n\npp$9.curContext = function() {\n  return this.context[this.context.length - 1]\n};\n\n// Read a single token, updating the parser object's token-related\n// properties.\n\npp$9.nextToken = function() {\n  var curContext = this.curContext();\n  if (!curContext || !curContext.preserveSpace) { this.skipSpace(); }\n\n  this.start = this.pos;\n  if (this.options.locations) { this.startLoc = this.curPosition(); }\n  if (this.pos >= this.input.length) { return this.finishToken(types.eof) }\n\n  if (curContext.override) { return curContext.override(this) }\n  else { this.readToken(this.fullCharCodeAtPos()); }\n};\n\npp$9.readToken = function(code) {\n  // Identifier or keyword. '\\uXXXX' sequences are allowed in\n  // identifiers, so '\\' also dispatches to that.\n  if (isIdentifierStart(code, this.options.ecmaVersion >= 6) || code === 92 /* '\\' */)\n    { return this.readWord() }\n\n  return this.getTokenFromCode(code)\n};\n\npp$9.fullCharCodeAtPos = function() {\n  var code = this.input.charCodeAt(this.pos);\n  if (code <= 0xd7ff || code >= 0xe000) { return code }\n  var next = this.input.charCodeAt(this.pos + 1);\n  return (code << 10) + next - 0x35fdc00\n};\n\npp$9.skipBlockComment = function() {\n  var startLoc = this.options.onComment && this.curPosition();\n  var start = this.pos, end = this.input.indexOf(\"*/\", this.pos += 2);\n  if (end === -1) { this.raise(this.pos - 2, \"Unterminated comment\"); }\n  this.pos = end + 2;\n  if (this.options.locations) {\n    lineBreakG.lastIndex = start;\n    var match;\n    while ((match = lineBreakG.exec(this.input)) && match.index < this.pos) {\n      ++this.curLine;\n      this.lineStart = match.index + match[0].length;\n    }\n  }\n  if (this.options.onComment)\n    { this.options.onComment(true, this.input.slice(start + 2, end), start, this.pos,\n                           startLoc, this.curPosition()); }\n};\n\npp$9.skipLineComment = function(startSkip) {\n  var start = this.pos;\n  var startLoc = this.options.onComment && this.curPosition();\n  var ch = this.input.charCodeAt(this.pos += startSkip);\n  while (this.pos < this.input.length && !isNewLine(ch)) {\n    ch = this.input.charCodeAt(++this.pos);\n  }\n  if (this.options.onComment)\n    { this.options.onComment(false, this.input.slice(start + startSkip, this.pos), start, this.pos,\n                           startLoc, this.curPosition()); }\n};\n\n// Called at the start of the parse and after every token. Skips\n// whitespace and comments, and.\n\npp$9.skipSpace = function() {\n  loop: while (this.pos < this.input.length) {\n    var ch = this.input.charCodeAt(this.pos);\n    switch (ch) {\n    case 32: case 160: // ' '\n      ++this.pos;\n      break\n    case 13:\n      if (this.input.charCodeAt(this.pos + 1) === 10) {\n        ++this.pos;\n      }\n    case 10: case 8232: case 8233:\n      ++this.pos;\n      if (this.options.locations) {\n        ++this.curLine;\n        this.lineStart = this.pos;\n      }\n      break\n    case 47: // '/'\n      switch (this.input.charCodeAt(this.pos + 1)) {\n      case 42: // '*'\n        this.skipBlockComment();\n        break\n      case 47:\n        this.skipLineComment(2);\n        break\n      default:\n        break loop\n      }\n      break\n    default:\n      if (ch > 8 && ch < 14 || ch >= 5760 && nonASCIIwhitespace.test(String.fromCharCode(ch))) {\n        ++this.pos;\n      } else {\n        break loop\n      }\n    }\n  }\n};\n\n// Called at the end of every token. Sets `end`, `val`, and\n// maintains `context` and `exprAllowed`, and skips the space after\n// the token, so that the next one's `start` will point at the\n// right position.\n\npp$9.finishToken = function(type, val) {\n  this.end = this.pos;\n  if (this.options.locations) { this.endLoc = this.curPosition(); }\n  var prevType = this.type;\n  this.type = type;\n  this.value = val;\n\n  this.updateContext(prevType);\n};\n\n// ### Token reading\n\n// This is the function that is called to fetch the next token. It\n// is somewhat obscure, because it works in character codes rather\n// than characters, and because operator parsing has been inlined\n// into it.\n//\n// All in the name of speed.\n//\npp$9.readToken_dot = function() {\n  var next = this.input.charCodeAt(this.pos + 1);\n  if (next >= 48 && next <= 57) { return this.readNumber(true) }\n  var next2 = this.input.charCodeAt(this.pos + 2);\n  if (this.options.ecmaVersion >= 6 && next === 46 && next2 === 46) { // 46 = dot '.'\n    this.pos += 3;\n    return this.finishToken(types.ellipsis)\n  } else {\n    ++this.pos;\n    return this.finishToken(types.dot)\n  }\n};\n\npp$9.readToken_slash = function() { // '/'\n  var next = this.input.charCodeAt(this.pos + 1);\n  if (this.exprAllowed) { ++this.pos; return this.readRegexp() }\n  if (next === 61) { return this.finishOp(types.assign, 2) }\n  return this.finishOp(types.slash, 1)\n};\n\npp$9.readToken_mult_modulo_exp = function(code) { // '%*'\n  var next = this.input.charCodeAt(this.pos + 1);\n  var size = 1;\n  var tokentype = code === 42 ? types.star : types.modulo;\n\n  // exponentiation operator ** and **=\n  if (this.options.ecmaVersion >= 7 && code === 42 && next === 42) {\n    ++size;\n    tokentype = types.starstar;\n    next = this.input.charCodeAt(this.pos + 2);\n  }\n\n  if (next === 61) { return this.finishOp(types.assign, size + 1) }\n  return this.finishOp(tokentype, size)\n};\n\npp$9.readToken_pipe_amp = function(code) { // '|&'\n  var next = this.input.charCodeAt(this.pos + 1);\n  if (next === code) {\n    if (this.options.ecmaVersion >= 12) {\n      var next2 = this.input.charCodeAt(this.pos + 2);\n      if (next2 === 61) { return this.finishOp(types.assign, 3) }\n    }\n    return this.finishOp(code === 124 ? types.logicalOR : types.logicalAND, 2)\n  }\n  if (next === 61) { return this.finishOp(types.assign, 2) }\n  return this.finishOp(code === 124 ? types.bitwiseOR : types.bitwiseAND, 1)\n};\n\npp$9.readToken_caret = function() { // '^'\n  var next = this.input.charCodeAt(this.pos + 1);\n  if (next === 61) { return this.finishOp(types.assign, 2) }\n  return this.finishOp(types.bitwiseXOR, 1)\n};\n\npp$9.readToken_plus_min = function(code) { // '+-'\n  var next = this.input.charCodeAt(this.pos + 1);\n  if (next === code) {\n    if (next === 45 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 62 &&\n        (this.lastTokEnd === 0 || lineBreak.test(this.input.slice(this.lastTokEnd, this.pos)))) {\n      // A `-->` line comment\n      this.skipLineComment(3);\n      this.skipSpace();\n      return this.nextToken()\n    }\n    return this.finishOp(types.incDec, 2)\n  }\n  if (next === 61) { return this.finishOp(types.assign, 2) }\n  return this.finishOp(types.plusMin, 1)\n};\n\npp$9.readToken_lt_gt = function(code) { // '<>'\n  var next = this.input.charCodeAt(this.pos + 1);\n  var size = 1;\n  if (next === code) {\n    size = code === 62 && this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2;\n    if (this.input.charCodeAt(this.pos + size) === 61) { return this.finishOp(types.assign, size + 1) }\n    return this.finishOp(types.bitShift, size)\n  }\n  if (next === 33 && code === 60 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 45 &&\n      this.input.charCodeAt(this.pos + 3) === 45) {\n    // `<!--`, an XML-style comment that should be interpreted as a line comment\n    this.skipLineComment(4);\n    this.skipSpace();\n    return this.nextToken()\n  }\n  if (next === 61) { size = 2; }\n  return this.finishOp(types.relational, size)\n};\n\npp$9.readToken_eq_excl = function(code) { // '=!'\n  var next = this.input.charCodeAt(this.pos + 1);\n  if (next === 61) { return this.finishOp(types.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2) }\n  if (code === 61 && next === 62 && this.options.ecmaVersion >= 6) { // '=>'\n    this.pos += 2;\n    return this.finishToken(types.arrow)\n  }\n  return this.finishOp(code === 61 ? types.eq : types.prefix, 1)\n};\n\npp$9.readToken_question = function() { // '?'\n  var ecmaVersion = this.options.ecmaVersion;\n  if (ecmaVersion >= 11) {\n    var next = this.input.charCodeAt(this.pos + 1);\n    if (next === 46) {\n      var next2 = this.input.charCodeAt(this.pos + 2);\n      if (next2 < 48 || next2 > 57) { return this.finishOp(types.questionDot, 2) }\n    }\n    if (next === 63) {\n      if (ecmaVersion >= 12) {\n        var next2$1 = this.input.charCodeAt(this.pos + 2);\n        if (next2$1 === 61) { return this.finishOp(types.assign, 3) }\n      }\n      return this.finishOp(types.coalesce, 2)\n    }\n  }\n  return this.finishOp(types.question, 1)\n};\n\npp$9.getTokenFromCode = function(code) {\n  switch (code) {\n  // The interpretation of a dot depends on whether it is followed\n  // by a digit or another two dots.\n  case 46: // '.'\n    return this.readToken_dot()\n\n  // Punctuation tokens.\n  case 40: ++this.pos; return this.finishToken(types.parenL)\n  case 41: ++this.pos; return this.finishToken(types.parenR)\n  case 59: ++this.pos; return this.finishToken(types.semi)\n  case 44: ++this.pos; return this.finishToken(types.comma)\n  case 91: ++this.pos; return this.finishToken(types.bracketL)\n  case 93: ++this.pos; return this.finishToken(types.bracketR)\n  case 123: ++this.pos; return this.finishToken(types.braceL)\n  case 125: ++this.pos; return this.finishToken(types.braceR)\n  case 58: ++this.pos; return this.finishToken(types.colon)\n\n  case 96: // '`'\n    if (this.options.ecmaVersion < 6) { break }\n    ++this.pos;\n    return this.finishToken(types.backQuote)\n\n  case 48: // '0'\n    var next = this.input.charCodeAt(this.pos + 1);\n    if (next === 120 || next === 88) { return this.readRadixNumber(16) } // '0x', '0X' - hex number\n    if (this.options.ecmaVersion >= 6) {\n      if (next === 111 || next === 79) { return this.readRadixNumber(8) } // '0o', '0O' - octal number\n      if (next === 98 || next === 66) { return this.readRadixNumber(2) } // '0b', '0B' - binary number\n    }\n\n  // Anything else beginning with a digit is an integer, octal\n  // number, or float.\n  case 49: case 50: case 51: case 52: case 53: case 54: case 55: case 56: case 57: // 1-9\n    return this.readNumber(false)\n\n  // Quotes produce strings.\n  case 34: case 39: // '\"', \"'\"\n    return this.readString(code)\n\n  // Operators are parsed inline in tiny state machines. '=' (61) is\n  // often referred to. `finishOp` simply skips the amount of\n  // characters it is given as second argument, and returns a token\n  // of the type given by its first argument.\n\n  case 47: // '/'\n    return this.readToken_slash()\n\n  case 37: case 42: // '%*'\n    return this.readToken_mult_modulo_exp(code)\n\n  case 124: case 38: // '|&'\n    return this.readToken_pipe_amp(code)\n\n  case 94: // '^'\n    return this.readToken_caret()\n\n  case 43: case 45: // '+-'\n    return this.readToken_plus_min(code)\n\n  case 60: case 62: // '<>'\n    return this.readToken_lt_gt(code)\n\n  case 61: case 33: // '=!'\n    return this.readToken_eq_excl(code)\n\n  case 63: // '?'\n    return this.readToken_question()\n\n  case 126: // '~'\n    return this.finishOp(types.prefix, 1)\n  }\n\n  this.raise(this.pos, \"Unexpected character '\" + codePointToString$1(code) + \"'\");\n};\n\npp$9.finishOp = function(type, size) {\n  var str = this.input.slice(this.pos, this.pos + size);\n  this.pos += size;\n  return this.finishToken(type, str)\n};\n\npp$9.readRegexp = function() {\n  var escaped, inClass, start = this.pos;\n  for (;;) {\n    if (this.pos >= this.input.length) { this.raise(start, \"Unterminated regular expression\"); }\n    var ch = this.input.charAt(this.pos);\n    if (lineBreak.test(ch)) { this.raise(start, \"Unterminated regular expression\"); }\n    if (!escaped) {\n      if (ch === \"[\") { inClass = true; }\n      else if (ch === \"]\" && inClass) { inClass = false; }\n      else if (ch === \"/\" && !inClass) { break }\n      escaped = ch === \"\\\\\";\n    } else { escaped = false; }\n    ++this.pos;\n  }\n  var pattern = this.input.slice(start, this.pos);\n  ++this.pos;\n  var flagsStart = this.pos;\n  var flags = this.readWord1();\n  if (this.containsEsc) { this.unexpected(flagsStart); }\n\n  // Validate pattern\n  var state = this.regexpState || (this.regexpState = new RegExpValidationState(this));\n  state.reset(start, pattern, flags);\n  this.validateRegExpFlags(state);\n  this.validateRegExpPattern(state);\n\n  // Create Literal#value property value.\n  var value = null;\n  try {\n    value = new RegExp(pattern, flags);\n  } catch (e) {\n    // ESTree requires null if it failed to instantiate RegExp object.\n    // https://github.com/estree/estree/blob/a27003adf4fd7bfad44de9cef372a2eacd527b1c/es5.md#regexpliteral\n  }\n\n  return this.finishToken(types.regexp, {pattern: pattern, flags: flags, value: value})\n};\n\n// Read an integer in the given radix. Return null if zero digits\n// were read, the integer value otherwise. When `len` is given, this\n// will return `null` unless the integer has exactly `len` digits.\n\npp$9.readInt = function(radix, len, maybeLegacyOctalNumericLiteral) {\n  // `len` is used for character escape sequences. In that case, disallow separators.\n  var allowSeparators = this.options.ecmaVersion >= 12 && len === undefined;\n\n  // `maybeLegacyOctalNumericLiteral` is true if it doesn't have prefix (0x,0o,0b)\n  // and isn't fraction part nor exponent part. In that case, if the first digit\n  // is zero then disallow separators.\n  var isLegacyOctalNumericLiteral = maybeLegacyOctalNumericLiteral && this.input.charCodeAt(this.pos) === 48;\n\n  var start = this.pos, total = 0, lastCode = 0;\n  for (var i = 0, e = len == null ? Infinity : len; i < e; ++i, ++this.pos) {\n    var code = this.input.charCodeAt(this.pos), val = (void 0);\n\n    if (allowSeparators && code === 95) {\n      if (isLegacyOctalNumericLiteral) { this.raiseRecoverable(this.pos, \"Numeric separator is not allowed in legacy octal numeric literals\"); }\n      if (lastCode === 95) { this.raiseRecoverable(this.pos, \"Numeric separator must be exactly one underscore\"); }\n      if (i === 0) { this.raiseRecoverable(this.pos, \"Numeric separator is not allowed at the first of digits\"); }\n      lastCode = code;\n      continue\n    }\n\n    if (code >= 97) { val = code - 97 + 10; } // a\n    else if (code >= 65) { val = code - 65 + 10; } // A\n    else if (code >= 48 && code <= 57) { val = code - 48; } // 0-9\n    else { val = Infinity; }\n    if (val >= radix) { break }\n    lastCode = code;\n    total = total * radix + val;\n  }\n\n  if (allowSeparators && lastCode === 95) { this.raiseRecoverable(this.pos - 1, \"Numeric separator is not allowed at the last of digits\"); }\n  if (this.pos === start || len != null && this.pos - start !== len) { return null }\n\n  return total\n};\n\nfunction stringToNumber(str, isLegacyOctalNumericLiteral) {\n  if (isLegacyOctalNumericLiteral) {\n    return parseInt(str, 8)\n  }\n\n  // `parseFloat(value)` stops parsing at the first numeric separator then returns a wrong value.\n  return parseFloat(str.replace(/_/g, \"\"))\n}\n\nfunction stringToBigInt(str) {\n  if (typeof BigInt !== \"function\") {\n    return null\n  }\n\n  // `BigInt(value)` throws syntax error if the string contains numeric separators.\n  return BigInt(str.replace(/_/g, \"\"))\n}\n\npp$9.readRadixNumber = function(radix) {\n  var start = this.pos;\n  this.pos += 2; // 0x\n  var val = this.readInt(radix);\n  if (val == null) { this.raise(this.start + 2, \"Expected number in radix \" + radix); }\n  if (this.options.ecmaVersion >= 11 && this.input.charCodeAt(this.pos) === 110) {\n    val = stringToBigInt(this.input.slice(start, this.pos));\n    ++this.pos;\n  } else if (isIdentifierStart(this.fullCharCodeAtPos())) { this.raise(this.pos, \"Identifier directly after number\"); }\n  return this.finishToken(types.num, val)\n};\n\n// Read an integer, octal integer, or floating-point number.\n\npp$9.readNumber = function(startsWithDot) {\n  var start = this.pos;\n  if (!startsWithDot && this.readInt(10, undefined, true) === null) { this.raise(start, \"Invalid number\"); }\n  var octal = this.pos - start >= 2 && this.input.charCodeAt(start) === 48;\n  if (octal && this.strict) { this.raise(start, \"Invalid number\"); }\n  var next = this.input.charCodeAt(this.pos);\n  if (!octal && !startsWithDot && this.options.ecmaVersion >= 11 && next === 110) {\n    var val$1 = stringToBigInt(this.input.slice(start, this.pos));\n    ++this.pos;\n    if (isIdentifierStart(this.fullCharCodeAtPos())) { this.raise(this.pos, \"Identifier directly after number\"); }\n    return this.finishToken(types.num, val$1)\n  }\n  if (octal && /[89]/.test(this.input.slice(start, this.pos))) { octal = false; }\n  if (next === 46 && !octal) { // '.'\n    ++this.pos;\n    this.readInt(10);\n    next = this.input.charCodeAt(this.pos);\n  }\n  if ((next === 69 || next === 101) && !octal) { // 'eE'\n    next = this.input.charCodeAt(++this.pos);\n    if (next === 43 || next === 45) { ++this.pos; } // '+-'\n    if (this.readInt(10) === null) { this.raise(start, \"Invalid number\"); }\n  }\n  if (isIdentifierStart(this.fullCharCodeAtPos())) { this.raise(this.pos, \"Identifier directly after number\"); }\n\n  var val = stringToNumber(this.input.slice(start, this.pos), octal);\n  return this.finishToken(types.num, val)\n};\n\n// Read a string value, interpreting backslash-escapes.\n\npp$9.readCodePoint = function() {\n  var ch = this.input.charCodeAt(this.pos), code;\n\n  if (ch === 123) { // '{'\n    if (this.options.ecmaVersion < 6) { this.unexpected(); }\n    var codePos = ++this.pos;\n    code = this.readHexChar(this.input.indexOf(\"}\", this.pos) - this.pos);\n    ++this.pos;\n    if (code > 0x10FFFF) { this.invalidStringToken(codePos, \"Code point out of bounds\"); }\n  } else {\n    code = this.readHexChar(4);\n  }\n  return code\n};\n\nfunction codePointToString$1(code) {\n  // UTF-16 Decoding\n  if (code <= 0xFFFF) { return String.fromCharCode(code) }\n  code -= 0x10000;\n  return String.fromCharCode((code >> 10) + 0xD800, (code & 1023) + 0xDC00)\n}\n\npp$9.readString = function(quote) {\n  var out = \"\", chunkStart = ++this.pos;\n  for (;;) {\n    if (this.pos >= this.input.length) { this.raise(this.start, \"Unterminated string constant\"); }\n    var ch = this.input.charCodeAt(this.pos);\n    if (ch === quote) { break }\n    if (ch === 92) { // '\\'\n      out += this.input.slice(chunkStart, this.pos);\n      out += this.readEscapedChar(false);\n      chunkStart = this.pos;\n    } else {\n      if (isNewLine(ch, this.options.ecmaVersion >= 10)) { this.raise(this.start, \"Unterminated string constant\"); }\n      ++this.pos;\n    }\n  }\n  out += this.input.slice(chunkStart, this.pos++);\n  return this.finishToken(types.string, out)\n};\n\n// Reads template string tokens.\n\nvar INVALID_TEMPLATE_ESCAPE_ERROR = {};\n\npp$9.tryReadTemplateToken = function() {\n  this.inTemplateElement = true;\n  try {\n    this.readTmplToken();\n  } catch (err) {\n    if (err === INVALID_TEMPLATE_ESCAPE_ERROR) {\n      this.readInvalidTemplateToken();\n    } else {\n      throw err\n    }\n  }\n\n  this.inTemplateElement = false;\n};\n\npp$9.invalidStringToken = function(position, message) {\n  if (this.inTemplateElement && this.options.ecmaVersion >= 9) {\n    throw INVALID_TEMPLATE_ESCAPE_ERROR\n  } else {\n    this.raise(position, message);\n  }\n};\n\npp$9.readTmplToken = function() {\n  var out = \"\", chunkStart = this.pos;\n  for (;;) {\n    if (this.pos >= this.input.length) { this.raise(this.start, \"Unterminated template\"); }\n    var ch = this.input.charCodeAt(this.pos);\n    if (ch === 96 || ch === 36 && this.input.charCodeAt(this.pos + 1) === 123) { // '`', '${'\n      if (this.pos === this.start && (this.type === types.template || this.type === types.invalidTemplate)) {\n        if (ch === 36) {\n          this.pos += 2;\n          return this.finishToken(types.dollarBraceL)\n        } else {\n          ++this.pos;\n          return this.finishToken(types.backQuote)\n        }\n      }\n      out += this.input.slice(chunkStart, this.pos);\n      return this.finishToken(types.template, out)\n    }\n    if (ch === 92) { // '\\'\n      out += this.input.slice(chunkStart, this.pos);\n      out += this.readEscapedChar(true);\n      chunkStart = this.pos;\n    } else if (isNewLine(ch)) {\n      out += this.input.slice(chunkStart, this.pos);\n      ++this.pos;\n      switch (ch) {\n      case 13:\n        if (this.input.charCodeAt(this.pos) === 10) { ++this.pos; }\n      case 10:\n        out += \"\\n\";\n        break\n      default:\n        out += String.fromCharCode(ch);\n        break\n      }\n      if (this.options.locations) {\n        ++this.curLine;\n        this.lineStart = this.pos;\n      }\n      chunkStart = this.pos;\n    } else {\n      ++this.pos;\n    }\n  }\n};\n\n// Reads a template token to search for the end, without validating any escape sequences\npp$9.readInvalidTemplateToken = function() {\n  for (; this.pos < this.input.length; this.pos++) {\n    switch (this.input[this.pos]) {\n    case \"\\\\\":\n      ++this.pos;\n      break\n\n    case \"$\":\n      if (this.input[this.pos + 1] !== \"{\") {\n        break\n      }\n    // falls through\n\n    case \"`\":\n      return this.finishToken(types.invalidTemplate, this.input.slice(this.start, this.pos))\n\n    // no default\n    }\n  }\n  this.raise(this.start, \"Unterminated template\");\n};\n\n// Used to read escaped characters\n\npp$9.readEscapedChar = function(inTemplate) {\n  var ch = this.input.charCodeAt(++this.pos);\n  ++this.pos;\n  switch (ch) {\n  case 110: return \"\\n\" // 'n' -> '\\n'\n  case 114: return \"\\r\" // 'r' -> '\\r'\n  case 120: return String.fromCharCode(this.readHexChar(2)) // 'x'\n  case 117: return codePointToString$1(this.readCodePoint()) // 'u'\n  case 116: return \"\\t\" // 't' -> '\\t'\n  case 98: return \"\\b\" // 'b' -> '\\b'\n  case 118: return \"\\u000b\" // 'v' -> '\\u000b'\n  case 102: return \"\\f\" // 'f' -> '\\f'\n  case 13: if (this.input.charCodeAt(this.pos) === 10) { ++this.pos; } // '\\r\\n'\n  case 10: // ' \\n'\n    if (this.options.locations) { this.lineStart = this.pos; ++this.curLine; }\n    return \"\"\n  case 56:\n  case 57:\n    if (inTemplate) {\n      var codePos = this.pos - 1;\n\n      this.invalidStringToken(\n        codePos,\n        \"Invalid escape sequence in template string\"\n      );\n\n      return null\n    }\n  default:\n    if (ch >= 48 && ch <= 55) {\n      var octalStr = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0];\n      var octal = parseInt(octalStr, 8);\n      if (octal > 255) {\n        octalStr = octalStr.slice(0, -1);\n        octal = parseInt(octalStr, 8);\n      }\n      this.pos += octalStr.length - 1;\n      ch = this.input.charCodeAt(this.pos);\n      if ((octalStr !== \"0\" || ch === 56 || ch === 57) && (this.strict || inTemplate)) {\n        this.invalidStringToken(\n          this.pos - 1 - octalStr.length,\n          inTemplate\n            ? \"Octal literal in template string\"\n            : \"Octal literal in strict mode\"\n        );\n      }\n      return String.fromCharCode(octal)\n    }\n    if (isNewLine(ch)) {\n      // Unicode new line characters after \\ get removed from output in both\n      // template literals and strings\n      return \"\"\n    }\n    return String.fromCharCode(ch)\n  }\n};\n\n// Used to read character escape sequences ('\\x', '\\u', '\\U').\n\npp$9.readHexChar = function(len) {\n  var codePos = this.pos;\n  var n = this.readInt(16, len);\n  if (n === null) { this.invalidStringToken(codePos, \"Bad character escape sequence\"); }\n  return n\n};\n\n// Read an identifier, and return it as a string. Sets `this.containsEsc`\n// to whether the word contained a '\\u' escape.\n//\n// Incrementally adds only escaped chars, adding other chunks as-is\n// as a micro-optimization.\n\npp$9.readWord1 = function() {\n  this.containsEsc = false;\n  var word = \"\", first = true, chunkStart = this.pos;\n  var astral = this.options.ecmaVersion >= 6;\n  while (this.pos < this.input.length) {\n    var ch = this.fullCharCodeAtPos();\n    if (isIdentifierChar(ch, astral)) {\n      this.pos += ch <= 0xffff ? 1 : 2;\n    } else if (ch === 92) { // \"\\\"\n      this.containsEsc = true;\n      word += this.input.slice(chunkStart, this.pos);\n      var escStart = this.pos;\n      if (this.input.charCodeAt(++this.pos) !== 117) // \"u\"\n        { this.invalidStringToken(this.pos, \"Expecting Unicode escape sequence \\\\uXXXX\"); }\n      ++this.pos;\n      var esc = this.readCodePoint();\n      if (!(first ? isIdentifierStart : isIdentifierChar)(esc, astral))\n        { this.invalidStringToken(escStart, \"Invalid Unicode escape\"); }\n      word += codePointToString$1(esc);\n      chunkStart = this.pos;\n    } else {\n      break\n    }\n    first = false;\n  }\n  return word + this.input.slice(chunkStart, this.pos)\n};\n\n// Read an identifier or keyword token. Will check for reserved\n// words when necessary.\n\npp$9.readWord = function() {\n  var word = this.readWord1();\n  var type = types.name;\n  if (this.keywords.test(word)) {\n    type = keywords$1[word];\n  }\n  return this.finishToken(type, word)\n};\n\n// Acorn is a tiny, fast JavaScript parser written in JavaScript.\n\nvar version = \"7.4.1\";\n\nParser.acorn = {\n  Parser: Parser,\n  version: version,\n  defaultOptions: defaultOptions,\n  Position: Position,\n  SourceLocation: SourceLocation,\n  getLineInfo: getLineInfo,\n  Node: Node,\n  TokenType: TokenType,\n  tokTypes: types,\n  keywordTypes: keywords$1,\n  TokContext: TokContext,\n  tokContexts: types$1,\n  isIdentifierChar: isIdentifierChar,\n  isIdentifierStart: isIdentifierStart,\n  Token: Token,\n  isNewLine: isNewLine,\n  lineBreak: lineBreak,\n  lineBreakG: lineBreakG,\n  nonASCIIwhitespace: nonASCIIwhitespace\n};\n\n// The main exported interface (under `self.acorn` when in the\n// browser) is a `parse` function that takes a code string and\n// returns an abstract syntax tree as specified by [Mozilla parser\n// API][api].\n//\n// [api]: https://developer.mozilla.org/en-US/docs/SpiderMonkey/Parser_API\n\nfunction parse(input, options) {\n  return Parser.parse(input, options)\n}\n\n// This function tries to parse a single expression at a given\n// offset in a string. Useful for parsing mixed-language formats\n// that embed JavaScript expressions.\n\nfunction parseExpressionAt(input, pos, options) {\n  return Parser.parseExpressionAt(input, pos, options)\n}\n\n// Acorn is organized as a tokenizer and a recursive-descent parser.\n// The `tokenizer` export provides an interface to the tokenizer.\n\nfunction tokenizer(input, options) {\n  return Parser.tokenizer(input, options)\n}\n\n\n\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/acorn/dist/acorn.mjs?");

/***/ }),

/***/ "./node_modules/is-core-module/core.json":
/*!***********************************************!*\
  !*** ./node_modules/is-core-module/core.json ***!
  \***********************************************/
/***/ ((module) => {

"use strict";
eval("module.exports = JSON.parse('{\"assert\":true,\"node:assert\":[\">= 14.18 && < 15\",\">= 16\"],\"assert/strict\":\">= 15\",\"node:assert/strict\":\">= 16\",\"async_hooks\":\">= 8\",\"node:async_hooks\":[\">= 14.18 && < 15\",\">= 16\"],\"buffer_ieee754\":\">= 0.5 && < 0.9.7\",\"buffer\":true,\"node:buffer\":[\">= 14.18 && < 15\",\">= 16\"],\"child_process\":true,\"node:child_process\":[\">= 14.18 && < 15\",\">= 16\"],\"cluster\":\">= 0.5\",\"node:cluster\":[\">= 14.18 && < 15\",\">= 16\"],\"console\":true,\"node:console\":[\">= 14.18 && < 15\",\">= 16\"],\"constants\":true,\"node:constants\":[\">= 14.18 && < 15\",\">= 16\"],\"crypto\":true,\"node:crypto\":[\">= 14.18 && < 15\",\">= 16\"],\"_debug_agent\":\">= 1 && < 8\",\"_debugger\":\"< 8\",\"dgram\":true,\"node:dgram\":[\">= 14.18 && < 15\",\">= 16\"],\"diagnostics_channel\":[\">= 14.17 && < 15\",\">= 15.1\"],\"node:diagnostics_channel\":[\">= 14.18 && < 15\",\">= 16\"],\"dns\":true,\"node:dns\":[\">= 14.18 && < 15\",\">= 16\"],\"dns/promises\":\">= 15\",\"node:dns/promises\":\">= 16\",\"domain\":\">= 0.7.12\",\"node:domain\":[\">= 14.18 && < 15\",\">= 16\"],\"events\":true,\"node:events\":[\">= 14.18 && < 15\",\">= 16\"],\"freelist\":\"< 6\",\"fs\":true,\"node:fs\":[\">= 14.18 && < 15\",\">= 16\"],\"fs/promises\":[\">= 10 && < 10.1\",\">= 14\"],\"node:fs/promises\":[\">= 14.18 && < 15\",\">= 16\"],\"_http_agent\":\">= 0.11.1\",\"node:_http_agent\":[\">= 14.18 && < 15\",\">= 16\"],\"_http_client\":\">= 0.11.1\",\"node:_http_client\":[\">= 14.18 && < 15\",\">= 16\"],\"_http_common\":\">= 0.11.1\",\"node:_http_common\":[\">= 14.18 && < 15\",\">= 16\"],\"_http_incoming\":\">= 0.11.1\",\"node:_http_incoming\":[\">= 14.18 && < 15\",\">= 16\"],\"_http_outgoing\":\">= 0.11.1\",\"node:_http_outgoing\":[\">= 14.18 && < 15\",\">= 16\"],\"_http_server\":\">= 0.11.1\",\"node:_http_server\":[\">= 14.18 && < 15\",\">= 16\"],\"http\":true,\"node:http\":[\">= 14.18 && < 15\",\">= 16\"],\"http2\":\">= 8.8\",\"node:http2\":[\">= 14.18 && < 15\",\">= 16\"],\"https\":true,\"node:https\":[\">= 14.18 && < 15\",\">= 16\"],\"inspector\":\">= 8\",\"node:inspector\":[\">= 14.18 && < 15\",\">= 16\"],\"_linklist\":\"< 8\",\"module\":true,\"node:module\":[\">= 14.18 && < 15\",\">= 16\"],\"net\":true,\"node:net\":[\">= 14.18 && < 15\",\">= 16\"],\"node-inspect/lib/_inspect\":\">= 7.6 && < 12\",\"node-inspect/lib/internal/inspect_client\":\">= 7.6 && < 12\",\"node-inspect/lib/internal/inspect_repl\":\">= 7.6 && < 12\",\"os\":true,\"node:os\":[\">= 14.18 && < 15\",\">= 16\"],\"path\":true,\"node:path\":[\">= 14.18 && < 15\",\">= 16\"],\"path/posix\":\">= 15.3\",\"node:path/posix\":\">= 16\",\"path/win32\":\">= 15.3\",\"node:path/win32\":\">= 16\",\"perf_hooks\":\">= 8.5\",\"node:perf_hooks\":[\">= 14.18 && < 15\",\">= 16\"],\"process\":\">= 1\",\"node:process\":[\">= 14.18 && < 15\",\">= 16\"],\"punycode\":\">= 0.5\",\"node:punycode\":[\">= 14.18 && < 15\",\">= 16\"],\"querystring\":true,\"node:querystring\":[\">= 14.18 && < 15\",\">= 16\"],\"readline\":true,\"node:readline\":[\">= 14.18 && < 15\",\">= 16\"],\"readline/promises\":\">= 17\",\"node:readline/promises\":\">= 17\",\"repl\":true,\"node:repl\":[\">= 14.18 && < 15\",\">= 16\"],\"smalloc\":\">= 0.11.5 && < 3\",\"_stream_duplex\":\">= 0.9.4\",\"node:_stream_duplex\":[\">= 14.18 && < 15\",\">= 16\"],\"_stream_transform\":\">= 0.9.4\",\"node:_stream_transform\":[\">= 14.18 && < 15\",\">= 16\"],\"_stream_wrap\":\">= 1.4.1\",\"node:_stream_wrap\":[\">= 14.18 && < 15\",\">= 16\"],\"_stream_passthrough\":\">= 0.9.4\",\"node:_stream_passthrough\":[\">= 14.18 && < 15\",\">= 16\"],\"_stream_readable\":\">= 0.9.4\",\"node:_stream_readable\":[\">= 14.18 && < 15\",\">= 16\"],\"_stream_writable\":\">= 0.9.4\",\"node:_stream_writable\":[\">= 14.18 && < 15\",\">= 16\"],\"stream\":true,\"node:stream\":[\">= 14.18 && < 15\",\">= 16\"],\"stream/consumers\":\">= 16.7\",\"node:stream/consumers\":\">= 16.7\",\"stream/promises\":\">= 15\",\"node:stream/promises\":\">= 16\",\"stream/web\":\">= 16.5\",\"node:stream/web\":\">= 16.5\",\"string_decoder\":true,\"node:string_decoder\":[\">= 14.18 && < 15\",\">= 16\"],\"sys\":[\">= 0.4 && < 0.7\",\">= 0.8\"],\"node:sys\":[\">= 14.18 && < 15\",\">= 16\"],\"node:test\":[\">= 16.17 && < 17\",\">= 18\"],\"timers\":true,\"node:timers\":[\">= 14.18 && < 15\",\">= 16\"],\"timers/promises\":\">= 15\",\"node:timers/promises\":\">= 16\",\"_tls_common\":\">= 0.11.13\",\"node:_tls_common\":[\">= 14.18 && < 15\",\">= 16\"],\"_tls_legacy\":\">= 0.11.3 && < 10\",\"_tls_wrap\":\">= 0.11.3\",\"node:_tls_wrap\":[\">= 14.18 && < 15\",\">= 16\"],\"tls\":true,\"node:tls\":[\">= 14.18 && < 15\",\">= 16\"],\"trace_events\":\">= 10\",\"node:trace_events\":[\">= 14.18 && < 15\",\">= 16\"],\"tty\":true,\"node:tty\":[\">= 14.18 && < 15\",\">= 16\"],\"url\":true,\"node:url\":[\">= 14.18 && < 15\",\">= 16\"],\"util\":true,\"node:util\":[\">= 14.18 && < 15\",\">= 16\"],\"util/types\":\">= 15.3\",\"node:util/types\":\">= 16\",\"v8/tools/arguments\":\">= 10 && < 12\",\"v8/tools/codemap\":[\">= 4.4 && < 5\",\">= 5.2 && < 12\"],\"v8/tools/consarray\":[\">= 4.4 && < 5\",\">= 5.2 && < 12\"],\"v8/tools/csvparser\":[\">= 4.4 && < 5\",\">= 5.2 && < 12\"],\"v8/tools/logreader\":[\">= 4.4 && < 5\",\">= 5.2 && < 12\"],\"v8/tools/profile_view\":[\">= 4.4 && < 5\",\">= 5.2 && < 12\"],\"v8/tools/splaytree\":[\">= 4.4 && < 5\",\">= 5.2 && < 12\"],\"v8\":\">= 1\",\"node:v8\":[\">= 14.18 && < 15\",\">= 16\"],\"vm\":true,\"node:vm\":[\">= 14.18 && < 15\",\">= 16\"],\"wasi\":\">= 13.4 && < 13.5\",\"worker_threads\":\">= 11.7\",\"node:worker_threads\":[\">= 14.18 && < 15\",\">= 16\"],\"zlib\":\">= 0.5\",\"node:zlib\":[\">= 14.18 && < 15\",\">= 16\"]}');\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/is-core-module/core.json?");

/***/ }),

/***/ "./node_modules/resolve/lib/core.json":
/*!********************************************!*\
  !*** ./node_modules/resolve/lib/core.json ***!
  \********************************************/
/***/ ((module) => {

"use strict";
eval("module.exports = JSON.parse('{\"assert\":true,\"node:assert\":[\">= 14.18 && < 15\",\">= 16\"],\"assert/strict\":\">= 15\",\"node:assert/strict\":\">= 16\",\"async_hooks\":\">= 8\",\"node:async_hooks\":[\">= 14.18 && < 15\",\">= 16\"],\"buffer_ieee754\":\">= 0.5 && < 0.9.7\",\"buffer\":true,\"node:buffer\":[\">= 14.18 && < 15\",\">= 16\"],\"child_process\":true,\"node:child_process\":[\">= 14.18 && < 15\",\">= 16\"],\"cluster\":\">= 0.5\",\"node:cluster\":[\">= 14.18 && < 15\",\">= 16\"],\"console\":true,\"node:console\":[\">= 14.18 && < 15\",\">= 16\"],\"constants\":true,\"node:constants\":[\">= 14.18 && < 15\",\">= 16\"],\"crypto\":true,\"node:crypto\":[\">= 14.18 && < 15\",\">= 16\"],\"_debug_agent\":\">= 1 && < 8\",\"_debugger\":\"< 8\",\"dgram\":true,\"node:dgram\":[\">= 14.18 && < 15\",\">= 16\"],\"diagnostics_channel\":[\">= 14.17 && < 15\",\">= 15.1\"],\"node:diagnostics_channel\":[\">= 14.18 && < 15\",\">= 16\"],\"dns\":true,\"node:dns\":[\">= 14.18 && < 15\",\">= 16\"],\"dns/promises\":\">= 15\",\"node:dns/promises\":\">= 16\",\"domain\":\">= 0.7.12\",\"node:domain\":[\">= 14.18 && < 15\",\">= 16\"],\"events\":true,\"node:events\":[\">= 14.18 && < 15\",\">= 16\"],\"freelist\":\"< 6\",\"fs\":true,\"node:fs\":[\">= 14.18 && < 15\",\">= 16\"],\"fs/promises\":[\">= 10 && < 10.1\",\">= 14\"],\"node:fs/promises\":[\">= 14.18 && < 15\",\">= 16\"],\"_http_agent\":\">= 0.11.1\",\"node:_http_agent\":[\">= 14.18 && < 15\",\">= 16\"],\"_http_client\":\">= 0.11.1\",\"node:_http_client\":[\">= 14.18 && < 15\",\">= 16\"],\"_http_common\":\">= 0.11.1\",\"node:_http_common\":[\">= 14.18 && < 15\",\">= 16\"],\"_http_incoming\":\">= 0.11.1\",\"node:_http_incoming\":[\">= 14.18 && < 15\",\">= 16\"],\"_http_outgoing\":\">= 0.11.1\",\"node:_http_outgoing\":[\">= 14.18 && < 15\",\">= 16\"],\"_http_server\":\">= 0.11.1\",\"node:_http_server\":[\">= 14.18 && < 15\",\">= 16\"],\"http\":true,\"node:http\":[\">= 14.18 && < 15\",\">= 16\"],\"http2\":\">= 8.8\",\"node:http2\":[\">= 14.18 && < 15\",\">= 16\"],\"https\":true,\"node:https\":[\">= 14.18 && < 15\",\">= 16\"],\"inspector\":\">= 8\",\"node:inspector\":[\">= 14.18 && < 15\",\">= 16\"],\"_linklist\":\"< 8\",\"module\":true,\"node:module\":[\">= 14.18 && < 15\",\">= 16\"],\"net\":true,\"node:net\":[\">= 14.18 && < 15\",\">= 16\"],\"node-inspect/lib/_inspect\":\">= 7.6 && < 12\",\"node-inspect/lib/internal/inspect_client\":\">= 7.6 && < 12\",\"node-inspect/lib/internal/inspect_repl\":\">= 7.6 && < 12\",\"os\":true,\"node:os\":[\">= 14.18 && < 15\",\">= 16\"],\"path\":true,\"node:path\":[\">= 14.18 && < 15\",\">= 16\"],\"path/posix\":\">= 15.3\",\"node:path/posix\":\">= 16\",\"path/win32\":\">= 15.3\",\"node:path/win32\":\">= 16\",\"perf_hooks\":\">= 8.5\",\"node:perf_hooks\":[\">= 14.18 && < 15\",\">= 16\"],\"process\":\">= 1\",\"node:process\":[\">= 14.18 && < 15\",\">= 16\"],\"punycode\":\">= 0.5\",\"node:punycode\":[\">= 14.18 && < 15\",\">= 16\"],\"querystring\":true,\"node:querystring\":[\">= 14.18 && < 15\",\">= 16\"],\"readline\":true,\"node:readline\":[\">= 14.18 && < 15\",\">= 16\"],\"readline/promises\":\">= 17\",\"node:readline/promises\":\">= 17\",\"repl\":true,\"node:repl\":[\">= 14.18 && < 15\",\">= 16\"],\"smalloc\":\">= 0.11.5 && < 3\",\"_stream_duplex\":\">= 0.9.4\",\"node:_stream_duplex\":[\">= 14.18 && < 15\",\">= 16\"],\"_stream_transform\":\">= 0.9.4\",\"node:_stream_transform\":[\">= 14.18 && < 15\",\">= 16\"],\"_stream_wrap\":\">= 1.4.1\",\"node:_stream_wrap\":[\">= 14.18 && < 15\",\">= 16\"],\"_stream_passthrough\":\">= 0.9.4\",\"node:_stream_passthrough\":[\">= 14.18 && < 15\",\">= 16\"],\"_stream_readable\":\">= 0.9.4\",\"node:_stream_readable\":[\">= 14.18 && < 15\",\">= 16\"],\"_stream_writable\":\">= 0.9.4\",\"node:_stream_writable\":[\">= 14.18 && < 15\",\">= 16\"],\"stream\":true,\"node:stream\":[\">= 14.18 && < 15\",\">= 16\"],\"stream/consumers\":\">= 16.7\",\"node:stream/consumers\":\">= 16.7\",\"stream/promises\":\">= 15\",\"node:stream/promises\":\">= 16\",\"stream/web\":\">= 16.5\",\"node:stream/web\":\">= 16.5\",\"string_decoder\":true,\"node:string_decoder\":[\">= 14.18 && < 15\",\">= 16\"],\"sys\":[\">= 0.4 && < 0.7\",\">= 0.8\"],\"node:sys\":[\">= 14.18 && < 15\",\">= 16\"],\"node:test\":\">= 18\",\"timers\":true,\"node:timers\":[\">= 14.18 && < 15\",\">= 16\"],\"timers/promises\":\">= 15\",\"node:timers/promises\":\">= 16\",\"_tls_common\":\">= 0.11.13\",\"node:_tls_common\":[\">= 14.18 && < 15\",\">= 16\"],\"_tls_legacy\":\">= 0.11.3 && < 10\",\"_tls_wrap\":\">= 0.11.3\",\"node:_tls_wrap\":[\">= 14.18 && < 15\",\">= 16\"],\"tls\":true,\"node:tls\":[\">= 14.18 && < 15\",\">= 16\"],\"trace_events\":\">= 10\",\"node:trace_events\":[\">= 14.18 && < 15\",\">= 16\"],\"tty\":true,\"node:tty\":[\">= 14.18 && < 15\",\">= 16\"],\"url\":true,\"node:url\":[\">= 14.18 && < 15\",\">= 16\"],\"util\":true,\"node:util\":[\">= 14.18 && < 15\",\">= 16\"],\"util/types\":\">= 15.3\",\"node:util/types\":\">= 16\",\"v8/tools/arguments\":\">= 10 && < 12\",\"v8/tools/codemap\":[\">= 4.4 && < 5\",\">= 5.2 && < 12\"],\"v8/tools/consarray\":[\">= 4.4 && < 5\",\">= 5.2 && < 12\"],\"v8/tools/csvparser\":[\">= 4.4 && < 5\",\">= 5.2 && < 12\"],\"v8/tools/logreader\":[\">= 4.4 && < 5\",\">= 5.2 && < 12\"],\"v8/tools/profile_view\":[\">= 4.4 && < 5\",\">= 5.2 && < 12\"],\"v8/tools/splaytree\":[\">= 4.4 && < 5\",\">= 5.2 && < 12\"],\"v8\":\">= 1\",\"node:v8\":[\">= 14.18 && < 15\",\">= 16\"],\"vm\":true,\"node:vm\":[\">= 14.18 && < 15\",\">= 16\"],\"wasi\":\">= 13.4 && < 13.5\",\"worker_threads\":\">= 11.7\",\"node:worker_threads\":[\">= 14.18 && < 15\",\">= 16\"],\"zlib\":\">= 0.5\",\"node:zlib\":[\">= 14.18 && < 15\",\">= 16\"]}');\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/resolve/lib/core.json?");

/***/ }),

/***/ "./node_modules/tailwindcss/package.json":
/*!***********************************************!*\
  !*** ./node_modules/tailwindcss/package.json ***!
  \***********************************************/
/***/ ((module) => {

"use strict";
eval("module.exports = JSON.parse('{\"name\":\"tailwindcss\",\"version\":\"3.1.8\",\"description\":\"A utility-first CSS framework for rapidly building custom user interfaces.\",\"license\":\"MIT\",\"main\":\"lib/index.js\",\"types\":\"types/index.d.ts\",\"repository\":\"https://github.com/tailwindlabs/tailwindcss.git\",\"bugs\":\"https://github.com/tailwindlabs/tailwindcss/issues\",\"homepage\":\"https://tailwindcss.com\",\"bin\":{\"tailwind\":\"lib/cli.js\",\"tailwindcss\":\"lib/cli.js\"},\"scripts\":{\"preswcify\":\"npm run generate && rimraf lib\",\"swcify\":\"swc src --out-dir lib --copy-files\",\"postswcify\":\"esbuild lib/cli-peer-dependencies.js --bundle --platform=node --outfile=peers/index.js\",\"rebuild-fixtures\":\"npm run swcify && node -r @swc/register scripts/rebuildFixtures.js\",\"prepublishOnly\":\"npm install --force && npm run swcify\",\"style\":\"eslint .\",\"pretest\":\"npm run generate\",\"test\":\"jest\",\"test:integrations\":\"npm run test --prefix ./integrations\",\"install:integrations\":\"node scripts/install-integrations.js\",\"posttest\":\"npm run style\",\"generate:plugin-list\":\"node -r @swc/register scripts/create-plugin-list.js\",\"generate:types\":\"node -r @swc/register scripts/generate-types.js\",\"generate\":\"npm run generate:plugin-list && npm run generate:types\"},\"files\":[\"src/*\",\"cli/*\",\"lib/*\",\"peers/*\",\"scripts/*.js\",\"stubs/*.stub.js\",\"nesting/*\",\"types/**/*\",\"*.d.ts\",\"*.css\",\"*.js\"],\"devDependencies\":{\"@swc/cli\":\"^0.1.57\",\"@swc/core\":\"^1.2.218\",\"@swc/jest\":\"^0.2.22\",\"@swc/register\":\"^0.1.10\",\"autoprefixer\":\"^10.4.8\",\"cssnano\":\"^5.1.12\",\"esbuild\":\"^0.14.48\",\"eslint\":\"^8.20.0\",\"eslint-config-prettier\":\"^8.5.0\",\"eslint-plugin-prettier\":\"^4.2.1\",\"jest\":\"^28.1.3\",\"jest-diff\":\"^28.1.3\",\"prettier\":\"^2.7.1\",\"prettier-plugin-tailwindcss\":\"^0.1.13\",\"rimraf\":\"^3.0.0\",\"source-map-js\":\"^1.0.2\"},\"peerDependencies\":{\"postcss\":\"^8.0.9\"},\"dependencies\":{\"arg\":\"^5.0.2\",\"chokidar\":\"^3.5.3\",\"color-name\":\"^1.1.4\",\"detective\":\"^5.2.1\",\"didyoumean\":\"^1.2.2\",\"dlv\":\"^1.1.3\",\"fast-glob\":\"^3.2.11\",\"glob-parent\":\"^6.0.2\",\"is-glob\":\"^4.0.3\",\"lilconfig\":\"^2.0.6\",\"normalize-path\":\"^3.0.0\",\"object-hash\":\"^3.0.0\",\"picocolors\":\"^1.0.0\",\"postcss\":\"^8.4.14\",\"postcss-import\":\"^14.1.0\",\"postcss-js\":\"^4.0.0\",\"postcss-load-config\":\"^3.1.4\",\"postcss-nested\":\"5.0.6\",\"postcss-selector-parser\":\"^6.0.10\",\"postcss-value-parser\":\"^4.2.0\",\"quick-lru\":\"^5.1.1\",\"resolve\":\"^1.22.1\"},\"browserslist\":[\"> 1%\",\"not edge <= 18\",\"not ie 11\",\"not op_mini all\"],\"jest\":{\"testTimeout\":30000,\"setupFilesAfterEnv\":[\"<rootDir>/jest/customMatchers.js\"],\"testPathIgnorePatterns\":[\"/node_modules/\",\"/integrations/\",\"/standalone-cli/\",\"\\\\\\\\.test\\\\\\\\.skip\\\\\\\\.js$\"],\"transform\":{\"\\\\\\\\.js$\":\"@swc/jest\"}},\"engines\":{\"node\":\">=12.13.0\"}}');\n\n//# sourceURL=webpack://webpack-tailwind/./node_modules/tailwindcss/package.json?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = __webpack_module_cache__;
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// module cache are used so entry inlining is disabled
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.js");
/******/ 	
/******/ })()
;